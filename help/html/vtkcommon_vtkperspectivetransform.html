<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkPerspectiveTransform</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkcommon_vtkperspectivetransform.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkPerspectiveTransform </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkcommon.html">Visualization Toolkit Common Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>A vtkPerspectiveTransform can be used to describe the full range of homogeneous transformations. It was designed in particular to describe a camera-view of a scene. </p>
<p>The order in which you set up the display coordinates (via AdjustZBuffer() and AdjustViewport()), the projection (via Perspective(), Frustum(), or Ortho()) and the camera view (via SetupCamera()) are important. If the transform is in PreMultiply mode, which is the default, set the Viewport and ZBuffer first, then the projection, and finally the camera view. Once the view is set up, the Translate and Rotate methods can be used to move the camera around in world coordinates. If the Oblique() or Stereo() methods are used, they should be called just before SetupCamera(). </p>
<p>In PostMultiply mode, you must perform all transformations in the opposite order. This is necessary, for example, if you already have a perspective transformation set up but must adjust the viewport. Another example is if you have a view transformation, and wish to perform translations and rotations in the camera's coordinate system rather than in world coordinates. </p>
<p>The SetInput and Concatenate methods can be used to create a transformation pipeline with vtkPerspectiveTransform. See vtkTransform for more information on the transformation pipeline.</p>
<p>To create an instance of class vtkPerspectiveTransform, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkPerspectiveTransform
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkPerspectiveTransform has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkPerspectiveTransform class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkPerspectiveTransform = obj.NewInstance ()</code>  </li>
<li>
<code>vtkPerspectiveTransform = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>obj.Identity ()</code> - Set this transformation to the identity transformation. If the transform has an Input, then the transformation will be reset so that it is the same as the Input.  </li>
<li>
<code>obj.Inverse ()</code> - Invert the transformation. This will also set a flag so that the transformation will use the inverse of its Input, if an Input has been set.  </li>
<li>
<code>obj.AdjustViewport (double oldXMin, double oldXMax, double oldYMin, double oldYMax, double newXMin, double newXMax, double newYMin, double newYMax)</code> - Perform an adjustment to the viewport coordinates. By default Ortho, Frustum, and Perspective provide a window of ([-1,+1],[-1,+1]). In PreMultiply mode, you call this method before calling Ortho, Frustum, or Perspective. In PostMultiply mode you can call it after. Note that if you must apply both AdjustZBuffer and AdjustViewport, it makes no difference which order you apply them in.  </li>
<li>
<code>obj.AdjustZBuffer (double oldNearZ, double oldFarZ, double newNearZ, double newFarZ)</code> - Perform an adjustment to the Z-Buffer range that the near and far clipping planes map to. By default Ortho, Frustum, and Perspective map the near clipping plane to -1 and the far clipping plane to +1. In PreMultiply mode, you call this method before calling Ortho, Frustum, or Perspective. In PostMultiply mode you can call it after.  </li>
<li>
<code>obj.Ortho (double xmin, double xmax, double ymin, double ymax, double znear, double zfar)</code> - Create an orthogonal projection matrix and concatenate it by the current transformation. The matrix maps [xmin,xmax], [ymin,ymax], [-znear,-zfar] to [-1,+1], [-1,+1], [+1,-1].  </li>
<li>
<code>obj.Frustum (double xmin, double xmax, double ymin, double ymax, double znear, double zfar)</code> - Create an perspective projection matrix and concatenate it by the current transformation. The matrix maps a frustum with a back plane at -zfar and a front plane at -znear with extent [xmin,xmax],[ymin,ymax] to [-1,+1], [-1,+1], [+1,-1].  </li>
<li>
<code>obj.Perspective (double angle, double aspect, double znear, double zfar)</code> - Create a perspective projection matrix by specifying the view angle (this angle is in the y direction), the aspect ratio, and the near and far clipping range. The projection matrix is concatenated with the current transformation. This method works via Frustum.  </li>
<li>
<code>obj.Shear (double dxdz, double dydz, double zplane)</code> - Create a shear transformation about a plane at distance z from the camera. The values dxdz (i.e. dx/dz) and dydz specify the amount of shear in the x and y directions. The 'zplane' specifies the distance from the camera to the plane at which the shear causes zero displacement. Generally you want this plane to be the focal plane. This transformation can be used in combination with Ortho to create an oblique projection. It can also be used in combination with Perspective to provide correct stereo views when the eye is at arbitrary but known positions relative to the center of a flat viewing screen.  </li>
<li>
<code>obj.Stereo (double angle, double focaldistance)</code> - Create a stereo shear matrix and concatenate it with the current transformation. This can be applied in conjunction with either a perspective transformation (via Frustum or Projection) or an orthographic projection. You must specify the distance from the camera plane to the focal plane, and the angle between the distance vector and the eye. The angle should be negative for the left eye, and positive for the right. This method works via Oblique.  </li>
<li>
<code>obj.SetupCamera (double position[3], double focalpoint[3], double viewup[3])</code> - Set a view transformation matrix for the camera (this matrix does not contain any perspective) and concatenate it with the current transformation.  </li>
<li>
<code>obj.SetupCamera (double p0, double p1, double p2, double fp0, double fp1, double fp2, double vup0, double vup1, double vup2)</code>  </li>
<li>
<code>obj.Translate (double x, double y, double z)</code> - Create a translation matrix and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.  </li>
<li>
<code>obj.Translate (double x[3])</code> - Create a translation matrix and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.  </li>
<li>
<code>obj.Translate (float x[3])</code> - Create a translation matrix and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.  </li>
<li>
<code>obj.RotateWXYZ (double angle, double x, double y, double z)</code> - Create a rotation matrix and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics. The angle is in degrees, and (x,y,z) specifies the axis that the rotation will be performed around.  </li>
<li>
<code>obj.RotateWXYZ (double angle, double axis[3])</code> - Create a rotation matrix and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics. The angle is in degrees, and (x,y,z) specifies the axis that the rotation will be performed around.  </li>
<li>
<code>obj.RotateWXYZ (double angle, float axis[3])</code> - Create a rotation matrix and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics. The angle is in degrees, and (x,y,z) specifies the axis that the rotation will be performed around.  </li>
<li>
<code>obj.RotateX (double angle)</code> - Create a rotation matrix about the X, Y, or Z axis and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics. The angle is expressed in degrees.  </li>
<li>
<code>obj.RotateY (double angle)</code> - Create a rotation matrix about the X, Y, or Z axis and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics. The angle is expressed in degrees.  </li>
<li>
<code>obj.RotateZ (double angle)</code> - Create a rotation matrix about the X, Y, or Z axis and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics. The angle is expressed in degrees.  </li>
<li>
<code>obj.Scale (double x, double y, double z)</code> - Create a scale matrix (i.e. set the diagonal elements to x, y, z) and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.  </li>
<li>
<code>obj.Scale (double s[3])</code> - Create a scale matrix (i.e. set the diagonal elements to x, y, z) and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.  </li>
<li>
<code>obj.Scale (float s[3])</code> - Create a scale matrix (i.e. set the diagonal elements to x, y, z) and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.  </li>
<li>
<code>obj.SetMatrix (vtkMatrix4x4 matrix)</code> - Set the current matrix directly. This actually calls Identity(), followed by Concatenate(matrix).  </li>
<li>
<code>obj.SetMatrix (double elements[16])</code> - Set the current matrix directly. This actually calls Identity(), followed by Concatenate(matrix).  </li>
<li>
<code>obj.Concatenate (vtkMatrix4x4 matrix)</code> - Concatenates the matrix with the current transformation according to PreMultiply or PostMultiply semantics.  </li>
<li>
<code>obj.Concatenate (double elements[16])</code> - Concatenates the matrix with the current transformation according to PreMultiply or PostMultiply semantics.  </li>
<li>
<code>obj.Concatenate (vtkHomogeneousTransform transform)</code> - Concatenate the specified transform with the current transformation according to PreMultiply or PostMultiply semantics. The concatenation is pipelined, meaning that if any of the transformations are changed, even after Concatenate() is called, those changes will be reflected when you call TransformPoint().  </li>
<li>
<code>obj.PreMultiply ()</code> - Sets the internal state of the transform to PreMultiply. All subsequent operations will occur before those already represented in the current transformation. In homogeneous matrix notation, M = M*A where M is the current transformation matrix and A is the applied matrix. The default is PreMultiply.  </li>
<li>
<code>obj.PostMultiply ()</code> - Sets the internal state of the transform to PostMultiply. All subsequent operations will occur after those already represented in the current transformation. In homogeneous matrix notation, M = A*M where M is the current transformation matrix and A is the applied matrix. The default is PreMultiply.  </li>
<li>
<code>int = obj.GetNumberOfConcatenatedTransforms ()</code> - Get the total number of transformations that are linked into this one via Concatenate() operations or via SetInput().  </li>
<li>
<code>vtkHomogeneousTransform = obj.GetConcatenatedTransform (int i)</code> - Set the input for this transformation. This will be used as the base transformation if it is set. This method allows you to build a transform pipeline: if the input is modified, then this transformation will automatically update accordingly. Note that the InverseFlag, controlled via Inverse(), determines whether this transformation will use the Input or the inverse of the Input.  </li>
<li>
<code>obj.SetInput (vtkHomogeneousTransform input)</code> - Set the input for this transformation. This will be used as the base transformation if it is set. This method allows you to build a transform pipeline: if the input is modified, then this transformation will automatically update accordingly. Note that the InverseFlag, controlled via Inverse(), determines whether this transformation will use the Input or the inverse of the Input.  </li>
<li>
<code>vtkHomogeneousTransform = obj.GetInput ()</code> - Set the input for this transformation. This will be used as the base transformation if it is set. This method allows you to build a transform pipeline: if the input is modified, then this transformation will automatically update accordingly. Note that the InverseFlag, controlled via Inverse(), determines whether this transformation will use the Input or the inverse of the Input.  </li>
<li>
<code>int = obj.GetInverseFlag ()</code> - Get the inverse flag of the transformation. This controls whether it is the Input or the inverse of the Input that is used as the base transformation. The InverseFlag is flipped every time Inverse() is called. The InverseFlag is off when a transform is first created.  </li>
<li>
<code>obj.Push ()</code> - Pushes the current transformation onto the transformation stack.  </li>
<li>
<code>obj.Pop ()</code> - Deletes the transformation on the top of the stack and sets the top to the next transformation on the stack.  </li>
<li>
<code>vtkAbstractTransform = obj.MakeTransform ()</code> - Make a new transform of the same type &ndash; you are responsible for deleting the transform when you are done with it.  </li>
<li>
<code>int = obj.CircuitCheck (vtkAbstractTransform transform)</code> - Check for self-reference. Will return true if concatenating with the specified transform, setting it to be our inverse, or setting it to be our input will create a circular reference. CircuitCheck is automatically called by SetInput(), SetInverse(), and Concatenate(vtkXTransform *). Avoid using this function, it is experimental.  </li>
<li>
<code>long = obj.GetMTime ()</code> - Override GetMTime to account for input and concatenation.  </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkcommon.html">Visualization Toolkit Common Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:30 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

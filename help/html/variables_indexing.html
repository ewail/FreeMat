<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: INDEXING Indexing Expressions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('variables_indexing.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">INDEXING Indexing Expressions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_variables.html">Variables and Arrays</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>There are three classes of indexing expressions available in FreeMat: <code>()</code>, <code>{}</code>, and <code>.</code> Each is explained below in some detail, and with its own example section. </p>
<h1><a class="anchor" id="Array"></a>
Indexing</h1>
<p>We start with array indexing <code>()</code>, which is the most general indexing expression, and can be used on any array. There are two general forms for the indexing expression - the N-dimensional form, for which the general syntax is </p>
<pre class="fragment">  variable(index_1,index_2,...,index_n)
</pre><p> and the vector form, for which the general syntax is </p>
<pre class="fragment">  variable(index)
</pre><p> Here each index expression is either a scalar, a range of integer values, or the special token <code>:</code>, which is shorthand for <code>1:end</code>. The keyword <code>end</code>, when included in an indexing expression, is assigned the length of the array in that dimension. The concept is easier to demonstrate than explain. Consider the following examples:</p>
<pre class="fragment">--&gt; A = zeros(4)

A = 
 0 0 0 0 
 0 0 0 0 
 0 0 0 0 
 0 0 0 0 

--&gt; B = float(randn(2))

B = 
   -0.1688    0.5183 
    0.9485   -0.6864 

--&gt; A(2:3,2:3) = B

A = 
         0         0         0         0 
         0   -0.1688    0.5183         0 
         0    0.9485   -0.6864         0 
         0         0         0         0 
</pre><p>Here the array indexing was used on the left hand side only. It can also be used for right hand side indexing, as in</p>
<pre class="fragment">--&gt; C = A(2:3,1:end)

C = 
         0   -0.1688    0.5183         0 
         0    0.9485   -0.6864         0 
</pre><p>Note that we used the <code>end</code> keyword to avoid having to know that <code>A</code> has 4 columns. Of course, we could also use the <code>:</code> token instead:</p>
<pre class="fragment">--&gt; C = A(2:3,:)

C = 
         0   -0.1688    0.5183         0 
         0    0.9485   -0.6864         0 
</pre><p>An extremely useful example of <code>:</code> with array indexing is for slicing. Suppose we have a 3-D array, that is <code>2 x 2 x 3</code>, and we want to set the middle slice:</p>
<pre class="fragment">--&gt; D = zeros(2,2,3)

D = 

(:,:,1) = 
 0 0 
 0 0 

(:,:,2) = 
 0 0 
 0 0 

(:,:,3) = 
 0 0 
 0 0 

--&gt; D(:,:,2) = int32(10*rand(2,2))

D = 

(:,:,1) = 
  0  0 
  0  0 

(:,:,2) = 
  9 10 
  5  8 

(:,:,3) = 
  0  0 
  0  0 
</pre><p>In another level of nuance, the assignment expression will automatically fill in the indexed rectangle on the left using data from the right hand side, as long as the lengths match. So we can take a vector and roll it into a matrix using this approach:</p>
<pre class="fragment">--&gt; A = zeros(4)

A = 
 0 0 0 0 
 0 0 0 0 
 0 0 0 0 
 0 0 0 0 

--&gt; v = [1;2;3;4]

v = 
 1 
 2 
 3 
 4 

--&gt; A(2:3,2:3) = v

A = 
 0 0 0 0 
 0 1 3 0 
 0 2 4 0 
 0 0 0 0 
</pre><p>The N-dimensional form of the variable index is limited to accessing only (hyper-) rectangular regions of the array. You cannot, for example, use it to access only the diagonal elements of the array. To do that, you use the second form of the array access (or a loop). The vector form treats an arbitrary N-dimensional array as though it were a column vector. You can then access arbitrary subsets of the arrays elements (for example, through a <code>find</code> expression) efficiently. Note that in vector form, the <code>end</code> keyword takes the meaning of the total length of the array (defined as the product of its dimensions), as opposed to the size along the first dimension. </p>
<h1><a class="anchor" id="Cell"></a>
Indexing</h1>
<p>The second form of indexing operates, to a large extent, in the same manner as the array indexing, but it is by no means interchangable. As the name implies, <code>cell</code>-indexing applies only to <code>cell</code> arrays. For those familiar with <code>C</code>, cell- indexing is equivalent to pointer derefencing in <code>C</code>. First, the syntax: </p>
<pre class="fragment">  variable{index_1,index_2,...,index_n}
</pre><p> and the vector form, for which the general syntax is </p>
<pre class="fragment">  variable{index}
</pre><p> The rules and interpretation for N-dimensional and vector indexing are identical to <code>()</code>, so we will describe only the differences. In simple terms, applying <code>()</code> to a cell-array returns another cell array that is a subset of the original array. On the other hand, applying <code>{}</code> to a cell-array returns the contents of that cell array. A simple example makes the difference quite clear:</p>
<pre class="fragment">--&gt; A = {1, 'hello', [1:4]}

A = 
 [1] [hello] [1x4 double array] 

--&gt; A(1:2)

ans = 
 [1] [hello] 

--&gt; A{1:2}

ans = 

1 of 2:
 1 


2 of 2:
hello
</pre><p>You may be surprised by the response to the last line. The output is multiple assignments to <code>ans</code>!. The output of a cell-array dereference can be used anywhere a list of expressions is required. This includes arguments and returns for function calls, matrix construction, etc. Here is an example of using cell-arrays to pass parameters to a function:</p>
<pre class="fragment">--&gt; A = {[1,3,0],[5,2,7]}

A = 
 [1x3 double array] [1x3 double array] 

--&gt; max(A{1:end})

ans = 
 5 3 7 
</pre><p>And here, cell-arrays are used to capture the return.</p>
<pre class="fragment">--&gt; [K{1:2}] = max(randn(1,4))
K = 
 [0.779398] [4] 
</pre><p>Here, cell-arrays are used in the matrix construction process:</p>
<pre class="fragment">--&gt; C = [A{1};A{2}]

C = 
 1 3 0 
 5 2 7 
</pre><p>Note that this form of indexing is used to implement variable length arguments to function. See <code>varargin</code> and <code>varargout</code> for more details. </p>
<h1><a class="anchor" id="Structure"></a>
Indexing</h1>
<p>The third form of indexing is structure indexing. It can only be applied to structure arrays, and has the general syntax </p>
<pre class="fragment">  variable.fieldname
</pre><p> where <code>fieldname</code> is one of the fields on the structure. Note that in FreeMat, fields are allocated dynamically, so if you reference a field that does not exist in an assignment, it is created automatically for you. If variable is an array, then the result of the <code>.</code> reference is an expression list, exactly like the <code>{}</code> operator. Hence, we can use structure indexing in a simple fashion:</p>
<pre class="fragment">--&gt; clear A
--&gt; A.color = 'blue'

A = 
    color: blue
--&gt; B = A.color

B = 
blue
</pre><p>Or in more complicated ways using expression lists for function arguments</p>
<pre class="fragment">--&gt; clear A
--&gt; A(1).maxargs = [1,6,7,3]

A = 
    maxargs: 1x4 double array
--&gt; A(2).maxargs = [5,2,9,0]

A = 
1x2 struct array with fields:
    maxargs
--&gt; max(A.maxargs)

ans = 
 5 6 9 3 
</pre><p>or to store function outputs</p>
<pre class="fragment">--&gt; clear A
--&gt; A(1).maxreturn = [];
--&gt; A(2).maxreturn = [];
--&gt; [A.maxreturn] = max(randn(1,4))
A = 
1x2 struct array with fields:
    maxreturn
</pre><p>FreeMat now also supports the so called dynamic-field indexing expressions. In this mode, the fieldname is supplied through an expression instead of being explicitly provided. For example, suppose we have a set of structure indexed by color,</p>
<pre class="fragment">--&gt; x.red = 430;
--&gt; x.green = 240;
--&gt; x.blue = 53;
--&gt; x.yello = 105

x = 
    red: 430
    green: 240
    blue: 53
    yello: 105
</pre><p>Then we can index into the structure <code>x</code> using a dynamic field reference:</p>
<pre class="fragment">--&gt; y = 'green'

y = 
green
--&gt; a = x.(y)

a = 
 240 
</pre><p>Note that the indexing expression has to resolve to a string for dynamic field indexing to work. </p>
<h1><a class="anchor" id="Complex"></a>
Indexing</h1>
<p>The indexing expressions described above can be freely combined to affect complicated indexing expressions. Here is an example that exercises all three indexing expressions in one assignment.</p>
<pre class="fragment">--&gt; Z{3}.foo(2) = pi

Z = 
 [0] [0] [1x1 struct array] 
</pre><p>From this statement, FreeMat infers that Z is a cell-array of length 3, that the third element is a structure array (with one element), and that this structure array contains a field named 'foo' with two double elements, the second of which is assigned a value of pi. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_variables.html">Variables and Arrays</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:30 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkInteractorStyle</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkrendering_vtkinteractorstyle.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkInteractorStyle </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkrendering.html">Visualization Toolkit Rendering Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>vtkInteractorStyle is a base class implementing the majority of motion control routines and defines an event driven interface to support vtkRenderWindowInteractor. vtkRenderWindowInteractor implements platform dependent key/mouse routing and timer control, which forwards events in a neutral form to vtkInteractorStyle.</p>
<p>vtkInteractorStyle implements the "joystick" style of interaction. That is, holding down the mouse keys generates a stream of events that cause continuous actions (e.g., rotate, translate, pan, zoom). (The class vtkInteractorStyleTrackball implements a grab and move style.) The event bindings for this class include the following:</p>
<ul>
<li>Keypress j / Keypress t: toggle between joystick (position sensitive) and trackball (motion sensitive) styles. In joystick style, motion occurs continuously as long as a mouse button is pressed. In trackball style, motion occurs when the mouse button is pressed and the mouse pointer moves.</li>
<li>Keypress c / Keypress a: toggle between camera and actor modes. In camera mode, mouse events affect the camera position and focal point. In actor mode, mouse events affect the actor that is under the mouse pointer.</li>
<li>Button 1: rotate the camera around its focal point (if camera mode) or rotate the actor around its origin (if actor mode). The rotation is in the direction defined from the center of the renderer's viewport towards the mouse position. In joystick mode, the magnitude of the rotation is determined by the distance the mouse is from the center of the render window.</li>
<li>Button 2: pan the camera (if camera mode) or translate the actor (if actor mode). In joystick mode, the direction of pan or translation is from the center of the viewport towards the mouse position. In trackball mode, the direction of motion is the direction the mouse moves. (Note: with 2-button mice, pan is defined as &lt;Shift&gt;-Button 1.)</li>
<li>Button 3: zoom the camera (if camera mode) or scale the actor (if actor mode). Zoom in/increase scale if the mouse position is in the top half of the viewport; zoom out/decrease scale if the mouse position is in the bottom half. In joystick mode, the amount of zoom is controlled by the distance of the mouse pointer from the horizontal centerline of the window.</li>
<li>Keypress 3: toggle the render window into and out of stereo mode. By default, red-blue stereo pairs are created. Some systems support Crystal Eyes LCD stereo glasses; you have to invoke SetStereoTypeToCrystalEyes() on the rendering window.</li>
<li>Keypress e: exit the application.</li>
<li>Keypress f: fly to the picked point</li>
<li>Keypress p: perform a pick operation. The render window interactor has an internal instance of vtkCellPicker that it uses to pick.</li>
<li>Keypress r: reset the camera view along the current view direction. Centers the actors and moves the camera so that all actors are visible.</li>
<li>Keypress s: modify the representation of all actors so that they are surfaces.</li>
<li>Keypress u: invoke the user-defined function. Typically, this keypress will bring up an interactor that you can type commands in. Typing u calls UserCallBack() on the vtkRenderWindowInteractor, which invokes a vtkCommand::UserEvent. In other words, to define a user-defined callback, just add an observer to the vtkCommand::UserEvent on the vtkRenderWindowInteractor object.</li>
<li>Keypress w: modify the representation of all actors so that they are wireframe.</li>
</ul>
<p>vtkInteractorStyle can be subclassed to provide new interaction styles and a facility to override any of the default mouse/key operations which currently handle trackball or joystick styles is provided. Note that this class will fire a variety of events that can be watched using an observer, such as LeftButtonPressEvent, LeftButtonReleaseEvent, MiddleButtonPressEvent, MiddleButtonReleaseEvent, RightButtonPressEvent, RightButtonReleaseEvent, EnterEvent, LeaveEvent, KeyPressEvent, KeyReleaseEvent, CharEvent, ExposeEvent, ConfigureEvent, TimerEvent, MouseMoveEvent,</p>
<p>To create an instance of class vtkInteractorStyle, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkInteractorStyle
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkInteractorStyle has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkInteractorStyle class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkInteractorStyle = obj.NewInstance ()</code>  </li>
<li>
<code>vtkInteractorStyle = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>obj.SetInteractor (vtkRenderWindowInteractor interactor)</code> - Set/Get the Interactor wrapper being controlled by this object. (Satisfy superclass API.)  </li>
<li>
<code>obj.SetEnabled (int )</code> - Turn on/off this interactor. Interactor styles operate a little bit differently than other types of interactor observers. When the SetInteractor() method is invoked, the automatically enable themselves. This is a legacy requirement, and convenient for the user.  </li>
<li>
<code>obj.SetAutoAdjustCameraClippingRange (int )</code> - If AutoAdjustCameraClippingRange is on, then before each render the camera clipping range will be adjusted to "fit" the whole scene. Clipping will still occur if objects in the scene are behind the camera or come very close. If AutoAdjustCameraClippingRange is off, no adjustment will be made per render, but the camera clipping range will still be reset when the camera is reset.  </li>
<li>
<code>int = obj.GetAutoAdjustCameraClippingRangeMinValue ()</code> - If AutoAdjustCameraClippingRange is on, then before each render the camera clipping range will be adjusted to "fit" the whole scene. Clipping will still occur if objects in the scene are behind the camera or come very close. If AutoAdjustCameraClippingRange is off, no adjustment will be made per render, but the camera clipping range will still be reset when the camera is reset.  </li>
<li>
<code>int = obj.GetAutoAdjustCameraClippingRangeMaxValue ()</code> - If AutoAdjustCameraClippingRange is on, then before each render the camera clipping range will be adjusted to "fit" the whole scene. Clipping will still occur if objects in the scene are behind the camera or come very close. If AutoAdjustCameraClippingRange is off, no adjustment will be made per render, but the camera clipping range will still be reset when the camera is reset.  </li>
<li>
<code>int = obj.GetAutoAdjustCameraClippingRange ()</code> - If AutoAdjustCameraClippingRange is on, then before each render the camera clipping range will be adjusted to "fit" the whole scene. Clipping will still occur if objects in the scene are behind the camera or come very close. If AutoAdjustCameraClippingRange is off, no adjustment will be made per render, but the camera clipping range will still be reset when the camera is reset.  </li>
<li>
<code>obj.AutoAdjustCameraClippingRangeOn ()</code> - If AutoAdjustCameraClippingRange is on, then before each render the camera clipping range will be adjusted to "fit" the whole scene. Clipping will still occur if objects in the scene are behind the camera or come very close. If AutoAdjustCameraClippingRange is off, no adjustment will be made per render, but the camera clipping range will still be reset when the camera is reset.  </li>
<li>
<code>obj.AutoAdjustCameraClippingRangeOff ()</code> - If AutoAdjustCameraClippingRange is on, then before each render the camera clipping range will be adjusted to "fit" the whole scene. Clipping will still occur if objects in the scene are behind the camera or come very close. If AutoAdjustCameraClippingRange is off, no adjustment will be made per render, but the camera clipping range will still be reset when the camera is reset.  </li>
<li>
<code>obj.FindPokedRenderer (int , int )</code> - When an event occurs, we must determine which Renderer the event occurred within, since one RenderWindow may contain multiple renderers.  </li>
<li>
<code>int = obj.GetState ()</code> - Some useful information for interaction  </li>
<li>
<code>int = obj.GetUseTimers ()</code> - Set/Get timer hint  </li>
<li>
<code>obj.SetUseTimers (int )</code> - Set/Get timer hint  </li>
<li>
<code>obj.UseTimersOn ()</code> - Set/Get timer hint  </li>
<li>
<code>obj.UseTimersOff ()</code> - Set/Get timer hint  </li>
<li>
<code>obj.SetTimerDuration (long )</code> - If using timers, specify the default timer interval (in milliseconds). Care must be taken when adjusting the timer interval from the default value of 10 milliseconds&ndash;it may adversely affect the interactors.  </li>
<li>
<code>GetTimerDurationMinValue = obj.()</code> - If using timers, specify the default timer interval (in milliseconds). Care must be taken when adjusting the timer interval from the default value of 10 milliseconds&ndash;it may adversely affect the interactors.  </li>
<li>
<code>GetTimerDurationMaxValue = obj.()</code> - If using timers, specify the default timer interval (in milliseconds). Care must be taken when adjusting the timer interval from the default value of 10 milliseconds&ndash;it may adversely affect the interactors.  </li>
<li>
<code>long = obj.GetTimerDuration ()</code> - If using timers, specify the default timer interval (in milliseconds). Care must be taken when adjusting the timer interval from the default value of 10 milliseconds&ndash;it may adversely affect the interactors.  </li>
<li>
<code>obj.SetHandleObservers (int )</code> - Does ProcessEvents handle observers on this class or not  </li>
<li>
<code>int = obj.GetHandleObservers ()</code> - Does ProcessEvents handle observers on this class or not  </li>
<li>
<code>obj.HandleObserversOn ()</code> - Does ProcessEvents handle observers on this class or not  </li>
<li>
<code>obj.HandleObserversOff ()</code> - Does ProcessEvents handle observers on this class or not  </li>
<li>
<code>obj.OnMouseMove ()</code> - Generic event bindings can be overridden in subclasses  </li>
<li>
<code>obj.OnLeftButtonDown ()</code> - Generic event bindings can be overridden in subclasses  </li>
<li>
<code>obj.OnLeftButtonUp ()</code> - Generic event bindings can be overridden in subclasses  </li>
<li>
<code>obj.OnMiddleButtonDown ()</code> - Generic event bindings can be overridden in subclasses  </li>
<li>
<code>obj.OnMiddleButtonUp ()</code> - Generic event bindings can be overridden in subclasses  </li>
<li>
<code>obj.OnRightButtonDown ()</code> - Generic event bindings can be overridden in subclasses  </li>
<li>
<code>obj.OnRightButtonUp ()</code> - Generic event bindings can be overridden in subclasses  </li>
<li>
<code>obj.OnMouseWheelForward ()</code> - Generic event bindings can be overridden in subclasses  </li>
<li>
<code>obj.OnMouseWheelBackward ()</code> - Generic event bindings can be overridden in subclasses  </li>
<li>
<code>obj.OnChar ()</code> - OnChar is triggered when an ASCII key is pressed. Some basic key presses are handled here ('q' for Quit, 'p' for Pick, etc)  </li>
<li>
<code>obj.OnKeyDown ()</code>  </li>
<li>
<code>obj.OnKeyUp ()</code>  </li>
<li>
<code>obj.OnKeyPress ()</code>  </li>
<li>
<code>obj.OnKeyRelease ()</code>  </li>
<li>
<code>obj.OnExpose ()</code> - These are more esoteric events, but are useful in some cases.  </li>
<li>
<code>obj.OnConfigure ()</code> - These are more esoteric events, but are useful in some cases.  </li>
<li>
<code>obj.OnEnter ()</code> - These are more esoteric events, but are useful in some cases.  </li>
<li>
<code>obj.OnLeave ()</code> - These are more esoteric events, but are useful in some cases.  </li>
<li>
<code>obj.OnTimer ()</code> - OnTimer calls Rotate, Rotate etc which should be overridden by style subclasses.  </li>
<li>
<code>obj.Rotate ()</code> - These methods for the different interactions in different modes are overridden in subclasses to perform the correct motion. Since they might be called from OnTimer, they do not have mouse coord parameters (use interactor's GetEventPosition and GetLastEventPosition)  </li>
<li>
<code>obj.Spin ()</code> - These methods for the different interactions in different modes are overridden in subclasses to perform the correct motion. Since they might be called from OnTimer, they do not have mouse coord parameters (use interactor's GetEventPosition and GetLastEventPosition)  </li>
<li>
<code>obj.Pan ()</code> - These methods for the different interactions in different modes are overridden in subclasses to perform the correct motion. Since they might be called from OnTimer, they do not have mouse coord parameters (use interactor's GetEventPosition and GetLastEventPosition)  </li>
<li>
<code>obj.Dolly ()</code> - These methods for the different interactions in different modes are overridden in subclasses to perform the correct motion. Since they might be called from OnTimer, they do not have mouse coord parameters (use interactor's GetEventPosition and GetLastEventPosition)  </li>
<li>
<code>obj.Zoom ()</code> - These methods for the different interactions in different modes are overridden in subclasses to perform the correct motion. Since they might be called from OnTimer, they do not have mouse coord parameters (use interactor's GetEventPosition and GetLastEventPosition)  </li>
<li>
<code>obj.UniformScale ()</code> - These methods for the different interactions in different modes are overridden in subclasses to perform the correct motion. Since they might be called from OnTimer, they do not have mouse coord parameters (use interactor's GetEventPosition and GetLastEventPosition)  </li>
<li>
<code>obj.StartState (int newstate)</code> - utility routines used by state changes  </li>
<li>
<code>obj.StopState ()</code> - utility routines used by state changes  </li>
<li>
<code>obj.StartAnimate ()</code> - Interaction mode entry points used internally.  </li>
<li>
<code>obj.StopAnimate ()</code> - Interaction mode entry points used internally.  </li>
<li>
<code>obj.StartRotate ()</code> - Interaction mode entry points used internally.  </li>
<li>
<code>obj.EndRotate ()</code> - Interaction mode entry points used internally.  </li>
<li>
<code>obj.StartZoom ()</code> - Interaction mode entry points used internally.  </li>
<li>
<code>obj.EndZoom ()</code> - Interaction mode entry points used internally.  </li>
<li>
<code>obj.StartPan ()</code> - Interaction mode entry points used internally.  </li>
<li>
<code>obj.EndPan ()</code> - Interaction mode entry points used internally.  </li>
<li>
<code>obj.StartSpin ()</code> - Interaction mode entry points used internally.  </li>
<li>
<code>obj.EndSpin ()</code> - Interaction mode entry points used internally.  </li>
<li>
<code>obj.StartDolly ()</code> - Interaction mode entry points used internally.  </li>
<li>
<code>obj.EndDolly ()</code> - Interaction mode entry points used internally.  </li>
<li>
<code>obj.StartUniformScale ()</code> - Interaction mode entry points used internally.  </li>
<li>
<code>obj.EndUniformScale ()</code> - Interaction mode entry points used internally.  </li>
<li>
<code>obj.StartTimer ()</code> - Interaction mode entry points used internally.  </li>
<li>
<code>obj.EndTimer ()</code> - Interaction mode entry points used internally.  </li>
<li>
<code>obj.HighlightProp (vtkProp prop)</code> - When picking successfully selects an actor, this method highlights the picked prop appropriately. Currently this is done by placing a bounding box around a picked vtkProp3D, and using the PickColor to highlight a vtkProp2D.  </li>
<li>
<code>obj.HighlightActor2D (vtkActor2D actor2D)</code> - When picking successfully selects an actor, this method highlights the picked prop appropriately. Currently this is done by placing a bounding box around a picked vtkProp3D, and using the PickColor to highlight a vtkProp2D.  </li>
<li>
<code>obj.HighlightProp3D (vtkProp3D prop3D)</code> - When picking successfully selects an actor, this method highlights the picked prop appropriately. Currently this is done by placing a bounding box around a picked vtkProp3D, and using the PickColor to highlight a vtkProp2D.  </li>
<li>
<code>obj.SetPickColor (double , double , double )</code> - Set/Get the pick color (used by default to color vtkActor2D's). The color is expressed as red/green/blue values between (0.0,1.0).  </li>
<li>
<code>obj.SetPickColor (double a[3])</code> - Set/Get the pick color (used by default to color vtkActor2D's). The color is expressed as red/green/blue values between (0.0,1.0).  </li>
<li>
<code>double = obj. GetPickColor ()</code> - Set/Get the pick color (used by default to color vtkActor2D's). The color is expressed as red/green/blue values between (0.0,1.0).  </li>
<li>
<code>obj.SetMouseWheelMotionFactor (double )</code> - Set/Get the mouse wheel motion factor. Default to 1.0. Set it to a different value to emphasize or de-emphasize the action triggered by mouse wheel motion.  </li>
<li>
<code>double = obj.GetMouseWheelMotionFactor ()</code> - Set/Get the mouse wheel motion factor. Default to 1.0. Set it to a different value to emphasize or de-emphasize the action triggered by mouse wheel motion.  </li>
<li>
<code>vtkTDxInteractorStyle = obj.GetTDxStyle ()</code> - 3Dconnexion device interactor style. Initial value is a pointer to an object of class vtkTdxInteractorStyleCamera.  </li>
<li>
<code>obj.SetTDxStyle (vtkTDxInteractorStyle tdxStyle)</code> - 3Dconnexion device interactor style. Initial value is a pointer to an object of class vtkTdxInteractorStyleCamera.  </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkrendering.html">Visualization Toolkit Rendering Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:35 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkGenericAdaptorCell</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkfiltering_vtkgenericadaptorcell.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkGenericAdaptorCell </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkfiltering.html">Visualization Toolkit Filtering Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>In VTK, spatial-temporal data is defined in terms of a dataset which is composed of cells. The cells are topological entities over which an interpolation field is applied. Cells are defined in terms of a topology (e.g., vertices, lines, triangles, polygons, tetrahedra, etc.), points that instantiate the geometry of the cells, and interpolation fields (in the general case one interpolation field is for geometry, the other is for attribute data associated with the cell).</p>
<p>Currently most algorithms in VTK use vtkCell and vtkDataSet, which make assumptions about the nature of datasets, cells, and attributes. In particular, this abstraction assumes that cell interpolation functions are linear, or products of linear functions. Further, VTK implements most of the interpolation functions. This implementation starts breaking down as the complexity of the interpolation (or basis) functions increases.</p>
<p>vtkGenericAdaptorCell addresses these issues by providing more general abstraction for cells. It also adopts modern C++ practices including using iterators. The vtkGenericAdaptorCell is designed to fit within the adaptor framework; meaning that it is meant to adapt VTK to external simulation systems (see the GenericFiltering/README.html).</p>
<p>Please note that most cells are defined in terms of other cells (the boundary cells). They are also defined in terms of points, which are not the same as vertices (vertices are a 0-D cell; points represent a position in space).</p>
<p>Another important concept is the notion of DOFNodes. These concept supports cell types with complex interpolation functions. For example, higher-order p-method finite elements may have different functions on each of their topological features (edges, faces, region). The coefficients of these polynomial functions are associated with DOFNodes. (There is a single DOFNode for each topological feature.) Note that from this perspective, points are used to establish the topological form of the cell; mid-side nodes and such are considered DOFNodes.</p>
<p>To create an instance of class vtkGenericAdaptorCell, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkGenericAdaptorCell
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkGenericAdaptorCell has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkGenericAdaptorCell class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkGenericAdaptorCell = obj.NewInstance ()</code>  </li>
<li>
<code>vtkGenericAdaptorCell = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>vtkIdType = obj.GetId ()</code> - Unique identification number of the cell over the whole data set. This unique key may not be contiguous.  </li>
<li>
<code>int = obj.IsInDataSet ()</code> - Does `this' a cell of a dataset? (otherwise, it is a boundary cell)  </li>
<li>
<code>int = obj.GetType ()</code> - Return the type of the current cell. <dl class="section post"><dt>Postcondition:</dt><dd>(result==VTK_HIGHER_ORDER_EDGE)|| (result==VTK_HIGHER_ORDER_TRIANGLE)|| (result==VTK_HIGHER_ORDER_TETRAHEDRON)  </dd></dl>
</li>
<li>
<code>int = obj.GetDimension ()</code> - Return the topological dimension of the current cell. <dl class="section post"><dt>Postcondition:</dt><dd>valid_result: result&gt;=0 &amp;&amp; result&lt;=3  </dd></dl>
</li>
<li>
<code>int = obj.GetGeometryOrder ()</code> - Return the interpolation order of the geometry. <dl class="section post"><dt>Postcondition:</dt><dd>positive_result: result&gt;=0  </dd></dl>
</li>
<li>
<code>int = obj.IsGeometryLinear ()</code> - Does the cell have a non-linear interpolation for the geometry? <dl class="section post"><dt>Postcondition:</dt><dd>definition: result==(GetGeometryOrder()==1)  </dd></dl>
</li>
<li>
<code>int = obj.GetAttributeOrder (vtkGenericAttribute a)</code> - Return the interpolation order of attribute `a' on the cell (may differ by cell). <dl class="section pre"><dt>Precondition:</dt><dd>a_exists: a!=0 </dd></dl>
<dl class="section post"><dt>Postcondition:</dt><dd>positive_result: result&gt;=0  </dd></dl>
</li>
<li>
<code>int = obj.GetHighestOrderAttribute (vtkGenericAttributeCollection ac)</code> - Return the index of the first point centered attribute with the highest order in `ac'. <dl class="section pre"><dt>Precondition:</dt><dd>ac_exists: ac!=0 </dd></dl>
<dl class="section post"><dt>Postcondition:</dt><dd>valid_result: result&gt;=-1 &amp;&amp; result&lt;ac-&gt;GetNumberOfAttributes()  </dd></dl>
</li>
<li>
<code>int = obj.IsAttributeLinear (vtkGenericAttribute a)</code> - Does the attribute `a' have a non-linear interpolation? <dl class="section pre"><dt>Precondition:</dt><dd>a_exists: a!=0 </dd></dl>
<dl class="section post"><dt>Postcondition:</dt><dd>definition: result==(GetAttributeOrder()==1)  </dd></dl>
</li>
<li>
<code>int = obj.IsPrimary ()</code> - Is the cell primary (i.e. not composite) ?  </li>
<li>
<code>int = obj.GetNumberOfPoints ()</code> - Return the number of corner points that compose the cell. <dl class="section post"><dt>Postcondition:</dt><dd>positive_result: result&gt;=0  </dd></dl>
</li>
<li>
<code>int = obj.GetNumberOfBoundaries (int dim)</code> - Return the number of boundaries of dimension `dim' (or all dimensions greater than 0 and less than GetDimension() if -1) of the cell. When <em>dim</em> is -1, the number of vertices is not included in the count because vertices are a special case: a vertex will have at most a single field value associated with it; DOF nodes may have an arbitrary number of field values associated with them. <dl class="section pre"><dt>Precondition:</dt><dd>valid_dim_range: (dim==-1) || ((dim&gt;=0)&amp;&amp;(dim&lt;GetDimension())) </dd></dl>
<dl class="section post"><dt>Postcondition:</dt><dd>positive_result: result&gt;=0  </dd></dl>
</li>
<li>
<p class="startli"><code>int = obj.GetNumberOfDOFNodes ()</code> - Accumulated number of DOF nodes of the current cell. A DOF node is a component of cell with a given topological dimension. e.g.: a triangle has 4 DOF: 1 face and 3 edges. An hexahedron has 19 DOF: 1 region, 6 faces, and 12 edges.</p>
<p class="endli">The number of vertices is not included in the count because vertices are a special case: a vertex will have at most a single field value associated with it; DOF nodes may have an arbitrary number of field values associated with them. </p>
<dl class="section post"><dt>Postcondition:</dt><dd>valid_result: result==GetNumberOfBoundaries(-1)+1  </dd></dl>
</li>
<li>
<code>obj.GetPointIterator (vtkGenericPointIterator it)</code> - Return the points of cell into `it'. <dl class="section pre"><dt>Precondition:</dt><dd>it_exists: it!=0  </dd></dl>
</li>
<li>
<code>vtkGenericCellIterator = obj.NewCellIterator ()</code> - Create an empty cell iterator. The user is responsible for deleting it. <dl class="section post"><dt>Postcondition:</dt><dd>result_exists: result!=0  </dd></dl>
</li>
<li>
<code>obj.GetBoundaryIterator (vtkGenericCellIterator boundaries, int dim)</code> - Return the `boundaries' cells of dimension `dim' (or all dimensions less than GetDimension() if -1) that are part of the boundary of the cell. <dl class="section pre"><dt>Precondition:</dt><dd>valid_dim_range: (dim==-1) || ((dim&gt;=0)&amp;&amp;(dim&lt;GetDimension())) </dd>
<dd>
boundaries_exist: boundaries!=0  </dd></dl>
</li>
<li>
<code>int = obj.CountNeighbors (vtkGenericAdaptorCell boundary)</code> - Number of cells (dimension&gt;boundary-&gt;GetDimension()) of the dataset that share the boundary `boundary' of `this'. `this' IS NOT INCLUDED. <dl class="section pre"><dt>Precondition:</dt><dd>boundary_exists: boundary!=0 </dd>
<dd>
real_boundary: !boundary-&gt;IsInDataSet() </dd>
<dd>
cell_of_the_dataset: IsInDataSet() </dd>
<dd>
boundary: HasBoundary(boundary) </dd></dl>
<dl class="section post"><dt>Postcondition:</dt><dd>positive_result: result&gt;=0  </dd></dl>
</li>
<li>
<code>obj.CountEdgeNeighbors (int sharing)</code> - Number of cells (dimension&gt;boundary-&gt;GetDimension()) of the dataset that share the boundary `boundary' of `this'. `this' IS NOT INCLUDED. <dl class="section pre"><dt>Precondition:</dt><dd>boundary_exists: boundary!=0 </dd>
<dd>
real_boundary: !boundary-&gt;IsInDataSet() </dd>
<dd>
cell_of_the_dataset: IsInDataSet() </dd>
<dd>
boundary: HasBoundary(boundary) </dd></dl>
<dl class="section post"><dt>Postcondition:</dt><dd>positive_result: result&gt;=0  </dd></dl>
</li>
<li>
<code>obj.GetNeighbors (vtkGenericAdaptorCell boundary, vtkGenericCellIterator neighbors)</code> - Put into `neighbors' the cells (dimension&gt;boundary-&gt;GetDimension()) of the dataset that share the boundary `boundary' with this cell. `this' IS NOT INCLUDED. <dl class="section pre"><dt>Precondition:</dt><dd>boundary_exists: boundary!=0 </dd>
<dd>
real_boundary: !boundary-&gt;IsInDataSet() </dd>
<dd>
cell_of_the_dataset: IsInDataSet() </dd>
<dd>
boundary: HasBoundary(boundary) </dd>
<dd>
neighbors_exist: neighbors!=0  </dd></dl>
</li>
<li>
<code>obj.EvaluateLocation (int subId, double pcoords[3], double x[3])</code> - Determine the global coordinates `x' from sub-cell `subId' and parametric coordinates `pcoords' in the cell. <dl class="section pre"><dt>Precondition:</dt><dd>positive_subId: subId&gt;=0 </dd>
<dd>
clamped_pcoords: (0&lt;=pcoords[0])&amp;&amp;(pcoords[0]&lt;=1)&amp;&amp;(0&lt;=pcoords[1]) &amp;&amp;(pcoords[1]&lt;=1)&amp;&amp;(0&lt;=pcoords[2])&amp;&amp;(pcoords[2]&lt;=1)  </dd></dl>
</li>
<li>
<code>obj.InterpolateTuple (vtkGenericAttribute a, double pcoords[3], double val)</code> - Interpolate the attribute `a' at local position `pcoords' of the cell into `val'. <dl class="section pre"><dt>Precondition:</dt><dd>a_exists: a!=0 </dd>
<dd>
a_is_point_centered: a-&gt;GetCentering()==vtkPointCentered </dd>
<dd>
clamped_point: pcoords[0]&gt;=0 &amp;&amp; pcoords[0]&lt;=1 &amp;&amp; pcoords[1]&gt;=0 &amp;&amp; pcoords[1]&lt;=1 &amp;&amp; pcoords[2]&gt;=0 &amp;&amp; pcoords[2]&lt;=1 </dd>
<dd>
val_exists: val!=0 </dd>
<dd>
valid_size: sizeof(val)==a-&gt;GetNumberOfComponents()  </dd></dl>
</li>
<li>
<code>obj.InterpolateTuple (vtkGenericAttributeCollection c, double pcoords[3], double val)</code> - Interpolate the whole collection of attributes `c' at local position `pcoords' of the cell into `val'. Only point centered attributes are taken into account. <dl class="section pre"><dt>Precondition:</dt><dd>c_exists: c!=0 </dd>
<dd>
clamped_point: pcoords[0]&gt;=0 &amp;&amp; pcoords[0]&lt;=1 &amp;&amp; pcoords[1]&gt;=0 &amp;&amp; pcoords[1]&lt;=1 &amp;&amp; pcoords[2]&gt;=0 &amp;&amp; pcoords[2]&lt;=1 </dd>
<dd>
val_exists: val!=0 </dd>
<dd>
valid_size: sizeof(val)==c-&gt;GetNumberOfPointCenteredComponents()  </dd></dl>
</li>
<li>
<p class="startli"><code>obj.Contour (vtkContourValues values, vtkImplicitFunction f, vtkGenericAttributeCollection attributes, vtkGenericCellTessellator tess, vtkIncrementalPointLocator locator, vtkCellArray verts, vtkCellArray lines, vtkCellArray polys, vtkPointData outPd, vtkCellData outCd, vtkPointData internalPd, vtkPointData secondaryPd, vtkCellData secondaryCd)</code> - Generate a contour (contouring primitives) for each `values' or with respect to an implicit function `f'. Contouring is performed on the scalar attribute (`attributes-&gt;GetActiveAttribute()' `attributes-&gt;GetActiveComponent()'). Contouring interpolates the `attributes-&gt;GetNumberOfattributesToInterpolate()' attributes `attributes-&gt;GetAttributesToInterpolate()'. The `locator', `verts', `lines', `polys', `outPd' and `outCd' are cumulative data arrays over cell iterations: they store the result of each call to Contour():</p>
<ul>
<li>`locator' is a points list that merges points as they are inserted (i.e., prevents duplicates).</li>
<li>`verts' is an array of generated vertices</li>
<li>`lines' is an array of generated lines</li>
<li>`polys' is an array of generated polygons</li>
<li>`outPd' is an array of interpolated point data along the edge (if not-NULL)</li>
<li>`outCd' is an array of copied cell data of the current cell (if not-NULL) `internalPd', `secondaryPd' and `secondaryCd' are initialized by the filter that call it from `attributes'.</li>
<li>`internalPd' stores the result of the tessellation pass: the higher-order cell is tessellated into linear sub-cells.</li>
<li>`secondaryPd' and `secondaryCd' are used internally as inputs to the Contour() method on linear sub-cells. Note: the CopyAllocate() method must be invoked on both `outPd' and `outCd', from `secondaryPd' and `secondaryCd'.</li>
</ul>
<p>NOTE: `vtkGenericAttributeCollection *attributes' will be replaced by a `vtkInformation'.</p>
<dl class="section pre"><dt>Precondition:</dt><dd>values_exist: (values!=0 &amp;&amp; f==0) || (values==0 &amp;&amp; f!=0) </dd>
<dd>
attributes_exist: attributes!=0 </dd>
<dd>
tessellator_exists: tess!=0 </dd>
<dd>
locator_exists: locator!=0 </dd>
<dd>
verts_exist: verts!=0 </dd>
<dd>
lines_exist: lines!=0 </dd>
<dd>
polys_exist: polys!=0 </dd>
<dd>
internalPd_exists: internalPd!=0 </dd>
<dd>
secondaryPd_exists: secondaryPd!=0 </dd>
<dd>
secondaryCd_exists: secondaryCd!=0  </dd></dl>
</li>
<li>
<p class="startli"><code>obj.Clip (double value, vtkImplicitFunction f, vtkGenericAttributeCollection attributes, vtkGenericCellTessellator tess, int insideOut, vtkIncrementalPointLocator locator, vtkCellArray connectivity, vtkPointData outPd, vtkCellData outCd, vtkPointData internalPd, vtkPointData secondaryPd, vtkCellData secondaryCd)</code> - Cut (or clip) the current cell with respect to the contour defined by the `value' or the implicit function `f' of the scalar attribute (`attributes-&gt;GetActiveAttribute()',`attributes-&gt;GetActiveComponent()'). If `f' exists, `value' is not used. The output is the part of the current cell which is inside the contour. The output is a set of zero, one or more cells of the same topological dimension as the current cell. Normally, cell points whose scalar value is greater than "value" are considered inside. If `insideOut' is on, this is reversed. Clipping interpolates the `attributes-&gt;GetNumberOfattributesToInterpolate()' attributes `attributes-&gt;GetAttributesToInterpolate()'. `locator', `connectivity', `outPd' and `outCd' are cumulative data arrays over cell iterations: they store the result of each call to Clip():</p>
<ul>
<li>`locator' is a points list that merges points as they are inserted (i.e., prevents duplicates).</li>
<li>`connectivity' is an array of generated cells</li>
<li>`outPd' is an array of interpolated point data along the edge (if not-NULL)</li>
<li>`outCd' is an array of copied cell data of the current cell (if not-NULL) `internalPd', `secondaryPd' and `secondaryCd' are initialized by the filter that call it from `attributes'.</li>
<li>`internalPd' stores the result of the tessellation pass: the higher-order cell is tessellated into linear sub-cells.</li>
<li>`secondaryPd' and `secondaryCd' are used internally as inputs to the Clip() method on linear sub-cells. Note: the CopyAllocate() method must be invoked on both `outPd' and `outCd', from `secondaryPd' and `secondaryCd'.</li>
</ul>
<p>NOTE: `vtkGenericAttributeCollection *attributes' will be replaced by a `vtkInformation'.</p>
<dl class="section pre"><dt>Precondition:</dt><dd>attributes_exist: attributes!=0 </dd>
<dd>
tessellator_exists: tess!=0 </dd>
<dd>
locator_exists: locator!=0 </dd>
<dd>
connectivity_exists: connectivity!=0 </dd>
<dd>
internalPd_exists: internalPd!=0 </dd>
<dd>
secondaryPd_exists: secondaryPd!=0 </dd>
<dd>
secondaryCd_exists: secondaryCd!=0  </dd></dl>
</li>
<li>
<code>obj.Derivatives (int subId, double pcoords[3], vtkGenericAttribute attribute, double derivs)</code> - Compute derivatives `derivs' of the attribute `attribute' (from its values at the corner points of the cell) given sub-cell `subId' (0 means primary cell) and parametric coordinates `pcoords'. Derivatives are in the x-y-z coordinate directions for each data value. <dl class="section pre"><dt>Precondition:</dt><dd>positive_subId: subId&gt;=0 </dd>
<dd>
clamped_pcoords: (0&lt;=pcoords[0])&amp;&amp;(pcoords[0]&lt;=1)&amp;&amp;(0&lt;=pcoords[1]) &amp;&amp;(pcoords[1]&lt;=1)&amp;&amp;(0&lt;=pcoords[2])%%(pcoords[2]&lt;=1) </dd>
<dd>
attribute_exists: attribute!=0 </dd>
<dd>
derivs_exists: derivs!=0 </dd>
<dd>
valid_size: sizeof(derivs)&gt;=attribute-&gt;GetNumberOfComponents()*3  </dd></dl>
</li>
<li>
<code>obj.GetBounds (double bounds[6])</code> - Compute the bounding box of the current cell in `bounds' in global coordinates. THREAD SAFE  </li>
<li>
<code>double = obj.GetLength2 ()</code> - Return the bounding box diagonal squared of the current cell. <dl class="section post"><dt>Postcondition:</dt><dd>positive_result: result&gt;=0  </dd></dl>
</li>
<li>
<code>int = obj.GetParametricCenter (double pcoords[3])</code> - Get the center of the current cell (in parametric coordinates) and place it in `pcoords'. If the current cell is a composite, the return value is the sub-cell id that the center is in. <dl class="section post"><dt>Postcondition:</dt><dd>valid_result: (result&gt;=0) &amp;&amp; (IsPrimary() implies result==0)  </dd></dl>
</li>
<li>
<code>double = obj.GetParametricDistance (double pcoords[3])</code> - Return the distance of the parametric coordinate `pcoords' to the current cell. If inside the cell, a distance of zero is returned. This is used during picking to get the correct cell picked. (The tolerance will occasionally allow cells to be picked who are not really intersected "inside" the cell.) <dl class="section post"><dt>Postcondition:</dt><dd>positive_result: result&gt;=0  </dd></dl>
</li>
<li>
<code>obj.Tessellate (vtkGenericAttributeCollection attributes, vtkGenericCellTessellator tess, vtkPoints points, vtkIncrementalPointLocator locator, vtkCellArray cellArray, vtkPointData internalPd, vtkPointData pd, vtkCellData cd, vtkUnsignedCharArray types)</code> - Tessellate the cell if it is not linear or if at least one attribute of `attributes' is not linear. The output are linear cells of the same dimension than the cell. If the cell is linear and all attributes are linear, the output is just a copy of the current cell. `points', `cellArray', `pd' and `cd' are cumulative output data arrays over cell iterations: they store the result of each call to Tessellate(). `internalPd' is initialized by the calling filter and stores the result of the tessellation. If it is not null, `types' is filled with the types of the linear cells. `types' is null when it is called from vtkGenericGeometryFilter and not null when it is called from vtkGenericDatasetTessellator. <dl class="section pre"><dt>Precondition:</dt><dd>attributes_exist: attributes!=0 </dd>
<dd>
tessellator_exists: tess!=0 </dd>
<dd>
points_exist: points!=0 </dd>
<dd>
cellArray_exists: cellArray!=0 </dd>
<dd>
internalPd_exists: internalPd!=0 </dd>
<dd>
pd_exist: pd!=0 </dd>
<dd>
cd_exists: cd!=0  </dd></dl>
</li>
<li>
<code>int = obj.IsFaceOnBoundary (vtkIdType faceId)</code> - Is the face `faceId' of the current cell on the exterior boundary of the dataset? <dl class="section pre"><dt>Precondition:</dt><dd>3d: GetDimension()==3  </dd></dl>
</li>
<li>
<code>int = obj.IsOnBoundary ()</code> - Is the cell on the exterior boundary of the dataset? <dl class="section pre"><dt>Precondition:</dt><dd>2d: GetDimension()==2  </dd></dl>
</li>
<li>
<code>obj.TriangulateFace (vtkGenericAttributeCollection attributes, vtkGenericCellTessellator tess, int index, vtkPoints points, vtkIncrementalPointLocator locator, vtkCellArray cellArray, vtkPointData internalPd, vtkPointData pd, vtkCellData cd)</code> - Tessellate face `index' of the cell. See Tessellate() for further explanations. <dl class="section pre"><dt>Precondition:</dt><dd>cell_is_3d: GetDimension()==3 </dd>
<dd>
attributes_exist: attributes!=0 </dd>
<dd>
tessellator_exists: tess!=0 </dd>
<dd>
valid_face: index&gt;=0 </dd>
<dd>
points_exist: points!=0 </dd>
<dd>
cellArray_exists: cellArray!=0 </dd>
<dd>
internalPd_exists: internalPd!=0 </dd>
<dd>
pd_exist: pd!=0 </dd>
<dd>
cd_exists: cd!=0  </dd></dl>
</li>
<li>
<code>int = obj.GetNumberOfVerticesOnFace (int faceId)</code> - Return the number of vertices defining face `faceId'. <dl class="section pre"><dt>Precondition:</dt><dd>is_3d: this-&gt;GetDimension()==3 </dd>
<dd>
valid_faceId_range: faceId&gt;=0 &amp;&amp; faceId&lt;this-&gt;GetNumberOfBoundaries(2) </dd></dl>
<dl class="section post"><dt>Postcondition:</dt><dd>positive_result: &amp;&amp; result&gt;0  </dd></dl>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkfiltering.html">Visualization Toolkit Filtering Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:30 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

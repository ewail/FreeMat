<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkParallelRenderManager</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkparallel_vtkparallelrendermanager.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkParallelRenderManager </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkparallel.html">Visualization Toolkit Parallel Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>vtkParallelRenderManager operates in multiple processes. It provides proper renderers and render windows for performing the parallel rendering correctly. It can also attach itself to render windows and propagate rendering events and camera views.</p>
<p>.SECTION Note: Many parallel rendering schemes do not correctly handle transparency. Unless otherwise documented, assume a sub class does not.</p>
<p>.SECTION ToDo: Synchronization/barrier primitives.</p>
<p>Query ranges of scalar values of objects in addition to the boundry in three-space</p>
<p>To create an instance of class vtkParallelRenderManager, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkParallelRenderManager
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkParallelRenderManager has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkParallelRenderManager class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkParallelRenderManager = obj.NewInstance ()</code>  </li>
<li>
<code>vtkParallelRenderManager = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>vtkRenderWindow = obj.MakeRenderWindow ()</code> - Builds a vtkRenderWindow compatible with this render manager. The user program is responsible for registering the render window with the SetRenderWindow method and calling Delete. It is not advisable to use a parallel render manager with a render window that was not built with this method.  </li>
<li>
<code>vtkRenderer = obj.MakeRenderer ()</code> - Builds a vtkRenderer compatible with this render manager. (Should we also register it?) The user program is responsible for calling Delete. It is not advisable to use a parallel render manager with a renderer that was not built with this method.  </li>
<li>
<code>vtkRenderWindow = obj.GetRenderWindow ()</code> - Set/Get the RenderWindow to use for compositing. We add a start and end observer to the window.  </li>
<li>
<code>obj.SetRenderWindow (vtkRenderWindow renWin)</code> - Set/Get the RenderWindow to use for compositing. We add a start and end observer to the window.  </li>
<li>
<code>vtkMultiProcessController = obj.GetController ()</code> - Set/Get the vtkMultiProcessController which will handle communications for the parallel rendering.  </li>
<li>
<code>obj.SetController (vtkMultiProcessController controller)</code> - Set/Get the vtkMultiProcessController which will handle communications for the parallel rendering.  </li>
<li>
<code>obj.InitializePieces ()</code> - This method sets the piece and number of pieces for each actor with a polydata mapper.  </li>
<li>
<code>obj.InitializeOffScreen ()</code> - Make all rendering windows not viewable set as off screen rendering. To make all renderwindows on screen rendering again, call OffScreenRenderingOff on all the render windows. This class assumes the window on root node is the only one viewable. Subclasses should change this as necessary.  </li>
<li>
<code>obj.StartInteractor ()</code> - Initializes the RMIs and then, if on root node, starts the interactor on the attached render window. Otherwise, starts processing RMIs. When the interactor returns, it breaks the RMI listening on all other processors.  </li>
<li>
<code>obj.StartServices ()</code> - If on node other than root, starts serving RMI requests for parallel renders.  </li>
<li>
<code>obj.StopServices ()</code> - If on root node, stops the RMI processing on all service nodes.  </li>
<li>
<code>obj.StartRender ()</code> - Callbacks that initialize and finish rendering and other tasks.  </li>
<li>
<code>obj.EndRender ()</code> - Callbacks that initialize and finish rendering and other tasks.  </li>
<li>
<code>obj.SatelliteStartRender ()</code> - Callbacks that initialize and finish rendering and other tasks.  </li>
<li>
<code>obj.SatelliteEndRender ()</code> - Callbacks that initialize and finish rendering and other tasks.  </li>
<li>
<code>obj.RenderRMI ()</code> - Callbacks that initialize and finish rendering and other tasks.  </li>
<li>
<code>obj.ResetCamera (vtkRenderer ren)</code> - Callbacks that initialize and finish rendering and other tasks.  </li>
<li>
<code>obj.ResetCameraClippingRange (vtkRenderer ren)</code> - Callbacks that initialize and finish rendering and other tasks.  </li>
<li>
<code>obj.ComputeVisiblePropBoundsRMI (int renderId)</code> - Callbacks that initialize and finish rendering and other tasks.  </li>
<li>
<code>obj.InitializeRMIs ()</code>  </li>
<li>
<code>obj.ResetAllCameras ()</code> - Resets the camera of each renderer contained in the RenderWindow. Should only be called in the "root" process, and all remote processes must be processing RMIs for this method to complete.  </li>
<li>
<code>obj.ComputeVisiblePropBounds (vtkRenderer ren, double bounds[6])</code> - Calculates the bounds by gathering information from all processes.  </li>
<li>
<code>obj.SetParallelRendering (int )</code> - Turns on/off parallel rendering. When on (the default) the object responds to render events of the attached window, propagates the render event to other processors, and otherwise enables the parallel rendering process.  </li>
<li>
<code>int = obj.GetParallelRendering ()</code> - Turns on/off parallel rendering. When on (the default) the object responds to render events of the attached window, propagates the render event to other processors, and otherwise enables the parallel rendering process.  </li>
<li>
<code>obj.ParallelRenderingOn ()</code> - Turns on/off parallel rendering. When on (the default) the object responds to render events of the attached window, propagates the render event to other processors, and otherwise enables the parallel rendering process.  </li>
<li>
<code>obj.ParallelRenderingOff ()</code> - Turns on/off parallel rendering. When on (the default) the object responds to render events of the attached window, propagates the render event to other processors, and otherwise enables the parallel rendering process.  </li>
<li>
<code>obj.SetRenderEventPropagation (int )</code> - Turns on/off render event propagation. When on (the default) and ParallelRendering is on, process 0 will send an RMI call to all remote processes to perform a synchronized render. When off, render must be manually called on each process.  </li>
<li>
<code>int = obj.GetRenderEventPropagation ()</code> - Turns on/off render event propagation. When on (the default) and ParallelRendering is on, process 0 will send an RMI call to all remote processes to perform a synchronized render. When off, render must be manually called on each process.  </li>
<li>
<code>obj.RenderEventPropagationOn ()</code> - Turns on/off render event propagation. When on (the default) and ParallelRendering is on, process 0 will send an RMI call to all remote processes to perform a synchronized render. When off, render must be manually called on each process.  </li>
<li>
<code>obj.RenderEventPropagationOff ()</code> - Turns on/off render event propagation. When on (the default) and ParallelRendering is on, process 0 will send an RMI call to all remote processes to perform a synchronized render. When off, render must be manually called on each process.  </li>
<li>
<code>obj.SetUseCompositing (int )</code> - This is used for tiled display rendering. When data has been duplicated on all processes, then we do not need to compositing. Cameras and renders are still propagated though.  </li>
<li>
<code>int = obj.GetUseCompositing ()</code> - This is used for tiled display rendering. When data has been duplicated on all processes, then we do not need to compositing. Cameras and renders are still propagated though.  </li>
<li>
<code>obj.UseCompositingOn ()</code> - This is used for tiled display rendering. When data has been duplicated on all processes, then we do not need to compositing. Cameras and renders are still propagated though.  </li>
<li>
<code>obj.UseCompositingOff ()</code> - This is used for tiled display rendering. When data has been duplicated on all processes, then we do not need to compositing. Cameras and renders are still propagated though.  </li>
<li>
<code>obj.SetImageReductionFactor (double factor)</code> - Set/Get the reduction factor (for sort-last based parallel renderers). The size of rendered image is divided by the reduction factor and then is blown up to the size of the current vtkRenderWindow. Setting higher reduction factors enables shorter image transfer times (which is often the bottleneck) but will greatly reduce image quality. A reduction factor of 2 or greater should only be used for intermediate images in interactive applications. A reduction factor of 1 (or less) will result in no change in image quality. A parallel render manager may ignore the image reduction factor if it will result in little or no performance enhancements (eg. it does not do image space manipulations).  </li>
<li>
<code>double = obj.GetImageReductionFactor ()</code> - Set/Get the reduction factor (for sort-last based parallel renderers). The size of rendered image is divided by the reduction factor and then is blown up to the size of the current vtkRenderWindow. Setting higher reduction factors enables shorter image transfer times (which is often the bottleneck) but will greatly reduce image quality. A reduction factor of 2 or greater should only be used for intermediate images in interactive applications. A reduction factor of 1 (or less) will result in no change in image quality. A parallel render manager may ignore the image reduction factor if it will result in little or no performance enhancements (eg. it does not do image space manipulations).  </li>
<li>
<code>obj.SetMaxImageReductionFactor (double )</code>  </li>
<li>
<code>double = obj.GetMaxImageReductionFactor ()</code>  </li>
<li>
<code>obj.SetImageReductionFactorForUpdateRate (double DesiredUpdateRate)</code> - Sets the ReductionFactor based on the given desired update rate and the rendering metrics taken from the last time UpdateServerInfo was called. Note that if AutoReductionFactor is on, this function is called with the desired update rate of the render window automatically.  </li>
<li>
<code>obj.SetAutoImageReductionFactor (int )</code> - If on, the ReductionFactor is automatically adjusted to best meet the the DesiredUpdateRate in the current RenderWindow based on metrics from the last render.  </li>
<li>
<code>int = obj.GetAutoImageReductionFactor ()</code> - If on, the ReductionFactor is automatically adjusted to best meet the the DesiredUpdateRate in the current RenderWindow based on metrics from the last render.  </li>
<li>
<code>obj.AutoImageReductionFactorOn ()</code> - If on, the ReductionFactor is automatically adjusted to best meet the the DesiredUpdateRate in the current RenderWindow based on metrics from the last render.  </li>
<li>
<code>obj.AutoImageReductionFactorOff ()</code> - If on, the ReductionFactor is automatically adjusted to best meet the the DesiredUpdateRate in the current RenderWindow based on metrics from the last render.  </li>
<li>
<code>double = obj.GetRenderTime ()</code> - Get rendering metrics.  </li>
<li>
<code>double = obj.GetImageProcessingTime ()</code> - Get rendering metrics.  </li>
<li>
<code>int = obj.GetSyncRenderWindowRenderers ()</code> - By default, the state of all renderers in the root's render window is propagated to the rest of the processes. In order for this to work, all render windows must have the same renderers in the same order. If this is not the case, you can turn off the SyncRenderWindowRenderers. When this flag is off, the list of renderers held by this parallel render manager (initially empty) is synced. You can modify the list of renderers with the AddRenderer, RemoveRenderer, and RemoveAllRenderers methods.  </li>
<li>
<code>obj.SetSyncRenderWindowRenderers (int )</code> - By default, the state of all renderers in the root's render window is propagated to the rest of the processes. In order for this to work, all render windows must have the same renderers in the same order. If this is not the case, you can turn off the SyncRenderWindowRenderers. When this flag is off, the list of renderers held by this parallel render manager (initially empty) is synced. You can modify the list of renderers with the AddRenderer, RemoveRenderer, and RemoveAllRenderers methods.  </li>
<li>
<code>obj.SyncRenderWindowRenderersOn ()</code> - By default, the state of all renderers in the root's render window is propagated to the rest of the processes. In order for this to work, all render windows must have the same renderers in the same order. If this is not the case, you can turn off the SyncRenderWindowRenderers. When this flag is off, the list of renderers held by this parallel render manager (initially empty) is synced. You can modify the list of renderers with the AddRenderer, RemoveRenderer, and RemoveAllRenderers methods.  </li>
<li>
<code>obj.SyncRenderWindowRenderersOff ()</code> - By default, the state of all renderers in the root's render window is propagated to the rest of the processes. In order for this to work, all render windows must have the same renderers in the same order. If this is not the case, you can turn off the SyncRenderWindowRenderers. When this flag is off, the list of renderers held by this parallel render manager (initially empty) is synced. You can modify the list of renderers with the AddRenderer, RemoveRenderer, and RemoveAllRenderers methods.  </li>
<li>
<code>obj.AddRenderer (vtkRenderer )</code> - By default, the state of all renderers in the root's render window is propagated to the rest of the processes. In order for this to work, all render windows must have the same renderers in the same order. If this is not the case, you can turn off the SyncRenderWindowRenderers. When this flag is off, the list of renderers held by this parallel render manager (initially empty) is synced. You can modify the list of renderers with the AddRenderer, RemoveRenderer, and RemoveAllRenderers methods.  </li>
<li>
<code>obj.RemoveRenderer (vtkRenderer )</code> - By default, the state of all renderers in the root's render window is propagated to the rest of the processes. In order for this to work, all render windows must have the same renderers in the same order. If this is not the case, you can turn off the SyncRenderWindowRenderers. When this flag is off, the list of renderers held by this parallel render manager (initially empty) is synced. You can modify the list of renderers with the AddRenderer, RemoveRenderer, and RemoveAllRenderers methods.  </li>
<li>
<code>obj.RemoveAllRenderers ()</code> - By default, the state of all renderers in the root's render window is propagated to the rest of the processes. In order for this to work, all render windows must have the same renderers in the same order. If this is not the case, you can turn off the SyncRenderWindowRenderers. When this flag is off, the list of renderers held by this parallel render manager (initially empty) is synced. You can modify the list of renderers with the AddRenderer, RemoveRenderer, and RemoveAllRenderers methods.  </li>
<li>
<code>obj.SetWriteBackImages (int )</code> - If on (the default), the result of any image space manipulations are written back to the render window frame buffer. If off, the image stored in the frame buffer may not be correct. Either way, the correct frame buffer images may be read with vtkParallelRenderManager::GetPixelData. Turning WriteBackImages off may result in a speedup if the render window is not visible to the user and images are read back for further processing or transit.  </li>
<li>
<code>int = obj.GetWriteBackImages ()</code> - If on (the default), the result of any image space manipulations are written back to the render window frame buffer. If off, the image stored in the frame buffer may not be correct. Either way, the correct frame buffer images may be read with vtkParallelRenderManager::GetPixelData. Turning WriteBackImages off may result in a speedup if the render window is not visible to the user and images are read back for further processing or transit.  </li>
<li>
<code>obj.WriteBackImagesOn ()</code> - If on (the default), the result of any image space manipulations are written back to the render window frame buffer. If off, the image stored in the frame buffer may not be correct. Either way, the correct frame buffer images may be read with vtkParallelRenderManager::GetPixelData. Turning WriteBackImages off may result in a speedup if the render window is not visible to the user and images are read back for further processing or transit.  </li>
<li>
<code>obj.WriteBackImagesOff ()</code> - If on (the default), the result of any image space manipulations are written back to the render window frame buffer. If off, the image stored in the frame buffer may not be correct. Either way, the correct frame buffer images may be read with vtkParallelRenderManager::GetPixelData. Turning WriteBackImages off may result in a speedup if the render window is not visible to the user and images are read back for further processing or transit.  </li>
<li>
<code>obj.SetMagnifyImages (int )</code> - If on (the default), when the ImageReductionFactor is greater than 1 and WriteBackImages is on, the image will be magnified to fill the entire render window.  </li>
<li>
<code>int = obj.GetMagnifyImages ()</code> - If on (the default), when the ImageReductionFactor is greater than 1 and WriteBackImages is on, the image will be magnified to fill the entire render window.  </li>
<li>
<code>obj.MagnifyImagesOn ()</code> - If on (the default), when the ImageReductionFactor is greater than 1 and WriteBackImages is on, the image will be magnified to fill the entire render window.  </li>
<li>
<code>obj.MagnifyImagesOff ()</code> - If on (the default), when the ImageReductionFactor is greater than 1 and WriteBackImages is on, the image will be magnified to fill the entire render window.  </li>
<li>
<code>obj.SetMagnifyImageMethod (int method)</code> - Sets the method used to magnify images. Nearest simply replicates each pixel enough times to fill the image. Linear performs linear interpolation between the pixels.  </li>
<li>
<code>int = obj.GetMagnifyImageMethod ()</code> - Sets the method used to magnify images. Nearest simply replicates each pixel enough times to fill the image. Linear performs linear interpolation between the pixels.  </li>
<li>
<code>obj.SetMagnifyImageMethodToNearest ()</code> - Sets the method used to magnify images. Nearest simply replicates each pixel enough times to fill the image. Linear performs linear interpolation between the pixels.  </li>
<li>
<code>obj.SetMagnifyImageMethodToLinear ()</code> - Convenience functions for magnifying images.  </li>
<li>
<code>obj.MagnifyImage (vtkUnsignedCharArray fullImage, int fullImageSize[2], vtkUnsignedCharArray reducedImage, int reducedImageSize[2], int fullImageViewport[4]NULL, int reducedImageViewport[4]NULL)</code> - Convenience functions for magnifying images.  </li>
<li>
<code>obj.GetPixelData (vtkUnsignedCharArray data)</code> - The most appropriate way to retrieve full size image data after a render. Will work regardless of whether WriteBackImages or MagnifyImage is on or off. The data returned may be a shallow copy of an internal array. Therefore, the data may be invalid after the next render or if the ParallelRenderManager is destroyed.  </li>
<li>
<code>obj.GetPixelData (int x1, int y1, int x2, int y2, vtkUnsignedCharArray data)</code> - The most appropriate way to retrieve full size image data after a render. Will work regardless of whether WriteBackImages or MagnifyImage is on or off. The data returned may be a shallow copy of an internal array. Therefore, the data may be invalid after the next render or if the ParallelRenderManager is destroyed.  </li>
<li>
<code>obj.GetReducedPixelData (vtkUnsignedCharArray data)</code> - The most appropriate way to retrieve reduced size image data after a render. Will work regardless of whether WriteBackImages or MagnifyImage is on or off. The data returned may be a shallow copy of an internal array. Therefore, the data may be invalid after the next render or if the ParallelRenderManager is destroyed.  </li>
<li>
<code>obj.GetReducedPixelData (int x1, int y1, int x2, int y2, vtkUnsignedCharArray data)</code> - The most appropriate way to retrieve reduced size image data after a render. Will work regardless of whether WriteBackImages or MagnifyImage is on or off. The data returned may be a shallow copy of an internal array. Therefore, the data may be invalid after the next render or if the ParallelRenderManager is destroyed.  </li>
<li>
<code>int = obj. GetFullImageSize ()</code> - Returns the full image size calculated at the last render.  </li>
<li>
<code>int = obj. GetReducedImageSize ()</code> - Returns the reduced image size calculated at the last render.  </li>
<li>
<code>obj.TileWindows (int xsize, int ysize, int nColumns)</code> - Given the x and y size of the render windows, reposition them in a tile of n columns.  </li>
<li>
<code>obj.SetUseRGBA (int )</code> - Get/Set if all Images must use RGBA instead of RGB. By default, this flag is on.  </li>
<li>
<code>int = obj.GetUseRGBA ()</code> - Get/Set if all Images must use RGBA instead of RGB. By default, this flag is on.  </li>
<li>
<code>obj.SetForceRenderWindowSize (int )</code> - If ForceRenderWindowSize is set to true, the render manager will use the RenderWindowSize ivar instead of getting the size from the render window.  </li>
<li>
<code>int = obj.GetForceRenderWindowSize ()</code> - If ForceRenderWindowSize is set to true, the render manager will use the RenderWindowSize ivar instead of getting the size from the render window.  </li>
<li>
<code>obj.SetForcedRenderWindowSize (int , int )</code> - If ForceRenderWindowSize is set to true, the render manager will use the Size ivar instead of getting the size from the render window.  </li>
<li>
<code>obj.SetForcedRenderWindowSize (int a[2])</code> - If ForceRenderWindowSize is set to true, the render manager will use the Size ivar instead of getting the size from the render window.  </li>
<li>
<code>int = obj. GetForcedRenderWindowSize ()</code> - If ForceRenderWindowSize is set to true, the render manager will use the Size ivar instead of getting the size from the render window.  </li>
<li>
<code>obj.StartService ()</code> -  </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkparallel.html">Visualization Toolkit Parallel Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:34 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkHyperOctreeCutter</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkgraphics_vtkhyperoctreecutter.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkHyperOctreeCutter </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkgraphics.html">Visualization Toolkit Graphics Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>vtkHyperOctreeCutter is a filter to cut through data using any subclass of vtkImplicitFunction. That is, a polygonal surface is created corresponding to the implicit function F(x,y,z) = value(s), where you can specify one or more values used to cut with.</p>
<p>In VTK, cutting means reducing a cell of dimension N to a cut surface of dimension N-1. For example, a tetrahedron when cut by a plane (i.e., vtkPlane implicit function) will generate triangles. (In comparison, clipping takes a N dimensional cell and creates N dimension primitives.)</p>
<p>vtkHyperOctreeCutter is generally used to "slice-through" a dataset, generating a surface that can be visualized. It is also possible to use vtkHyperOctreeCutter to do a form of volume rendering. vtkHyperOctreeCutter does this by generating multiple cut surfaces (usually planes) which are ordered (and rendered) from back-to-front. The surfaces are set translucent to give a volumetric rendering effect.</p>
<p>Note that data can be cut using either 1) the scalar values associated with the dataset or 2) an implicit function associated with this class. By default, if an implicit function is set it is used to cut the data set, otherwise the dataset scalars are used to perform the cut.</p>
<p>To create an instance of class vtkHyperOctreeCutter, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkHyperOctreeCutter
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkHyperOctreeCutter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkHyperOctreeCutter class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkHyperOctreeCutter = obj.NewInstance ()</code>  </li>
<li>
<code>vtkHyperOctreeCutter = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>obj.SetValue (int i, double value)</code> - Get the ith contour value.  </li>
<li>
<code>double = obj.GetValue (int i)</code> - Get a pointer to an array of contour values. There will be GetNumberOfContours() values in the list.  </li>
<li>
<code>obj.GetValues (double contourValues)</code> - Set the number of contours to place into the list. You only really need to use this method to reduce list size. The method SetValue() will automatically increase list size as needed.  </li>
<li>
<code>obj.SetNumberOfContours (int number)</code> - Get the number of contours in the list of contour values.  </li>
<li>
<code>int = obj.GetNumberOfContours ()</code> - Generate numContours equally spaced contour values between specified range. Contour values will include min/max range values.  </li>
<li>
<code>obj.GenerateValues (int numContours, double range[2])</code> - Generate numContours equally spaced contour values between specified range. Contour values will include min/max range values.  </li>
<li>
<code>obj.GenerateValues (int numContours, double rangeStart, double rangeEnd)</code> - Override GetMTime because we delegate to vtkContourValues and refer to vtkImplicitFunction.  </li>
<li>
<code>long = obj.GetMTime ()</code> - Override GetMTime because we delegate to vtkContourValues and refer to vtkImplicitFunction.  </li>
<li>
<code>obj.SetCutFunction (vtkImplicitFunction )</code>  </li>
<li>
<code>vtkImplicitFunction = obj.GetCutFunction ()</code>  </li>
<li>
<code>obj.SetGenerateCutScalars (int )</code> - If this flag is enabled, then the output scalar values will be interpolated from the implicit function values, and not the input scalar data.  </li>
<li>
<code>int = obj.GetGenerateCutScalars ()</code> - If this flag is enabled, then the output scalar values will be interpolated from the implicit function values, and not the input scalar data.  </li>
<li>
<code>obj.GenerateCutScalarsOn ()</code> - If this flag is enabled, then the output scalar values will be interpolated from the implicit function values, and not the input scalar data.  </li>
<li>
<code>obj.GenerateCutScalarsOff ()</code> - If this flag is enabled, then the output scalar values will be interpolated from the implicit function values, and not the input scalar data.  </li>
<li>
<code>obj.SetLocator (vtkIncrementalPointLocator locator)</code> - Specify a spatial locator for merging points. By default, an instance of vtkMergePoints is used.  </li>
<li>
<code>vtkIncrementalPointLocator = obj.GetLocator ()</code> - Specify a spatial locator for merging points. By default, an instance of vtkMergePoints is used.  </li>
<li>
<p class="startli"><code>obj.SetSortBy (int )</code> - Set the sorting order for the generated polydata. There are two possibilities: Sort by value = 0 - This is the most efficient sort. For each cell, all contour values are processed. This is the default. Sort by cell = 1 - For each contour value, all cells are processed. This order should be used if the extracted polygons must be rendered in a back-to-front or front-to-back order. This is very problem dependent. For most applications, the default order is fine (and faster).</p>
<p class="endli">Sort by cell is going to have a problem if the input has 2D and 3D cells. Cell data will be scrambled becauses with vtkPolyData output, verts and lines have lower cell ids than triangles.  </p>
</li>
<li>
<p class="startli"><code>int = obj.GetSortByMinValue ()</code> - Set the sorting order for the generated polydata. There are two possibilities: Sort by value = 0 - This is the most efficient sort. For each cell, all contour values are processed. This is the default. Sort by cell = 1 - For each contour value, all cells are processed. This order should be used if the extracted polygons must be rendered in a back-to-front or front-to-back order. This is very problem dependent. For most applications, the default order is fine (and faster).</p>
<p class="endli">Sort by cell is going to have a problem if the input has 2D and 3D cells. Cell data will be scrambled becauses with vtkPolyData output, verts and lines have lower cell ids than triangles.  </p>
</li>
<li>
<p class="startli"><code>int = obj.GetSortByMaxValue ()</code> - Set the sorting order for the generated polydata. There are two possibilities: Sort by value = 0 - This is the most efficient sort. For each cell, all contour values are processed. This is the default. Sort by cell = 1 - For each contour value, all cells are processed. This order should be used if the extracted polygons must be rendered in a back-to-front or front-to-back order. This is very problem dependent. For most applications, the default order is fine (and faster).</p>
<p class="endli">Sort by cell is going to have a problem if the input has 2D and 3D cells. Cell data will be scrambled becauses with vtkPolyData output, verts and lines have lower cell ids than triangles.  </p>
</li>
<li>
<p class="startli"><code>int = obj.GetSortBy ()</code> - Set the sorting order for the generated polydata. There are two possibilities: Sort by value = 0 - This is the most efficient sort. For each cell, all contour values are processed. This is the default. Sort by cell = 1 - For each contour value, all cells are processed. This order should be used if the extracted polygons must be rendered in a back-to-front or front-to-back order. This is very problem dependent. For most applications, the default order is fine (and faster).</p>
<p class="endli">Sort by cell is going to have a problem if the input has 2D and 3D cells. Cell data will be scrambled becauses with vtkPolyData output, verts and lines have lower cell ids than triangles.  </p>
</li>
<li>
<p class="startli"><code>obj.SetSortByToSortByValue ()</code> - Set the sorting order for the generated polydata. There are two possibilities: Sort by value = 0 - This is the most efficient sort. For each cell, all contour values are processed. This is the default. Sort by cell = 1 - For each contour value, all cells are processed. This order should be used if the extracted polygons must be rendered in a back-to-front or front-to-back order. This is very problem dependent. For most applications, the default order is fine (and faster).</p>
<p class="endli">Sort by cell is going to have a problem if the input has 2D and 3D cells. Cell data will be scrambled becauses with vtkPolyData output, verts and lines have lower cell ids than triangles.  </p>
</li>
<li>
<code>obj.SetSortByToSortByCell ()</code> - Return the sorting procedure as a descriptive character string.  </li>
<li>
<code>string = obj.GetSortByAsString ()</code> - Create default locator. Used to create one when none is specified. The locator is used to merge coincident points.  </li>
<li>
<code>obj.CreateDefaultLocator ()</code> - Create default locator. Used to create one when none is specified. The locator is used to merge coincident points.  </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkgraphics.html">Visualization Toolkit Graphics Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:32 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

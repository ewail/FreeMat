<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkKdTree</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkfiltering_vtkkdtree.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkKdTree </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkfiltering.html">Visualization Toolkit Filtering Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>Given one or more vtkDataSets, create a load balancing k-d tree decomposition of the points at the center of the cells. Or, create a k-d tree point locator from a list of points.</p>
<p>This class can also generate a PolyData representation of the boundaries of the spatial regions in the decomposition.</p>
<p>It can sort the regions with respect to a viewing direction, and it can decompose a list of regions into subsets, each of which represent a convex spatial region (since many algorithms require a convex region).</p>
<p>If the points were derived from cells, vtkKdTree can create a list of cell Ids for each region for each data set. Two lists are available - all cells with centroid in the region, and all cells that intersect the region but whose centroid lies in another region.</p>
<p>For the purpose of removing duplicate points quickly from large data sets, or for finding nearby points, we added another mode for building the locator. BuildLocatorFromPoints will build a k-d tree from one or more vtkPoints objects. This can be followed by BuildMapForDuplicatePoints which returns a mapping from the original ids to a subset of the ids that is unique within a supplied tolerance, or you can use FindPoint and FindClosestPoint to locate points in the original set that the tree was built from.</p>
<p>To create an instance of class vtkKdTree, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkKdTree
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkKdTree has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkKdTree class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkKdTree = obj.NewInstance ()</code>  </li>
<li>
<code>vtkKdTree = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>obj.TimingOn ()</code> - Turn on timing of the k-d tree build  </li>
<li>
<code>obj.TimingOff ()</code> - Turn on timing of the k-d tree build  </li>
<li>
<code>obj.SetTiming (int )</code> - Turn on timing of the k-d tree build  </li>
<li>
<code>int = obj.GetTiming ()</code> - Turn on timing of the k-d tree build  </li>
<li>
<code>obj.SetMinCells (int )</code> - Minimum number of cells per spatial region. Default is 100.  </li>
<li>
<code>int = obj.GetMinCells ()</code> - Minimum number of cells per spatial region. Default is 100.  </li>
<li>
<code>int = obj.GetNumberOfRegionsOrLess ()</code>  </li>
<li>
<code>obj.SetNumberOfRegionsOrLess (int )</code>  </li>
<li>
<code>int = obj.GetNumberOfRegionsOrMore ()</code>  </li>
<li>
<code>obj.SetNumberOfRegionsOrMore (int )</code>  </li>
<li>
<code>double = obj.GetFudgeFactor ()</code>  </li>
<li>
<code>obj.SetFudgeFactor (double )</code>  </li>
<li>
<code>vtkBSPCuts = obj.GetCuts ()</code>  </li>
<li>
<code>obj.SetCuts (vtkBSPCuts cuts)</code>  </li>
<li>
<code>obj.OmitXPartitioning ()</code> - Omit partitions along the X axis, yielding shafts in the X direction  </li>
<li>
<code>obj.OmitYPartitioning ()</code> - Omit partitions along the Y axis, yielding shafts in the Y direction  </li>
<li>
<code>obj.OmitZPartitioning ()</code> - Omit partitions along the Z axis, yielding shafts in the Z direction  </li>
<li>
<code>obj.OmitXYPartitioning ()</code> - Omit partitions along the X and Y axes, yielding slabs along Z  </li>
<li>
<code>obj.OmitYZPartitioning ()</code> - Omit partitions along the Y and Z axes, yielding slabs along X  </li>
<li>
<code>obj.OmitZXPartitioning ()</code> - Omit partitions along the Z and X axes, yielding slabs along Y  </li>
<li>
<code>obj.OmitNoPartitioning ()</code> - Partition along all three axes - this is the default  </li>
<li>
<code>obj.SetDataSet (vtkDataSet set)</code> - Clear out all data sets and replace with single data set. For backward compatibility with superclass.  </li>
<li>
<code>obj.AddDataSet (vtkDataSet set)</code> - This class can compute a spatial decomposition based on the cells in a list of one or more input data sets. Add them one at a time with this method.  </li>
<li>
<code>obj.RemoveDataSet (int index)</code> - Remove the given data set.  </li>
<li>
<code>obj.RemoveDataSet (vtkDataSet set)</code> - Remove the given data set.  </li>
<li>
<code>obj.RemoveAllDataSets ()</code> - Remove the given data set.  </li>
<li>
<code>int = obj.GetNumberOfDataSets ()</code> - Get the number of data sets included in spatial paritioning  </li>
<li>
<code>vtkDataSet = obj.GetDataSet (int n)</code> - Return the n'th data set.  </li>
<li>
<code>vtkDataSet = obj.GetDataSet ()</code> - Return a collection of all the data sets.  </li>
<li>
<code>vtkDataSetCollection = obj.GetDataSets ()</code> - Return a collection of all the data sets.  </li>
<li>
<code>int = obj.GetDataSetIndex (vtkDataSet set)</code> - Return the index of the given data set. Returns -1 if that data set does not exist.  </li>
<li>
<code>obj.GetBounds (double bounds)</code> - Get the spatial bounds of the entire k-d tree space. Sets bounds array to xmin, xmax, ymin, ymax, zmin, zmax.  </li>
<li>
<code>obj.SetNewBounds (double bounds)</code>  </li>
<li>
<code>int = obj.GetNumberOfRegions ()</code> - The number of leaf nodes of the tree, the spatial regions  </li>
<li>
<code>obj.GetRegionBounds (int regionID, double bounds[6])</code> - Get the spatial bounds of k-d tree region  </li>
<li>
<code>obj.GetRegionDataBounds (int regionID, double bounds[6])</code> - Get the bounds of the data within the k-d tree region  </li>
<li>
<code>obj.PrintTree ()</code> - Print out nodes of kd tree  </li>
<li>
<code>obj.PrintVerboseTree ()</code> - Print out nodes of kd tree  </li>
<li>
<code>obj.PrintRegion (int id)</code> - Print out leaf node data for given id  </li>
<li>
<code>obj.CreateCellLists (int dataSetIndex, int regionReqList, int reqListSize)</code>  </li>
<li>
<code>obj.CreateCellLists (vtkDataSet set, int regionReqList, int reqListSize)</code>  </li>
<li>
<code>obj.CreateCellLists (int regionReqList, int listSize)</code>  </li>
<li>
<code>obj.CreateCellLists ()</code>  </li>
<li>
<code>obj.SetIncludeRegionBoundaryCells (int )</code> - If IncludeRegionBoundaryCells is ON, CreateCellLists() will also create a list of cells which intersect a given region, but are not assigned to the region. These lists are obtained with GetBoundaryCellList(). Default is OFF.  </li>
<li>
<code>int = obj.GetIncludeRegionBoundaryCells ()</code> - If IncludeRegionBoundaryCells is ON, CreateCellLists() will also create a list of cells which intersect a given region, but are not assigned to the region. These lists are obtained with GetBoundaryCellList(). Default is OFF.  </li>
<li>
<code>obj.IncludeRegionBoundaryCellsOn ()</code> - If IncludeRegionBoundaryCells is ON, CreateCellLists() will also create a list of cells which intersect a given region, but are not assigned to the region. These lists are obtained with GetBoundaryCellList(). Default is OFF.  </li>
<li>
<code>obj.IncludeRegionBoundaryCellsOff ()</code> - If IncludeRegionBoundaryCells is ON, CreateCellLists() will also create a list of cells which intersect a given region, but are not assigned to the region. These lists are obtained with GetBoundaryCellList(). Default is OFF.  </li>
<li>
<code>obj.DeleteCellLists ()</code> - Free the memory used by the cell lists.  </li>
<li>
<code>vtkIdList = obj.GetCellList (int regionID)</code> - Get the cell list for a region. This returns a pointer to vtkKdTree's memory, so don't free it.  </li>
<li>
<code>vtkIdList = obj.GetBoundaryCellList (int regionID)</code> - The cell list obtained with GetCellList is the list of all cells such that their centroid is contained in the spatial region. It may also be desirable to get a list of all cells intersecting a spatial region, but with centroid in some other region. This is that list. This list is computed in CreateCellLists() if and only if IncludeRegionBoundaryCells is ON. This returns a pointer to KdTree's memory, so don't free it.  </li>
<li>
<p class="startli"><code>vtkIdType = obj.GetCellLists (vtkIntArray regions, int set, vtkIdList inRegionCells, vtkIdList onBoundaryCells)</code> - For a list of regions, get two cell lists. The first lists the IDs all cells whose centroids lie in one of the regions. The second lists the IDs of all cells that intersect the regions, but whose centroid lies in a region not on the list.</p>
<p>The total number of cell IDs written to both lists is returned. Either list pointer passed in can be NULL, and it will be ignored. If there are multiple data sets, you must specify which data set you wish cell IDs for.</p>
<p class="endli">The caller should delete these two lists when done. This method uses the cell lists created in CreateCellLists(). If the cell list for any of the requested regions does not exist, then this method will call CreateCellLists() to create cell lists for <em>every</em> region of the k-d tree. You must remember to DeleteCellLists() when done with all calls to this method, as cell lists can require a great deal of memory.  </p>
</li>
<li>
<p class="startli"><code>vtkIdType = obj.GetCellLists (vtkIntArray regions, vtkDataSet set, vtkIdList inRegionCells, vtkIdList onBoundaryCells)</code> - For a list of regions, get two cell lists. The first lists the IDs all cells whose centroids lie in one of the regions. The second lists the IDs of all cells that intersect the regions, but whose centroid lies in a region not on the list.</p>
<p>The total number of cell IDs written to both lists is returned. Either list pointer passed in can be NULL, and it will be ignored. If there are multiple data sets, you must specify which data set you wish cell IDs for.</p>
<p class="endli">The caller should delete these two lists when done. This method uses the cell lists created in CreateCellLists(). If the cell list for any of the requested regions does not exist, then this method will call CreateCellLists() to create cell lists for <em>every</em> region of the k-d tree. You must remember to DeleteCellLists() when done with all calls to this method, as cell lists can require a great deal of memory.  </p>
</li>
<li>
<p class="startli"><code>vtkIdType = obj.GetCellLists (vtkIntArray regions, vtkIdList inRegionCells, vtkIdList onBoundaryCells)</code> - For a list of regions, get two cell lists. The first lists the IDs all cells whose centroids lie in one of the regions. The second lists the IDs of all cells that intersect the regions, but whose centroid lies in a region not on the list.</p>
<p>The total number of cell IDs written to both lists is returned. Either list pointer passed in can be NULL, and it will be ignored. If there are multiple data sets, you must specify which data set you wish cell IDs for.</p>
<p class="endli">The caller should delete these two lists when done. This method uses the cell lists created in CreateCellLists(). If the cell list for any of the requested regions does not exist, then this method will call CreateCellLists() to create cell lists for <em>every</em> region of the k-d tree. You must remember to DeleteCellLists() when done with all calls to this method, as cell lists can require a great deal of memory.  </p>
</li>
<li>
<code>int = obj.GetRegionContainingCell (vtkDataSet set, vtkIdType cellID)</code> - Get the id of the region containing the cell centroid. If no DataSet is specified, assume DataSet 0. If you need the region ID for every cell, use AllGetRegionContainingCell instead. It is more efficient.  </li>
<li>
<code>int = obj.GetRegionContainingCell (int set, vtkIdType cellID)</code> - Get the id of the region containing the cell centroid. If no DataSet is specified, assume DataSet 0. If you need the region ID for every cell, use AllGetRegionContainingCell instead. It is more efficient.  </li>
<li>
<code>int = obj.GetRegionContainingCell (vtkIdType cellID)</code> - Get the id of the region containing the cell centroid. If no DataSet is specified, assume DataSet 0. If you need the region ID for every cell, use AllGetRegionContainingCell instead. It is more efficient.  </li>
<li>
<code>int = obj.GetRegionContainingPoint (double x, double y, double z)</code> - Get the id of the region containing the specified location.  </li>
<li>
<code>obj.BuildLocator ()</code> - Create the k-d tree decomposition of the cells of the data set or data sets. Cells are assigned to k-d tree spatial regions based on the location of their centroids.  </li>
<li>
<code>int = obj.DepthOrderAllRegions (double dop, vtkIntArray orderedList)</code> - DO NOT CALL. Depricated in VTK 5.2. Use ViewOrderAllRegionsInDirection or ViewOrderAllRegionsFromPosition.  </li>
<li>
<code>int = obj.DepthOrderRegions (vtkIntArray regionIds, double dop, vtkIntArray orderedList)</code> - DO NOT CALL. Depricated in VTK 5.2. Use ViewOrderRegionsInDirection or ViewOrderRegionsFromPosition.  </li>
<li>
<code>int = obj.ViewOrderAllRegionsInDirection (double directionOfProjection[3], vtkIntArray orderedList)</code> - Given a direction of projection (typically obtained with vtkCamera::GetDirectionOfProjection()), this method, creates a list of the k-d tree region IDs in order from front to back with respect to that direction. The number of ordered regions is returned. Use this method to view order regions for cameras that use parallel projection.  </li>
<li>
<code>int = obj.ViewOrderRegionsInDirection (vtkIntArray regionIds, double directionOfProjection[3], vtkIntArray orderedList)</code> - Given a direction of projection and a list of k-d tree region IDs, this method, creates a list of the k-d tree region IDs in order from front to back with respect to that direction. The number of ordered regions is returned. Use this method to view order regions for cameras that use parallel projection.  </li>
<li>
<code>int = obj.ViewOrderAllRegionsFromPosition (double directionOfProjection[3], vtkIntArray orderedList)</code> - Given a camera position (typically obtained with vtkCamera::GetPosition()), this method, creates a list of the k-d tree region IDs in order from front to back with respect to that direction. The number of ordered regions is returned. Use this method to view order regions for cameras that use perspective projection.  </li>
<li>
<code>int = obj.ViewOrderRegionsFromPosition (vtkIntArray regionIds, double directionOfProjection[3], vtkIntArray orderedList)</code> - Given a camera position and a list of k-d tree region IDs, this method, creates a list of the k-d tree region IDs in order from front to back with respect to that direction. The number of ordered regions is returned. Use this method to view order regions for cameras that use perspective projection.  </li>
<li>
<p class="startli"><code>obj.BuildLocatorFromPoints (vtkPointSet pointset)</code> - This is a special purpose locator that builds a k-d tree to find duplicate and near-by points. It builds the tree from one or more vtkPoints objects instead of from the cells of a vtkDataSet. This build would normally be followed by BuildMapForDuplicatePoints, FindPoint, or FindClosestPoint. Since this will build a normal k-d tree, all the region intersection queries will still work, as will most other calls except those that have "Cell" in the name.</p>
<p class="endli">This method works most efficiently when the point arrays are float arrays.  </p>
</li>
<li>
<p class="startli"><code>obj.BuildLocatorFromPoints (vtkPoints ptArray)</code> - This is a special purpose locator that builds a k-d tree to find duplicate and near-by points. It builds the tree from one or more vtkPoints objects instead of from the cells of a vtkDataSet. This build would normally be followed by BuildMapForDuplicatePoints, FindPoint, or FindClosestPoint. Since this will build a normal k-d tree, all the region intersection queries will still work, as will most other calls except those that have "Cell" in the name.</p>
<p class="endli">This method works most efficiently when the point arrays are float arrays.  </p>
</li>
<li>
<p class="startli"><code>vtkIdTypeArray = obj.BuildMapForDuplicatePoints (float tolerance)</code> - This call returns a mapping from the original point IDs supplied to BuildLocatorFromPoints to a subset of those IDs that is unique within the specified tolerance. If points 2, 5, and 12 are the same, then IdMap[2] = IdMap[5] = IdMap[12] = 2 (or 5 or 12).</p>
<p>"original point IDs" - For point IDs we start at 0 for the first point in the first vtkPoints object, and increase by 1 for subsequent points and subsequent vtkPoints objects.</p>
<p class="endli">You must have called BuildLocatorFromPoints() before calling this. You are responsible for deleting the returned array.  </p>
</li>
<li>
<code>vtkIdType = obj.FindPoint (double x)</code> - Find the Id of the point that was previously supplied to BuildLocatorFromPoints(). Returns -1 if the point was not in the original array.  </li>
<li>
<code>vtkIdType = obj.FindPoint (double x, double y, double z)</code> - Find the Id of the point that was previously supplied to BuildLocatorFromPoints(). Returns -1 if the point was not in the original array.  </li>
<li>
<code>obj.FindPointsWithinRadius (double R, double x[3], vtkIdList result)</code> - Find all points within a specified radius R of position x. The result is not sorted in any specific manner. These methods are thread safe if BuildLocator() is directly or indirectly called from a single thread first.  </li>
<li>
<code>obj.FindClosestNPoints (int N, double x[3], vtkIdList result)</code> - Find the closest N points to a position. This returns the closest N points to a position. A faster method could be created that returned N close points to a position, but necessarily the exact N closest. The returned points are sorted from closest to farthest. These methods are thread safe if BuildLocator() is directly or indirectly called from a single thread first.  </li>
<li>
<code>vtkIdTypeArray = obj.GetPointsInRegion (int regionId)</code> - Get a list of the original IDs of all points in a region. You must have called BuildLocatorFromPoints before calling this.  </li>
<li>
<code>obj.FreeSearchStructure ()</code> - Delete the k-d tree data structure. Also delete any cell lists that were computed with CreateCellLists().  </li>
<li>
<code>obj.GenerateRepresentation (int level, vtkPolyData pd)</code> - Create a polydata representation of the boundaries of the k-d tree regions. If level equals GetLevel(), the leaf nodes are represented.  </li>
<li>
<code>obj.GenerateRepresentation (int regionList, int len, vtkPolyData pd)</code> - Generate a polygonal representation of a list of regions. Only leaf nodes have region IDs, so these will be leaf nodes.  </li>
<li>
<code>obj.GenerateRepresentationUsingDataBoundsOn ()</code> - The polydata representation of the k-d tree shows the boundaries of the k-d tree decomposition spatial regions. The data inside the regions may not occupy the entire space. To draw just the bounds of the data in the regions, set this variable ON.  </li>
<li>
<code>obj.GenerateRepresentationUsingDataBoundsOff ()</code> - The polydata representation of the k-d tree shows the boundaries of the k-d tree decomposition spatial regions. The data inside the regions may not occupy the entire space. To draw just the bounds of the data in the regions, set this variable ON.  </li>
<li>
<code>obj.SetGenerateRepresentationUsingDataBounds (int )</code> - The polydata representation of the k-d tree shows the boundaries of the k-d tree decomposition spatial regions. The data inside the regions may not occupy the entire space. To draw just the bounds of the data in the regions, set this variable ON.  </li>
<li>
<code>int = obj.GetGenerateRepresentationUsingDataBounds ()</code> - The polydata representation of the k-d tree shows the boundaries of the k-d tree decomposition spatial regions. The data inside the regions may not occupy the entire space. To draw just the bounds of the data in the regions, set this variable ON.  </li>
<li>
<code>int = obj.NewGeometry ()</code> - Return 1 if the geometry of the input data sets has changed since the last time the k-d tree was built.  </li>
<li>
<code>obj.InvalidateGeometry ()</code> - Forget about the last geometry used. The next call to NewGeometry will return 1. A new k-d tree will be built the next time BuildLocator is called.  </li>
<li>
<code>obj.FindPointsInArea (double area, vtkIdTypeArray ids, bool clearArraytrue)</code> - Fill ids with points found in area. The area is a 6-tuple containing (xmin, xmax, ymin, ymax, zmin, zmax). This method will clear the array by default. To append ids to an array, set clearArray to false.  </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkfiltering.html">Visualization Toolkit Filtering Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:31 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

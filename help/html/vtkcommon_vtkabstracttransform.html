<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkAbstractTransform</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkcommon_vtkabstracttransform.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkAbstractTransform </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkcommon.html">Visualization Toolkit Common Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>vtkAbstractTransform is the superclass for all VTK geometric transformations. The VTK transform hierarchy is split into two major branches: warp transformations and homogeneous (including linear) transformations. The latter can be represented in terms of a 4x4 transformation matrix, the former cannot. </p>
<p>Transformations can be pipelined through two mechanisms: </p>
<p>1) GetInverse() returns the pipelined inverse of a transformation i.e. if you modify the original transform, any transform previously returned by the GetInverse() method will automatically update itself according to the change. </p>
<p>2) You can do pipelined concatenation of transformations through the vtkGeneralTransform class, the vtkPerspectiveTransform class, or the vtkTransform class.</p>
<p>To create an instance of class vtkAbstractTransform, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkAbstractTransform
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkAbstractTransform has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkAbstractTransform class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkAbstractTransform = obj.NewInstance ()</code>  </li>
<li>
<code>vtkAbstractTransform = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>obj.TransformPoint (float in[3], float out[3])</code> - Apply the transformation to a coordinate. You can use the same array to store both the input and output point.  </li>
<li>
<code>obj.TransformPoint (double in[3], double out[3])</code> - Apply the transformation to a double-precision coordinate. You can use the same array to store both the input and output point.  </li>
<li>
<code>double = obj.TransformPoint (double x, double y, double z)</code> - Apply the transformation to a double-precision coordinate. Use this if you are programming in Python, tcl or Java.  </li>
<li>
<code>double = obj.TransformPoint (double point[3])</code> - Apply the transformation to a double-precision coordinate. Use this if you are programming in Python, tcl or Java.  </li>
<li>
<code>float = obj.TransformFloatPoint (float x, float y, float z)</code> - Apply the transformation to an (x,y,z) coordinate. Use this if you are programming in Python, tcl or Java.  </li>
<li>
<code>float = obj.TransformFloatPoint (float point[3])</code> - Apply the transformation to an (x,y,z) coordinate. Use this if you are programming in Python, tcl or Java.  </li>
<li>
<code>double = obj.TransformDoublePoint (double x, double y, double z)</code> - Apply the transformation to a double-precision (x,y,z) coordinate. Use this if you are programming in Python, tcl or Java.  </li>
<li>
<code>double = obj.TransformDoublePoint (double point[3])</code> - Apply the transformation to a double-precision (x,y,z) coordinate. Use this if you are programming in Python, tcl or Java.  </li>
<li>
<code>obj.TransformNormalAtPoint (float point[3], float in[3], float out[3])</code> - Apply the transformation to a normal at the specified vertex. If the transformation is a vtkLinearTransform, you can use TransformNormal() instead.  </li>
<li>
<code>obj.TransformNormalAtPoint (double point[3], double in[3], double out[3])</code> - Apply the transformation to a normal at the specified vertex. If the transformation is a vtkLinearTransform, you can use TransformNormal() instead.  </li>
<li>
<code>double = obj.TransformNormalAtPoint (double point[3], double normal[3])</code>  </li>
<li>
<code>double = obj.TransformDoubleNormalAtPoint (double point[3], double normal[3])</code> - Apply the transformation to a double-precision normal at the specified vertex. If the transformation is a vtkLinearTransform, you can use TransformDoubleNormal() instead.  </li>
<li>
<code>float = obj.TransformFloatNormalAtPoint (float point[3], float normal[3])</code> - Apply the transformation to a single-precision normal at the specified vertex. If the transformation is a vtkLinearTransform, you can use TransformFloatNormal() instead.  </li>
<li>
<code>obj.TransformVectorAtPoint (float point[3], float in[3], float out[3])</code> - Apply the transformation to a vector at the specified vertex. If the transformation is a vtkLinearTransform, you can use TransformVector() instead.  </li>
<li>
<code>obj.TransformVectorAtPoint (double point[3], double in[3], double out[3])</code> - Apply the transformation to a vector at the specified vertex. If the transformation is a vtkLinearTransform, you can use TransformVector() instead.  </li>
<li>
<code>double = obj.TransformVectorAtPoint (double point[3], double vector[3])</code>  </li>
<li>
<code>double = obj.TransformDoubleVectorAtPoint (double point[3], double vector[3])</code> - Apply the transformation to a double-precision vector at the specified vertex. If the transformation is a vtkLinearTransform, you can use TransformDoubleVector() instead.  </li>
<li>
<code>float = obj.TransformFloatVectorAtPoint (float point[3], float vector[3])</code> - Apply the transformation to a single-precision vector at the specified vertex. If the transformation is a vtkLinearTransform, you can use TransformFloatVector() instead.  </li>
<li>
<code>obj.TransformPoints (vtkPoints inPts, vtkPoints outPts)</code> - Apply the transformation to a series of points, and append the results to outPts.  </li>
<li>
<code>obj.TransformPointsNormalsVectors (vtkPoints inPts, vtkPoints outPts, vtkDataArray inNms, vtkDataArray outNms, vtkDataArray inVrs, vtkDataArray outVrs)</code> - Apply the transformation to a combination of points, normals and vectors.  </li>
<li>
<code>vtkAbstractTransform = obj.GetInverse ()</code> - Get the inverse of this transform. If you modify this transform, the returned inverse transform will automatically update. If you want the inverse of a vtkTransform, you might want to use GetLinearInverse() instead which will type cast the result from vtkAbstractTransform to vtkLinearTransform.  </li>
<li>
<code>obj.SetInverse (vtkAbstractTransform transform)</code> - Set a transformation that this transform will be the inverse of. This transform will automatically update to agree with the inverse transform that you set.  </li>
<li>
<code>obj.Inverse ()</code> - Invert the transformation.  </li>
<li>
<code>obj.DeepCopy (vtkAbstractTransform )</code> - Copy this transform from another of the same type.  </li>
<li>
<code>obj.Update ()</code> - Update the transform to account for any changes which have been made. You do not have to call this method yourself, it is called automatically whenever the transform needs an update.  </li>
<li>
<code>obj.InternalTransformPoint (float in[3], float out[3])</code> - This will calculate the transformation without calling Update. Meant for use only within other VTK classes.  </li>
<li>
<code>obj.InternalTransformPoint (double in[3], double out[3])</code> - This will calculate the transformation without calling Update. Meant for use only within other VTK classes.  </li>
<li>
<code>vtkAbstractTransform = obj.MakeTransform ()</code> - Make another transform of the same type.  </li>
<li>
<code>int = obj.CircuitCheck (vtkAbstractTransform transform)</code> - Check for self-reference. Will return true if concatenating with the specified transform, setting it to be our inverse, or setting it to be our input will create a circular reference. CircuitCheck is automatically called by SetInput(), SetInverse(), and Concatenate(vtkXTransform *). Avoid using this function, it is experimental.  </li>
<li>
<code>long = obj.GetMTime ()</code> - Override GetMTime necessary because of inverse transforms.  </li>
<li>
<code>obj.UnRegister (vtkObjectBase O)</code> - Needs a special UnRegister() implementation to avoid circular references.  </li>
<li>
<code>obj.Identity ()</code> -  </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkcommon.html">Visualization Toolkit Common Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:30 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

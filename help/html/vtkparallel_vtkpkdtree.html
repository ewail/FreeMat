<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkPKdTree</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkparallel_vtkpkdtree.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkPKdTree </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkparallel.html">Visualization Toolkit Parallel Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>Build, in parallel, a k-d tree decomposition of one or more vtkDataSets distributed across processors. We assume each process has read in one portion of a large distributed data set. When done, each process has access to the k-d tree structure, can obtain information about which process contains data for each spatial region, and can depth sort the spatial regions.</p>
<p>This class can also assign spatial regions to processors, based on one of several region assignment schemes. By default a contiguous, convex region is assigned to each process. Several queries return information about how many and what cells I have that lie in a region assigned to another process.</p>
<p>To create an instance of class vtkPKdTree, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkPKdTree
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkPKdTree has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkPKdTree class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkPKdTree = obj.NewInstance ()</code>  </li>
<li>
<code>vtkPKdTree = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>obj.BuildLocator ()</code> - Build the spatial decomposition. Call this explicitly after changing any parameters affecting the build of the tree. It must be called by all processes in the parallel application, or it will hang.  </li>
<li>
<code>vtkIdType = obj.GetTotalNumberOfCells ()</code> - Create tables of counts of cells per process per region. These tables can be accessed with queries like "HasData", "GetProcessCellCountForRegion", and so on. You must have called BuildLocator() beforehand. This method must be called by all processes or it will hang. Returns 1 on error, 0 when no error.  </li>
<li>
<code>int = obj.CreateProcessCellCountData ()</code> - Create tables of counts of cells per process per region. These tables can be accessed with queries like "HasData", "GetProcessCellCountForRegion", and so on. You must have called BuildLocator() beforehand. This method must be called by all processes or it will hang. Returns 1 on error, 0 when no error.  </li>
<li>
<code>int = obj.CreateGlobalDataArrayBounds ()</code> - A convenience function which compiles the global bounds of the data arrays across processes. These bounds can be accessed with "GetCellArrayGlobalRange" and "GetPointArrayGlobalRange". This method must be called by all processes or it will hang. Returns 1 on error, 0 when no error.  </li>
<li>
<code>obj.SetController (vtkMultiProcessController c)</code> - Set/Get the communicator object  </li>
<li>
<code>vtkMultiProcessController = obj.GetController ()</code> - Set/Get the communicator object  </li>
<li>
<code>int = obj.GetRegionAssignment ()</code> - The PKdTree class can assign spatial regions to processors after building the k-d tree, using one of several partitioning criteria. These functions Set/Get whether this assignment is computed. The default is "Off", no assignment is computed. If "On", and no assignment scheme is specified, contiguous assignment will be computed. Specifying an assignment scheme (with AssignRegions*()) automatically turns on RegionAssignment.  </li>
<li>
<code>int = obj.AssignRegions (int map, int numRegions)</code> - Assign spatial regions to processes via a user defined map. The user-supplied map is indexed by region ID, and provides a process ID for each region.  </li>
<li>
<code>int = obj.AssignRegionsRoundRobin ()</code> - Let the PKdTree class assign a process to each region in a round robin fashion. If the k-d tree has not yet been built, the regions will be assigned after BuildLocator executes.  </li>
<li>
<code>int = obj.AssignRegionsContiguous ()</code> - Let the PKdTree class assign a process to each region by assigning contiguous sets of spatial regions to each process. The set of regions assigned to each process will always have a union that is a convex space (a box). If the k-d tree has not yet been built, the regions will be assigned after BuildLocator executes.  </li>
<li>
<code>int = obj.GetRegionAssignmentList (int procId, vtkIntArray list)</code> - Writes the list of region IDs assigned to the specified process. Regions IDs start at 0 and increase by 1 from there. Returns the number of regions in the list.  </li>
<li>
<code>obj.GetAllProcessesBorderingOnPoint (float x, float y, float z, vtkIntArray list)</code> - The k-d tree spatial regions have been assigned to processes. Given a point on the boundary of one of the regions, this method creates a list of all processes whose region boundaries include that point. This may be required when looking for processes that have cells adjacent to the cells of a given process.  </li>
<li>
<code>int = obj.GetProcessAssignedToRegion (int regionId)</code> - Returns the ID of the process assigned to the region.  </li>
<li>
<code>int = obj.HasData (int processId, int regionId)</code> - Returns 1 if the process has data for the given region, 0 otherwise.  </li>
<li>
<code>int = obj.GetProcessCellCountForRegion (int processId, int regionId)</code> - Returns the number of cells the specified process has in the specified region.  </li>
<li>
<code>int = obj.GetTotalProcessesInRegion (int regionId)</code> - Returns the total number of processes that have data falling within this spatial region.  </li>
<li>
<code>int = obj.GetProcessListForRegion (int regionId, vtkIntArray processes)</code> - Adds the list of processes having data for the given region to the supplied list, returns the number of processes added.  </li>
<li>
<code>int = obj.GetProcessesCellCountForRegion (int regionId, int count, int len)</code> - Writes the number of cells each process has for the region to the supplied list of length len. Returns the number of cell counts written. The order of the cell counts corresponds to the order of process IDs in the process list returned by GetProcessListForRegion.  </li>
<li>
<code>int = obj.GetTotalRegionsForProcess (int processId)</code> - Returns the total number of spatial regions that a given process has data for.  </li>
<li>
<code>int = obj.GetRegionListForProcess (int processId, vtkIntArray regions)</code> - Adds the region IDs for which this process has data to the supplied vtkIntArray. Retruns the number of regions.  </li>
<li>
<code>int = obj.GetRegionsCellCountForProcess (int ProcessId, int count, int len)</code> - Writes to the supplied integer array the number of cells this process has for each region. Returns the number of cell counts written. The order of the cell counts corresponds to the order of region IDs in the region list returned by GetRegionListForProcess.  </li>
<li>
<p class="startli"><code>vtkIdType = obj.GetCellListsForProcessRegions (int ProcessId, int set, vtkIdList inRegionCells, vtkIdList onBoundaryCells)</code> - After regions have been assigned to processes, I may want to know which cells I have that are in the regions assigned to a particular process.</p>
<p>This method takes a process ID and two vtkIdLists. It writes to the first list the IDs of the cells contained in the process' regions. (That is, their cell centroid is contained in the region.) To the second list it write the IDs of the cells which intersect the process' regions but whose cell centroid lies elsewhere.</p>
<p>The total number of cell IDs written to both lists is returned. Either list pointer passed in can be NULL, and it will be ignored. If there are multiple data sets, you must specify which data set you wish cell IDs for.</p>
<p class="endli">The caller should delete these two lists when done. This method uses the cell lists created in vtkKdTree::CreateCellLists(). If the cell lists for the process' regions do not exist, this method will first build the cell lists for all regions by calling CreateCellLists(). You must remember to DeleteCellLists() when done with all calls to this method, as cell lists can require a great deal of memory.  </p>
</li>
<li>
<p class="startli"><code>vtkIdType = obj.GetCellListsForProcessRegions (int ProcessId, vtkDataSet set, vtkIdList inRegionCells, vtkIdList onBoundaryCells)</code> - After regions have been assigned to processes, I may want to know which cells I have that are in the regions assigned to a particular process.</p>
<p>This method takes a process ID and two vtkIdLists. It writes to the first list the IDs of the cells contained in the process' regions. (That is, their cell centroid is contained in the region.) To the second list it write the IDs of the cells which intersect the process' regions but whose cell centroid lies elsewhere.</p>
<p>The total number of cell IDs written to both lists is returned. Either list pointer passed in can be NULL, and it will be ignored. If there are multiple data sets, you must specify which data set you wish cell IDs for.</p>
<p class="endli">The caller should delete these two lists when done. This method uses the cell lists created in vtkKdTree::CreateCellLists(). If the cell lists for the process' regions do not exist, this method will first build the cell lists for all regions by calling CreateCellLists(). You must remember to DeleteCellLists() when done with all calls to this method, as cell lists can require a great deal of memory.  </p>
</li>
<li>
<p class="startli"><code>vtkIdType = obj.GetCellListsForProcessRegions (int ProcessId, vtkIdList inRegionCells, vtkIdList onBoundaryCells)</code> - After regions have been assigned to processes, I may want to know which cells I have that are in the regions assigned to a particular process.</p>
<p>This method takes a process ID and two vtkIdLists. It writes to the first list the IDs of the cells contained in the process' regions. (That is, their cell centroid is contained in the region.) To the second list it write the IDs of the cells which intersect the process' regions but whose cell centroid lies elsewhere.</p>
<p>The total number of cell IDs written to both lists is returned. Either list pointer passed in can be NULL, and it will be ignored. If there are multiple data sets, you must specify which data set you wish cell IDs for.</p>
<p class="endli">The caller should delete these two lists when done. This method uses the cell lists created in vtkKdTree::CreateCellLists(). If the cell lists for the process' regions do not exist, this method will first build the cell lists for all regions by calling CreateCellLists(). You must remember to DeleteCellLists() when done with all calls to this method, as cell lists can require a great deal of memory.  </p>
</li>
<li>
<code>int = obj.DepthOrderAllProcesses (double directionOfProjection, vtkIntArray orderedList)</code> - DO NOT CALL. Deprecated in VTK 5.2. Use ViewOrderAllProcessesInDirection or ViewOrderAllProcessesFromPosition.  </li>
<li>
<code>int = obj.ViewOrderAllProcessesInDirection (double directionOfProjection[3], vtkIntArray orderedList)</code> - Return a list of all processes in order from front to back given a vector direction of projection. Use this to do visibility sorts in parallel projection mode. `orderedList' will be resized to the number of processes. The return value is the number of processes. <dl class="section pre"><dt>Precondition:</dt><dd>orderedList_exists: orderedList!=0  </dd></dl>
</li>
<li>
<code>int = obj.ViewOrderAllProcessesFromPosition (double cameraPosition[3], vtkIntArray orderedList)</code> - Return a list of all processes in order from front to back given a camera position. Use this to do visibility sorts in perspective projection mode. `orderedList' will be resized to the number of processes. The return value is the number of processes. <dl class="section pre"><dt>Precondition:</dt><dd>orderedList_exists: orderedList!=0  </dd></dl>
</li>
<li>
<code>int = obj.GetCellArrayGlobalRange (string name, float range[2])</code>  </li>
<li>
<code>int = obj.GetPointArrayGlobalRange (string name, float range[2])</code>  </li>
<li>
<code>int = obj.GetCellArrayGlobalRange (string name, double range[2])</code>  </li>
<li>
<code>int = obj.GetPointArrayGlobalRange (string name, double range[2])</code>  </li>
<li>
<code>int = obj.GetCellArrayGlobalRange (int arrayIndex, double range[2])</code>  </li>
<li>
<code>int = obj.GetPointArrayGlobalRange (int arrayIndex, double range[2])</code>  </li>
<li>
<code>int = obj.GetCellArrayGlobalRange (int arrayIndex, float range[2])</code>  </li>
<li>
<code>int = obj.GetPointArrayGlobalRange (int arrayIndex, float range[2])</code>  </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkparallel.html">Visualization Toolkit Parallel Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:34 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

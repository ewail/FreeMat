<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkWeightedTransformFilter</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkhybrid_vtkweightedtransformfilter.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkWeightedTransformFilter </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkhybrid.html">Visualization Toolkit Hybrid Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>To create an instance of class vtkWeightedTransformFilter, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkWeightedTransformFilter
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkWeightedTransformFilter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkWeightedTransformFilter class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkWeightedTransformFilter = obj.NewInstance ()</code>  </li>
<li>
<code>vtkWeightedTransformFilter = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>long = obj.GetMTime ()</code> - Return the MTime also considering the filter's transforms.  </li>
<li>
<code>obj.SetWeightArray (string )</code> - WeightArray is the string name of the DataArray in the input's FieldData that holds the weighting coefficients for each point. The filter will first look for the array in the input's PointData FieldData. If the array isn't there, the filter looks in the input's FieldData. The WeightArray can have tuples of any length, but must have a tuple for every point in the input data set. This array transforms points, normals, and vectors.  </li>
<li>
<code>string = obj.GetWeightArray ()</code> - WeightArray is the string name of the DataArray in the input's FieldData that holds the weighting coefficients for each point. The filter will first look for the array in the input's PointData FieldData. If the array isn't there, the filter looks in the input's FieldData. The WeightArray can have tuples of any length, but must have a tuple for every point in the input data set. This array transforms points, normals, and vectors.  </li>
<li>
<p class="startli"><code>obj.SetTransformIndexArray (string )</code> - TransformIndexArray is the string name of the DataArray in the input's FieldData that holds the indices for the transforms for each point. These indices are used to select which transforms each weight of the DataArray refers. If the TransformIndexArray is not specified, the weights of each point are assumed to map directly to a transform. This DataArray must be of type UnsignedShort, which effectively limits the number of transforms to 65536 if a transform index array is used.</p>
<p class="endli">The filter will first look for the array in the input's PointData FieldData. If the array isn't there, the filter looks in the input's FieldData. The TransformIndexArray can have tuples of any length, but must have a tuple for every point in the input data set. This array transforms points, normals, and vectors.  </p>
</li>
<li>
<p class="startli"><code>string = obj.GetTransformIndexArray ()</code> - TransformIndexArray is the string name of the DataArray in the input's FieldData that holds the indices for the transforms for each point. These indices are used to select which transforms each weight of the DataArray refers. If the TransformIndexArray is not specified, the weights of each point are assumed to map directly to a transform. This DataArray must be of type UnsignedShort, which effectively limits the number of transforms to 65536 if a transform index array is used.</p>
<p class="endli">The filter will first look for the array in the input's PointData FieldData. If the array isn't there, the filter looks in the input's FieldData. The TransformIndexArray can have tuples of any length, but must have a tuple for every point in the input data set. This array transforms points, normals, and vectors.  </p>
</li>
<li>
<code>obj.SetCellDataWeightArray (string )</code> - The CellDataWeightArray is analogous to the WeightArray, except for CellData. The array is searched for first in the CellData FieldData, then in the input's FieldData. The data array must have a tuple for each cell. This array is used to transform only normals and vectors.  </li>
<li>
<code>string = obj.GetCellDataWeightArray ()</code> - The CellDataWeightArray is analogous to the WeightArray, except for CellData. The array is searched for first in the CellData FieldData, then in the input's FieldData. The data array must have a tuple for each cell. This array is used to transform only normals and vectors.  </li>
<li>
<code>obj.SetCellDataTransformIndexArray (string )</code>  </li>
<li>
<code>string = obj.GetCellDataTransformIndexArray ()</code>  </li>
<li>
<code>obj.SetTransform (vtkAbstractTransform transform, int num)</code> - Set or Get one of the filter's transforms. The transform number must be less than the number of transforms allocated for the object. Setting a transform slot to NULL is equivalent to assigning an overriding weight of zero to that filter slot.  </li>
<li>
<code>vtkAbstractTransform = obj.GetTransform (int num)</code> - Set or Get one of the filter's transforms. The transform number must be less than the number of transforms allocated for the object. Setting a transform slot to NULL is equivalent to assigning an overriding weight of zero to that filter slot.  </li>
<li>
<code>obj.SetNumberOfTransforms (int num)</code> - Set the number of transforms for the filter. References to non-existent filter numbers in the data array is equivalent to a weight of zero (i.e., no contribution of that filter or weight). The maximum number of transforms is limited to 65536 if transform index arrays are used.  </li>
<li>
<code>int = obj.GetNumberOfTransforms ()</code> - Set the number of transforms for the filter. References to non-existent filter numbers in the data array is equivalent to a weight of zero (i.e., no contribution of that filter or weight). The maximum number of transforms is limited to 65536 if transform index arrays are used.  </li>
<li>
<code>obj.AddInputValuesOn ()</code> - If AddInputValues is true, the output values of this filter will be offset from the input values. The effect is exactly equivalent to having an identity transform of weight 1 added into each output point.  </li>
<li>
<code>obj.AddInputValuesOff ()</code> - If AddInputValues is true, the output values of this filter will be offset from the input values. The effect is exactly equivalent to having an identity transform of weight 1 added into each output point.  </li>
<li>
<code>obj.SetAddInputValues (int )</code> - If AddInputValues is true, the output values of this filter will be offset from the input values. The effect is exactly equivalent to having an identity transform of weight 1 added into each output point.  </li>
<li>
<code>int = obj.GetAddInputValues ()</code> - If AddInputValues is true, the output values of this filter will be offset from the input values. The effect is exactly equivalent to having an identity transform of weight 1 added into each output point.  </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkhybrid.html">Visualization Toolkit Hybrid Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:33 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

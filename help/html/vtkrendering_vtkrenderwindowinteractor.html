<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkRenderWindowInteractor</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkrendering_vtkrenderwindowinteractor.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkRenderWindowInteractor </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkrendering.html">Visualization Toolkit Rendering Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>vtkRenderWindowInteractor provides a platform-independent interaction mechanism for mouse/key/time events. It serves as a base class for platform-dependent implementations that handle routing of mouse/key/timer messages to vtkInteractorObserver and its subclasses. vtkRenderWindowInteractor also provides controls for picking, rendering frame rate, and headlights.</p>
<p>vtkRenderWindowInteractor has changed from previous implementations and now serves only as a shell to hold user preferences and route messages to vtkInteractorStyle. Callbacks are available for many events. Platform specific subclasses should provide methods for manipulating timers, TerminateApp, and an event loop if required via Initialize/Start/Enable/Disable.</p>
<p>To create an instance of class vtkRenderWindowInteractor, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkRenderWindowInteractor
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkRenderWindowInteractor has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkRenderWindowInteractor class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkRenderWindowInteractor = obj.NewInstance ()</code>  </li>
<li>
<code>vtkRenderWindowInteractor = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>obj.Initialize ()</code> - Prepare for handling events. This must be called before the interactor will work.  </li>
<li>
<code>obj.ReInitialize ()</code> - This Method detects loops of RenderWindow-Interactor, so objects are freed properly.  </li>
<li>
<code>obj.UnRegister (vtkObjectBase o)</code> - This Method detects loops of RenderWindow-Interactor, so objects are freed properly.  </li>
<li>
<code>obj.Start ()</code> - Enable/Disable interactions. By default interactors are enabled when initialized. Initialize() must be called prior to enabling/disabling interaction. These methods are used when a window/widget is being shared by multiple renderers and interactors. This allows a "modal" display where one interactor is active when its data is to be displayed and all other interactors associated with the widget are disabled when their data is not displayed.  </li>
<li>
<code>obj.Enable ()</code> - Enable/Disable interactions. By default interactors are enabled when initialized. Initialize() must be called prior to enabling/disabling interaction. These methods are used when a window/widget is being shared by multiple renderers and interactors. This allows a "modal" display where one interactor is active when its data is to be displayed and all other interactors associated with the widget are disabled when their data is not displayed.  </li>
<li>
<code>obj.Disable ()</code> - Enable/Disable interactions. By default interactors are enabled when initialized. Initialize() must be called prior to enabling/disabling interaction. These methods are used when a window/widget is being shared by multiple renderers and interactors. This allows a "modal" display where one interactor is active when its data is to be displayed and all other interactors associated with the widget are disabled when their data is not displayed.  </li>
<li>
<code>int = obj.GetEnabled ()</code> - Enable/Disable interactions. By default interactors are enabled when initialized. Initialize() must be called prior to enabling/disabling interaction. These methods are used when a window/widget is being shared by multiple renderers and interactors. This allows a "modal" display where one interactor is active when its data is to be displayed and all other interactors associated with the widget are disabled when their data is not displayed.  </li>
<li>
<code>obj.EnableRenderOn ()</code> - Enable/Disable whether vtkRenderWindowInteractor::Render() calls this-&gt;RenderWindow-&gt;Render().  </li>
<li>
<code>obj.EnableRenderOff ()</code> - Enable/Disable whether vtkRenderWindowInteractor::Render() calls this-&gt;RenderWindow-&gt;Render().  </li>
<li>
<code>obj.SetEnableRender (bool )</code> - Enable/Disable whether vtkRenderWindowInteractor::Render() calls this-&gt;RenderWindow-&gt;Render().  </li>
<li>
<code>bool = obj.GetEnableRender ()</code> - Enable/Disable whether vtkRenderWindowInteractor::Render() calls this-&gt;RenderWindow-&gt;Render().  </li>
<li>
<code>obj.SetRenderWindow (vtkRenderWindow aren)</code> - Set/Get the rendering window being controlled by this object.  </li>
<li>
<code>vtkRenderWindow = obj.GetRenderWindow ()</code> - Set/Get the rendering window being controlled by this object.  </li>
<li>
<code>obj.UpdateSize (int x, int y)</code> - Event loop notification member for window size change. Window size is measured in pixels.  </li>
<li>
<code>int = obj.CreateTimer (int timerType)</code> - This class provides two groups of methods for manipulating timers. The first group (CreateTimer(timerType) and DestroyTimer()) implicitly use an internal timer id (and are present for backward compatibility). The second group (CreateRepeatingTimer(long),CreateOneShotTimer(long), ResetTimer(int),DestroyTimer(int)) use timer ids so multiple timers can be independently managed. In the first group, the CreateTimer() method takes an argument indicating whether the timer is created the first time (timerType==VTKI_TIMER_FIRST) or whether it is being reset (timerType==VTKI_TIMER_UPDATE). (In initial implementations of VTK this was how one shot and repeating timers were managed.) In the second group, the create methods take a timer duration argument (in milliseconds) and return a timer id. Thus the ResetTimer(timerId) and DestroyTimer(timerId) methods take this timer id and operate on the timer as appropriate. Methods are also available for determining  </li>
<li>
<code>int = obj.DestroyTimer ()</code> - This class provides two groups of methods for manipulating timers. The first group (CreateTimer(timerType) and DestroyTimer()) implicitly use an internal timer id (and are present for backward compatibility). The second group (CreateRepeatingTimer(long),CreateOneShotTimer(long), ResetTimer(int),DestroyTimer(int)) use timer ids so multiple timers can be independently managed. In the first group, the CreateTimer() method takes an argument indicating whether the timer is created the first time (timerType==VTKI_TIMER_FIRST) or whether it is being reset (timerType==VTKI_TIMER_UPDATE). (In initial implementations of VTK this was how one shot and repeating timers were managed.) In the second group, the create methods take a timer duration argument (in milliseconds) and return a timer id. Thus the ResetTimer(timerId) and DestroyTimer(timerId) methods take this timer id and operate on the timer as appropriate. Methods are also available for determining  </li>
<li>
<code>int = obj.CreateRepeatingTimer (long duration)</code> - This class provides two groups of methods for manipulating timers. The first group (CreateTimer(timerType) and DestroyTimer()) implicitly use an internal timer id (and are present for backward compatibility). The second group (CreateRepeatingTimer(long),CreateOneShotTimer(long), ResetTimer(int),DestroyTimer(int)) use timer ids so multiple timers can be independently managed. In the first group, the CreateTimer() method takes an argument indicating whether the timer is created the first time (timerType==VTKI_TIMER_FIRST) or whether it is being reset (timerType==VTKI_TIMER_UPDATE). (In initial implementations of VTK this was how one shot and repeating timers were managed.) In the second group, the create methods take a timer duration argument (in milliseconds) and return a timer id. Thus the ResetTimer(timerId) and DestroyTimer(timerId) methods take this timer id and operate on the timer as appropriate. Methods are also available for determining  </li>
<li>
<code>int = obj.CreateOneShotTimer (long duration)</code> - This class provides two groups of methods for manipulating timers. The first group (CreateTimer(timerType) and DestroyTimer()) implicitly use an internal timer id (and are present for backward compatibility). The second group (CreateRepeatingTimer(long),CreateOneShotTimer(long), ResetTimer(int),DestroyTimer(int)) use timer ids so multiple timers can be independently managed. In the first group, the CreateTimer() method takes an argument indicating whether the timer is created the first time (timerType==VTKI_TIMER_FIRST) or whether it is being reset (timerType==VTKI_TIMER_UPDATE). (In initial implementations of VTK this was how one shot and repeating timers were managed.) In the second group, the create methods take a timer duration argument (in milliseconds) and return a timer id. Thus the ResetTimer(timerId) and DestroyTimer(timerId) methods take this timer id and operate on the timer as appropriate. Methods are also available for determining  </li>
<li>
<code>int = obj.IsOneShotTimer (int timerId)</code> - This class provides two groups of methods for manipulating timers. The first group (CreateTimer(timerType) and DestroyTimer()) implicitly use an internal timer id (and are present for backward compatibility). The second group (CreateRepeatingTimer(long),CreateOneShotTimer(long), ResetTimer(int),DestroyTimer(int)) use timer ids so multiple timers can be independently managed. In the first group, the CreateTimer() method takes an argument indicating whether the timer is created the first time (timerType==VTKI_TIMER_FIRST) or whether it is being reset (timerType==VTKI_TIMER_UPDATE). (In initial implementations of VTK this was how one shot and repeating timers were managed.) In the second group, the create methods take a timer duration argument (in milliseconds) and return a timer id. Thus the ResetTimer(timerId) and DestroyTimer(timerId) methods take this timer id and operate on the timer as appropriate. Methods are also available for determining  </li>
<li>
<code>long = obj.GetTimerDuration (int timerId)</code> - This class provides two groups of methods for manipulating timers. The first group (CreateTimer(timerType) and DestroyTimer()) implicitly use an internal timer id (and are present for backward compatibility). The second group (CreateRepeatingTimer(long),CreateOneShotTimer(long), ResetTimer(int),DestroyTimer(int)) use timer ids so multiple timers can be independently managed. In the first group, the CreateTimer() method takes an argument indicating whether the timer is created the first time (timerType==VTKI_TIMER_FIRST) or whether it is being reset (timerType==VTKI_TIMER_UPDATE). (In initial implementations of VTK this was how one shot and repeating timers were managed.) In the second group, the create methods take a timer duration argument (in milliseconds) and return a timer id. Thus the ResetTimer(timerId) and DestroyTimer(timerId) methods take this timer id and operate on the timer as appropriate. Methods are also available for determining  </li>
<li>
<code>int = obj.ResetTimer (int timerId)</code> - This class provides two groups of methods for manipulating timers. The first group (CreateTimer(timerType) and DestroyTimer()) implicitly use an internal timer id (and are present for backward compatibility). The second group (CreateRepeatingTimer(long),CreateOneShotTimer(long), ResetTimer(int),DestroyTimer(int)) use timer ids so multiple timers can be independently managed. In the first group, the CreateTimer() method takes an argument indicating whether the timer is created the first time (timerType==VTKI_TIMER_FIRST) or whether it is being reset (timerType==VTKI_TIMER_UPDATE). (In initial implementations of VTK this was how one shot and repeating timers were managed.) In the second group, the create methods take a timer duration argument (in milliseconds) and return a timer id. Thus the ResetTimer(timerId) and DestroyTimer(timerId) methods take this timer id and operate on the timer as appropriate. Methods are also available for determining  </li>
<li>
<code>int = obj.DestroyTimer (int timerId)</code> - This class provides two groups of methods for manipulating timers. The first group (CreateTimer(timerType) and DestroyTimer()) implicitly use an internal timer id (and are present for backward compatibility). The second group (CreateRepeatingTimer(long),CreateOneShotTimer(long), ResetTimer(int),DestroyTimer(int)) use timer ids so multiple timers can be independently managed. In the first group, the CreateTimer() method takes an argument indicating whether the timer is created the first time (timerType==VTKI_TIMER_FIRST) or whether it is being reset (timerType==VTKI_TIMER_UPDATE). (In initial implementations of VTK this was how one shot and repeating timers were managed.) In the second group, the create methods take a timer duration argument (in milliseconds) and return a timer id. Thus the ResetTimer(timerId) and DestroyTimer(timerId) methods take this timer id and operate on the timer as appropriate. Methods are also available for determining  </li>
<li>
<code>int = obj.GetVTKTimerId (int platformTimerId)</code> - This class provides two groups of methods for manipulating timers. The first group (CreateTimer(timerType) and DestroyTimer()) implicitly use an internal timer id (and are present for backward compatibility). The second group (CreateRepeatingTimer(long),CreateOneShotTimer(long), ResetTimer(int),DestroyTimer(int)) use timer ids so multiple timers can be independently managed. In the first group, the CreateTimer() method takes an argument indicating whether the timer is created the first time (timerType==VTKI_TIMER_FIRST) or whether it is being reset (timerType==VTKI_TIMER_UPDATE). (In initial implementations of VTK this was how one shot and repeating timers were managed.) In the second group, the create methods take a timer duration argument (in milliseconds) and return a timer id. Thus the ResetTimer(timerId) and DestroyTimer(timerId) methods take this timer id and operate on the timer as appropriate. Methods are also available for determining  </li>
<li>
<code>obj.SetTimerDuration (long )</code> - Specify the default timer interval (in milliseconds). (This is used in conjunction with the timer methods described previously, e.g., CreateTimer() uses this value; and CreateRepeatingTimer(duration) and CreateOneShotTimer(duration) use the default value if the parameter "duration" is less than or equal to zero.) Care must be taken when adjusting the timer interval from the default value of 10 milliseconds&ndash;it may adversely affect the interactors.  </li>
<li>
<code>GetTimerDurationMinValue = obj.()</code> - Specify the default timer interval (in milliseconds). (This is used in conjunction with the timer methods described previously, e.g., CreateTimer() uses this value; and CreateRepeatingTimer(duration) and CreateOneShotTimer(duration) use the default value if the parameter "duration" is less than or equal to zero.) Care must be taken when adjusting the timer interval from the default value of 10 milliseconds&ndash;it may adversely affect the interactors.  </li>
<li>
<code>GetTimerDurationMaxValue = obj.()</code> - Specify the default timer interval (in milliseconds). (This is used in conjunction with the timer methods described previously, e.g., CreateTimer() uses this value; and CreateRepeatingTimer(duration) and CreateOneShotTimer(duration) use the default value if the parameter "duration" is less than or equal to zero.) Care must be taken when adjusting the timer interval from the default value of 10 milliseconds&ndash;it may adversely affect the interactors.  </li>
<li>
<code>long = obj.GetTimerDuration ()</code> - Specify the default timer interval (in milliseconds). (This is used in conjunction with the timer methods described previously, e.g., CreateTimer() uses this value; and CreateRepeatingTimer(duration) and CreateOneShotTimer(duration) use the default value if the parameter "duration" is less than or equal to zero.) Care must be taken when adjusting the timer interval from the default value of 10 milliseconds&ndash;it may adversely affect the interactors.  </li>
<li>
<code>obj.SetTimerEventId (int )</code> - These methods are used to communicate information about the currently firing CreateTimerEvent or DestroyTimerEvent. The caller of CreateTimerEvent sets up TimerEventId, TimerEventType and TimerEventDuration. The observer of CreateTimerEvent should set up an appropriate platform specific timer based on those values and set the TimerEventPlatformId before returning. The caller of DestroyTimerEvent sets up TimerEventPlatformId. The observer of DestroyTimerEvent should simply destroy the platform specific timer created by CreateTimerEvent. See vtkGenericRenderWindowInteractor's InternalCreateTimer and InternalDestroyTimer for an example.  </li>
<li>
<code>int = obj.GetTimerEventId ()</code> - These methods are used to communicate information about the currently firing CreateTimerEvent or DestroyTimerEvent. The caller of CreateTimerEvent sets up TimerEventId, TimerEventType and TimerEventDuration. The observer of CreateTimerEvent should set up an appropriate platform specific timer based on those values and set the TimerEventPlatformId before returning. The caller of DestroyTimerEvent sets up TimerEventPlatformId. The observer of DestroyTimerEvent should simply destroy the platform specific timer created by CreateTimerEvent. See vtkGenericRenderWindowInteractor's InternalCreateTimer and InternalDestroyTimer for an example.  </li>
<li>
<code>obj.SetTimerEventType (int )</code> - These methods are used to communicate information about the currently firing CreateTimerEvent or DestroyTimerEvent. The caller of CreateTimerEvent sets up TimerEventId, TimerEventType and TimerEventDuration. The observer of CreateTimerEvent should set up an appropriate platform specific timer based on those values and set the TimerEventPlatformId before returning. The caller of DestroyTimerEvent sets up TimerEventPlatformId. The observer of DestroyTimerEvent should simply destroy the platform specific timer created by CreateTimerEvent. See vtkGenericRenderWindowInteractor's InternalCreateTimer and InternalDestroyTimer for an example.  </li>
<li>
<code>int = obj.GetTimerEventType ()</code> - These methods are used to communicate information about the currently firing CreateTimerEvent or DestroyTimerEvent. The caller of CreateTimerEvent sets up TimerEventId, TimerEventType and TimerEventDuration. The observer of CreateTimerEvent should set up an appropriate platform specific timer based on those values and set the TimerEventPlatformId before returning. The caller of DestroyTimerEvent sets up TimerEventPlatformId. The observer of DestroyTimerEvent should simply destroy the platform specific timer created by CreateTimerEvent. See vtkGenericRenderWindowInteractor's InternalCreateTimer and InternalDestroyTimer for an example.  </li>
<li>
<code>obj.SetTimerEventDuration (int )</code> - These methods are used to communicate information about the currently firing CreateTimerEvent or DestroyTimerEvent. The caller of CreateTimerEvent sets up TimerEventId, TimerEventType and TimerEventDuration. The observer of CreateTimerEvent should set up an appropriate platform specific timer based on those values and set the TimerEventPlatformId before returning. The caller of DestroyTimerEvent sets up TimerEventPlatformId. The observer of DestroyTimerEvent should simply destroy the platform specific timer created by CreateTimerEvent. See vtkGenericRenderWindowInteractor's InternalCreateTimer and InternalDestroyTimer for an example.  </li>
<li>
<code>int = obj.GetTimerEventDuration ()</code> - These methods are used to communicate information about the currently firing CreateTimerEvent or DestroyTimerEvent. The caller of CreateTimerEvent sets up TimerEventId, TimerEventType and TimerEventDuration. The observer of CreateTimerEvent should set up an appropriate platform specific timer based on those values and set the TimerEventPlatformId before returning. The caller of DestroyTimerEvent sets up TimerEventPlatformId. The observer of DestroyTimerEvent should simply destroy the platform specific timer created by CreateTimerEvent. See vtkGenericRenderWindowInteractor's InternalCreateTimer and InternalDestroyTimer for an example.  </li>
<li>
<code>obj.SetTimerEventPlatformId (int )</code> - These methods are used to communicate information about the currently firing CreateTimerEvent or DestroyTimerEvent. The caller of CreateTimerEvent sets up TimerEventId, TimerEventType and TimerEventDuration. The observer of CreateTimerEvent should set up an appropriate platform specific timer based on those values and set the TimerEventPlatformId before returning. The caller of DestroyTimerEvent sets up TimerEventPlatformId. The observer of DestroyTimerEvent should simply destroy the platform specific timer created by CreateTimerEvent. See vtkGenericRenderWindowInteractor's InternalCreateTimer and InternalDestroyTimer for an example.  </li>
<li>
<code>int = obj.GetTimerEventPlatformId ()</code> - These methods are used to communicate information about the currently firing CreateTimerEvent or DestroyTimerEvent. The caller of CreateTimerEvent sets up TimerEventId, TimerEventType and TimerEventDuration. The observer of CreateTimerEvent should set up an appropriate platform specific timer based on those values and set the TimerEventPlatformId before returning. The caller of DestroyTimerEvent sets up TimerEventPlatformId. The observer of DestroyTimerEvent should simply destroy the platform specific timer created by CreateTimerEvent. See vtkGenericRenderWindowInteractor's InternalCreateTimer and InternalDestroyTimer for an example.  </li>
<li>
<code>obj.TerminateApp (void )</code> - External switching between joystick/trackball/new? modes. Initial value is a vtkInteractorStyleSwitch object.  </li>
<li>
<code>obj.SetInteractorStyle (vtkInteractorObserver )</code> - External switching between joystick/trackball/new? modes. Initial value is a vtkInteractorStyleSwitch object.  </li>
<li>
<code>vtkInteractorObserver = obj.GetInteractorStyle ()</code> - External switching between joystick/trackball/new? modes. Initial value is a vtkInteractorStyleSwitch object.  </li>
<li>
<code>obj.SetLightFollowCamera (int )</code> - Turn on/off the automatic repositioning of lights as the camera moves. Default is On.  </li>
<li>
<code>int = obj.GetLightFollowCamera ()</code> - Turn on/off the automatic repositioning of lights as the camera moves. Default is On.  </li>
<li>
<code>obj.LightFollowCameraOn ()</code> - Turn on/off the automatic repositioning of lights as the camera moves. Default is On.  </li>
<li>
<code>obj.LightFollowCameraOff ()</code> - Turn on/off the automatic repositioning of lights as the camera moves. Default is On.  </li>
<li>
<code>obj.SetDesiredUpdateRate (double )</code> - Set/Get the desired update rate. This is used by vtkLODActor's to tell them how quickly they need to render. This update is in effect only when the camera is being rotated, or zoomed. When the interactor is still, the StillUpdateRate is used instead. The default is 15.  </li>
<li>
<code>double = obj.GetDesiredUpdateRateMinValue ()</code> - Set/Get the desired update rate. This is used by vtkLODActor's to tell them how quickly they need to render. This update is in effect only when the camera is being rotated, or zoomed. When the interactor is still, the StillUpdateRate is used instead. The default is 15.  </li>
<li>
<code>double = obj.GetDesiredUpdateRateMaxValue ()</code> - Set/Get the desired update rate. This is used by vtkLODActor's to tell them how quickly they need to render. This update is in effect only when the camera is being rotated, or zoomed. When the interactor is still, the StillUpdateRate is used instead. The default is 15.  </li>
<li>
<code>double = obj.GetDesiredUpdateRate ()</code> - Set/Get the desired update rate. This is used by vtkLODActor's to tell them how quickly they need to render. This update is in effect only when the camera is being rotated, or zoomed. When the interactor is still, the StillUpdateRate is used instead. The default is 15.  </li>
<li>
<code>obj.SetStillUpdateRate (double )</code> - Set/Get the desired update rate when movement has stopped. For the non-still update rate, see the SetDesiredUpdateRate method. The default is 0.0001  </li>
<li>
<code>double = obj.GetStillUpdateRateMinValue ()</code> - Set/Get the desired update rate when movement has stopped. For the non-still update rate, see the SetDesiredUpdateRate method. The default is 0.0001  </li>
<li>
<code>double = obj.GetStillUpdateRateMaxValue ()</code> - Set/Get the desired update rate when movement has stopped. For the non-still update rate, see the SetDesiredUpdateRate method. The default is 0.0001  </li>
<li>
<code>double = obj.GetStillUpdateRate ()</code> - Set/Get the desired update rate when movement has stopped. For the non-still update rate, see the SetDesiredUpdateRate method. The default is 0.0001  </li>
<li>
<code>int = obj.GetInitialized ()</code> - See whether interactor has been initialized yet. Default is 0.  </li>
<li>
<code>obj.SetPicker (vtkAbstractPicker )</code> - Set/Get the object used to perform pick operations. In order to pick instances of vtkProp, the picker must be a subclass of vtkAbstractPropPicker, meaning that it can identify a particular instance of vtkProp.  </li>
<li>
<code>vtkAbstractPicker = obj.GetPicker ()</code> - Set/Get the object used to perform pick operations. In order to pick instances of vtkProp, the picker must be a subclass of vtkAbstractPropPicker, meaning that it can identify a particular instance of vtkProp.  </li>
<li>
<code>vtkAbstractPropPicker = obj.CreateDefaultPicker ()</code> - Create default picker. Used to create one when none is specified. Default is an instance of vtkPropPicker.  </li>
<li>
<code>obj.ExitCallback ()</code> - These methods correspond to the the Exit, User and Pick callbacks. They allow for the Style to invoke them.  </li>
<li>
<code>obj.UserCallback ()</code> - These methods correspond to the the Exit, User and Pick callbacks. They allow for the Style to invoke them.  </li>
<li>
<code>obj.StartPickCallback ()</code> - These methods correspond to the the Exit, User and Pick callbacks. They allow for the Style to invoke them.  </li>
<li>
<code>obj.EndPickCallback ()</code> - These methods correspond to the the Exit, User and Pick callbacks. They allow for the Style to invoke them.  </li>
<li>
<code>obj.GetMousePosition (int x, int y)</code> - Hide or show the mouse cursor, it is nice to be able to hide the default cursor if you want VTK to display a 3D cursor instead.  </li>
<li>
<code>obj.HideCursor ()</code> - Hide or show the mouse cursor, it is nice to be able to hide the default cursor if you want VTK to display a 3D cursor instead.  </li>
<li>
<code>obj.ShowCursor ()</code> - Hide or show the mouse cursor, it is nice to be able to hide the default cursor if you want VTK to display a 3D cursor instead.  </li>
<li>
<code>obj.Render ()</code> - Render the scene. Just pass the render call on to the associated vtkRenderWindow.  </li>
<li>
<code>obj.FlyTo (vtkRenderer ren, double x, double y, double z)</code> - Given a position x, move the current camera's focal point to x. The movement is animated over the number of frames specified in NumberOfFlyFrames. The LOD desired frame rate is used.  </li>
<li>
<code>obj.FlyTo (vtkRenderer ren, double x)</code> - Given a position x, move the current camera's focal point to x. The movement is animated over the number of frames specified in NumberOfFlyFrames. The LOD desired frame rate is used.  </li>
<li>
<code>obj.FlyToImage (vtkRenderer ren, double x, double y)</code> - Given a position x, move the current camera's focal point to x. The movement is animated over the number of frames specified in NumberOfFlyFrames. The LOD desired frame rate is used.  </li>
<li>
<code>obj.FlyToImage (vtkRenderer ren, double x)</code> - Set the number of frames to fly to when FlyTo is invoked.  </li>
<li>
<code>obj.SetNumberOfFlyFrames (int )</code> - Set the number of frames to fly to when FlyTo is invoked.  </li>
<li>
<code>int = obj.GetNumberOfFlyFramesMinValue ()</code> - Set the number of frames to fly to when FlyTo is invoked.  </li>
<li>
<code>int = obj.GetNumberOfFlyFramesMaxValue ()</code> - Set the number of frames to fly to when FlyTo is invoked.  </li>
<li>
<code>int = obj.GetNumberOfFlyFrames ()</code> - Set the number of frames to fly to when FlyTo is invoked.  </li>
<li>
<code>obj.SetDolly (double )</code> - Set the total Dolly value to use when flying to (FlyTo()) a specified point. Negative values fly away from the point.  </li>
<li>
<code>double = obj.GetDolly ()</code> - Set the total Dolly value to use when flying to (FlyTo()) a specified point. Negative values fly away from the point.  </li>
<li>
<code>int = obj. GetEventPosition ()</code> - Set/Get information about the current event. The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method. Mouse positions are measured in pixels. The other information is about key board input.  </li>
<li>
<code>int = obj. GetLastEventPosition ()</code> - Set/Get information about the current event. The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method. Mouse positions are measured in pixels. The other information is about key board input.  </li>
<li>
<code>obj.SetLastEventPosition (int , int )</code> - Set/Get information about the current event. The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method. Mouse positions are measured in pixels. The other information is about key board input.  </li>
<li>
<code>obj.SetLastEventPosition (int a[2])</code> - Set/Get information about the current event. The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method. Mouse positions are measured in pixels. The other information is about key board input.  </li>
<li>
<code>obj.SetEventPosition (int x, int y)</code> - Set/Get information about the current event. The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method. Mouse positions are measured in pixels. The other information is about key board input.  </li>
<li>
<code>obj.SetEventPosition (int pos[2])</code> - Set/Get information about the current event. The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method. Mouse positions are measured in pixels. The other information is about key board input.  </li>
<li>
<code>obj.SetEventPositionFlipY (int x, int y)</code> - Set/Get information about the current event. The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method. Mouse positions are measured in pixels. The other information is about key board input.  </li>
<li>
<code>obj.SetEventPositionFlipY (int pos[2])</code> - Set/Get information about the current event. The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method. Mouse positions are measured in pixels. The other information is about key board input.  </li>
<li>
<code>obj.SetAltKey (int )</code> - Set/Get information about the current event. The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method. Mouse positions are measured in pixels. The other information is about key board input.  </li>
<li>
<code>int = obj.GetAltKey ()</code> - Set/Get information about the current event. The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method. Mouse positions are measured in pixels. The other information is about key board input.  </li>
<li>
<code>obj.SetControlKey (int )</code> - Set/Get information about the current event. The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method. Mouse positions are measured in pixels. The other information is about key board input.  </li>
<li>
<code>int = obj.GetControlKey ()</code> - Set/Get information about the current event. The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method. Mouse positions are measured in pixels. The other information is about key board input.  </li>
<li>
<code>obj.SetShiftKey (int )</code> - Set/Get information about the current event. The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method. Mouse positions are measured in pixels. The other information is about key board input.  </li>
<li>
<code>int = obj.GetShiftKey ()</code> - Set/Get information about the current event. The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method. Mouse positions are measured in pixels. The other information is about key board input.  </li>
<li>
<code>obj.SetKeyCode (char )</code> - Set/Get information about the current event. The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method. Mouse positions are measured in pixels. The other information is about key board input.  </li>
<li>
<code>char = obj.GetKeyCode ()</code> - Set/Get information about the current event. The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method. Mouse positions are measured in pixels. The other information is about key board input.  </li>
<li>
<code>obj.SetRepeatCount (int )</code> - Set/Get information about the current event. The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method. Mouse positions are measured in pixels. The other information is about key board input.  </li>
<li>
<code>int = obj.GetRepeatCount ()</code> - Set/Get information about the current event. The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method. Mouse positions are measured in pixels. The other information is about key board input.  </li>
<li>
<code>obj.SetKeySym (string )</code> - Set/Get information about the current event. The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method. Mouse positions are measured in pixels. The other information is about key board input.  </li>
<li>
<code>string = obj.GetKeySym ()</code> - Set/Get information about the current event. The current x,y position is in the EventPosition, and the previous event position is in LastEventPosition, updated automatically each time EventPosition is set using its Set() method. Mouse positions are measured in pixels. The other information is about key board input.  </li>
<li>
<code>obj.SetEventInformation (int x, int y, int ctrl, int shift, char keycode, int repeatcount, string keysym)</code> - Calls SetEventInformation, but flips the Y based on the current Size[1] value (i.e. y = this-&gt;Size[1] - y - 1).  </li>
<li>
<code>obj.SetEventInformationFlipY (int x, int y, int ctrl, int shift, char keycode, int repeatcount, string keysym)</code> - Set all the keyboard-related event information in one call.  </li>
<li>
<code>obj.SetKeyEventInformation (int ctrl, int shift, char keycode, int repeatcount, string keysym)</code> - This methods sets the Size ivar of the interactor without actually changing the size of the window. Normally application programmers would use UpdateSize if anything. This is useful for letting someone else change the size of the rendering window and just letting the interactor know about the change. The current event width/height (if any) is in EventSize (Expose event, for example). Window size is measured in pixels.  </li>
<li>
<code>obj.SetSize (int , int )</code> - This methods sets the Size ivar of the interactor without actually changing the size of the window. Normally application programmers would use UpdateSize if anything. This is useful for letting someone else change the size of the rendering window and just letting the interactor know about the change. The current event width/height (if any) is in EventSize (Expose event, for example). Window size is measured in pixels.  </li>
<li>
<code>obj.SetSize (int a[2])</code> - This methods sets the Size ivar of the interactor without actually changing the size of the window. Normally application programmers would use UpdateSize if anything. This is useful for letting someone else change the size of the rendering window and just letting the interactor know about the change. The current event width/height (if any) is in EventSize (Expose event, for example). Window size is measured in pixels.  </li>
<li>
<code>int = obj. GetSize ()</code> - This methods sets the Size ivar of the interactor without actually changing the size of the window. Normally application programmers would use UpdateSize if anything. This is useful for letting someone else change the size of the rendering window and just letting the interactor know about the change. The current event width/height (if any) is in EventSize (Expose event, for example). Window size is measured in pixels.  </li>
<li>
<code>obj.SetEventSize (int , int )</code> - This methods sets the Size ivar of the interactor without actually changing the size of the window. Normally application programmers would use UpdateSize if anything. This is useful for letting someone else change the size of the rendering window and just letting the interactor know about the change. The current event width/height (if any) is in EventSize (Expose event, for example). Window size is measured in pixels.  </li>
<li>
<code>obj.SetEventSize (int a[2])</code> - This methods sets the Size ivar of the interactor without actually changing the size of the window. Normally application programmers would use UpdateSize if anything. This is useful for letting someone else change the size of the rendering window and just letting the interactor know about the change. The current event width/height (if any) is in EventSize (Expose event, for example). Window size is measured in pixels.  </li>
<li>
<code>int = obj. GetEventSize ()</code> - This methods sets the Size ivar of the interactor without actually changing the size of the window. Normally application programmers would use UpdateSize if anything. This is useful for letting someone else change the size of the rendering window and just letting the interactor know about the change. The current event width/height (if any) is in EventSize (Expose event, for example). Window size is measured in pixels.  </li>
<li>
<code>vtkRenderer = obj.FindPokedRenderer (int , int )</code> - When an event occurs, we must determine which Renderer the event occurred within, since one RenderWindow may contain multiple renderers.  </li>
<li>
<code>vtkObserverMediator = obj.GetObserverMediator ()</code> - Return the object used to mediate between vtkInteractorObservers contending for resources. Multiple interactor observers will often request different resources (e.g., cursor shape); the mediator uses a strategy to provide the resource based on priority of the observer plus the particular request (default versus non-default cursor shape).  </li>
<li>
<code>obj.SetUseTDx (bool )</code> - Use a 3DConnexion device. Initial value is false. If VTK is not build with the TDx option, this is no-op. If VTK is build with the TDx option, and a device is not connected, a warning is emitted. It is must be called before the first Render to be effective, otherwise it is ignored.  </li>
<li>
<code>bool = obj.GetUseTDx ()</code> - Use a 3DConnexion device. Initial value is false. If VTK is not build with the TDx option, this is no-op. If VTK is build with the TDx option, and a device is not connected, a warning is emitted. It is must be called before the first Render to be effective, otherwise it is ignored.  </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkrendering.html">Visualization Toolkit Rendering Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:35 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkAbstractInterpolatedVelocityField</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkfiltering_vtkabstractinterpolatedvelocityfield.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkAbstractInterpolatedVelocityField </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkfiltering.html">Visualization Toolkit Filtering Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>vtkAbstractInterpolatedVelocityField acts as a continuous velocity field by performing cell interpolation on the underlying vtkDataSet. This is an abstract sub-class of vtkFunctionSet, NumberOfIndependentVariables = 4 (x,y,z,t) and NumberOfFunctions = 3 (u,v,w). With a brute-force scheme, every time an evaluation is performed, the target cell containing point (x,y,z) needs to be found by calling FindCell(), via either vtkDataSet or vtkAbstractCelllocator's sub-classes (vtkCellLocator &amp; vtkModifiedBSPTree). As it incurs a large cost, one (for vtkCellLocatorInterpolatedVelocityField via vtkAbstractCellLocator) or two (for vtkInterpolatedVelocityField via vtkDataSet that involves vtkPointLocator in addressing vtkPointSet) levels of cell caching may be exploited to increase the performance.</p>
<p>For vtkInterpolatedVelocityField, level #0 begins with intra-cell caching. Specifically if the previous cell is valid and the next point is still in it ( i.e., vtkCell::EvaluatePosition() returns 1, coupled with newly created parametric coordinates &amp; weights ), the function values can be interpolated and only vtkCell::EvaluatePosition() is invoked. If this fails, then level #1 follows by inter-cell search for the target cell that contains the next point. By an inter-cell search, the previous cell provides an important clue or serves as an immediate neighbor to aid in locating the target cell via vtkPointSet:: FindCell(). If this still fails, a global cell location / search is invoked via vtkPointSet::FindCell(). Here regardless of either inter-cell or global search, vtkPointLocator is in fact employed (for datasets of type vtkPointSet only, note vtkImageData and vtkRectilinearGrid are able to provide rapid and robust cell location due to the simple mesh topology) as a crucial tool underlying the cell locator. However, the use of vtkPointLocator makes vtkInterpolatedVelocityField non-robust in cell location for vtkPointSet.</p>
<p>For vtkCellLocatorInterpolatedVelocityField, the only caching (level #0) works by intra-cell trial. In case of failure, a global search for the target cell is invoked via vtkAbstractCellLocator::FindCell() and the actual work is done by either vtkCellLocator or vtkModifiedBSPTree (for datasets of type vtkPointSet only, while vtkImageData and vtkRectilinearGrid themselves are able to provide fast robust cell location). Without the involvement of vtkPointLocator, robust cell location is achieved for vtkPointSet.</p>
<p>To create an instance of class vtkAbstractInterpolatedVelocityField, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkAbstractInterpolatedVelocityField
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkAbstractInterpolatedVelocityField has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkAbstractInterpolatedVelocityField class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkAbstractInterpolatedVelocityField = obj.NewInstance ()</code>  </li>
<li>
<code>vtkAbstractInterpolatedVelocityField = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>obj.SetCaching (bool )</code> - Set/Get the caching flag. If this flag is turned ON, there are two levels of caching for derived concrete class vtkInterpolatedVelocityField and one level of caching for derived concrete class vtkCellLocatorInterpolatedVelocityField. Otherwise a global cell location is always invoked for evaluating the function values at any point.  </li>
<li>
<code>bool = obj.GetCaching ()</code> - Set/Get the caching flag. If this flag is turned ON, there are two levels of caching for derived concrete class vtkInterpolatedVelocityField and one level of caching for derived concrete class vtkCellLocatorInterpolatedVelocityField. Otherwise a global cell location is always invoked for evaluating the function values at any point.  </li>
<li>
<code>int = obj.GetCacheHit ()</code> - Get the caching statistics. CacheHit refers to the number of level #0 cache hits while CacheMiss is the number of level #0 cache misses.  </li>
<li>
<code>int = obj.GetCacheMiss ()</code> - Get the caching statistics. CacheHit refers to the number of level #0 cache hits while CacheMiss is the number of level #0 cache misses.  </li>
<li>
<code>int = obj.GetLastDataSetIndex ()</code> - Get the most recently visited dataset and it id. The dataset is used for a guess regarding where the next point will be, without searching through all datasets. When setting the last dataset, care is needed as no reference counting or checks are performed. This feature is intended for custom interpolators only that cache datasets independently.  </li>
<li>
<code>vtkDataSet = obj.GetLastDataSet ()</code> - Get the most recently visited dataset and it id. The dataset is used for a guess regarding where the next point will be, without searching through all datasets. When setting the last dataset, care is needed as no reference counting or checks are performed. This feature is intended for custom interpolators only that cache datasets independently.  </li>
<li>
<code>vtkIdType = obj.GetLastCellId ()</code> - Get/Set the id of the cell cached from last evaluation.  </li>
<li>
<code>obj.SetLastCellId (vtkIdType c)</code> - Set the id of the most recently visited cell of a dataset.  </li>
<li>
<code>obj.SetLastCellId (vtkIdType c, int dataindex)</code> - Set the id of the most recently visited cell of a dataset.  </li>
<li>
<code>string = obj.GetVectorsSelection ()</code> - Get/Set the name of a spcified vector array. By default it is NULL, with the active vector array for use.  </li>
<li>
<code>obj.SelectVectors (string fieldName)</code> - Set/Get the flag indicating vector post-normalization (following vector interpolation). Vector post-normalization is required to avoid the 'curve-overshooting' problem (caused by high velocity magnitude) that occurs when Cell-Length is used as the step size unit (particularly the Minimum step size unit). Furthermore, it is required by RK45 to achieve, as expected, high numerical accuracy (or high smoothness of flow lines) through adaptive step sizing. Note this operation is performed (when NormalizeVector TRUE) right after vector interpolation such that the differing amount of contribution of each node (of a cell) to the resulting direction of the interpolated vector, due to the possibly significantly-differing velocity magnitude values at the nodes (which is the case with large cells), can be reflected as is. Also note that this flag needs to be turned to FALSE after vtkInitialValueProblemSolver:: ComputeNextStep() as subsequent operations, e.g., vorticity computation, may need non-normalized vectors.  </li>
<li>
<code>obj.SetNormalizeVector (bool )</code> - Set/Get the flag indicating vector post-normalization (following vector interpolation). Vector post-normalization is required to avoid the 'curve-overshooting' problem (caused by high velocity magnitude) that occurs when Cell-Length is used as the step size unit (particularly the Minimum step size unit). Furthermore, it is required by RK45 to achieve, as expected, high numerical accuracy (or high smoothness of flow lines) through adaptive step sizing. Note this operation is performed (when NormalizeVector TRUE) right after vector interpolation such that the differing amount of contribution of each node (of a cell) to the resulting direction of the interpolated vector, due to the possibly significantly-differing velocity magnitude values at the nodes (which is the case with large cells), can be reflected as is. Also note that this flag needs to be turned to FALSE after vtkInitialValueProblemSolver:: ComputeNextStep() as subsequent operations, e.g., vorticity computation, may need non-normalized vectors.  </li>
<li>
<code>bool = obj.GetNormalizeVector ()</code> - Set/Get the flag indicating vector post-normalization (following vector interpolation). Vector post-normalization is required to avoid the 'curve-overshooting' problem (caused by high velocity magnitude) that occurs when Cell-Length is used as the step size unit (particularly the Minimum step size unit). Furthermore, it is required by RK45 to achieve, as expected, high numerical accuracy (or high smoothness of flow lines) through adaptive step sizing. Note this operation is performed (when NormalizeVector TRUE) right after vector interpolation such that the differing amount of contribution of each node (of a cell) to the resulting direction of the interpolated vector, due to the possibly significantly-differing velocity magnitude values at the nodes (which is the case with large cells), can be reflected as is. Also note that this flag needs to be turned to FALSE after vtkInitialValueProblemSolver:: ComputeNextStep() as subsequent operations, e.g., vorticity computation, may need non-normalized vectors.  </li>
<li>
<code>obj.CopyParameters (vtkAbstractInterpolatedVelocityField from)</code> - Add a dataset for implicit velocity function evaluation. If more than one dataset is added, the evaluation point is searched in all until a match is found. THIS FUNCTION DOES NOT CHANGE THE REFERENCE COUNT OF dataset FOR THREAD SAFETY REASONS.  </li>
<li>
<code>obj.AddDataSet (vtkDataSet dataset)</code> - Add a dataset for implicit velocity function evaluation. If more than one dataset is added, the evaluation point is searched in all until a match is found. THIS FUNCTION DOES NOT CHANGE THE REFERENCE COUNT OF dataset FOR THREAD SAFETY REASONS.  </li>
<li>
<code>int = obj.FunctionValues (double x, double f)</code> - Evaluate the velocity field f at point (x, y, z).  </li>
<li>
<code>obj.ClearLastCellId ()</code> - Get the interpolation weights cached from last evaluation. Return 1 if the cached cell is valid and 0 otherwise.  </li>
<li>
<code>int = obj.GetLastWeights (double w)</code> - Get the interpolation weights cached from last evaluation. Return 1 if the cached cell is valid and 0 otherwise.  </li>
<li>
<code>int = obj.GetLastLocalCoordinates (double pcoords[3])</code> - Get the interpolation weights cached from last evaluation. Return 1 if the cached cell is valid and 0 otherwise.  </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkfiltering.html">Visualization Toolkit Filtering Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:30 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

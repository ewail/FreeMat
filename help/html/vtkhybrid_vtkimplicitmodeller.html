<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkImplicitModeller</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkhybrid_vtkimplicitmodeller.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkImplicitModeller </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkhybrid.html">Visualization Toolkit Hybrid Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>vtkImplicitModeller is a filter that computes the distance from the input geometry to the points of an output structured point set. This distance function can then be "contoured" to generate new, offset surfaces from the original geometry. An important feature of this object is "capping". If capping is turned on, after the implicit model is created, the values on the boundary of the structured points dataset are set to the cap value. This is used to force closure of the resulting contoured surface. Note, however, that large cap values can generate weird surface normals in those cells adjacent to the boundary of the dataset. Using smaller cap value will reduce this effect. </p>
<p>Another important ivar is MaximumDistance. This controls how far into the volume the distance function is computed from the input geometry. Small values give significant increases in performance. However, there can strange sampling effects at the extreme range of the MaximumDistance. </p>
<p>In order to properly execute and sample the input data, a rectangular region in space must be defined (this is the ivar ModelBounds). If not explicitly defined, the model bounds will be computed. Note that to avoid boundary effects, it is possible to adjust the model bounds (i.e., using the AdjustBounds and AdjustDistance ivars) to strictly contain the sampled data. </p>
<p>This filter has one other unusual capability: it is possible to append data in a sequence of operations to generate a single output. This is useful when you have multiple datasets and want to create a conglomeration of all the data. However, the user must be careful to either specify the ModelBounds or specify the first item such that its bounds completely contain all other items. This is because the rectangular region of the output can not be changed after the 1st Append. </p>
<p>The ProcessMode ivar controls the method used within the Append function (where the actual work is done regardless if the Append function is explicitly called) to compute the implicit model. If set to work in voxel mode, each voxel is visited once. If set to cell mode, each cell is visited once. Tests have shown once per voxel to be faster when there are a lot of cells (at least a thousand?); relative performance improvement increases with addition cells. Primitives should not be stripped for best performance of the voxel mode. Also, if explicitly using the Append feature many times, the cell mode will probably be better because each voxel will be visited each Append. Append the data before input if possible when using the voxel mode. Do not switch between voxel and cell mode between execution of StartAppend and EndAppend. </p>
<p>Further performance improvement is now possible using the PerVoxel process mode on multi-processor machines (the mode is now multithreaded). Each thread processes a different "slab" of the output. Also, if the input is vtkPolyData, it is appropriately clipped for each thread; that is, each thread only considers the input which could affect its slab of the output. </p>
<p>This filter can now produce output of any type supported by vtkImageData. However to support this change, additional sqrts must be executed during the Append step. Previously, the output was initialized to the squared CapValue in StartAppend, the output was updated with squared distance values during the Append, and then the sqrt of the distances was computed in EndAppend. To support different scalar types in the output (largely to reduce memory requirements as an vtkImageShiftScale and/or vtkImageCast could have achieved the same result), we can't "afford" to save squared value in the output, because then we could only represent up to the sqrt of the scalar max for an integer type in the output; 1 (instead of 255) for an unsigned char; 11 for a char (instead of 127). Thus this change may result in a minor performance degradation. Non-float output types can be scaled to the CapValue by turning ScaleToMaximumDistance On.</p>
<p>To create an instance of class vtkImplicitModeller, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkImplicitModeller
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkImplicitModeller has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkImplicitModeller class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkImplicitModeller = obj.NewInstance ()</code>  </li>
<li>
<code>vtkImplicitModeller = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>double = obj.ComputeModelBounds (vtkDataSet inputNULL)</code> - Compute ModelBounds from input geometry. If input is not specified, the input of the filter will be used.  </li>
<li>
<code>int = obj. GetSampleDimensions ()</code> - Set/Get the i-j-k dimensions on which to sample distance function.  </li>
<li>
<code>obj.SetSampleDimensions (int i, int j, int k)</code> - Set/Get the i-j-k dimensions on which to sample distance function.  </li>
<li>
<code>obj.SetSampleDimensions (int dim[3])</code> - Set/Get the i-j-k dimensions on which to sample distance function.  </li>
<li>
<code>obj.SetMaximumDistance (double )</code> - Set / get the distance away from surface of input geometry to sample. Smaller values make large increases in performance.  </li>
<li>
<code>double = obj.GetMaximumDistanceMinValue ()</code> - Set / get the distance away from surface of input geometry to sample. Smaller values make large increases in performance.  </li>
<li>
<code>double = obj.GetMaximumDistanceMaxValue ()</code> - Set / get the distance away from surface of input geometry to sample. Smaller values make large increases in performance.  </li>
<li>
<code>double = obj.GetMaximumDistance ()</code> - Set / get the distance away from surface of input geometry to sample. Smaller values make large increases in performance.  </li>
<li>
<code>obj.SetModelBounds (double , double , double , double , double , double )</code> - Set / get the region in space in which to perform the sampling. If not specified, it will be computed automatically.  </li>
<li>
<code>obj.SetModelBounds (double a[6])</code> - Set / get the region in space in which to perform the sampling. If not specified, it will be computed automatically.  </li>
<li>
<code>double = obj. GetModelBounds ()</code> - Set / get the region in space in which to perform the sampling. If not specified, it will be computed automatically.  </li>
<li>
<code>obj.SetAdjustBounds (int )</code> - Control how the model bounds are computed. If the ivar AdjustBounds is set, then the bounds specified (or computed automatically) is modified by the fraction given by AdjustDistance. This means that the model bounds is expanded in each of the x-y-z directions.  </li>
<li>
<code>int = obj.GetAdjustBounds ()</code> - Control how the model bounds are computed. If the ivar AdjustBounds is set, then the bounds specified (or computed automatically) is modified by the fraction given by AdjustDistance. This means that the model bounds is expanded in each of the x-y-z directions.  </li>
<li>
<code>obj.AdjustBoundsOn ()</code> - Control how the model bounds are computed. If the ivar AdjustBounds is set, then the bounds specified (or computed automatically) is modified by the fraction given by AdjustDistance. This means that the model bounds is expanded in each of the x-y-z directions.  </li>
<li>
<code>obj.AdjustBoundsOff ()</code> - Control how the model bounds are computed. If the ivar AdjustBounds is set, then the bounds specified (or computed automatically) is modified by the fraction given by AdjustDistance. This means that the model bounds is expanded in each of the x-y-z directions.  </li>
<li>
<code>obj.SetAdjustDistance (double )</code> - Specify the amount to grow the model bounds (if the ivar AdjustBounds is set). The value is a fraction of the maximum length of the sides of the box specified by the model bounds.  </li>
<li>
<code>double = obj.GetAdjustDistanceMinValue ()</code> - Specify the amount to grow the model bounds (if the ivar AdjustBounds is set). The value is a fraction of the maximum length of the sides of the box specified by the model bounds.  </li>
<li>
<code>double = obj.GetAdjustDistanceMaxValue ()</code> - Specify the amount to grow the model bounds (if the ivar AdjustBounds is set). The value is a fraction of the maximum length of the sides of the box specified by the model bounds.  </li>
<li>
<code>double = obj.GetAdjustDistance ()</code> - Specify the amount to grow the model bounds (if the ivar AdjustBounds is set). The value is a fraction of the maximum length of the sides of the box specified by the model bounds.  </li>
<li>
<code>obj.SetCapping (int )</code> - The outer boundary of the structured point set can be assigned a particular value. This can be used to close or "cap" all surfaces.  </li>
<li>
<code>int = obj.GetCapping ()</code> - The outer boundary of the structured point set can be assigned a particular value. This can be used to close or "cap" all surfaces.  </li>
<li>
<code>obj.CappingOn ()</code> - The outer boundary of the structured point set can be assigned a particular value. This can be used to close or "cap" all surfaces.  </li>
<li>
<code>obj.CappingOff ()</code> - The outer boundary of the structured point set can be assigned a particular value. This can be used to close or "cap" all surfaces.  </li>
<li>
<code>obj.SetCapValue (double value)</code> - Specify the capping value to use. The CapValue is also used as an initial distance value at each point in the dataset.  </li>
<li>
<code>double = obj.GetCapValue ()</code> - Specify the capping value to use. The CapValue is also used as an initial distance value at each point in the dataset.  </li>
<li>
<code>obj.SetScaleToMaximumDistance (int )</code> - If a non-floating output type is specified, the output distances can be scaled to use the entire positive scalar range of the output type specified (up to the CapValue which is equal to the max for the type unless modified by the user). For example, if ScaleToMaximumDistance is On and the OutputScalarType is UnsignedChar the distances saved in the output would be linearly scaled between 0 (for distances "very close" to the surface) and 255 (at the specifed maximum distance)... assuming the CapValue is not changed from 255.  </li>
<li>
<code>int = obj.GetScaleToMaximumDistance ()</code> - If a non-floating output type is specified, the output distances can be scaled to use the entire positive scalar range of the output type specified (up to the CapValue which is equal to the max for the type unless modified by the user). For example, if ScaleToMaximumDistance is On and the OutputScalarType is UnsignedChar the distances saved in the output would be linearly scaled between 0 (for distances "very close" to the surface) and 255 (at the specifed maximum distance)... assuming the CapValue is not changed from 255.  </li>
<li>
<code>obj.ScaleToMaximumDistanceOn ()</code> - If a non-floating output type is specified, the output distances can be scaled to use the entire positive scalar range of the output type specified (up to the CapValue which is equal to the max for the type unless modified by the user). For example, if ScaleToMaximumDistance is On and the OutputScalarType is UnsignedChar the distances saved in the output would be linearly scaled between 0 (for distances "very close" to the surface) and 255 (at the specifed maximum distance)... assuming the CapValue is not changed from 255.  </li>
<li>
<code>obj.ScaleToMaximumDistanceOff ()</code> - If a non-floating output type is specified, the output distances can be scaled to use the entire positive scalar range of the output type specified (up to the CapValue which is equal to the max for the type unless modified by the user). For example, if ScaleToMaximumDistance is On and the OutputScalarType is UnsignedChar the distances saved in the output would be linearly scaled between 0 (for distances "very close" to the surface) and 255 (at the specifed maximum distance)... assuming the CapValue is not changed from 255.  </li>
<li>
<code>obj.SetProcessMode (int )</code> - Specify whether to visit each cell once per append or each voxel once per append. Some tests have shown once per voxel to be faster when there are a lot of cells (at least a thousand?); relative performance improvement increases with addition cells. Primitives should not be stripped for best performance of the voxel mode.  </li>
<li>
<code>int = obj.GetProcessModeMinValue ()</code> - Specify whether to visit each cell once per append or each voxel once per append. Some tests have shown once per voxel to be faster when there are a lot of cells (at least a thousand?); relative performance improvement increases with addition cells. Primitives should not be stripped for best performance of the voxel mode.  </li>
<li>
<code>int = obj.GetProcessModeMaxValue ()</code> - Specify whether to visit each cell once per append or each voxel once per append. Some tests have shown once per voxel to be faster when there are a lot of cells (at least a thousand?); relative performance improvement increases with addition cells. Primitives should not be stripped for best performance of the voxel mode.  </li>
<li>
<code>int = obj.GetProcessMode ()</code> - Specify whether to visit each cell once per append or each voxel once per append. Some tests have shown once per voxel to be faster when there are a lot of cells (at least a thousand?); relative performance improvement increases with addition cells. Primitives should not be stripped for best performance of the voxel mode.  </li>
<li>
<code>obj.SetProcessModeToPerVoxel ()</code> - Specify whether to visit each cell once per append or each voxel once per append. Some tests have shown once per voxel to be faster when there are a lot of cells (at least a thousand?); relative performance improvement increases with addition cells. Primitives should not be stripped for best performance of the voxel mode.  </li>
<li>
<code>obj.SetProcessModeToPerCell ()</code> - Specify whether to visit each cell once per append or each voxel once per append. Some tests have shown once per voxel to be faster when there are a lot of cells (at least a thousand?); relative performance improvement increases with addition cells. Primitives should not be stripped for best performance of the voxel mode.  </li>
<li>
<code>string = obj.GetProcessModeAsString (void )</code> - Specify whether to visit each cell once per append or each voxel once per append. Some tests have shown once per voxel to be faster when there are a lot of cells (at least a thousand?); relative performance improvement increases with addition cells. Primitives should not be stripped for best performance of the voxel mode.  </li>
<li>
<code>obj.SetLocatorMaxLevel (int )</code> - Specify the level of the locator to use when using the per voxel process mode.  </li>
<li>
<code>int = obj.GetLocatorMaxLevel ()</code> - Specify the level of the locator to use when using the per voxel process mode.  </li>
<li>
<code>obj.SetNumberOfThreads (int )</code> - Set / Get the number of threads used during Per-Voxel processing mode  </li>
<li>
<code>int = obj.GetNumberOfThreadsMinValue ()</code> - Set / Get the number of threads used during Per-Voxel processing mode  </li>
<li>
<code>int = obj.GetNumberOfThreadsMaxValue ()</code> - Set / Get the number of threads used during Per-Voxel processing mode  </li>
<li>
<code>int = obj.GetNumberOfThreads ()</code> - Set / Get the number of threads used during Per-Voxel processing mode  </li>
<li>
<code>obj.SetOutputScalarType (int type)</code> - Set the desired output scalar type.  </li>
<li>
<code>int = obj.GetOutputScalarType ()</code> - Set the desired output scalar type.  </li>
<li>
<code>obj.SetOutputScalarTypeToFloat ()</code> - Set the desired output scalar type.  </li>
<li>
<code>obj.SetOutputScalarTypeToDouble ()</code> - Set the desired output scalar type.  </li>
<li>
<code>obj.SetOutputScalarTypeToInt ()</code> - Set the desired output scalar type.  </li>
<li>
<code>obj.SetOutputScalarTypeToUnsignedInt ()</code> - Set the desired output scalar type.  </li>
<li>
<code>obj.SetOutputScalarTypeToLong ()</code> - Set the desired output scalar type.  </li>
<li>
<code>obj.SetOutputScalarTypeToUnsignedLong ()</code> - Set the desired output scalar type.  </li>
<li>
<code>obj.SetOutputScalarTypeToShort ()</code> - Set the desired output scalar type.  </li>
<li>
<code>obj.SetOutputScalarTypeToUnsignedShort ()</code> - Set the desired output scalar type.  </li>
<li>
<code>obj.SetOutputScalarTypeToUnsignedChar ()</code> - Set the desired output scalar type.  </li>
<li>
<code>obj.SetOutputScalarTypeToChar ()</code> - Set the desired output scalar type.  </li>
<li>
<code>obj.StartAppend ()</code> - Initialize the filter for appending data. You must invoke the StartAppend() method before doing successive Appends(). It's also a good idea to manually specify the model bounds; otherwise the input bounds for the data will be used.  </li>
<li>
<code>obj.Append (vtkDataSet input)</code> - Append a data set to the existing output. To use this function, you'll have to invoke the StartAppend() method before doing successive appends. It's also a good idea to specify the model bounds; otherwise the input model bounds is used. When you've finished appending, use the EndAppend() method.  </li>
<li>
<code>obj.EndAppend ()</code> - Method completes the append process.  </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkhybrid.html">Visualization Toolkit Hybrid Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:33 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

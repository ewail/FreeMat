<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkLSDynaReader</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkhybrid_vtklsdynareader.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkLSDynaReader </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkhybrid.html">Visualization Toolkit Hybrid Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>This filter reads LS-Dyna databases.</p>
<p>The Set/GetFileName() routines are actually wrappers around the Set/GetDatabaseDirectory() members; the actual filename you choose is irrelevant &ndash; only the directory name is used. This is done in order to accommodate ParaView.</p>
<p>Note that this reader produces 7 output meshes. These meshes are required as several attributes are defined on subsets of the mesh. Below is a list of meshes in the order they are output and an explanation of which attributes are unique to each mesh:</p>
<ul>
<li>solid (3D) elements: number of integration points are different than 2D</li>
<li>thick shell elements: number of integration points are different than planar 2D</li>
<li>shell (2D) elements: number of integration points are different than 3D</li>
<li>rigid surfaces: can't have deflection, only velocity, accel, etc.</li>
<li>road surfaces: have only a "segment ID" (serves as material ID) and a velocity.</li>
<li>beam elements: have Frenet (TNB) frame and cross-section attributes (shape and size)</li>
<li>spherical particle hydrodynamics (SPH) elements: have a radius of influence, internal energy, etc. Because each mesh has its own cell attributes, the vtkLSDynaReader has a rather large API. Instead of a single set of routines to query and set cell array names and status, one exists for each possible output mesh. Also, GetNumberOfCells() will return the sum of all the cells in all 7 meshes. If you want the number of cells in a specific mesh, there are separate routines for each mesh type.</li>
</ul>
<p>.SECTION "Developer Notes"</p>
<p>To create an instance of class vtkLSDynaReader, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkLSDynaReader
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkLSDynaReader has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkLSDynaReader class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkLSDynaReader = obj.NewInstance ()</code>  </li>
<li>
<code>vtkLSDynaReader = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>obj.DebugDump ()</code> - A routine to call Dump() from within a lame debugger that won't properly pass a C++ iostream object like cout.  </li>
<li>
<code>int = obj.CanReadFile (string fname)</code> - Determine if the file can be readed with this reader.  </li>
<li>
<code>obj.SetDatabaseDirectory (string )</code> - Get/Set the directory containing the LS-Dyna database and determine whether it is valid.  </li>
<li>
<code>string = obj.GetDatabaseDirectory ()</code> - Get/Set the directory containing the LS-Dyna database and determine whether it is valid.  </li>
<li>
<code>int = obj.IsDatabaseValid ()</code> - Get/Set the directory containing the LS-Dyna database and determine whether it is valid.  </li>
<li>
<code>obj.SetFileName (string )</code> - Get/Set the filename. The Set/GetFileName() routines are actually wrappers around the Set/GetDatabaseDirectory() members; the actual filename you choose is irrelevant &ndash; only the directory name is used. This is done in order to accommodate ParaView.  </li>
<li>
<code>string = obj.GetFileName ()</code> - Get/Set the filename. The Set/GetFileName() routines are actually wrappers around the Set/GetDatabaseDirectory() members; the actual filename you choose is irrelevant &ndash; only the directory name is used. This is done in order to accommodate ParaView.  </li>
<li>
<code>string = obj.GetTitle ()</code> - The title of the database is a 40 or 80 character text description stored at the front of a d3plot file. Do not call this function before setting the database directory and calling UpdateInformation().  </li>
<li>
<code>int = obj.GetDimensionality ()</code> - Retrieve the dimension of points in the database. This should return 2 or 3. Do not call this function before setting the database directory and calling UpdateInformation().  </li>
<li>
<code>vtkIdType = obj.GetNumberOfNodes ()</code> - Retrieve the number of points in the database. Do not call this function before setting the database directory and calling UpdateInformation().  </li>
<li>
<p class="startli"><code>vtkIdType = obj.GetNumberOfCells ()</code> - Retrieve the number of cells of a given type in the database. Do not call this function before setting the database directory and calling UpdateInformation().</p>
<p class="endli">Note that GetNumberOfCells() returns the sum of GetNumberOfContinuumCells() and GetNumberOfParticleCells().  </p>
</li>
<li>
<p class="startli"><code>vtkIdType = obj.GetNumberOfContinuumCells ()</code> - Retrieve the number of cells of a given type in the database. Do not call this function before setting the database directory and calling UpdateInformation().</p>
<p class="endli">Note that GetNumberOfContinuumCells() returns the sum of GetNumberOfSolidCells(), GetNumberOfThickShellCells(), GetNumberOfShellCells(), GetNumberOfRigidBodyCells(), GetNumberOfRoadSurfaceCells(), and GetNumberOfBeamCells().  </p>
</li>
<li>
<code>vtkIdType = obj.GetNumberOfSolidCells ()</code> - Retrieve the number of cells of a given type in the database. Do not call this function before setting the database directory and calling UpdateInformation().  </li>
<li>
<code>vtkIdType = obj.GetNumberOfThickShellCells ()</code> - Retrieve the number of cells of a given type in the database. Do not call this function before setting the database directory and calling UpdateInformation().  </li>
<li>
<code>vtkIdType = obj.GetNumberOfShellCells ()</code> - Retrieve the number of cells of a given type in the database. Do not call this function before setting the database directory and calling UpdateInformation().  </li>
<li>
<code>vtkIdType = obj.GetNumberOfRigidBodyCells ()</code> - Retrieve the number of cells of a given type in the database. Do not call this function before setting the database directory and calling UpdateInformation().  </li>
<li>
<code>vtkIdType = obj.GetNumberOfRoadSurfaceCells ()</code> - Retrieve the number of cells of a given type in the database. Do not call this function before setting the database directory and calling UpdateInformation().  </li>
<li>
<code>vtkIdType = obj.GetNumberOfBeamCells ()</code> - Retrieve the number of cells of a given type in the database. Do not call this function before setting the database directory and calling UpdateInformation().  </li>
<li>
<code>vtkIdType = obj.GetNumberOfParticleCells ()</code> - Retrieve the number of cells of a given type in the database. Do not call this function before setting the database directory and calling UpdateInformation().  </li>
<li>
<code>vtkIdType = obj.GetNumberOfTimeSteps ()</code> - Retrieve information about the time extents of the LS-Dyna database. Do not call these functions before setting the database directory and calling UpdateInformation().  </li>
<li>
<code>obj.SetTimeStep (vtkIdType )</code> - Retrieve information about the time extents of the LS-Dyna database. Do not call these functions before setting the database directory and calling UpdateInformation().  </li>
<li>
<code>vtkIdType = obj.GetTimeStep ()</code> - Retrieve information about the time extents of the LS-Dyna database. Do not call these functions before setting the database directory and calling UpdateInformation().  </li>
<li>
<code>double = obj.GetTimeValue (vtkIdType )</code> - Retrieve information about the time extents of the LS-Dyna database. Do not call these functions before setting the database directory and calling UpdateInformation().  </li>
<li>
<code>int = obj. GetTimeStepRange ()</code> - Retrieve information about the time extents of the LS-Dyna database. Do not call these functions before setting the database directory and calling UpdateInformation().  </li>
<li>
<code>obj.SetTimeStepRange (int , int )</code> - Retrieve information about the time extents of the LS-Dyna database. Do not call these functions before setting the database directory and calling UpdateInformation().  </li>
<li>
<code>obj.SetTimeStepRange (int a[2])</code> - Retrieve information about the time extents of the LS-Dyna database. Do not call these functions before setting the database directory and calling UpdateInformation().  </li>
<li>
<code>int = obj.GetNumberOfPointArrays ()</code> - These methods allow you to load only selected subsets of the nodal variables defined over the mesh.  </li>
<li>
<code>string = obj.GetPointArrayName (int )</code> - These methods allow you to load only selected subsets of the nodal variables defined over the mesh.  </li>
<li>
<code>obj.SetPointArrayStatus (int arr, int status)</code> - These methods allow you to load only selected subsets of the nodal variables defined over the mesh.  </li>
<li>
<code>obj.SetPointArrayStatus (string arrName, int status)</code> - These methods allow you to load only selected subsets of the nodal variables defined over the mesh.  </li>
<li>
<code>int = obj.GetPointArrayStatus (int arr)</code> - These methods allow you to load only selected subsets of the nodal variables defined over the mesh.  </li>
<li>
<code>int = obj.GetPointArrayStatus (string arrName)</code> - These methods allow you to load only selected subsets of the nodal variables defined over the mesh.  </li>
<li>
<code>int = obj.GetNumberOfComponentsInPointArray (int arr)</code> - These methods allow you to load only selected subsets of the nodal variables defined over the mesh.  </li>
<li>
<code>int = obj.GetNumberOfComponentsInPointArray (string arrName)</code> - These methods allow you to load only selected subsets of the nodal variables defined over the mesh.  </li>
<li>
<code>int = obj.GetNumberOfCellArrays (int cellType)</code> - Routines that allow the status of a cell variable to be adjusted or queried independent of the output mesh. The <em>cellType</em> parameter should be one of: LS_POINT, LS_BEAM, LS_SHELL, LS_THICK_SHELL, LS_SOLID, LS_RIGID_BODY, or LS_ROAD_SURFACE  </li>
<li>
<code>string = obj.GetCellArrayName (int cellType, int arr)</code> - Routines that allow the status of a cell variable to be adjusted or queried independent of the output mesh. The <em>cellType</em> parameter should be one of: LS_POINT, LS_BEAM, LS_SHELL, LS_THICK_SHELL, LS_SOLID, LS_RIGID_BODY, or LS_ROAD_SURFACE  </li>
<li>
<code>obj.SetCellArrayStatus (int cellType, int arr, int status)</code> - Routines that allow the status of a cell variable to be adjusted or queried independent of the output mesh. The <em>cellType</em> parameter should be one of: LS_POINT, LS_BEAM, LS_SHELL, LS_THICK_SHELL, LS_SOLID, LS_RIGID_BODY, or LS_ROAD_SURFACE  </li>
<li>
<code>obj.SetCellArrayStatus (int cellType, string arrName, int status)</code> - Routines that allow the status of a cell variable to be adjusted or queried independent of the output mesh. The <em>cellType</em> parameter should be one of: LS_POINT, LS_BEAM, LS_SHELL, LS_THICK_SHELL, LS_SOLID, LS_RIGID_BODY, or LS_ROAD_SURFACE  </li>
<li>
<code>int = obj.GetCellArrayStatus (int cellType, int arr)</code> - Routines that allow the status of a cell variable to be adjusted or queried independent of the output mesh. The <em>cellType</em> parameter should be one of: LS_POINT, LS_BEAM, LS_SHELL, LS_THICK_SHELL, LS_SOLID, LS_RIGID_BODY, or LS_ROAD_SURFACE  </li>
<li>
<code>int = obj.GetCellArrayStatus (int cellType, string arrName)</code> - Routines that allow the status of a cell variable to be adjusted or queried independent of the output mesh. The <em>cellType</em> parameter should be one of: LS_POINT, LS_BEAM, LS_SHELL, LS_THICK_SHELL, LS_SOLID, LS_RIGID_BODY, or LS_ROAD_SURFACE  </li>
<li>
<code>int = obj.GetNumberOfComponentsInCellArray (int cellType, int arr)</code> - Routines that allow the status of a cell variable to be adjusted or queried independent of the output mesh. The <em>cellType</em> parameter should be one of: LS_POINT, LS_BEAM, LS_SHELL, LS_THICK_SHELL, LS_SOLID, LS_RIGID_BODY, or LS_ROAD_SURFACE  </li>
<li>
<code>int = obj.GetNumberOfComponentsInCellArray (int cellType, string arrName)</code> - Routines that allow the status of a cell variable to be adjusted or queried independent of the output mesh. The <em>cellType</em> parameter should be one of: LS_POINT, LS_BEAM, LS_SHELL, LS_THICK_SHELL, LS_SOLID, LS_RIGID_BODY, or LS_ROAD_SURFACE  </li>
<li>
<code>int = obj.GetNumberOfSolidArrays ()</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>string = obj.GetSolidArrayName (int )</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>obj.SetSolidArrayStatus (int arr, int status)</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>obj.SetSolidArrayStatus (string arrName, int status)</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>int = obj.GetSolidArrayStatus (int arr)</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>int = obj.GetSolidArrayStatus (string arrName)</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>int = obj.GetNumberOfComponentsInSolidArray (int a)</code>  </li>
<li>
<code>int = obj.GetNumberOfComponentsInSolidArray (string arrName)</code>  </li>
<li>
<code>int = obj.GetNumberOfThickShellArrays ()</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>string = obj.GetThickShellArrayName (int )</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>obj.SetThickShellArrayStatus (int arr, int status)</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>obj.SetThickShellArrayStatus (string arrName, int status)</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>int = obj.GetThickShellArrayStatus (int arr)</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>int = obj.GetThickShellArrayStatus (string arrName)</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>int = obj.GetNumberOfComponentsInThickShellArray (int a)</code>  </li>
<li>
<code>int = obj.GetNumberOfComponentsInThickShellArray (string arrName)</code>  </li>
<li>
<code>int = obj.GetNumberOfShellArrays ()</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>string = obj.GetShellArrayName (int )</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>obj.SetShellArrayStatus (int arr, int status)</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>obj.SetShellArrayStatus (string arrName, int status)</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>int = obj.GetShellArrayStatus (int arr)</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>int = obj.GetShellArrayStatus (string arrName)</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>int = obj.GetNumberOfComponentsInShellArray (int a)</code>  </li>
<li>
<code>int = obj.GetNumberOfComponentsInShellArray (string arrName)</code>  </li>
<li>
<code>int = obj.GetNumberOfRigidBodyArrays ()</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>string = obj.GetRigidBodyArrayName (int )</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>obj.SetRigidBodyArrayStatus (int arr, int status)</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>obj.SetRigidBodyArrayStatus (string arrName, int status)</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>int = obj.GetRigidBodyArrayStatus (int arr)</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>int = obj.GetRigidBodyArrayStatus (string arrName)</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>int = obj.GetNumberOfComponentsInRigidBodyArray (int a)</code>  </li>
<li>
<code>int = obj.GetNumberOfComponentsInRigidBodyArray (string arrName)</code>  </li>
<li>
<code>int = obj.GetNumberOfRoadSurfaceArrays ()</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>string = obj.GetRoadSurfaceArrayName (int )</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>obj.SetRoadSurfaceArrayStatus (int arr, int status)</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>obj.SetRoadSurfaceArrayStatus (string arrName, int status)</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>int = obj.GetRoadSurfaceArrayStatus (int arr)</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>int = obj.GetRoadSurfaceArrayStatus (string arrName)</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>int = obj.GetNumberOfComponentsInRoadSurfaceArray (int a)</code>  </li>
<li>
<code>int = obj.GetNumberOfComponentsInRoadSurfaceArray (string arrName)</code>  </li>
<li>
<code>int = obj.GetNumberOfBeamArrays ()</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>string = obj.GetBeamArrayName (int )</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>obj.SetBeamArrayStatus (int arr, int status)</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>obj.SetBeamArrayStatus (string arrName, int status)</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>int = obj.GetBeamArrayStatus (int arr)</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>int = obj.GetBeamArrayStatus (string arrName)</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>int = obj.GetNumberOfComponentsInBeamArray (int a)</code>  </li>
<li>
<code>int = obj.GetNumberOfComponentsInBeamArray (string arrName)</code>  </li>
<li>
<code>int = obj.GetNumberOfParticleArrays ()</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>string = obj.GetParticleArrayName (int )</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>obj.SetParticleArrayStatus (int arr, int status)</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>obj.SetParticleArrayStatus (string arrName, int status)</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>int = obj.GetParticleArrayStatus (int arr)</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>int = obj.GetParticleArrayStatus (string arrName)</code> - These methods allow you to load only selected subsets of the cell variables defined over the mesh.  </li>
<li>
<code>int = obj.GetNumberOfComponentsInParticleArray (int a)</code>  </li>
<li>
<code>int = obj.GetNumberOfComponentsInParticleArray (string arrName)</code>  </li>
<li>
<code>obj.SetDeformedMesh (int )</code> - Should deflected coordinates be used, or should the mesh remain undeflected? By default, this is true but its value is ignored if the nodal "Deflection" array is not set to be loaded.  </li>
<li>
<code>int = obj.GetDeformedMesh ()</code> - Should deflected coordinates be used, or should the mesh remain undeflected? By default, this is true but its value is ignored if the nodal "Deflection" array is not set to be loaded.  </li>
<li>
<code>obj.DeformedMeshOn ()</code> - Should deflected coordinates be used, or should the mesh remain undeflected? By default, this is true but its value is ignored if the nodal "Deflection" array is not set to be loaded.  </li>
<li>
<code>obj.DeformedMeshOff ()</code> - Should deflected coordinates be used, or should the mesh remain undeflected? By default, this is true but its value is ignored if the nodal "Deflection" array is not set to be loaded.  </li>
<li>
<code>obj.SetRemoveDeletedCells (int )</code> - Should dead cells be removed from the mesh? Cells are marked dead by setting the corresponding entry in the <b>cell</b> array "Death" to 0. Cells that are not dead have the corresponding entry in the cell array "Death" set to their material ID. By default, this is true but its value is ignored if the cell "Death" array is not set to be loaded. It is also ignored if the database's element deletion option is set to denote <b>points</b> (not cells) as deleted; in that case, "Death" will appear to be a point array.  </li>
<li>
<code>int = obj.GetRemoveDeletedCells ()</code> - Should dead cells be removed from the mesh? Cells are marked dead by setting the corresponding entry in the <b>cell</b> array "Death" to 0. Cells that are not dead have the corresponding entry in the cell array "Death" set to their material ID. By default, this is true but its value is ignored if the cell "Death" array is not set to be loaded. It is also ignored if the database's element deletion option is set to denote <b>points</b> (not cells) as deleted; in that case, "Death" will appear to be a point array.  </li>
<li>
<code>obj.RemoveDeletedCellsOn ()</code> - Should dead cells be removed from the mesh? Cells are marked dead by setting the corresponding entry in the <b>cell</b> array "Death" to 0. Cells that are not dead have the corresponding entry in the cell array "Death" set to their material ID. By default, this is true but its value is ignored if the cell "Death" array is not set to be loaded. It is also ignored if the database's element deletion option is set to denote <b>points</b> (not cells) as deleted; in that case, "Death" will appear to be a point array.  </li>
<li>
<code>obj.RemoveDeletedCellsOff ()</code> - Should dead cells be removed from the mesh? Cells are marked dead by setting the corresponding entry in the <b>cell</b> array "Death" to 0. Cells that are not dead have the corresponding entry in the cell array "Death" set to their material ID. By default, this is true but its value is ignored if the cell "Death" array is not set to be loaded. It is also ignored if the database's element deletion option is set to denote <b>points</b> (not cells) as deleted; in that case, "Death" will appear to be a point array.  </li>
<li>
<code>obj.SetSplitByMaterialId (int )</code> - Split each part into submeshes based on material ID. By default, this is false and all cells of a given type (solid, thick shell, shell, ...) are in a single mesh.  </li>
<li>
<code>int = obj.GetSplitByMaterialId ()</code> - Split each part into submeshes based on material ID. By default, this is false and all cells of a given type (solid, thick shell, shell, ...) are in a single mesh.  </li>
<li>
<code>obj.SplitByMaterialIdOn ()</code> - Split each part into submeshes based on material ID. By default, this is false and all cells of a given type (solid, thick shell, shell, ...) are in a single mesh.  </li>
<li>
<code>obj.SplitByMaterialIdOff ()</code> - Split each part into submeshes based on material ID. By default, this is false and all cells of a given type (solid, thick shell, shell, ...) are in a single mesh.  </li>
<li>
<code>obj.SetInputDeck (string )</code> - The name of the input deck corresponding to the current database. This is used to determine the part names associated with each material ID. This file may be in two formats: a valid LSDyna input deck or a short XML summary. If the file begins with "&lt;?xml" then the summary format is used. Otherwise, the keyword format is used and a summary file will be created if write permissions exist in the directory containing the keyword file. The newly created summary will have ".k" or ".key" stripped from the end of the keyword filename and ".lsdyna" appended.  </li>
<li>
<code>string = obj.GetInputDeck ()</code> - The name of the input deck corresponding to the current database. This is used to determine the part names associated with each material ID. This file may be in two formats: a valid LSDyna input deck or a short XML summary. If the file begins with "&lt;?xml" then the summary format is used. Otherwise, the keyword format is used and a summary file will be created if write permissions exist in the directory containing the keyword file. The newly created summary will have ".k" or ".key" stripped from the end of the keyword filename and ".lsdyna" appended.  </li>
<li>
<code>int = obj.GetNumberOfPartArrays ()</code> - These methods allow you to load only selected parts of the input. If InputDeck points to a valid keyword file (or summary), then part names will be taken from that file. Otherwise, when arbitrary material numbering is used, parts will be named "PartXXX (MatlYYY)" where XXX is an increasing sequential number and YYY is the respective material ID. If no input deck is specified and arbitrary arbitrary material numbering is not used, parts will be named "PartXXX" where XXX is a sequential material ID.  </li>
<li>
<code>string = obj.GetPartArrayName (int )</code> - These methods allow you to load only selected parts of the input. If InputDeck points to a valid keyword file (or summary), then part names will be taken from that file. Otherwise, when arbitrary material numbering is used, parts will be named "PartXXX (MatlYYY)" where XXX is an increasing sequential number and YYY is the respective material ID. If no input deck is specified and arbitrary arbitrary material numbering is not used, parts will be named "PartXXX" where XXX is a sequential material ID.  </li>
<li>
<code>obj.SetPartArrayStatus (int arr, int status)</code> - These methods allow you to load only selected parts of the input. If InputDeck points to a valid keyword file (or summary), then part names will be taken from that file. Otherwise, when arbitrary material numbering is used, parts will be named "PartXXX (MatlYYY)" where XXX is an increasing sequential number and YYY is the respective material ID. If no input deck is specified and arbitrary arbitrary material numbering is not used, parts will be named "PartXXX" where XXX is a sequential material ID.  </li>
<li>
<code>obj.SetPartArrayStatus (string partName, int status)</code> - These methods allow you to load only selected parts of the input. If InputDeck points to a valid keyword file (or summary), then part names will be taken from that file. Otherwise, when arbitrary material numbering is used, parts will be named "PartXXX (MatlYYY)" where XXX is an increasing sequential number and YYY is the respective material ID. If no input deck is specified and arbitrary arbitrary material numbering is not used, parts will be named "PartXXX" where XXX is a sequential material ID.  </li>
<li>
<code>int = obj.GetPartArrayStatus (int arr)</code> - These methods allow you to load only selected parts of the input. If InputDeck points to a valid keyword file (or summary), then part names will be taken from that file. Otherwise, when arbitrary material numbering is used, parts will be named "PartXXX (MatlYYY)" where XXX is an increasing sequential number and YYY is the respective material ID. If no input deck is specified and arbitrary arbitrary material numbering is not used, parts will be named "PartXXX" where XXX is a sequential material ID.  </li>
<li>
<code>int = obj.GetPartArrayStatus (string partName)</code> - These methods allow you to load only selected parts of the input. If InputDeck points to a valid keyword file (or summary), then part names will be taken from that file. Otherwise, when arbitrary material numbering is used, parts will be named "PartXXX (MatlYYY)" where XXX is an increasing sequential number and YYY is the respective material ID. If no input deck is specified and arbitrary arbitrary material numbering is not used, parts will be named "PartXXX" where XXX is a sequential material ID.  </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkhybrid.html">Visualization Toolkit Hybrid Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:33 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkGraph</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkfiltering_vtkgraph.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkGraph </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkfiltering.html">Visualization Toolkit Filtering Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>vtkGraph is the abstract base class that provides all read-only API for graph data types. A graph consists of a collection of vertices and a collection of edges connecting pairs of vertices. The vtkDirectedGraph subclass represents a graph whose edges have inherent order from source vertex to target vertex, while vtkUndirectedGraph is a graph whose edges have no inherent ordering.</p>
<p>Graph vertices may be traversed in two ways. In the current implementation, all vertices are assigned consecutive ids starting at zero, so they may be traversed in a simple for loop from 0 to graph-&gt;GetNumberOfVertices() - 1. You may alternately create a vtkVertexListIterator and call graph-&gt;GetVertices(it). it-&gt;Next() will return the id of the next vertex, while it-&gt;HasNext() indicates whether there are more vertices in the graph. This is the preferred method, since in the future graphs may support filtering or subsetting where the vertex ids may not be contiguous.</p>
<p>Graph edges must be traversed through iterators. To traverse all edges in a graph, create an instance of vtkEdgeListIterator and call graph-&gt;GetEdges(it). it-&gt;Next() returns lightweight vtkEdgeType structures, which contain the public fields Id, Source and Target. Id is the identifier for the edge, which may be used to look up values in assiciated edge data arrays. Source and Target store the ids of the source and target vertices of the edge. Note that the edge list iterator DOES NOT necessarily iterate over edges in order of ascending id. To traverse edges from wrapper code (Python, Tcl, Java), use it-&gt;NextGraphEdge() instead of it-&gt;Next(). This will return a heavyweight, wrappable vtkGraphEdge object, which has the same fields as vtkEdgeType accessible through getter methods.</p>
<p>To traverse all edges outgoing from a vertex, create a vtkOutEdgeIterator and call graph-&gt;GetOutEdges(v, it). it-&gt;Next() returns a lightweight vtkOutEdgeType containing the fields Id and Target. The source of the edge is always the vertex that was passed as an argument to GetOutEdges(). Incoming edges may be similarly traversed with vtkInEdgeIterator, which returns vtkInEdgeType structures with Id and Source fields. Both vtkOutEdgeIterator and vtkInEdgeIterator also provide the wrapper functions NextGraphEdge() which return vtkGraphEdge objects.</p>
<p>An additional iterator, vtkAdjacentVertexIterator can traverse outgoing vertices directly, instead needing to parse through edges. Initialize the iterator by calling graph-&gt;GetAdjacentVertices(v, it).</p>
<p>vtkGraph has two instances of vtkDataSetAttributes for associated vertex and edge data. It also has a vtkPoints instance which may store x,y,z locations for each vertex. This is populated by filters such as vtkGraphLayout and vtkAssignCoordinates.</p>
<p>All graph types share the same implementation, so the structure of one may be shared among multiple graphs, even graphs of different types. Structures from vtkUndirectedGraph and vtkMutableUndirectedGraph may be shared directly. Structures from vtkDirectedGraph, vtkMutableDirectedGraph, and vtkTree may be shared directly with the exception that setting a structure to a tree requires that a "is a tree" test passes.</p>
<p>For graph types that are known to be compatible, calling ShallowCopy() or DeepCopy() will work as expected. When the outcome of a conversion is unknown (i.e. setting a graph to a tree), CheckedShallowCopy() and CheckedDeepCopy() exist which are identical to ShallowCopy() and DeepCopy(), except that instead of emitting an error for an incompatible structure, the function returns false. This allows you to programmatically check structure compatibility without causing error messages.</p>
<p>To construct a graph, use vtkMutableDirectedGraph or vtkMutableUndirectedGraph. You may then use CheckedShallowCopy to set the contents of a mutable graph type into one of the non-mutable types vtkDirectedGraph, vtkUndirectedGraph. To construct a tree, use vtkMutableDirectedGraph, with directed edges which point from the parent to the child, then use CheckedShallowCopy to set the structure to a vtkTree.</p>
<p>To create an instance of class vtkGraph, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkGraph
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkGraph has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkGraph class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkGraph = obj.NewInstance ()</code>  </li>
<li>
<code>vtkGraph = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>vtkDataSetAttributes = obj.GetVertexData ()</code> - Get the vertex or edge data.  </li>
<li>
<code>vtkDataSetAttributes = obj.GetEdgeData ()</code> - Get the vertex or edge data.  </li>
<li>
<code>int = obj.GetDataObjectType ()</code> - Initialize to an empty graph.  </li>
<li>
<code>obj.Initialize ()</code> - Initialize to an empty graph.  </li>
<li>
<code>obj.GetPoint (vtkIdType ptId, double x[3])</code> - These methods return the point (0,0,0) until the points structure is created, when it returns the actual point position. In a distributed graph, only the points for local vertices can be retrieved.  </li>
<li>
<code>vtkPoints = obj.GetPoints ()</code> - Returns the points array for this graph. If points is not yet constructed, generates and returns a new points array filled with (0,0,0) coordinates. In a distributed graph, only the points for local vertices can be retrieved or modified.  </li>
<li>
<code>obj.SetPoints (vtkPoints points)</code> - Returns the points array for this graph. If points is not yet constructed, generates and returns a new points array filled with (0,0,0) coordinates. In a distributed graph, only the points for local vertices can be retrieved or modified.  </li>
<li>
<code>obj.ComputeBounds ()</code> - Compute the bounds of the graph. In a distributed graph, this computes the bounds around the local part of the graph.  </li>
<li>
<code>obj.GetBounds (double bounds[6])</code> - Return a pointer to the geometry bounding box in the form (xmin,xmax, ymin,ymax, zmin,zmax). In a distributed graph, this computes the bounds around the local part of the graph.  </li>
<li>
<code>long = obj.GetMTime ()</code> - The modified time of the graph.  </li>
<li>
<code>obj.GetOutEdges (vtkIdType v, vtkOutEdgeIterator it)</code> - Initializes the out edge iterator to iterate over all outgoing edges of vertex v. For an undirected graph, returns all incident edges. In a distributed graph, the vertex v must be local to this processor.  </li>
<li>
<code>vtkIdType = obj.GetDegree (vtkIdType v)</code> - The total of all incoming and outgoing vertices for vertex v. For undirected graphs, this is simply the number of edges incident to v. In a distributed graph, the vertex v must be local to this processor.  </li>
<li>
<code>vtkIdType = obj.GetOutDegree (vtkIdType v)</code> - The number of outgoing edges from vertex v. For undirected graphs, returns the same as GetDegree(). In a distributed graph, the vertex v must be local to this processor.  </li>
<li>
<code>obj.GetOutEdge (vtkIdType v, vtkIdType index, vtkGraphEdge e)</code> - Random-access method for retrieving outgoing edges from vertex v. The method fills the vtkGraphEdge instance with the id, source, and target of the edge. This method is provided for wrappers, GetOutEdge(vtkIdType, vtkIdType) is preferred.  </li>
<li>
<code>obj.GetInEdges (vtkIdType v, vtkInEdgeIterator it)</code> - Initializes the in edge iterator to iterate over all incoming edges to vertex v. For an undirected graph, returns all incident edges. In a distributed graph, the vertex v must be local to this processor.  </li>
<li>
<code>vtkIdType = obj.GetInDegree (vtkIdType v)</code> - The number of incoming edges to vertex v. For undirected graphs, returns the same as GetDegree(). In a distributed graph, the vertex v must be local to this processor.  </li>
<li>
<code>obj.GetInEdge (vtkIdType v, vtkIdType index, vtkGraphEdge e)</code> - Random-access method for retrieving incoming edges to vertex v. The method fills the vtkGraphEdge instance with the id, source, and target of the edge. This method is provided for wrappers, GetInEdge(vtkIdType, vtkIdType) is preferred.  </li>
<li>
<code>obj.GetAdjacentVertices (vtkIdType v, vtkAdjacentVertexIterator it)</code> - Initializes the adjacent vertex iterator to iterate over all outgoing vertices from vertex v. For an undirected graph, returns all adjacent vertices. In a distributed graph, the vertex v must be local to this processor.  </li>
<li>
<code>obj.GetEdges (vtkEdgeListIterator it)</code> - Initializes the edge list iterator to iterate over all edges in the graph. Edges may not be traversed in order of increasing edge id. In a distributed graph, this returns edges that are stored locally.  </li>
<li>
<code>vtkIdType = obj.GetNumberOfEdges ()</code> - The number of edges in the graph. In a distributed graph, this returns the number of edges stored locally.  </li>
<li>
<code>obj.GetVertices (vtkVertexListIterator it)</code> - Initializes the vertex list iterator to iterate over all vertices in the graph. In a distributed graph, the iterator traverses all local vertices.  </li>
<li>
<code>vtkIdType = obj.GetNumberOfVertices ()</code> - The number of vertices in the graph. In a distributed graph, returns the number of local vertices in the graph.  </li>
<li>
<code>obj.SetDistributedGraphHelper (vtkDistributedGraphHelper helper)</code> - Sets the distributed graph helper of this graph, turning it into a distributed graph. This operation can only be executed on an empty graph.  </li>
<li>
<code>vtkDistributedGraphHelper = obj.GetDistributedGraphHelper ()</code> - Retrieves the distributed graph helper for this graph  </li>
<li>
<code>obj.ShallowCopy (vtkDataObject obj)</code> - Shallow copies the data object into this graph. If it is an incompatible graph, reports an error.  </li>
<li>
<code>obj.DeepCopy (vtkDataObject obj)</code> - Deep copies the data object into this graph. If it is an incompatible graph, reports an error.  </li>
<li>
<code>obj.CopyStructure (vtkGraph g)</code> - Does a shallow copy of the topological information, but not the associated attributes.  </li>
<li>
<code>bool = obj.CheckedShallowCopy (vtkGraph g)</code> - Performs the same operation as ShallowCopy(), but instead of reporting an error for an incompatible graph, returns false.  </li>
<li>
<code>bool = obj.CheckedDeepCopy (vtkGraph g)</code> - Performs the same operation as DeepCopy(), but instead of reporting an error for an incompatible graph, returns false.  </li>
<li>
<code>obj.Squeeze ()</code>  </li>
<li>
<code>obj.ReorderOutVertices (vtkIdType v, vtkIdTypeArray vertices)</code> - Reorder the outgoing vertices of a vertex. The vertex list must have the same elements as the current out edge list, just in a different order. This method does not change the topology of the graph. In a distributed graph, the vertex v must be local.  </li>
<li>
<code>bool = obj.IsSameStructure (vtkGraph other)</code> - Returns true if both graphs point to the same adjacency structure. Can be used to test the copy-on-write feature of the graph.  </li>
<li>
<code>vtkIdType = obj.GetSourceVertex (vtkIdType e)</code> - Retrieve the source and target vertices for an edge id. NOTE: The first time this is called, the graph will build a mapping array from edge id to source/target that is the same size as the number of edges in the graph. If you have access to a vtkOutEdgeType, vtkInEdgeType, vtkEdgeType, or vtkGraphEdge, you should directly use these structures to look up the source or target instead of this method.  </li>
<li>
<code>vtkIdType = obj.GetTargetVertex (vtkIdType e)</code> - Retrieve the source and target vertices for an edge id. NOTE: The first time this is called, the graph will build a mapping array from edge id to source/target that is the same size as the number of edges in the graph. If you have access to a vtkOutEdgeType, vtkInEdgeType, vtkEdgeType, or vtkGraphEdge, you should directly use these structures to look up the source or target instead of this method.  </li>
<li>
<code>vtkIdType = obj.GetNumberOfEdgePoints (vtkIdType e)</code> - Get the number of edge points associated with an edge.  </li>
<li>
<code>double = obj.GetEdgePoint (vtkIdType e, vtkIdType i)</code> - Get the x,y,z location of a point along edge e.  </li>
<li>
<code>obj.ClearEdgePoints (vtkIdType e)</code> - Clear all points associated with an edge.  </li>
<li>
<code>obj.SetEdgePoint (vtkIdType e, vtkIdType i, double x[3])</code> - Set an x,y,z location of a point along an edge. This assumes there is already a point at location i, and simply overwrites it.  </li>
<li>
<code>obj.SetEdgePoint (vtkIdType e, vtkIdType i, double x, double y, double z)</code> - Adds a point to the end of the list of edge points for a certain edge.  </li>
<li>
<code>obj.AddEdgePoint (vtkIdType e, double x[3])</code> - Adds a point to the end of the list of edge points for a certain edge.  </li>
<li>
<code>obj.AddEdgePoint (vtkIdType e, double x, double y, double z)</code> - Copy the internal edge point data from another graph into this graph. Both graphs must have the same number of edges.  </li>
<li>
<code>obj.ShallowCopyEdgePoints (vtkGraph g)</code> - Copy the internal edge point data from another graph into this graph. Both graphs must have the same number of edges.  </li>
<li>
<code>obj.DeepCopyEdgePoints (vtkGraph g)</code> - Copy the internal edge point data from another graph into this graph. Both graphs must have the same number of edges.  </li>
<li>
<code>vtkGraphInternals = obj.GetGraphInternals (bool modifying)</code> - Returns the internal representation of the graph. If modifying is true, then the returned vtkGraphInternals object will be unique to this vtkGraph object.  </li>
<li>
<code>obj.GetInducedEdges (vtkIdTypeArray verts, vtkIdTypeArray edges)</code> - Fills a list of edge indices with the edges contained in the induced subgraph formed by the vertices in the vertex list.  </li>
<li>
<code>vtkFieldData = obj.GetAttributesAsFieldData (int type)</code> - Returns the attributes of the data object as a vtkFieldData. This returns non-null values in all the same cases as GetAttributes, in addition to the case of FIELD, which will return the field data for any vtkDataObject subclass.  </li>
<li>
<code>vtkIdType = obj.GetNumberOfElements (int type)</code> - Get the number of elements for a specific attribute type (VERTEX, EDGE, etc.).  </li>
<li>
<code>obj.Dump ()</code> - Dump the contents of the graph to standard output.  </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkfiltering.html">Visualization Toolkit Filtering Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:30 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkWidgetRepresentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkwidgets_vtkwidgetrepresentation.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkWidgetRepresentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkwidgets.html">Visualization Toolkit Widget Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>This class is used to define the API for, and partially implement, a representation for different types of widgets. Note that the widget representation (i.e., subclasses of vtkWidgetRepresentation) are a type of vtkProp; meaning that they can be associated with a vtkRenderer end embedded in a scene like any other vtkActor. However, vtkWidgetRepresentation also defines an API that enables it to be paired with a subclass vtkAbstractWidget, meaning that it can be driven by a widget, serving to represent the widget as the widget responds to registered events.</p>
<p>The API defined here should be regarded as a guideline for implementing widgets and widget representations. Widget behavior is complex, as is the way the representation responds to the registered widget events, so the API may vary from widget to widget to reflect this complexity.</p>
<p>To create an instance of class vtkWidgetRepresentation, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkWidgetRepresentation
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkWidgetRepresentation has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkWidgetRepresentation class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code> - Standard methods for instances of this class.  </li>
<li>
<code>int = obj.IsA (string name)</code> - Standard methods for instances of this class.  </li>
<li>
<code>vtkWidgetRepresentation = obj.NewInstance ()</code> - Standard methods for instances of this class.  </li>
<li>
<code>vtkWidgetRepresentation = obj.SafeDownCast (vtkObject o)</code> - Standard methods for instances of this class.  </li>
<li>
<code>obj.SetRenderer (vtkRenderer ren)</code> - Subclasses of vtkWidgetRepresentation must implement these methods. This is considered the minimum API for a widget representation. <pre>
 SetRenderer() - the renderer in which the widget is to appear must be set.
 BuildRepresentation() - update the geometry of the widget based on its
                         current state.
 </pre> WARNING: The renderer is NOT reference counted by the representation, in order to avoid reference loops. Be sure that the representation lifetime does not extend beyond the renderer lifetime.  </li>
<li>
<code>vtkRenderer = obj.GetRenderer ()</code> - Subclasses of vtkWidgetRepresentation must implement these methods. This is considered the minimum API for a widget representation. <pre>
 SetRenderer() - the renderer in which the widget is to appear must be set.
 BuildRepresentation() - update the geometry of the widget based on its
                         current state.
 </pre> WARNING: The renderer is NOT reference counted by the representation, in order to avoid reference loops. Be sure that the representation lifetime does not extend beyond the renderer lifetime.  </li>
<li>
<code>obj.BuildRepresentation ()</code> - Subclasses of vtkWidgetRepresentation must implement these methods. This is considered the minimum API for a widget representation. <pre>
 SetRenderer() - the renderer in which the widget is to appear must be set.
 BuildRepresentation() - update the geometry of the widget based on its
                         current state.
 </pre> WARNING: The renderer is NOT reference counted by the representation, in order to avoid reference loops. Be sure that the representation lifetime does not extend beyond the renderer lifetime.  </li>
<li>
<code>obj.PlaceWidget (double )</code> - The following is a suggested API for widget representations. These methods define the communication between the widget and its representation. These methods are only suggestions because widgets take on so many different forms that a universal API is not deemed practical. However, these methods should be implemented when possible to insure that the VTK widget hierarchy remains self-consistent. <pre>
 PlaceWidget() - given a bounding box (xmin,xmax,ymin,ymax,zmin,zmax), place 
                 the widget inside of it. The current orientation of the widget 
                 is preserved, only scaling and translation is performed.
 StartWidgetInteraction() - generally corresponds to a initial event (e.g.,
                            mouse down) that starts the interaction process
                            with the widget.
 WidgetInteraction() - invoked when an event causes the widget to change 
                       appearance.
 EndWidgetInteraction() - generally corresponds to a final event (e.g., mouse up)
                          and completes the interaction sequence.
 ComputeInteractionState() - given (X,Y) display coordinates in a renderer, with a
                             possible flag that modifies the computation,
                             what is the state of the widget?
 GetInteractionState() - return the current state of the widget. Note that the
                         value of "0" typically refers to "outside". The 
                         interaction state is strictly a function of the
                         representation, and the widget/represent must agree
                         on what they mean.
 Highlight() - turn on or off any highlights associated with the widget.
               Highlights are generally turned on when the widget is selected.
 </pre> Note that subclasses may ignore some of these methods and implement their own depending on the specifics of the widget.  </li>
<li>
<code>obj.StartWidgetInteraction (double eventPos[2])</code> - The following is a suggested API for widget representations. These methods define the communication between the widget and its representation. These methods are only suggestions because widgets take on so many different forms that a universal API is not deemed practical. However, these methods should be implemented when possible to insure that the VTK widget hierarchy remains self-consistent. <pre>
 PlaceWidget() - given a bounding box (xmin,xmax,ymin,ymax,zmin,zmax), place 
                 the widget inside of it. The current orientation of the widget 
                 is preserved, only scaling and translation is performed.
 StartWidgetInteraction() - generally corresponds to a initial event (e.g.,
                            mouse down) that starts the interaction process
                            with the widget.
 WidgetInteraction() - invoked when an event causes the widget to change 
                       appearance.
 EndWidgetInteraction() - generally corresponds to a final event (e.g., mouse up)
                          and completes the interaction sequence.
 ComputeInteractionState() - given (X,Y) display coordinates in a renderer, with a
                             possible flag that modifies the computation,
                             what is the state of the widget?
 GetInteractionState() - return the current state of the widget. Note that the
                         value of "0" typically refers to "outside". The 
                         interaction state is strictly a function of the
                         representation, and the widget/represent must agree
                         on what they mean.
 Highlight() - turn on or off any highlights associated with the widget.
               Highlights are generally turned on when the widget is selected.
 </pre> Note that subclasses may ignore some of these methods and implement their own depending on the specifics of the widget.  </li>
<li>
<code>obj.WidgetInteraction (double newEventPos[2])</code> - The following is a suggested API for widget representations. These methods define the communication between the widget and its representation. These methods are only suggestions because widgets take on so many different forms that a universal API is not deemed practical. However, these methods should be implemented when possible to insure that the VTK widget hierarchy remains self-consistent. <pre>
 PlaceWidget() - given a bounding box (xmin,xmax,ymin,ymax,zmin,zmax), place 
                 the widget inside of it. The current orientation of the widget 
                 is preserved, only scaling and translation is performed.
 StartWidgetInteraction() - generally corresponds to a initial event (e.g.,
                            mouse down) that starts the interaction process
                            with the widget.
 WidgetInteraction() - invoked when an event causes the widget to change 
                       appearance.
 EndWidgetInteraction() - generally corresponds to a final event (e.g., mouse up)
                          and completes the interaction sequence.
 ComputeInteractionState() - given (X,Y) display coordinates in a renderer, with a
                             possible flag that modifies the computation,
                             what is the state of the widget?
 GetInteractionState() - return the current state of the widget. Note that the
                         value of "0" typically refers to "outside". The 
                         interaction state is strictly a function of the
                         representation, and the widget/represent must agree
                         on what they mean.
 Highlight() - turn on or off any highlights associated with the widget.
               Highlights are generally turned on when the widget is selected.
 </pre> Note that subclasses may ignore some of these methods and implement their own depending on the specifics of the widget.  </li>
<li>
<code>obj.EndWidgetInteraction (double newEventPos[2])</code> - The following is a suggested API for widget representations. These methods define the communication between the widget and its representation. These methods are only suggestions because widgets take on so many different forms that a universal API is not deemed practical. However, these methods should be implemented when possible to insure that the VTK widget hierarchy remains self-consistent. <pre>
 PlaceWidget() - given a bounding box (xmin,xmax,ymin,ymax,zmin,zmax), place 
                 the widget inside of it. The current orientation of the widget 
                 is preserved, only scaling and translation is performed.
 StartWidgetInteraction() - generally corresponds to a initial event (e.g.,
                            mouse down) that starts the interaction process
                            with the widget.
 WidgetInteraction() - invoked when an event causes the widget to change 
                       appearance.
 EndWidgetInteraction() - generally corresponds to a final event (e.g., mouse up)
                          and completes the interaction sequence.
 ComputeInteractionState() - given (X,Y) display coordinates in a renderer, with a
                             possible flag that modifies the computation,
                             what is the state of the widget?
 GetInteractionState() - return the current state of the widget. Note that the
                         value of "0" typically refers to "outside". The 
                         interaction state is strictly a function of the
                         representation, and the widget/represent must agree
                         on what they mean.
 Highlight() - turn on or off any highlights associated with the widget.
               Highlights are generally turned on when the widget is selected.
 </pre> Note that subclasses may ignore some of these methods and implement their own depending on the specifics of the widget.  </li>
<li>
<code>int = obj.ComputeInteractionState (int X, int Y, int modify)</code> - The following is a suggested API for widget representations. These methods define the communication between the widget and its representation. These methods are only suggestions because widgets take on so many different forms that a universal API is not deemed practical. However, these methods should be implemented when possible to insure that the VTK widget hierarchy remains self-consistent. <pre>
 PlaceWidget() - given a bounding box (xmin,xmax,ymin,ymax,zmin,zmax), place 
                 the widget inside of it. The current orientation of the widget 
                 is preserved, only scaling and translation is performed.
 StartWidgetInteraction() - generally corresponds to a initial event (e.g.,
                            mouse down) that starts the interaction process
                            with the widget.
 WidgetInteraction() - invoked when an event causes the widget to change 
                       appearance.
 EndWidgetInteraction() - generally corresponds to a final event (e.g., mouse up)
                          and completes the interaction sequence.
 ComputeInteractionState() - given (X,Y) display coordinates in a renderer, with a
                             possible flag that modifies the computation,
                             what is the state of the widget?
 GetInteractionState() - return the current state of the widget. Note that the
                         value of "0" typically refers to "outside". The 
                         interaction state is strictly a function of the
                         representation, and the widget/represent must agree
                         on what they mean.
 Highlight() - turn on or off any highlights associated with the widget.
               Highlights are generally turned on when the widget is selected.
 </pre> Note that subclasses may ignore some of these methods and implement their own depending on the specifics of the widget.  </li>
<li>
<code>int = obj.GetInteractionState ()</code> - The following is a suggested API for widget representations. These methods define the communication between the widget and its representation. These methods are only suggestions because widgets take on so many different forms that a universal API is not deemed practical. However, these methods should be implemented when possible to insure that the VTK widget hierarchy remains self-consistent. <pre>
 PlaceWidget() - given a bounding box (xmin,xmax,ymin,ymax,zmin,zmax), place 
                 the widget inside of it. The current orientation of the widget 
                 is preserved, only scaling and translation is performed.
 StartWidgetInteraction() - generally corresponds to a initial event (e.g.,
                            mouse down) that starts the interaction process
                            with the widget.
 WidgetInteraction() - invoked when an event causes the widget to change 
                       appearance.
 EndWidgetInteraction() - generally corresponds to a final event (e.g., mouse up)
                          and completes the interaction sequence.
 ComputeInteractionState() - given (X,Y) display coordinates in a renderer, with a
                             possible flag that modifies the computation,
                             what is the state of the widget?
 GetInteractionState() - return the current state of the widget. Note that the
                         value of "0" typically refers to "outside". The 
                         interaction state is strictly a function of the
                         representation, and the widget/represent must agree
                         on what they mean.
 Highlight() - turn on or off any highlights associated with the widget.
               Highlights are generally turned on when the widget is selected.
 </pre> Note that subclasses may ignore some of these methods and implement their own depending on the specifics of the widget.  </li>
<li>
<code>obj.Highlight (int )</code> - Set/Get a factor representing the scaling of the widget upon placement (via the PlaceWidget() method). Normally the widget is placed so that it just fits within the bounding box defined in PlaceWidget(bounds). The PlaceFactor will make the widget larger (PlaceFactor &gt; 1) or smaller (PlaceFactor &lt; 1). By default, PlaceFactor is set to 0.5.  </li>
<li>
<code>obj.SetPlaceFactor (double )</code> - Set/Get a factor representing the scaling of the widget upon placement (via the PlaceWidget() method). Normally the widget is placed so that it just fits within the bounding box defined in PlaceWidget(bounds). The PlaceFactor will make the widget larger (PlaceFactor &gt; 1) or smaller (PlaceFactor &lt; 1). By default, PlaceFactor is set to 0.5.  </li>
<li>
<code>double = obj.GetPlaceFactorMinValue ()</code> - Set/Get a factor representing the scaling of the widget upon placement (via the PlaceWidget() method). Normally the widget is placed so that it just fits within the bounding box defined in PlaceWidget(bounds). The PlaceFactor will make the widget larger (PlaceFactor &gt; 1) or smaller (PlaceFactor &lt; 1). By default, PlaceFactor is set to 0.5.  </li>
<li>
<code>double = obj.GetPlaceFactorMaxValue ()</code> - Set/Get a factor representing the scaling of the widget upon placement (via the PlaceWidget() method). Normally the widget is placed so that it just fits within the bounding box defined in PlaceWidget(bounds). The PlaceFactor will make the widget larger (PlaceFactor &gt; 1) or smaller (PlaceFactor &lt; 1). By default, PlaceFactor is set to 0.5.  </li>
<li>
<code>double = obj.GetPlaceFactor ()</code> - Set/Get a factor representing the scaling of the widget upon placement (via the PlaceWidget() method). Normally the widget is placed so that it just fits within the bounding box defined in PlaceWidget(bounds). The PlaceFactor will make the widget larger (PlaceFactor &gt; 1) or smaller (PlaceFactor &lt; 1). By default, PlaceFactor is set to 0.5.  </li>
<li>
<code>obj.SetHandleSize (double )</code> - Set/Get the factor that controls the size of the handles that appear as part of the widget (if any). These handles (like spheres, etc.) are used to manipulate the widget. The HandleSize data member allows you to change the relative size of the handles. Note that while the handle size is typically expressed in pixels, some subclasses may use a relative size with respect to the viewport. (As a corollary, the value of this ivar is often set by subclasses of this class during instance instantiation.)  </li>
<li>
<code>double = obj.GetHandleSizeMinValue ()</code> - Set/Get the factor that controls the size of the handles that appear as part of the widget (if any). These handles (like spheres, etc.) are used to manipulate the widget. The HandleSize data member allows you to change the relative size of the handles. Note that while the handle size is typically expressed in pixels, some subclasses may use a relative size with respect to the viewport. (As a corollary, the value of this ivar is often set by subclasses of this class during instance instantiation.)  </li>
<li>
<code>double = obj.GetHandleSizeMaxValue ()</code> - Set/Get the factor that controls the size of the handles that appear as part of the widget (if any). These handles (like spheres, etc.) are used to manipulate the widget. The HandleSize data member allows you to change the relative size of the handles. Note that while the handle size is typically expressed in pixels, some subclasses may use a relative size with respect to the viewport. (As a corollary, the value of this ivar is often set by subclasses of this class during instance instantiation.)  </li>
<li>
<code>double = obj.GetHandleSize ()</code> - Set/Get the factor that controls the size of the handles that appear as part of the widget (if any). These handles (like spheres, etc.) are used to manipulate the widget. The HandleSize data member allows you to change the relative size of the handles. Note that while the handle size is typically expressed in pixels, some subclasses may use a relative size with respect to the viewport. (As a corollary, the value of this ivar is often set by subclasses of this class during instance instantiation.)  </li>
<li>
<code>int = obj.GetNeedToRender ()</code> - Some subclasses use this data member to keep track of whether to render or not (i.e., to minimize the total number of renders).  </li>
<li>
<code>obj.SetNeedToRender (int )</code> - Some subclasses use this data member to keep track of whether to render or not (i.e., to minimize the total number of renders).  </li>
<li>
<code>int = obj.GetNeedToRenderMinValue ()</code> - Some subclasses use this data member to keep track of whether to render or not (i.e., to minimize the total number of renders).  </li>
<li>
<code>int = obj.GetNeedToRenderMaxValue ()</code> - Some subclasses use this data member to keep track of whether to render or not (i.e., to minimize the total number of renders).  </li>
<li>
<code>obj.NeedToRenderOn ()</code> - Some subclasses use this data member to keep track of whether to render or not (i.e., to minimize the total number of renders).  </li>
<li>
<code>obj.NeedToRenderOff ()</code> - Some subclasses use this data member to keep track of whether to render or not (i.e., to minimize the total number of renders).  </li>
<li>
<code>double = obj.GetBounds ()</code> - Methods to make this class behave as a vtkProp. They are repeated here (from the vtkProp superclass) as a reminder to the widget implementor. Failure to implement these methods properly may result in the representation not appearing in the scene (i.e., not implementing the Render() methods properly) or leaking graphics resources (i.e., not implementing ReleaseGraphicsResources() properly).  </li>
<li>
<code>obj.ShallowCopy (vtkProp prop)</code> - Methods to make this class behave as a vtkProp. They are repeated here (from the vtkProp superclass) as a reminder to the widget implementor. Failure to implement these methods properly may result in the representation not appearing in the scene (i.e., not implementing the Render() methods properly) or leaking graphics resources (i.e., not implementing ReleaseGraphicsResources() properly).  </li>
<li>
<code>obj.GetActors (vtkPropCollection )</code> - Methods to make this class behave as a vtkProp. They are repeated here (from the vtkProp superclass) as a reminder to the widget implementor. Failure to implement these methods properly may result in the representation not appearing in the scene (i.e., not implementing the Render() methods properly) or leaking graphics resources (i.e., not implementing ReleaseGraphicsResources() properly).  </li>
<li>
<code>obj.GetActors2D (vtkPropCollection )</code> - Methods to make this class behave as a vtkProp. They are repeated here (from the vtkProp superclass) as a reminder to the widget implementor. Failure to implement these methods properly may result in the representation not appearing in the scene (i.e., not implementing the Render() methods properly) or leaking graphics resources (i.e., not implementing ReleaseGraphicsResources() properly).  </li>
<li>
<code>obj.GetVolumes (vtkPropCollection )</code> - Methods to make this class behave as a vtkProp. They are repeated here (from the vtkProp superclass) as a reminder to the widget implementor. Failure to implement these methods properly may result in the representation not appearing in the scene (i.e., not implementing the Render() methods properly) or leaking graphics resources (i.e., not implementing ReleaseGraphicsResources() properly).  </li>
<li>
<code>obj.ReleaseGraphicsResources (vtkWindow )</code> - Methods to make this class behave as a vtkProp. They are repeated here (from the vtkProp superclass) as a reminder to the widget implementor. Failure to implement these methods properly may result in the representation not appearing in the scene (i.e., not implementing the Render() methods properly) or leaking graphics resources (i.e., not implementing ReleaseGraphicsResources() properly).  </li>
<li>
<code>int = obj.RenderOverlay (vtkViewport )</code> - Methods to make this class behave as a vtkProp. They are repeated here (from the vtkProp superclass) as a reminder to the widget implementor. Failure to implement these methods properly may result in the representation not appearing in the scene (i.e., not implementing the Render() methods properly) or leaking graphics resources (i.e., not implementing ReleaseGraphicsResources() properly).  </li>
<li>
<code>int = obj.RenderOpaqueGeometry (vtkViewport )</code> - Methods to make this class behave as a vtkProp. They are repeated here (from the vtkProp superclass) as a reminder to the widget implementor. Failure to implement these methods properly may result in the representation not appearing in the scene (i.e., not implementing the Render() methods properly) or leaking graphics resources (i.e., not implementing ReleaseGraphicsResources() properly).  </li>
<li>
<code>int = obj.RenderTranslucentPolygonalGeometry (vtkViewport )</code> - Methods to make this class behave as a vtkProp. They are repeated here (from the vtkProp superclass) as a reminder to the widget implementor. Failure to implement these methods properly may result in the representation not appearing in the scene (i.e., not implementing the Render() methods properly) or leaking graphics resources (i.e., not implementing ReleaseGraphicsResources() properly).  </li>
<li>
<code>int = obj.RenderVolumetricGeometry (vtkViewport )</code> - Methods to make this class behave as a vtkProp. They are repeated here (from the vtkProp superclass) as a reminder to the widget implementor. Failure to implement these methods properly may result in the representation not appearing in the scene (i.e., not implementing the Render() methods properly) or leaking graphics resources (i.e., not implementing ReleaseGraphicsResources() properly).  </li>
<li>
<code>int = obj.HasTranslucentPolygonalGeometry ()</code>  </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkwidgets.html">Visualization Toolkit Widget Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:37 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

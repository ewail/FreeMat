<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkFixedPointVolumeRayCastMapper</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkvolumerendering_vtkfixedpointvolumeraycastmapper.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkFixedPointVolumeRayCastMapper </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkvolumerendering.html">Visualization Toolkit Volume Rendering Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>This is a software ray caster for rendering volumes in vtkImageData. It works with all input data types and up to four components. It performs composite or MIP rendering, and can be intermixed with geometric data. Space leaping is used to speed up the rendering process. In addition, calculation are performed in 15 bit fixed point precision. This mapper is threaded, and will interleave scan lines across processors.</p>
<p>This mapper is a good replacement for vtkVolumeRayCastMapper EXCEPT:</p>
<ul>
<li>it does not do isosurface ray casting</li>
<li>it does only interpolate before classify compositing</li>
<li>it does only maximum scalar value MIP</li>
</ul>
<p>The vtkVolumeRayCastMapper CANNOT be used in these instances when a vtkFixedPointVolumeRayCastMapper can be used:</p>
<ul>
<li>if the data is not unsigned char or unsigned short</li>
<li>if the data has more than one component</li>
</ul>
<p>This mapper handles all data type from unsigned char through double. However, some of the internal calcultions are performed in float and therefore even the full float range may cause problems for this mapper (both in scalar data values and in spacing between samples).</p>
<p>Space leaping is performed by creating a sub-sampled volume. 4x4x4 cells in the original volume are represented by a min, max, and combined gradient and flag value. The min max volume has three unsigned shorts per 4x4x4 group of cells from the original volume - one reprenting the minumum scalar index (the scalar value adjusted to fit in the 15 bit range), the maximum scalar index, and a third unsigned short which is both the maximum gradient opacity in the neighborhood (an unsigned char) and the flag that is filled in for the current lookup tables to indicate whether this region can be skipped.</p>
<p>To create an instance of class vtkFixedPointVolumeRayCastMapper, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkFixedPointVolumeRayCastMapper
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkFixedPointVolumeRayCastMapper has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkFixedPointVolumeRayCastMapper class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkFixedPointVolumeRayCastMapper = obj.NewInstance ()</code>  </li>
<li>
<code>vtkFixedPointVolumeRayCastMapper = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>obj.SetSampleDistance (float )</code> - Set/Get the distance between samples used for rendering when AutoAdjustSampleDistances is off, or when this mapper has more than 1 second allocated to it for rendering.  </li>
<li>
<code>float = obj.GetSampleDistance ()</code> - Set/Get the distance between samples used for rendering when AutoAdjustSampleDistances is off, or when this mapper has more than 1 second allocated to it for rendering.  </li>
<li>
<code>obj.SetInteractiveSampleDistance (float )</code> - Set/Get the distance between samples when interactive rendering is happening. In this case, interactive is defined as this volume mapper having less than 1 second allocated for rendering. When AutoAdjustSampleDistance is On, and the allocated render time is less than 1 second, then this InteractiveSampleDistance will be used instead of the SampleDistance above.  </li>
<li>
<code>float = obj.GetInteractiveSampleDistance ()</code> - Set/Get the distance between samples when interactive rendering is happening. In this case, interactive is defined as this volume mapper having less than 1 second allocated for rendering. When AutoAdjustSampleDistance is On, and the allocated render time is less than 1 second, then this InteractiveSampleDistance will be used instead of the SampleDistance above.  </li>
<li>
<code>obj.SetImageSampleDistance (float )</code> - Sampling distance in the XY image dimensions. Default value of 1 meaning 1 ray cast per pixel. If set to 0.5, 4 rays will be cast per pixel. If set to 2.0, 1 ray will be cast for every 4 (2 by 2) pixels. This value will be adjusted to meet a desired frame rate when AutoAdjustSampleDistances is on.  </li>
<li>
<code>float = obj.GetImageSampleDistanceMinValue ()</code> - Sampling distance in the XY image dimensions. Default value of 1 meaning 1 ray cast per pixel. If set to 0.5, 4 rays will be cast per pixel. If set to 2.0, 1 ray will be cast for every 4 (2 by 2) pixels. This value will be adjusted to meet a desired frame rate when AutoAdjustSampleDistances is on.  </li>
<li>
<code>float = obj.GetImageSampleDistanceMaxValue ()</code> - Sampling distance in the XY image dimensions. Default value of 1 meaning 1 ray cast per pixel. If set to 0.5, 4 rays will be cast per pixel. If set to 2.0, 1 ray will be cast for every 4 (2 by 2) pixels. This value will be adjusted to meet a desired frame rate when AutoAdjustSampleDistances is on.  </li>
<li>
<code>float = obj.GetImageSampleDistance ()</code> - Sampling distance in the XY image dimensions. Default value of 1 meaning 1 ray cast per pixel. If set to 0.5, 4 rays will be cast per pixel. If set to 2.0, 1 ray will be cast for every 4 (2 by 2) pixels. This value will be adjusted to meet a desired frame rate when AutoAdjustSampleDistances is on.  </li>
<li>
<code>obj.SetMinimumImageSampleDistance (float )</code> - This is the minimum image sample distance allow when the image sample distance is being automatically adjusted.  </li>
<li>
<code>float = obj.GetMinimumImageSampleDistanceMinValue ()</code> - This is the minimum image sample distance allow when the image sample distance is being automatically adjusted.  </li>
<li>
<code>float = obj.GetMinimumImageSampleDistanceMaxValue ()</code> - This is the minimum image sample distance allow when the image sample distance is being automatically adjusted.  </li>
<li>
<code>float = obj.GetMinimumImageSampleDistance ()</code> - This is the minimum image sample distance allow when the image sample distance is being automatically adjusted.  </li>
<li>
<code>obj.SetMaximumImageSampleDistance (float )</code> - This is the maximum image sample distance allow when the image sample distance is being automatically adjusted.  </li>
<li>
<code>float = obj.GetMaximumImageSampleDistanceMinValue ()</code> - This is the maximum image sample distance allow when the image sample distance is being automatically adjusted.  </li>
<li>
<code>float = obj.GetMaximumImageSampleDistanceMaxValue ()</code> - This is the maximum image sample distance allow when the image sample distance is being automatically adjusted.  </li>
<li>
<code>float = obj.GetMaximumImageSampleDistance ()</code> - This is the maximum image sample distance allow when the image sample distance is being automatically adjusted.  </li>
<li>
<code>obj.SetAutoAdjustSampleDistances (int )</code> - If AutoAdjustSampleDistances is on, the the ImageSampleDistance and the SampleDistance will be varied to achieve the allocated render time of this prop (controlled by the desired update rate and any culling in use). If this is an interactive render (more than 1 frame per second) the SampleDistance will be increased, otherwise it will not be altered (a binary decision, as opposed to the ImageSampleDistance which will vary continuously).  </li>
<li>
<code>int = obj.GetAutoAdjustSampleDistancesMinValue ()</code> - If AutoAdjustSampleDistances is on, the the ImageSampleDistance and the SampleDistance will be varied to achieve the allocated render time of this prop (controlled by the desired update rate and any culling in use). If this is an interactive render (more than 1 frame per second) the SampleDistance will be increased, otherwise it will not be altered (a binary decision, as opposed to the ImageSampleDistance which will vary continuously).  </li>
<li>
<code>int = obj.GetAutoAdjustSampleDistancesMaxValue ()</code> - If AutoAdjustSampleDistances is on, the the ImageSampleDistance and the SampleDistance will be varied to achieve the allocated render time of this prop (controlled by the desired update rate and any culling in use). If this is an interactive render (more than 1 frame per second) the SampleDistance will be increased, otherwise it will not be altered (a binary decision, as opposed to the ImageSampleDistance which will vary continuously).  </li>
<li>
<code>int = obj.GetAutoAdjustSampleDistances ()</code> - If AutoAdjustSampleDistances is on, the the ImageSampleDistance and the SampleDistance will be varied to achieve the allocated render time of this prop (controlled by the desired update rate and any culling in use). If this is an interactive render (more than 1 frame per second) the SampleDistance will be increased, otherwise it will not be altered (a binary decision, as opposed to the ImageSampleDistance which will vary continuously).  </li>
<li>
<code>obj.AutoAdjustSampleDistancesOn ()</code> - If AutoAdjustSampleDistances is on, the the ImageSampleDistance and the SampleDistance will be varied to achieve the allocated render time of this prop (controlled by the desired update rate and any culling in use). If this is an interactive render (more than 1 frame per second) the SampleDistance will be increased, otherwise it will not be altered (a binary decision, as opposed to the ImageSampleDistance which will vary continuously).  </li>
<li>
<code>obj.AutoAdjustSampleDistancesOff ()</code> - If AutoAdjustSampleDistances is on, the the ImageSampleDistance and the SampleDistance will be varied to achieve the allocated render time of this prop (controlled by the desired update rate and any culling in use). If this is an interactive render (more than 1 frame per second) the SampleDistance will be increased, otherwise it will not be altered (a binary decision, as opposed to the ImageSampleDistance which will vary continuously).  </li>
<li>
<code>obj.SetLockSampleDistanceToInputSpacing (int )</code> - Automatically compute the sample distance from the data spacing. When the number of voxels is 8, the sample distance will be roughly 1/200 the average voxel size. The distance will grow proportionally to numVoxels^(1/3) until it reaches 1/2 average voxel size when number of voxels is 1E6. Note that ScalarOpacityUnitDistance is still taken into account and if different than 1, will effect the sample distance.  </li>
<li>
<code>int = obj.GetLockSampleDistanceToInputSpacingMinValue ()</code> - Automatically compute the sample distance from the data spacing. When the number of voxels is 8, the sample distance will be roughly 1/200 the average voxel size. The distance will grow proportionally to numVoxels^(1/3) until it reaches 1/2 average voxel size when number of voxels is 1E6. Note that ScalarOpacityUnitDistance is still taken into account and if different than 1, will effect the sample distance.  </li>
<li>
<code>int = obj.GetLockSampleDistanceToInputSpacingMaxValue ()</code> - Automatically compute the sample distance from the data spacing. When the number of voxels is 8, the sample distance will be roughly 1/200 the average voxel size. The distance will grow proportionally to numVoxels^(1/3) until it reaches 1/2 average voxel size when number of voxels is 1E6. Note that ScalarOpacityUnitDistance is still taken into account and if different than 1, will effect the sample distance.  </li>
<li>
<code>int = obj.GetLockSampleDistanceToInputSpacing ()</code> - Automatically compute the sample distance from the data spacing. When the number of voxels is 8, the sample distance will be roughly 1/200 the average voxel size. The distance will grow proportionally to numVoxels^(1/3) until it reaches 1/2 average voxel size when number of voxels is 1E6. Note that ScalarOpacityUnitDistance is still taken into account and if different than 1, will effect the sample distance.  </li>
<li>
<code>obj.LockSampleDistanceToInputSpacingOn ()</code> - Automatically compute the sample distance from the data spacing. When the number of voxels is 8, the sample distance will be roughly 1/200 the average voxel size. The distance will grow proportionally to numVoxels^(1/3) until it reaches 1/2 average voxel size when number of voxels is 1E6. Note that ScalarOpacityUnitDistance is still taken into account and if different than 1, will effect the sample distance.  </li>
<li>
<code>obj.LockSampleDistanceToInputSpacingOff ()</code> - Automatically compute the sample distance from the data spacing. When the number of voxels is 8, the sample distance will be roughly 1/200 the average voxel size. The distance will grow proportionally to numVoxels^(1/3) until it reaches 1/2 average voxel size when number of voxels is 1E6. Note that ScalarOpacityUnitDistance is still taken into account and if different than 1, will effect the sample distance.  </li>
<li>
<code>obj.SetNumberOfThreads (int num)</code> - Set/Get the number of threads to use. This by default is equal to the number of available processors detected.  </li>
<li>
<code>int = obj.GetNumberOfThreads ()</code> - Set/Get the number of threads to use. This by default is equal to the number of available processors detected.  </li>
<li>
<code>obj.SetIntermixIntersectingGeometry (int )</code> - If IntermixIntersectingGeometry is turned on, the zbuffer will be captured and used to limit the traversal of the rays.  </li>
<li>
<code>int = obj.GetIntermixIntersectingGeometryMinValue ()</code> - If IntermixIntersectingGeometry is turned on, the zbuffer will be captured and used to limit the traversal of the rays.  </li>
<li>
<code>int = obj.GetIntermixIntersectingGeometryMaxValue ()</code> - If IntermixIntersectingGeometry is turned on, the zbuffer will be captured and used to limit the traversal of the rays.  </li>
<li>
<code>int = obj.GetIntermixIntersectingGeometry ()</code> - If IntermixIntersectingGeometry is turned on, the zbuffer will be captured and used to limit the traversal of the rays.  </li>
<li>
<code>obj.IntermixIntersectingGeometryOn ()</code> - If IntermixIntersectingGeometry is turned on, the zbuffer will be captured and used to limit the traversal of the rays.  </li>
<li>
<code>obj.IntermixIntersectingGeometryOff ()</code> - If IntermixIntersectingGeometry is turned on, the zbuffer will be captured and used to limit the traversal of the rays.  </li>
<li>
<code>float = obj.ComputeRequiredImageSampleDistance (float desiredTime, vtkRenderer ren)</code> - What is the image sample distance required to achieve the desired time? A version of this method is provided that does not require the volume argument since if you are using an LODProp3D you may not know this information. If you use this version you must be certain that the ray cast mapper is only used for one volume (and not shared among multiple volumes)  </li>
<li>
<code>float = obj.ComputeRequiredImageSampleDistance (float desiredTime, vtkRenderer ren, vtkVolume vol)</code> - What is the image sample distance required to achieve the desired time? A version of this method is provided that does not require the volume argument since if you are using an LODProp3D you may not know this information. If you use this version you must be certain that the ray cast mapper is only used for one volume (and not shared among multiple volumes)  </li>
<li>
<code>vtkRenderWindow = obj.GetRenderWindow ()</code>  </li>
<li>
<code>vtkFixedPointVolumeRayCastMIPHelper = obj.GetMIPHelper ()</code>  </li>
<li>
<code>vtkFixedPointVolumeRayCastCompositeHelper = obj.GetCompositeHelper ()</code>  </li>
<li>
<code>vtkFixedPointVolumeRayCastCompositeGOHelper = obj.GetCompositeGOHelper ()</code>  </li>
<li>
<code>vtkFixedPointVolumeRayCastCompositeGOShadeHelper = obj.GetCompositeGOShadeHelper ()</code>  </li>
<li>
<code>vtkFixedPointVolumeRayCastCompositeShadeHelper = obj.GetCompositeShadeHelper ()</code>  </li>
<li>
<code>float = obj. GetTableShift ()</code>  </li>
<li>
<code>float = obj. GetTableScale ()</code>  </li>
<li>
<code>int = obj.GetShadingRequired ()</code>  </li>
<li>
<code>int = obj.GetGradientOpacityRequired ()</code>  </li>
<li>
<code>vtkDataArray = obj.GetCurrentScalars ()</code>  </li>
<li>
<code>vtkDataArray = obj.GetPreviousScalars ()</code>  </li>
<li>
<code>vtkVolume = obj.GetVolume ()</code>  </li>
<li>
<code>obj.ComputeRayInfo (int x, int y, int pos[3], int dir[3], int numSteps)</code>  </li>
<li>
<code>obj.InitializeRayInfo (vtkVolume vol)</code>  </li>
<li>
<code>int = obj.ShouldUseNearestNeighborInterpolation (vtkVolume vol)</code>  </li>
<li>
<code>obj.SetRayCastImage (vtkFixedPointRayCastImage )</code> - Set / Get the underlying image object. One will be automatically created - only need to set it when using from an AMR mapper which renders multiple times into the same image.  </li>
<li>
<code>vtkFixedPointRayCastImage = obj.GetRayCastImage ()</code> - Set / Get the underlying image object. One will be automatically created - only need to set it when using from an AMR mapper which renders multiple times into the same image.  </li>
<li>
<code>int = obj.PerImageInitialization (vtkRenderer , vtkVolume , int , double , double , int )</code>  </li>
<li>
<code>obj.PerVolumeInitialization (vtkRenderer , vtkVolume )</code>  </li>
<li>
<code>obj.PerSubVolumeInitialization (vtkRenderer , vtkVolume , int )</code>  </li>
<li>
<code>obj.RenderSubVolume ()</code>  </li>
<li>
<code>obj.DisplayRenderedImage (vtkRenderer , vtkVolume )</code>  </li>
<li>
<code>obj.AbortRender ()</code>  </li>
<li>
<code>obj.CreateCanonicalView (vtkVolume volume, vtkImageData image, int blend_mode, double viewDirection[3], double viewUp[3])</code>  </li>
<li>
<code>float = obj.GetEstimatedRenderTime (vtkRenderer ren, vtkVolume vol)</code> - Get an estimate of the rendering time for a given volume / renderer. Only valid if this mapper has been used to render that volume for that renderer previously. Estimate is good when the viewing parameters have not changed much since that last render.  </li>
<li>
<code>float = obj.GetEstimatedRenderTime (vtkRenderer ren)</code> - Set/Get the window / level applied to the final color. This allows brightness / contrast adjustments on the final image. window is the width of the window. level is the center of the window. Initial window value is 1.0 Initial level value is 0.5 window cannot be null but can be negative, this way values will be reversed. |window| can be larger than 1.0 level can be any real value.  </li>
<li>
<code>obj.SetFinalColorWindow (float )</code> - Set/Get the window / level applied to the final color. This allows brightness / contrast adjustments on the final image. window is the width of the window. level is the center of the window. Initial window value is 1.0 Initial level value is 0.5 window cannot be null but can be negative, this way values will be reversed. |window| can be larger than 1.0 level can be any real value.  </li>
<li>
<code>float = obj.GetFinalColorWindow ()</code> - Set/Get the window / level applied to the final color. This allows brightness / contrast adjustments on the final image. window is the width of the window. level is the center of the window. Initial window value is 1.0 Initial level value is 0.5 window cannot be null but can be negative, this way values will be reversed. |window| can be larger than 1.0 level can be any real value.  </li>
<li>
<code>obj.SetFinalColorLevel (float )</code> - Set/Get the window / level applied to the final color. This allows brightness / contrast adjustments on the final image. window is the width of the window. level is the center of the window. Initial window value is 1.0 Initial level value is 0.5 window cannot be null but can be negative, this way values will be reversed. |window| can be larger than 1.0 level can be any real value.  </li>
<li>
<code>float = obj.GetFinalColorLevel ()</code> - Set/Get the window / level applied to the final color. This allows brightness / contrast adjustments on the final image. window is the width of the window. level is the center of the window. Initial window value is 1.0 Initial level value is 0.5 window cannot be null but can be negative, this way values will be reversed. |window| can be larger than 1.0 level can be any real value.  </li>
<li>
<code>int = obj.GetFlipMIPComparison ()</code>  </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkvolumerendering.html">Visualization Toolkit Volume Rendering Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:36 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

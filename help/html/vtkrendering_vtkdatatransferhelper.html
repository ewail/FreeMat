<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkDataTransferHelper</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkrendering_vtkdatatransferhelper.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkDataTransferHelper </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkrendering.html">Visualization Toolkit Rendering Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>vtkDataTransferHelper is a helper class that aids in transferring data between the CPU memory and the GPU memory. The data in GPU memory is stored as textures which that in CPU memory is stored as vtkDataArray. vtkDataTransferHelper provides API to transfer only a sub-extent of CPU structured data to/from the GPU.</p>
<p>To create an instance of class vtkDataTransferHelper, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkDataTransferHelper
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkDataTransferHelper has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkDataTransferHelper class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkDataTransferHelper = obj.NewInstance ()</code>  </li>
<li>
<code>vtkDataTransferHelper = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>obj.SetContext (vtkRenderWindow context)</code> - Get/Set the context. Context must be a vtkOpenGLRenderWindow. This does not increase the reference count of the context to avoid reference loops. SetContext() may raise an error is the OpenGL context does not support the required OpenGL extensions.  </li>
<li>
<code>vtkRenderWindow = obj.GetContext ()</code> - Get/Set the context. Context must be a vtkOpenGLRenderWindow. This does not increase the reference count of the context to avoid reference loops. SetContext() may raise an error is the OpenGL context does not support the required OpenGL extensions.  </li>
<li>
<code>obj.SetCPUExtent (int , int , int , int , int , int )</code> - Set the CPU data extent. The extent matches the vtkDataArray size. If the vtkDataArray comes from an vtkImageData and it is part of the point data, it is usually the vtkImageData extent. It can be on cell data too, but in this case it does not match the vtkImageData extent. If the vtkDataArray comes from a vtkDataSet, just set it to a one-dimenstional extent equal to the number of tuples. Initial value is (0,0,0,0,0,0), a valid one tuple array.  </li>
<li>
<code>obj.SetCPUExtent (int a[6])</code> - Set the CPU data extent. The extent matches the vtkDataArray size. If the vtkDataArray comes from an vtkImageData and it is part of the point data, it is usually the vtkImageData extent. It can be on cell data too, but in this case it does not match the vtkImageData extent. If the vtkDataArray comes from a vtkDataSet, just set it to a one-dimenstional extent equal to the number of tuples. Initial value is (0,0,0,0,0,0), a valid one tuple array.  </li>
<li>
<code>int = obj. GetCPUExtent ()</code> - Set the CPU data extent. The extent matches the vtkDataArray size. If the vtkDataArray comes from an vtkImageData and it is part of the point data, it is usually the vtkImageData extent. It can be on cell data too, but in this case it does not match the vtkImageData extent. If the vtkDataArray comes from a vtkDataSet, just set it to a one-dimenstional extent equal to the number of tuples. Initial value is (0,0,0,0,0,0), a valid one tuple array.  </li>
<li>
<code>obj.SetGPUExtent (int , int , int , int , int , int )</code> - Set the GPU data extent. This is the sub-extent to copy from or to the GPU. This extent matches the size of the data to transfer. GPUExtent and TextureExtent don't have to match (GPUExtent can be 1D whereas TextureExtent is 2D) but the number of elements have to match. Initial value is (0,0,0,0,0,0), a valid one tuple array.  </li>
<li>
<code>obj.SetGPUExtent (int a[6])</code> - Set the GPU data extent. This is the sub-extent to copy from or to the GPU. This extent matches the size of the data to transfer. GPUExtent and TextureExtent don't have to match (GPUExtent can be 1D whereas TextureExtent is 2D) but the number of elements have to match. Initial value is (0,0,0,0,0,0), a valid one tuple array.  </li>
<li>
<code>int = obj. GetGPUExtent ()</code> - Set the GPU data extent. This is the sub-extent to copy from or to the GPU. This extent matches the size of the data to transfer. GPUExtent and TextureExtent don't have to match (GPUExtent can be 1D whereas TextureExtent is 2D) but the number of elements have to match. Initial value is (0,0,0,0,0,0), a valid one tuple array.  </li>
<li>
<code>obj.SetTextureExtent (int , int , int , int , int , int )</code> - Set the texture data extent. This is the extent of the texture image that will receive the data. This extent matches the size of the data to transfer. If it is set to an invalid extent, GPUExtent is used. See more comment on GPUExtent. Initial value is an invalid extent.  </li>
<li>
<code>obj.SetTextureExtent (int a[6])</code> - Set the texture data extent. This is the extent of the texture image that will receive the data. This extent matches the size of the data to transfer. If it is set to an invalid extent, GPUExtent is used. See more comment on GPUExtent. Initial value is an invalid extent.  </li>
<li>
<code>int = obj. GetTextureExtent ()</code> - Set the texture data extent. This is the extent of the texture image that will receive the data. This extent matches the size of the data to transfer. If it is set to an invalid extent, GPUExtent is used. See more comment on GPUExtent. Initial value is an invalid extent.  </li>
<li>
<code>bool = obj.GetExtentIsValid (int extent)</code> - Tells if the given extent (6 int) is valid. True if min extent&lt;=max extent. <dl class="section pre"><dt>Precondition:</dt><dd>extent_exists: extent!=0  </dd></dl>
</li>
<li>
<code>bool = obj.GetCPUExtentIsValid ()</code> - Tells if CPUExtent is valid. True if min extent&lt;=max extent.  </li>
<li>
<code>bool = obj.GetGPUExtentIsValid ()</code> - Tells if GPUExtent is valid. True if min extent&lt;=max extent.  </li>
<li>
<code>bool = obj.GetTextureExtentIsValid ()</code> - Tells if TextureExtent is valid. True if min extent&lt;=max extent.  </li>
<li>
<code>obj.SetMinTextureDimension (int )</code> - Define the minimal dimension of the texture regardless of the dimensions of the TextureExtent. Initial value is 1. A texture extent can have a given dimension 0D (one value), 1D, 2D or 3D. By default 0D and 1D are translated into a 1D texture, 2D is translated into a 2D texture, 3D is translated into a 3D texture. To make life easier when writting GLSL code and use only one type of sampler (ex: sampler2d), the default behavior can be changed by forcing a type of texture with this ivar. 1: default behavior. Initial value. 2: force 0D and 1D to be in a 2D texture 3: force 0D, 1D and 2D texture to be in a 3D texture.  </li>
<li>
<code>int = obj.GetMinTextureDimension ()</code> - Define the minimal dimension of the texture regardless of the dimensions of the TextureExtent. Initial value is 1. A texture extent can have a given dimension 0D (one value), 1D, 2D or 3D. By default 0D and 1D are translated into a 1D texture, 2D is translated into a 2D texture, 3D is translated into a 3D texture. To make life easier when writting GLSL code and use only one type of sampler (ex: sampler2d), the default behavior can be changed by forcing a type of texture with this ivar. 1: default behavior. Initial value. 2: force 0D and 1D to be in a 2D texture 3: force 0D, 1D and 2D texture to be in a 3D texture.  </li>
<li>
<code>vtkDataArray = obj.GetArray ()</code> - Get/Set the CPU data buffer. Initial value is 0.  </li>
<li>
<code>obj.SetArray (vtkDataArray array)</code> - Get/Set the CPU data buffer. Initial value is 0.  </li>
<li>
<code>vtkTextureObject = obj.GetTexture ()</code> - Get/Set the GPU data buffer. Initial value is 0.  </li>
<li>
<code>obj.SetTexture (vtkTextureObject texture)</code> - Get/Set the GPU data buffer. Initial value is 0.  </li>
<li>
<code>bool = obj.Upload (int components, int componentListNULL)</code> - Old comment. Upload Extent from CPU data buffer to GPU. The WholeExtent must match the Array size. New comment. Upload GPUExtent from CPU vtkDataArray to GPU texture. It is possible to send a subset of the components or to specify and order of components or both. If components=0, componentList is ignored and all components are passed, a texture cannot have more than 4 components. <dl class="section pre"><dt>Precondition:</dt><dd>array_exists: array!=0 </dd>
<dd>
array_not_empty: array-&gt;GetNumberOfTuples()&gt;0 </dd>
<dd>
valid_cpu_extent: this-&gt;GetCPUExtentIsValid() </dd>
<dd>
valid_cpu_extent_size: (CPUExtent[1]-CPUExtent[0]+1)*(CPUExtent[3]-CPUExtent[2]+1)*(CPUExtent[5]-CPUExtent[4]+1)==array-&gt;GetNumberOfTuples() </dd>
<dd>
valid_gpu_extent: this-&gt;GetGPUExtentIsValid() </dd>
<dd>
gpu_extent_in_cpu_extent: CPUExtent[0]&lt;=GPUExtent[0] &amp;&amp; GPUExtent[1]&lt;=CPUExtent[1] &amp;&amp; CPUExtent[2]&lt;=GPUExtent[2] &amp;&amp; GPUExtent[3]&lt;=CPUExtent[3] &amp;&amp; CPUExtent[4]&lt;=GPUExtent[4] &amp;&amp; GPUExtent[5]&lt;=CPUExtent[5] </dd>
<dd>
gpu_texture_size: !this-&gt;GetTextureExtentIsValid() || (GPUExtent[1]-GPUExtent[0]+1)*(GPUExtent[3]-GPUExtent[2]+1)*(GPUExtent[5]-GPUExtent[4]+1)==(TextureExtent[1]-TextureExtent[0]+1)*(TextureExtent[3]-TextureExtent[2]+1)*(TextureExtent[5]-TextureExtent[4]+1) </dd>
<dd>
texture_can_exist_or_not: texture==0 || texture!=0 </dd>
<dd>
valid_components: (components==0 &amp;&amp; componentList==0 &amp;&amp; array-&gt;GetNumberOfComponents()&lt;=4) || (components&gt;=1 &amp;&amp; components&lt;=array-&gt;GetNumberOfComponents() &amp;&amp; components&lt;=4 &amp;&amp; componentList!=0)  </dd></dl>
</li>
<li>
<code>bool = obj.Download ()</code> - old comment: Downlad Extent from GPU data buffer to CPU. GPU data size must exactly match Extent. CPU data buffer will be resized to match WholeExtent in which only the Extent will be filled with the GPU data. new comment: Download GPUExtent from GPU texture to CPU vtkDataArray. If Array is not provided, it will be created with the size of CPUExtent. But only the tuples covered by GPUExtent will be download. In this case, if GPUExtent does not cover all GPUExtent, some of the vtkDataArray will be uninitialized. Reminder: A=&gt;B &lt;=&gt; !A||B <dl class="section pre"><dt>Precondition:</dt><dd>texture_exists: texture!=0 </dd>
<dd>
array_not_empty: array==0 || array-&gt;GetNumberOfTuples()&gt;0 </dd>
<dd>
valid_cpu_extent: this-&gt;GetCPUExtentIsValid() </dd>
<dd>
valid_cpu_extent_size: array==0 || (CPUExtent[1]-CPUExtent[0]+1)*(CPUExtent[3]-CPUExtent[2]+1)*(CPUExtent[5]-CPUExtent[4]+1)==array-&gt;GetNumberOfTuples() </dd>
<dd>
valid_gpu_extent: this-&gt;GetGPUExtentIsValid() </dd>
<dd>
gpu_extent_in_cpu_extent: CPUExtent[0]&lt;=GPUExtent[0] &amp;&amp; GPUExtent[1]&lt;=CPUExtent[1] &amp;&amp; CPUExtent[2]&lt;=GPUExtent[2] &amp;&amp; GPUExtent[3]&lt;=CPUExtent[3] &amp;&amp; CPUExtent[4]&lt;=GPUExtent[4] &amp;&amp; GPUExtent[5]&lt;=CPUExtent[5] </dd>
<dd>
gpu_texture_size: !this-&gt;GetTextureExtentIsValid() || (GPUExtent[1]-GPUExtent[0]+1)*(GPUExtent[3]-GPUExtent[2]+1)*(GPUExtent[5]-GPUExtent[4]+1)==(TextureExtent[1]-TextureExtent[0]+1)*(TextureExtent[3]-TextureExtent[2]+1)*(TextureExtent[5]-TextureExtent[4]+1) </dd>
<dd>
valid_components: array==0 || array-&gt;GetNumberOfComponents()&lt;=4 </dd>
<dd>
components_match: array==0 || (texture-&gt;GetComponents()==array-&gt;GetNumberOfComponents())  </dd></dl>
</li>
<li>
<code>bool = obj.DownloadAsync1 ()</code> - Splits the download in two operations Asynchronously download from texture memory to PBO (DownloadAsync1()). Copy from pbo to user array (DownloadAsync2()).  </li>
<li>
<code>bool = obj.DownloadAsync2 ()</code> - Splits the download in two operations Asynchronously download from texture memory to PBO (DownloadAsync1()). Copy from pbo to user array (DownloadAsync2()).  </li>
<li>
<code>bool = obj.GetShaderSupportsTextureInt ()</code>  </li>
<li>
<code>obj.SetShaderSupportsTextureInt (bool value)</code>  </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkrendering.html">Visualization Toolkit Rendering Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:35 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

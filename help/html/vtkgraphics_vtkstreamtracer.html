<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkStreamTracer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkgraphics_vtkstreamtracer.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkStreamTracer </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkgraphics.html">Visualization Toolkit Graphics Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>vtkStreamTracer is a filter that integrates a vector field to generate streamlines. The integration is performed using a specified integrator, by default Runge-Kutta2.</p>
<p>vtkStreamTracer produces polylines as the output, with each cell (i.e., polyline) representing a streamline. The attribute values associated with each streamline are stored in the cell data, whereas those associated with streamline-points are stored in the point data.</p>
<p>vtkStreamTracer supports forward (the default), backward, and combined (i.e., BOTH) integration. The length of a streamline is governed by specifying a maximum value either in physical arc length or in (local) cell length. Otherwise, the integration terminates upon exiting the flow field domain, or if the particle speed is reduced to a value less than a specified terminal speed, or when a maximum number of steps is completed. The specific reason for the termination is stored in a cell array named ReasonForTermination.</p>
<p>Note that normalized vectors are adopted in streamline integration, which achieves high numerical accuracy/smoothness of flow lines that is particularly guranteed for Runge-Kutta45 with adaptive step size and error control). In support of this feature, the underlying step size is ALWAYS in arc length unit (LENGTH_UNIT) while the 'real' time interval (virtual for steady flows) that a particle actually takes to trave in a single step is obtained by dividing the arc length by the LOCAL speed. The overall elapsed time (i.e., the life span) of the particle is the sum of those individual step-wise time intervals.</p>
<p>The quality of streamline integration can be controlled by setting the initial integration step (InitialIntegrationStep), particularly for Runge-Kutta2 and Runge-Kutta4 (with a fixed step size), and in the case of Runge-Kutta45 (with an adaptive step size and error control) the minimum integration step, the maximum integration step, and the maximum error. These steps are in either LENGTH_UNIT or CELL_LENGTH_UNIT while the error is in physical arc length. For the former two integrators, there is a trade-off between integration speed and streamline quality.</p>
<p>The integration time, vorticity, rotation and angular velocity are stored in point data arrays named "IntegrationTime", "Vorticity", "Rotation" and "AngularVelocity", respectively (vorticity, rotation and angular velocity are computed only when ComputeVorticity is on). All point data attributes in the source dataset are interpolated on the new streamline points.</p>
<p>vtkStreamTracer supports integration through any type of dataset. Thus if the dataset contains 2D cells like polygons or triangles, the integration is constrained to lie on the surface defined by 2D cells.</p>
<p>The starting point, or the so-called 'seed', of a streamline may be set in two different ways. Starting from global x-y-z "position" allows you to start a single trace at a specified x-y-z coordinate. If you specify a source object, traces will be generated from each point in the source that is inside the dataset.</p>
<p>To create an instance of class vtkStreamTracer, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkStreamTracer
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkStreamTracer has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkStreamTracer class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkStreamTracer = obj.NewInstance ()</code>  </li>
<li>
<code>vtkStreamTracer = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>obj.SetStartPosition (double , double , double )</code> - Specify the starting point (seed) of a streamline in the global coordinate system. Search must be performed to find the initial cell from which to start integration.  </li>
<li>
<code>obj.SetStartPosition (double a[3])</code> - Specify the starting point (seed) of a streamline in the global coordinate system. Search must be performed to find the initial cell from which to start integration.  </li>
<li>
<code>double = obj. GetStartPosition ()</code> - Specify the starting point (seed) of a streamline in the global coordinate system. Search must be performed to find the initial cell from which to start integration.  </li>
<li>
<code>obj.SetSource (vtkDataSet source)</code> - Specify the source object used to generate starting points (seeds). Old style. Do not use.  </li>
<li>
<code>vtkDataSet = obj.GetSource ()</code> - Specify the source object used to generate starting points (seeds). Old style. Do not use.  </li>
<li>
<code>obj.SetSourceConnection (vtkAlgorithmOutput algOutput)</code> - Specify the source object used to generate starting points (seeds). New style.  </li>
<li>
<code>obj.SetIntegrator (vtkInitialValueProblemSolver )</code> - Set/get the integrator type to be used for streamline generation. The object passed is not actually used but is cloned with NewInstance in the process of integration (prototype pattern). The default is Runge-Kutta2. The integrator can also be changed using SetIntegratorType. The recognized solvers are: RUNGE_KUTTA2 = 0 RUNGE_KUTTA4 = 1 RUNGE_KUTTA45 = 2  </li>
<li>
<code>vtkInitialValueProblemSolver = obj.GetIntegrator ()</code> - Set/get the integrator type to be used for streamline generation. The object passed is not actually used but is cloned with NewInstance in the process of integration (prototype pattern). The default is Runge-Kutta2. The integrator can also be changed using SetIntegratorType. The recognized solvers are: RUNGE_KUTTA2 = 0 RUNGE_KUTTA4 = 1 RUNGE_KUTTA45 = 2  </li>
<li>
<code>obj.SetIntegratorType (int type)</code> - Set/get the integrator type to be used for streamline generation. The object passed is not actually used but is cloned with NewInstance in the process of integration (prototype pattern). The default is Runge-Kutta2. The integrator can also be changed using SetIntegratorType. The recognized solvers are: RUNGE_KUTTA2 = 0 RUNGE_KUTTA4 = 1 RUNGE_KUTTA45 = 2  </li>
<li>
<code>int = obj.GetIntegratorType ()</code> - Set/get the integrator type to be used for streamline generation. The object passed is not actually used but is cloned with NewInstance in the process of integration (prototype pattern). The default is Runge-Kutta2. The integrator can also be changed using SetIntegratorType. The recognized solvers are: RUNGE_KUTTA2 = 0 RUNGE_KUTTA4 = 1 RUNGE_KUTTA45 = 2  </li>
<li>
<code>obj.SetIntegratorTypeToRungeKutta2 ()</code> - Set/get the integrator type to be used for streamline generation. The object passed is not actually used but is cloned with NewInstance in the process of integration (prototype pattern). The default is Runge-Kutta2. The integrator can also be changed using SetIntegratorType. The recognized solvers are: RUNGE_KUTTA2 = 0 RUNGE_KUTTA4 = 1 RUNGE_KUTTA45 = 2  </li>
<li>
<code>obj.SetIntegratorTypeToRungeKutta4 ()</code> - Set/get the integrator type to be used for streamline generation. The object passed is not actually used but is cloned with NewInstance in the process of integration (prototype pattern). The default is Runge-Kutta2. The integrator can also be changed using SetIntegratorType. The recognized solvers are: RUNGE_KUTTA2 = 0 RUNGE_KUTTA4 = 1 RUNGE_KUTTA45 = 2  </li>
<li>
<code>obj.SetIntegratorTypeToRungeKutta45 ()</code> - Set/get the integrator type to be used for streamline generation. The object passed is not actually used but is cloned with NewInstance in the process of integration (prototype pattern). The default is Runge-Kutta2. The integrator can also be changed using SetIntegratorType. The recognized solvers are: RUNGE_KUTTA2 = 0 RUNGE_KUTTA4 = 1 RUNGE_KUTTA45 = 2  </li>
<li>
<code>obj.SetInterpolatorTypeToDataSetPointLocator ()</code> - Set the velocity field interpolator type to the one involving a dataset point locator.  </li>
<li>
<code>obj.SetInterpolatorTypeToCellLocator ()</code> - Set the velocity field interpolator type to the one involving a cell locator.  </li>
<li>
<code>obj.SetMaximumPropagation (double max)</code> - Specify the maximum length of a streamline expressed in LENGTH_UNIT.  </li>
<li>
<code>double = obj.GetMaximumPropagation ()</code> - Specify a uniform integration step unit for MinimumIntegrationStep, InitialIntegrationStep, and MaximumIntegrationStep. NOTE: The valid unit is now limited to only LENGTH_UNIT (1) and CELL_LENGTH_UNIT (2), EXCLUDING the previously-supported TIME_UNIT.  </li>
<li>
<code>obj.SetIntegrationStepUnit (int unit)</code> - Specify a uniform integration step unit for MinimumIntegrationStep, InitialIntegrationStep, and MaximumIntegrationStep. NOTE: The valid unit is now limited to only LENGTH_UNIT (1) and CELL_LENGTH_UNIT (2), EXCLUDING the previously-supported TIME_UNIT.  </li>
<li>
<code>int = obj.GetIntegrationStepUnit ()</code> - Specify the Initial step size used for line integration, expressed in: LENGTH_UNIT = 1 CELL_LENGTH_UNIT = 2 (either the starting size for an adaptive integrator, e.g., RK45, or the constant / fixed size for non-adaptive ones, i.e., RK2 and RK4)  </li>
<li>
<code>obj.SetInitialIntegrationStep (double step)</code> - Specify the Initial step size used for line integration, expressed in: LENGTH_UNIT = 1 CELL_LENGTH_UNIT = 2 (either the starting size for an adaptive integrator, e.g., RK45, or the constant / fixed size for non-adaptive ones, i.e., RK2 and RK4)  </li>
<li>
<code>double = obj.GetInitialIntegrationStep ()</code> - Specify the Minimum step size used for line integration, expressed in: LENGTH_UNIT = 1 CELL_LENGTH_UNIT = 2 (Only valid for an adaptive integrator, e.g., RK45)  </li>
<li>
<code>obj.SetMinimumIntegrationStep (double step)</code> - Specify the Minimum step size used for line integration, expressed in: LENGTH_UNIT = 1 CELL_LENGTH_UNIT = 2 (Only valid for an adaptive integrator, e.g., RK45)  </li>
<li>
<code>double = obj.GetMinimumIntegrationStep ()</code> - Specify the Maximum step size used for line integration, expressed in: LENGTH_UNIT = 1 CELL_LENGTH_UNIT = 2 (Only valid for an adaptive integrator, e.g., RK45)  </li>
<li>
<code>obj.SetMaximumIntegrationStep (double step)</code> - Specify the Maximum step size used for line integration, expressed in: LENGTH_UNIT = 1 CELL_LENGTH_UNIT = 2 (Only valid for an adaptive integrator, e.g., RK45)  </li>
<li>
<code>double = obj.GetMaximumIntegrationStep ()</code>  </li>
<li>
<code>obj.SetMaximumError (double )</code>  </li>
<li>
<code>double = obj.GetMaximumError ()</code>  </li>
<li>
<code>obj.SetMaximumNumberOfSteps (vtkIdType )</code>  </li>
<li>
<code>vtkIdType = obj.GetMaximumNumberOfSteps ()</code>  </li>
<li>
<code>obj.SetTerminalSpeed (double )</code>  </li>
<li>
<code>double = obj.GetTerminalSpeed ()</code>  </li>
<li>
<code>obj.SetIntegrationDirection (int )</code> - Specify whether the streamline is integrated in the upstream or downstream direction.  </li>
<li>
<code>int = obj.GetIntegrationDirectionMinValue ()</code> - Specify whether the streamline is integrated in the upstream or downstream direction.  </li>
<li>
<code>int = obj.GetIntegrationDirectionMaxValue ()</code> - Specify whether the streamline is integrated in the upstream or downstream direction.  </li>
<li>
<code>int = obj.GetIntegrationDirection ()</code> - Specify whether the streamline is integrated in the upstream or downstream direction.  </li>
<li>
<code>obj.SetIntegrationDirectionToForward ()</code> - Specify whether the streamline is integrated in the upstream or downstream direction.  </li>
<li>
<code>obj.SetIntegrationDirectionToBackward ()</code> - Specify whether the streamline is integrated in the upstream or downstream direction.  </li>
<li>
<code>obj.SetIntegrationDirectionToBoth ()</code> - Specify whether the streamline is integrated in the upstream or downstream direction.  </li>
<li>
<code>obj.SetComputeVorticity (bool )</code>  </li>
<li>
<code>bool = obj.GetComputeVorticity ()</code>  </li>
<li>
<code>obj.SetRotationScale (double )</code>  </li>
<li>
<code>double = obj.GetRotationScale ()</code>  </li>
<li>
<code>obj.SetInterpolatorPrototype (vtkAbstractInterpolatedVelocityField ivf)</code> - The object used to interpolate the velocity field during integration is of the same class as this prototype.  </li>
<li>
<code>obj.SetInterpolatorType (int interpType)</code> - Set the type of the velocity field interpolator to determine whether vtkInterpolatedVelocityField (INTERPOLATOR_WITH_DATASET_POINT_LOCATOR) or vtkCellLocatorInterpolatedVelocityField (INTERPOLATOR_WITH_CELL_LOCATOR) is employed for locating cells during streamline integration. The latter (adopting vtkAbstractCellLocator sub-classes such as vtkCellLocator and vtkModifiedBSPTree) is more robust then the former (through vtkDataSet / vtkPointSet::FindCell() coupled with vtkPointLocator).  </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkgraphics.html">Visualization Toolkit Graphics Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:32 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

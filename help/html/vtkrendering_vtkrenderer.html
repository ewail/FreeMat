<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkRenderer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkrendering_vtkrenderer.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkRenderer </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkrendering.html">Visualization Toolkit Rendering Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>vtkRenderer provides an abstract specification for renderers. A renderer is an object that controls the rendering process for objects. Rendering is the process of converting geometry, a specification for lights, and a camera view into an image. vtkRenderer also performs coordinate transformation between world coordinates, view coordinates (the computer graphics rendering coordinate system), and display coordinates (the actual screen coordinates on the display device). Certain advanced rendering features such as two-sided lighting can also be controlled.</p>
<p>To create an instance of class vtkRenderer, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkRenderer
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkRenderer has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkRenderer class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkRenderer = obj.NewInstance ()</code>  </li>
<li>
<code>vtkRenderer = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>obj.AddActor (vtkProp p)</code> - Add/Remove different types of props to the renderer. These methods are all synonyms to AddViewProp and RemoveViewProp. They are here for convenience and backwards compatibility.  </li>
<li>
<code>obj.AddVolume (vtkProp p)</code> - Add/Remove different types of props to the renderer. These methods are all synonyms to AddViewProp and RemoveViewProp. They are here for convenience and backwards compatibility.  </li>
<li>
<code>obj.RemoveActor (vtkProp p)</code> - Add/Remove different types of props to the renderer. These methods are all synonyms to AddViewProp and RemoveViewProp. They are here for convenience and backwards compatibility.  </li>
<li>
<code>obj.RemoveVolume (vtkProp p)</code> - Add/Remove different types of props to the renderer. These methods are all synonyms to AddViewProp and RemoveViewProp. They are here for convenience and backwards compatibility.  </li>
<li>
<code>obj.AddLight (vtkLight )</code> - Add a light to the list of lights.  </li>
<li>
<code>obj.RemoveLight (vtkLight )</code> - Remove a light from the list of lights.  </li>
<li>
<code>obj.RemoveAllLights ()</code> - Remove all lights from the list of lights.  </li>
<li>
<code>vtkLightCollection = obj.GetLights ()</code> - Return the collection of lights.  </li>
<li>
<code>obj.SetLightCollection (vtkLightCollection lights)</code> - Set the collection of lights. We cannot name it SetLights because of TestSetGet <dl class="section pre"><dt>Precondition:</dt><dd>lights_exist: lights!=0 </dd></dl>
<dl class="section post"><dt>Postcondition:</dt><dd>lights_set: lights==this-&gt;GetLights()  </dd></dl>
</li>
<li>
<code>obj.CreateLight (void )</code> - Create and add a light to renderer.  </li>
<li>
<code>vtkLight = obj.MakeLight ()</code> - Create a new Light sutible for use with this type of Renderer. For example, a vtkMesaRenderer should create a vtkMesaLight in this function. The default is to just call vtkLight::New.  </li>
<li>
<code>int = obj.GetTwoSidedLighting ()</code> - Turn on/off two-sided lighting of surfaces. If two-sided lighting is off, then only the side of the surface facing the light(s) will be lit, and the other side dark. If two-sided lighting on, both sides of the surface will be lit.  </li>
<li>
<code>obj.SetTwoSidedLighting (int )</code> - Turn on/off two-sided lighting of surfaces. If two-sided lighting is off, then only the side of the surface facing the light(s) will be lit, and the other side dark. If two-sided lighting on, both sides of the surface will be lit.  </li>
<li>
<code>obj.TwoSidedLightingOn ()</code> - Turn on/off two-sided lighting of surfaces. If two-sided lighting is off, then only the side of the surface facing the light(s) will be lit, and the other side dark. If two-sided lighting on, both sides of the surface will be lit.  </li>
<li>
<code>obj.TwoSidedLightingOff ()</code> - Turn on/off two-sided lighting of surfaces. If two-sided lighting is off, then only the side of the surface facing the light(s) will be lit, and the other side dark. If two-sided lighting on, both sides of the surface will be lit.  </li>
<li>
<p class="startli"><code>obj.SetLightFollowCamera (int )</code> - Turn on/off the automatic repositioning of lights as the camera moves. If LightFollowCamera is on, lights that are designated as Headlights or CameraLights will be adjusted to move with this renderer's camera. If LightFollowCamera is off, the lights will not be adjusted.</p>
<p class="endli">(Note: In previous versions of vtk, this light-tracking functionality was part of the interactors, not the renderer. For backwards compatibility, the older, more limited interactor behavior is enabled by default. To disable this mode, turn the interactor's LightFollowCamera flag OFF, and leave the renderer's LightFollowCamera flag ON.)  </p>
</li>
<li>
<p class="startli"><code>int = obj.GetLightFollowCamera ()</code> - Turn on/off the automatic repositioning of lights as the camera moves. If LightFollowCamera is on, lights that are designated as Headlights or CameraLights will be adjusted to move with this renderer's camera. If LightFollowCamera is off, the lights will not be adjusted.</p>
<p class="endli">(Note: In previous versions of vtk, this light-tracking functionality was part of the interactors, not the renderer. For backwards compatibility, the older, more limited interactor behavior is enabled by default. To disable this mode, turn the interactor's LightFollowCamera flag OFF, and leave the renderer's LightFollowCamera flag ON.)  </p>
</li>
<li>
<p class="startli"><code>obj.LightFollowCameraOn ()</code> - Turn on/off the automatic repositioning of lights as the camera moves. If LightFollowCamera is on, lights that are designated as Headlights or CameraLights will be adjusted to move with this renderer's camera. If LightFollowCamera is off, the lights will not be adjusted.</p>
<p class="endli">(Note: In previous versions of vtk, this light-tracking functionality was part of the interactors, not the renderer. For backwards compatibility, the older, more limited interactor behavior is enabled by default. To disable this mode, turn the interactor's LightFollowCamera flag OFF, and leave the renderer's LightFollowCamera flag ON.)  </p>
</li>
<li>
<p class="startli"><code>obj.LightFollowCameraOff ()</code> - Turn on/off the automatic repositioning of lights as the camera moves. If LightFollowCamera is on, lights that are designated as Headlights or CameraLights will be adjusted to move with this renderer's camera. If LightFollowCamera is off, the lights will not be adjusted.</p>
<p class="endli">(Note: In previous versions of vtk, this light-tracking functionality was part of the interactors, not the renderer. For backwards compatibility, the older, more limited interactor behavior is enabled by default. To disable this mode, turn the interactor's LightFollowCamera flag OFF, and leave the renderer's LightFollowCamera flag ON.)  </p>
</li>
<li>
<code>int = obj.GetAutomaticLightCreation ()</code> - Turn on/off a flag which disables the automatic light creation capability. Normally in VTK if no lights are associated with the renderer, then a light is automatically created. However, in special circumstances this feature is undesirable, so the following boolean is provided to disable automatic light creation. (Turn AutomaticLightCreation off if you do not want lights to be created.)  </li>
<li>
<code>obj.SetAutomaticLightCreation (int )</code> - Turn on/off a flag which disables the automatic light creation capability. Normally in VTK if no lights are associated with the renderer, then a light is automatically created. However, in special circumstances this feature is undesirable, so the following boolean is provided to disable automatic light creation. (Turn AutomaticLightCreation off if you do not want lights to be created.)  </li>
<li>
<code>obj.AutomaticLightCreationOn ()</code> - Turn on/off a flag which disables the automatic light creation capability. Normally in VTK if no lights are associated with the renderer, then a light is automatically created. However, in special circumstances this feature is undesirable, so the following boolean is provided to disable automatic light creation. (Turn AutomaticLightCreation off if you do not want lights to be created.)  </li>
<li>
<code>obj.AutomaticLightCreationOff ()</code> - Turn on/off a flag which disables the automatic light creation capability. Normally in VTK if no lights are associated with the renderer, then a light is automatically created. However, in special circumstances this feature is undesirable, so the following boolean is provided to disable automatic light creation. (Turn AutomaticLightCreation off if you do not want lights to be created.)  </li>
<li>
<code>int = obj.UpdateLightsGeometryToFollowCamera (void )</code> - Ask the lights in the scene that are not in world space (for instance, Headlights or CameraLights that are attached to the camera) to update their geometry to match the active camera.  </li>
<li>
<code>vtkVolumeCollection = obj.GetVolumes ()</code> - Return the collection of volumes.  </li>
<li>
<code>vtkActorCollection = obj.GetActors ()</code> - Return any actors in this renderer.  </li>
<li>
<code>obj.SetActiveCamera (vtkCamera )</code> - Specify the camera to use for this renderer.  </li>
<li>
<code>vtkCamera = obj.GetActiveCamera ()</code> - Get the current camera. If there is not camera assigned to the renderer already, a new one is created automatically. This does <em>not</em> reset the camera.  </li>
<li>
<code>vtkCamera = obj.MakeCamera ()</code> - Create a new Camera sutible for use with this type of Renderer. For example, a vtkMesaRenderer should create a vtkMesaCamera in this function. The default is to just call vtkCamera::New.  </li>
<li>
<code>obj.SetErase (int )</code> - When this flag is off, the renderer will not erase the background or the Zbuffer. It is used to have overlapping renderers. Both the RenderWindow Erase and Render Erase must be on for the camera to clear the renderer. By default, Erase is on.  </li>
<li>
<code>int = obj.GetErase ()</code> - When this flag is off, the renderer will not erase the background or the Zbuffer. It is used to have overlapping renderers. Both the RenderWindow Erase and Render Erase must be on for the camera to clear the renderer. By default, Erase is on.  </li>
<li>
<code>obj.EraseOn ()</code> - When this flag is off, the renderer will not erase the background or the Zbuffer. It is used to have overlapping renderers. Both the RenderWindow Erase and Render Erase must be on for the camera to clear the renderer. By default, Erase is on.  </li>
<li>
<code>obj.EraseOff ()</code> - When this flag is off, the renderer will not erase the background or the Zbuffer. It is used to have overlapping renderers. Both the RenderWindow Erase and Render Erase must be on for the camera to clear the renderer. By default, Erase is on.  </li>
<li>
<code>obj.SetDraw (int )</code> - When this flag is off, render commands are ignored. It is used to either multiplex a vtkRenderWindow or render only part of a vtkRenderWindow. By default, Draw is on.  </li>
<li>
<code>int = obj.GetDraw ()</code> - When this flag is off, render commands are ignored. It is used to either multiplex a vtkRenderWindow or render only part of a vtkRenderWindow. By default, Draw is on.  </li>
<li>
<code>obj.DrawOn ()</code> - When this flag is off, render commands are ignored. It is used to either multiplex a vtkRenderWindow or render only part of a vtkRenderWindow. By default, Draw is on.  </li>
<li>
<code>obj.DrawOff ()</code> - When this flag is off, render commands are ignored. It is used to either multiplex a vtkRenderWindow or render only part of a vtkRenderWindow. By default, Draw is on.  </li>
<li>
<code>obj.AddCuller (vtkCuller )</code> - Add an culler to the list of cullers.  </li>
<li>
<code>obj.RemoveCuller (vtkCuller )</code> - Remove an actor from the list of cullers.  </li>
<li>
<code>vtkCullerCollection = obj.GetCullers ()</code> - Return the collection of cullers.  </li>
<li>
<code>obj.SetAmbient (double , double , double )</code> - Set the intensity of ambient lighting.  </li>
<li>
<code>obj.SetAmbient (double a[3])</code> - Set the intensity of ambient lighting.  </li>
<li>
<code>double = obj. GetAmbient ()</code> - Set the intensity of ambient lighting.  </li>
<li>
<code>obj.SetAllocatedRenderTime (double )</code> - Set/Get the amount of time this renderer is allowed to spend rendering its scene. This is used by vtkLODActor's.  </li>
<li>
<code>double = obj.GetAllocatedRenderTime ()</code> - Set/Get the amount of time this renderer is allowed to spend rendering its scene. This is used by vtkLODActor's.  </li>
<li>
<code>double = obj.GetTimeFactor ()</code> - Get the ratio between allocated time and actual render time. TimeFactor has been taken out of the render process. It is still computed in case someone finds it useful. It may be taken away in the future.  </li>
<li>
<code>obj.Render ()</code> - CALLED BY vtkRenderWindow ONLY. End-user pass your way and call vtkRenderWindow::Render(). Create an image. This is a superclass method which will in turn call the DeviceRender method of Subclasses of vtkRenderer.  </li>
<li>
<code>obj.DeviceRender ()</code> - Create an image. Subclasses of vtkRenderer must implement this method.  </li>
<li>
<code>obj.DeviceRenderTranslucentPolygonalGeometry ()</code> - Render translucent polygonal geometry. Default implementation just call UpdateTranslucentPolygonalGeometry(). Subclasses of vtkRenderer that can deal with depth peeling must override this method. It updates boolean ivar LastRenderingUsedDepthPeeling.  </li>
<li>
<code>obj.Clear ()</code> - Clear the image to the background color.  </li>
<li>
<code>int = obj.VisibleActorCount ()</code> - Returns the number of visible actors.  </li>
<li>
<code>int = obj.VisibleVolumeCount ()</code> - Returns the number of visible volumes.  </li>
<li>
<code>obj.ComputeVisiblePropBounds (double bounds[6])</code> - Compute the bounding box of all the visible props Used in ResetCamera() and ResetCameraClippingRange()  </li>
<li>
<code>double = obj.ComputeVisiblePropBounds ()</code> - Wrapper-friendly version of ComputeVisiblePropBounds  </li>
<li>
<code>obj.ResetCameraClippingRange ()</code> - Reset the camera clipping range based on the bounds of the visible actors. This ensures that no props are cut off  </li>
<li>
<code>obj.ResetCameraClippingRange (double bounds[6])</code> - Reset the camera clipping range based on a bounding box. This method is called from ResetCameraClippingRange()  </li>
<li>
<code>obj.ResetCameraClippingRange (double xmin, double xmax, double ymin, double ymax, double zmin, double zmax)</code> - Reset the camera clipping range based on a bounding box. This method is called from ResetCameraClippingRange()  </li>
<li>
<code>obj.SetNearClippingPlaneTolerance (double )</code> - Specify tolerance for near clipping plane distance to the camera as a percentage of the far clipping plane distance. By default this will be set to 0.01 for 16 bit zbuffers and 0.001 for higher depth z buffers  </li>
<li>
<code>double = obj.GetNearClippingPlaneToleranceMinValue ()</code> - Specify tolerance for near clipping plane distance to the camera as a percentage of the far clipping plane distance. By default this will be set to 0.01 for 16 bit zbuffers and 0.001 for higher depth z buffers  </li>
<li>
<code>double = obj.GetNearClippingPlaneToleranceMaxValue ()</code> - Specify tolerance for near clipping plane distance to the camera as a percentage of the far clipping plane distance. By default this will be set to 0.01 for 16 bit zbuffers and 0.001 for higher depth z buffers  </li>
<li>
<code>double = obj.GetNearClippingPlaneTolerance ()</code> - Specify tolerance for near clipping plane distance to the camera as a percentage of the far clipping plane distance. By default this will be set to 0.01 for 16 bit zbuffers and 0.001 for higher depth z buffers  </li>
<li>
<code>obj.ResetCamera ()</code> - Automatically set up the camera based on the visible actors. The camera will reposition itself to view the center point of the actors, and move along its initial view plane normal (i.e., vector defined from camera position to focal point) so that all of the actors can be seen.  </li>
<li>
<code>obj.ResetCamera (double bounds[6])</code> - Automatically set up the camera based on a specified bounding box (xmin,xmax, ymin,ymax, zmin,zmax). Camera will reposition itself so that its focal point is the center of the bounding box, and adjust its distance and position to preserve its initial view plane normal (i.e., vector defined from camera position to focal point). Note: is the view plane is parallel to the view up axis, the view up axis will be reset to one of the three coordinate axes.  </li>
<li>
<code>obj.ResetCamera (double xmin, double xmax, double ymin, double ymax, double zmin, double zmax)</code> - Alternative version of ResetCamera(bounds[6]);  </li>
<li>
<code>obj.SetRenderWindow (vtkRenderWindow )</code> - Specify the rendering window in which to draw. This is automatically set when the renderer is created by MakeRenderer. The user probably shouldn't ever need to call this method.  </li>
<li>
<code>vtkRenderWindow = obj.GetRenderWindow ()</code> - Specify the rendering window in which to draw. This is automatically set when the renderer is created by MakeRenderer. The user probably shouldn't ever need to call this method.  </li>
<li>
<code>vtkWindow = obj.GetVTKWindow ()</code> - Specify the rendering window in which to draw. This is automatically set when the renderer is created by MakeRenderer. The user probably shouldn't ever need to call this method.  </li>
<li>
<code>obj.SetBackingStore (int )</code> - Turn on/off using backing store. This may cause the re-rendering time to be slightly slower when the view changes. But it is much faster when the image has not changed, such as during an expose event.  </li>
<li>
<code>int = obj.GetBackingStore ()</code> - Turn on/off using backing store. This may cause the re-rendering time to be slightly slower when the view changes. But it is much faster when the image has not changed, such as during an expose event.  </li>
<li>
<code>obj.BackingStoreOn ()</code> - Turn on/off using backing store. This may cause the re-rendering time to be slightly slower when the view changes. But it is much faster when the image has not changed, such as during an expose event.  </li>
<li>
<code>obj.BackingStoreOff ()</code> - Turn on/off using backing store. This may cause the re-rendering time to be slightly slower when the view changes. But it is much faster when the image has not changed, such as during an expose event.  </li>
<li>
<code>obj.SetInteractive (int )</code> - Turn on/off interactive status. An interactive renderer is one that can receive events from an interactor. Should only be set if there are multiple renderers in the same section of the viewport.  </li>
<li>
<code>int = obj.GetInteractive ()</code> - Turn on/off interactive status. An interactive renderer is one that can receive events from an interactor. Should only be set if there are multiple renderers in the same section of the viewport.  </li>
<li>
<code>obj.InteractiveOn ()</code> - Turn on/off interactive status. An interactive renderer is one that can receive events from an interactor. Should only be set if there are multiple renderers in the same section of the viewport.  </li>
<li>
<code>obj.InteractiveOff ()</code> - Turn on/off interactive status. An interactive renderer is one that can receive events from an interactor. Should only be set if there are multiple renderers in the same section of the viewport.  </li>
<li>
<code>obj.SetLayer (int )</code> - Set/Get the layer that this renderer belongs to. This is only used if there are layered renderers.  </li>
<li>
<code>int = obj.GetLayer ()</code> - Set/Get the layer that this renderer belongs to. This is only used if there are layered renderers.  </li>
<li>
<code>obj.SetPreserveDepthBuffer (int )</code> - Normally a renderer is treated as transparent if Layer &gt; 0. To treat a renderer at Layer 0 as transparent, set this flag to true.  </li>
<li>
<code>int = obj.GetPreserveDepthBuffer ()</code> - Normally a renderer is treated as transparent if Layer &gt; 0. To treat a renderer at Layer 0 as transparent, set this flag to true.  </li>
<li>
<code>obj.PreserveDepthBufferOn ()</code> - Normally a renderer is treated as transparent if Layer &gt; 0. To treat a renderer at Layer 0 as transparent, set this flag to true.  </li>
<li>
<code>obj.PreserveDepthBufferOff ()</code> - Normally a renderer is treated as transparent if Layer &gt; 0. To treat a renderer at Layer 0 as transparent, set this flag to true.  </li>
<li>
<code>int = obj.Transparent ()</code> - Returns a boolean indicating if this renderer is transparent. It is transparent if it is not in the deepest layer of its render window.  </li>
<li>
<code>obj.WorldToView ()</code> - Convert world point coordinates to view coordinates.  </li>
<li>
<code>obj.ViewToWorld ()</code> - Convert view point coordinates to world coordinates.  </li>
<li>
<code>double = obj.GetZ (int x, int y)</code> - Given a pixel location, return the Z value. The z value is normalized (0,1) between the front and back clipping planes.  </li>
<li>
<code>long = obj.GetMTime ()</code> - Return the MTime of the renderer also considering its ivars.  </li>
<li>
<code>double = obj.GetLastRenderTimeInSeconds ()</code> - Get the time required, in seconds, for the last Render call.  </li>
<li>
<code>int = obj.GetNumberOfPropsRendered ()</code> - Should be used internally only during a render Get the number of props that were rendered using a RenderOpaqueGeometry or RenderTranslucentPolygonalGeometry call. This is used to know if something is in the frame buffer.  </li>
<li>
<code>vtkAssemblyPath = obj.PickProp (double selectionX, double selectionY)</code> - Return the prop (via a vtkAssemblyPath) that has the highest z value at the given x, y position in the viewport. Basically, the top most prop that renders the pixel at selectionX, selectionY will be returned. If nothing was picked then NULL is returned. This method selects from the renderers Prop list.  </li>
<li>
<code>vtkAssemblyPath = obj.PickProp (double selectionX1, double selectionY1, double selectionX2, double selectionY2)</code> - Return the prop (via a vtkAssemblyPath) that has the highest z value at the given x, y position in the viewport. Basically, the top most prop that renders the pixel at selectionX, selectionY will be returned. If nothing was picked then NULL is returned. This method selects from the renderers Prop list.  </li>
<li>
<code>obj.StereoMidpoint ()</code> - Do anything necessary between rendering the left and right viewpoints in a stereo render. Doesn't do anything except in the derived vtkIceTRenderer in ParaView.  </li>
<li>
<code>double = obj.GetTiledAspectRatio ()</code> - Compute the aspect ratio of this renderer for the current tile. When tiled displays are used the aspect ratio of the renderer for a given tile may be diferent that the aspect ratio of the renderer when rendered in it entirity  </li>
<li>
<code>int = obj.IsActiveCameraCreated ()</code> - Turn on/off rendering of translucent material with depth peeling technique. The render window must have alpha bits (ie call SetAlphaBitPlanes(1)) and no multisample buffer (ie call SetMultiSamples(0) ) to support depth peeling. If UseDepthPeeling is on and the GPU supports it, depth peeling is used for rendering translucent materials. If UseDepthPeeling is off, alpha blending is used. Initial value is off.  </li>
<li>
<code>obj.SetUseDepthPeeling (int )</code> - Turn on/off rendering of translucent material with depth peeling technique. The render window must have alpha bits (ie call SetAlphaBitPlanes(1)) and no multisample buffer (ie call SetMultiSamples(0) ) to support depth peeling. If UseDepthPeeling is on and the GPU supports it, depth peeling is used for rendering translucent materials. If UseDepthPeeling is off, alpha blending is used. Initial value is off.  </li>
<li>
<code>int = obj.GetUseDepthPeeling ()</code> - Turn on/off rendering of translucent material with depth peeling technique. The render window must have alpha bits (ie call SetAlphaBitPlanes(1)) and no multisample buffer (ie call SetMultiSamples(0) ) to support depth peeling. If UseDepthPeeling is on and the GPU supports it, depth peeling is used for rendering translucent materials. If UseDepthPeeling is off, alpha blending is used. Initial value is off.  </li>
<li>
<code>obj.UseDepthPeelingOn ()</code> - Turn on/off rendering of translucent material with depth peeling technique. The render window must have alpha bits (ie call SetAlphaBitPlanes(1)) and no multisample buffer (ie call SetMultiSamples(0) ) to support depth peeling. If UseDepthPeeling is on and the GPU supports it, depth peeling is used for rendering translucent materials. If UseDepthPeeling is off, alpha blending is used. Initial value is off.  </li>
<li>
<code>obj.UseDepthPeelingOff ()</code> - Turn on/off rendering of translucent material with depth peeling technique. The render window must have alpha bits (ie call SetAlphaBitPlanes(1)) and no multisample buffer (ie call SetMultiSamples(0) ) to support depth peeling. If UseDepthPeeling is on and the GPU supports it, depth peeling is used for rendering translucent materials. If UseDepthPeeling is off, alpha blending is used. Initial value is off.  </li>
<li>
<code>obj.SetOcclusionRatio (double )</code> - In case of use of depth peeling technique for rendering translucent material, define the threshold under which the algorithm stops to iterate over peel layers. This is the ratio of the number of pixels that have been touched by the last layer over the total number of pixels of the viewport area. Initial value is 0.0, meaning rendering have to be exact. Greater values may speed-up the rendering with small impact on the quality.  </li>
<li>
<code>double = obj.GetOcclusionRatioMinValue ()</code> - In case of use of depth peeling technique for rendering translucent material, define the threshold under which the algorithm stops to iterate over peel layers. This is the ratio of the number of pixels that have been touched by the last layer over the total number of pixels of the viewport area. Initial value is 0.0, meaning rendering have to be exact. Greater values may speed-up the rendering with small impact on the quality.  </li>
<li>
<code>double = obj.GetOcclusionRatioMaxValue ()</code> - In case of use of depth peeling technique for rendering translucent material, define the threshold under which the algorithm stops to iterate over peel layers. This is the ratio of the number of pixels that have been touched by the last layer over the total number of pixels of the viewport area. Initial value is 0.0, meaning rendering have to be exact. Greater values may speed-up the rendering with small impact on the quality.  </li>
<li>
<code>double = obj.GetOcclusionRatio ()</code> - In case of use of depth peeling technique for rendering translucent material, define the threshold under which the algorithm stops to iterate over peel layers. This is the ratio of the number of pixels that have been touched by the last layer over the total number of pixels of the viewport area. Initial value is 0.0, meaning rendering have to be exact. Greater values may speed-up the rendering with small impact on the quality.  </li>
<li>
<code>obj.SetMaximumNumberOfPeels (int )</code> - In case of depth peeling, define the maximum number of peeling layers. Initial value is 4. A special value of 0 means no maximum limit. It has to be a positive value.  </li>
<li>
<code>int = obj.GetMaximumNumberOfPeels ()</code> - In case of depth peeling, define the maximum number of peeling layers. Initial value is 4. A special value of 0 means no maximum limit. It has to be a positive value.  </li>
<li>
<code>int = obj.GetLastRenderingUsedDepthPeeling ()</code> - Tells if the last call to DeviceRenderTranslucentPolygonalGeometry() actually used depth peeling. Initial value is false.  </li>
<li>
<code>obj.SetDelegate (vtkRendererDelegate d)</code> - Set/Get a custom Render call. Allows to hook a Render call from an external project.It will be used in place of vtkRenderer::Render() if it is not NULL and its Used ivar is set to true. Initial value is NULL.  </li>
<li>
<code>vtkRendererDelegate = obj.GetDelegate ()</code> - Set/Get a custom Render call. Allows to hook a Render call from an external project.It will be used in place of vtkRenderer::Render() if it is not NULL and its Used ivar is set to true. Initial value is NULL.  </li>
<li>
<code>obj.SetPass (vtkRenderPass p)</code> - Set/Get a custom render pass. Initial value is NULL.  </li>
<li>
<code>vtkRenderPass = obj.GetPass ()</code> - Set/Get a custom render pass. Initial value is NULL.  </li>
<li>
<code>vtkHardwareSelector = obj.GetSelector ()</code> - Get the current hardware selector. If the Selector is set, it implies the current render pass is for selection. Mappers/Properties may choose to behave differently when rendering for hardware selection.  </li>
<li>
<code>obj.SetBackgroundTexture (vtkTexture )</code> - Set/Get the texture to be used for the background. If set and enabled this gets the priority over the gradient background.  </li>
<li>
<code>vtkTexture = obj.GetBackgroundTexture ()</code> - Set/Get the texture to be used for the background. If set and enabled this gets the priority over the gradient background.  </li>
<li>
<code>obj.SetTexturedBackground (bool )</code> - Set/Get whether this viewport should have a textured background. Default is off.  </li>
<li>
<code>bool = obj.GetTexturedBackground ()</code> - Set/Get whether this viewport should have a textured background. Default is off.  </li>
<li>
<code>obj.TexturedBackgroundOn ()</code> - Set/Get whether this viewport should have a textured background. Default is off.  </li>
<li>
<code>obj.TexturedBackgroundOff ()</code> - Set/Get whether this viewport should have a textured background. Default is off.  </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkrendering.html">Visualization Toolkit Rendering Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:35 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

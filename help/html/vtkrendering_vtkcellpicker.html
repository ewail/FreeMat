<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkCellPicker</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkrendering_vtkcellpicker.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkCellPicker </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkrendering.html">Visualization Toolkit Rendering Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>vtkCellPicker will shoot a ray into a 3D scene and return information about the first object that the ray hits. It works for all Prop3Ds. For vtkVolume objects, it shoots a ray into the volume and returns the point where the ray intersects an isosurface of a chosen opacity. For vtkImageActor objects, it intersects the ray with the displayed slice. For vtkActor objects, it intersects the actor's polygons. If the object's mapper has ClippingPlanes, then it takes the clipping into account, and will return the Id of the clipping plane that was intersected. For all prop types, it returns point and cell information, plus the normal of the surface that was intersected at the pick position. For volumes and images, it also returns (i,j,k) coordinates for the point and the cell that were picked.</p>
<p>To create an instance of class vtkCellPicker, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkCellPicker
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkCellPicker has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkCellPicker class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkCellPicker = obj.NewInstance ()</code>  </li>
<li>
<code>vtkCellPicker = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>int = obj.Pick (double selectionX, double selectionY, double selectionZ, vtkRenderer renderer)</code> - Perform pick operation with selection point provided. Normally the first two values are the (x,y) pixel coordinates for the pick, and the third value is z=0. The return value will be non-zero if something was successfully picked.  </li>
<li>
<code>obj.AddLocator (vtkAbstractCellLocator locator)</code> - Add a locator for one of the data sets that will be included in the scene. You must set up the locator with exactly the same data set that was input to the mapper of one or more of the actors in the scene. As well, you must either build the locator before doing the pick, or you must turn on LazyEvaluation in the locator to make it build itself on the first pick. Note that if you try to add the same locator to the picker twice, the second addition will be ignored.  </li>
<li>
<code>obj.RemoveLocator (vtkAbstractCellLocator locator)</code> - Remove a locator that was previously added. If you try to remove a nonexistent locator, then nothing will happen and no errors will be raised.  </li>
<li>
<code>obj.RemoveAllLocators ()</code> - Remove all locators associated with this picker.  </li>
<li>
<code>obj.SetVolumeOpacityIsovalue (double )</code> - Set the opacity isovalue to use for defining volume surfaces. The pick will occur at the location along the pick ray where the opacity of the volume is equal to this isovalue. If you want to do the pick based on an actual data isovalue rather than the opacity, then pass the data value through the scalar opacity function before using this method.  </li>
<li>
<code>double = obj.GetVolumeOpacityIsovalue ()</code> - Set the opacity isovalue to use for defining volume surfaces. The pick will occur at the location along the pick ray where the opacity of the volume is equal to this isovalue. If you want to do the pick based on an actual data isovalue rather than the opacity, then pass the data value through the scalar opacity function before using this method.  </li>
<li>
<code>obj.SetUseVolumeGradientOpacity (int )</code> - Use the product of the scalar and gradient opacity functions when computing the opacity isovalue, instead of just using the scalar opacity. This parameter is only relevant to volume picking and is off by default.  </li>
<li>
<code>obj.UseVolumeGradientOpacityOn ()</code> - Use the product of the scalar and gradient opacity functions when computing the opacity isovalue, instead of just using the scalar opacity. This parameter is only relevant to volume picking and is off by default.  </li>
<li>
<code>obj.UseVolumeGradientOpacityOff ()</code> - Use the product of the scalar and gradient opacity functions when computing the opacity isovalue, instead of just using the scalar opacity. This parameter is only relevant to volume picking and is off by default.  </li>
<li>
<code>int = obj.GetUseVolumeGradientOpacity ()</code> - Use the product of the scalar and gradient opacity functions when computing the opacity isovalue, instead of just using the scalar opacity. This parameter is only relevant to volume picking and is off by default.  </li>
<li>
<code>obj.SetPickClippingPlanes (int )</code> - The PickClippingPlanes setting controls how clipping planes are handled by the pick. If it is On, then the clipping planes become pickable objects, even though they are usually invisible. This means that if the pick ray intersects a clipping plane before it hits anything else, the pick will stop at that clipping plane. The GetProp3D() and GetMapper() methods will return the Prop3D and Mapper that the clipping plane belongs to. The GetClippingPlaneId() method will return the index of the clipping plane so that you can retrieve it from the mapper, or -1 if no clipping plane was picked. The picking of vtkImageActors is not influenced by this setting, since they have no clipping planes.  </li>
<li>
<code>obj.PickClippingPlanesOn ()</code> - The PickClippingPlanes setting controls how clipping planes are handled by the pick. If it is On, then the clipping planes become pickable objects, even though they are usually invisible. This means that if the pick ray intersects a clipping plane before it hits anything else, the pick will stop at that clipping plane. The GetProp3D() and GetMapper() methods will return the Prop3D and Mapper that the clipping plane belongs to. The GetClippingPlaneId() method will return the index of the clipping plane so that you can retrieve it from the mapper, or -1 if no clipping plane was picked. The picking of vtkImageActors is not influenced by this setting, since they have no clipping planes.  </li>
<li>
<code>obj.PickClippingPlanesOff ()</code> - The PickClippingPlanes setting controls how clipping planes are handled by the pick. If it is On, then the clipping planes become pickable objects, even though they are usually invisible. This means that if the pick ray intersects a clipping plane before it hits anything else, the pick will stop at that clipping plane. The GetProp3D() and GetMapper() methods will return the Prop3D and Mapper that the clipping plane belongs to. The GetClippingPlaneId() method will return the index of the clipping plane so that you can retrieve it from the mapper, or -1 if no clipping plane was picked. The picking of vtkImageActors is not influenced by this setting, since they have no clipping planes.  </li>
<li>
<code>int = obj.GetPickClippingPlanes ()</code> - The PickClippingPlanes setting controls how clipping planes are handled by the pick. If it is On, then the clipping planes become pickable objects, even though they are usually invisible. This means that if the pick ray intersects a clipping plane before it hits anything else, the pick will stop at that clipping plane. The GetProp3D() and GetMapper() methods will return the Prop3D and Mapper that the clipping plane belongs to. The GetClippingPlaneId() method will return the index of the clipping plane so that you can retrieve it from the mapper, or -1 if no clipping plane was picked. The picking of vtkImageActors is not influenced by this setting, since they have no clipping planes.  </li>
<li>
<code>int = obj.GetClippingPlaneId ()</code> - Get the index of the clipping plane that was intersected during the pick. This will be set regardless of whether PickClippingPlanes is On, all that is required is that the pick intersected a clipping plane of the Prop3D that was picked. The result will be -1 if the Prop3D that was picked has no clipping planes, or if the ray didn't intersect the planes.  </li>
<li>
<code>double = obj. GetPickNormal ()</code> - Return the normal of the picked surface at the PickPosition. If no surface was picked, then a vector pointing back at the camera is returned.  </li>
<li>
<code>double = obj. GetMapperNormal ()</code> - Return the normal of the surface at the PickPosition in mapper coordinates. The result is undefined if no prop was picked.  </li>
<li>
<code>int = obj. GetPointIJK ()</code> - Get the structured coordinates of the point at the PickPosition. Only valid for image actors and volumes with vtkImageData.  </li>
<li>
<code>int = obj. GetCellIJK ()</code> - Get the structured coordinates of the cell at the PickPosition. Only valid for image actors and volumes with vtkImageData. Combine this with the PCoords to get the position within the cell.  </li>
<li>
<code>vtkIdType = obj.GetPointId ()</code> - Get the id of the picked point. If PointId = -1, nothing was picked. This point will be a member of any cell that is picked.  </li>
<li>
<code>vtkIdType = obj.GetCellId ()</code> - Get the id of the picked cell. If CellId = -1, nothing was picked.  </li>
<li>
<code>int = obj.GetSubId ()</code> - Get the subId of the picked cell. This is useful, for example, if the data is made of triangle strips. If SubId = -1, nothing was picked.  </li>
<li>
<code>double = obj. GetPCoords ()</code> - Get the parametric coordinates of the picked cell. Only valid if a prop was picked. The PCoords can be used to compute the weights that are needed to interpolate data values within the cell.  </li>
<li>
<code>vtkTexture = obj.GetTexture ()</code> - Get the texture that was picked. This will always be set if the picked prop has a texture, and will always be null otherwise.  </li>
<li>
<code>obj.SetPickTextureData (int )</code> - If this is "On" and if the picked prop has a texture, then the data returned by GetDataSet() will be the texture's data instead of the mapper's data. The GetPointId(), GetCellId(), GetPCoords() etc. will all return information for use with the texture's data. If the picked prop does not have any texture, then GetDataSet() will return the mapper's data instead and GetPointId() etc. will return information related to the mapper's data. The default value of PickTextureData is "Off".  </li>
<li>
<code>obj.PickTextureDataOn ()</code> - If this is "On" and if the picked prop has a texture, then the data returned by GetDataSet() will be the texture's data instead of the mapper's data. The GetPointId(), GetCellId(), GetPCoords() etc. will all return information for use with the texture's data. If the picked prop does not have any texture, then GetDataSet() will return the mapper's data instead and GetPointId() etc. will return information related to the mapper's data. The default value of PickTextureData is "Off".  </li>
<li>
<code>obj.PickTextureDataOff ()</code> - If this is "On" and if the picked prop has a texture, then the data returned by GetDataSet() will be the texture's data instead of the mapper's data. The GetPointId(), GetCellId(), GetPCoords() etc. will all return information for use with the texture's data. If the picked prop does not have any texture, then GetDataSet() will return the mapper's data instead and GetPointId() etc. will return information related to the mapper's data. The default value of PickTextureData is "Off".  </li>
<li>
<code>int = obj.GetPickTextureData ()</code> - If this is "On" and if the picked prop has a texture, then the data returned by GetDataSet() will be the texture's data instead of the mapper's data. The GetPointId(), GetCellId(), GetPCoords() etc. will all return information for use with the texture's data. If the picked prop does not have any texture, then GetDataSet() will return the mapper's data instead and GetPointId() etc. will return information related to the mapper's data. The default value of PickTextureData is "Off".  </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkrendering.html">Visualization Toolkit Rendering Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:35 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

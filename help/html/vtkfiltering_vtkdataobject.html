<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkDataObject</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkfiltering_vtkdataobject.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkDataObject </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkfiltering.html">Visualization Toolkit Filtering Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>vtkDataObject is an general representation of visualization data. It serves to encapsulate instance variables and methods for visualization network execution, as well as representing data consisting of a field (i.e., just an unstructured pile of data). This is to be compared with a vtkDataSet, which is data with geometric and/or topological structure.</p>
<p>vtkDataObjects are used to represent arbitrary repositories of data via the vtkFieldData instance variable. These data must be eventually mapped into a concrete subclass of vtkDataSet before they can actually be displayed.</p>
<p>To create an instance of class vtkDataObject, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkDataObject
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkDataObject has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkDataObject class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkDataObject = obj.NewInstance ()</code>  </li>
<li>
<code>vtkDataObject = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>vtkSource = obj.GetSource ()</code> - Set/Get the source object creating this data object.  </li>
<li>
<code>obj.SetSource (vtkSource s)</code> - Set/Get the source object creating this data object.  </li>
<li>
<code>vtkInformation = obj.GetInformation ()</code> - Set/Get the information object associated with this data object.  </li>
<li>
<code>obj.SetInformation (vtkInformation )</code> - Set/Get the information object associated with this data object.  </li>
<li>
<code>vtkInformation = obj.GetPipelineInformation ()</code> - Get/Set the pipeline information object that owns this data object.  </li>
<li>
<code>obj.SetPipelineInformation (vtkInformation )</code> - Get/Set the pipeline information object that owns this data object.  </li>
<li>
<code>vtkAlgorithmOutput = obj.GetProducerPort ()</code> - Get the port currently producing this object.  </li>
<li>
<code>long = obj.GetMTime ()</code> - Data objects are composite objects and need to check each part for MTime. The information object also needs to be considered.  </li>
<li>
<code>obj.Initialize ()</code> - Restore data object to initial state,  </li>
<li>
<code>obj.ReleaseData ()</code> - Release data back to system to conserve memory resource. Used during visualization network execution. Releasing this data does not make down-stream data invalid, so it does not modify the MTime of this data object.  </li>
<li>
<code>int = obj.ShouldIReleaseData ()</code> - Return flag indicating whether data should be released after use by a filter.  </li>
<li>
<code>int = obj.GetDataReleased ()</code> - Get the flag indicating the data has been released.  </li>
<li>
<code>obj.SetReleaseDataFlag (int )</code> - Turn on/off flag to control whether this object's data is released after being used by a filter.  </li>
<li>
<code>int = obj.GetReleaseDataFlag ()</code> - Turn on/off flag to control whether this object's data is released after being used by a filter.  </li>
<li>
<code>obj.ReleaseDataFlagOn ()</code> - Turn on/off flag to control whether this object's data is released after being used by a filter.  </li>
<li>
<code>obj.ReleaseDataFlagOff ()</code> - Turn on/off flag to control whether this object's data is released after being used by a filter.  </li>
<li>
<code>obj.GlobalReleaseDataFlagOn ()</code> - Turn on/off flag to control whether every object releases its data after being used by a filter.  </li>
<li>
<code>obj.GlobalReleaseDataFlagOff ()</code> - Turn on/off flag to control whether every object releases its data after being used by a filter.  </li>
<li>
<code>obj.SetFieldData (vtkFieldData )</code> - Assign or retrieve a general field data to this data object.  </li>
<li>
<code>vtkFieldData = obj.GetFieldData ()</code> - Assign or retrieve a general field data to this data object.  </li>
<li>
<code>obj.Register (vtkObjectBase o)</code>  </li>
<li>
<code>obj.UnRegister (vtkObjectBase o)</code>  </li>
<li>
<code>obj.Update ()</code> - Provides opportunity for the data object to insure internal consistency before access. Also causes owning source/filter (if any) to update itself. The Update() method is composed of UpdateInformation(), PropagateUpdateExtent(), TriggerAsynchronousUpdate(), and UpdateData().  </li>
<li>
<code>obj.UpdateInformation ()</code> - WARNING: INTERNAL METHOD - NOT FOR GENERAL USE. THIS METHOD IS PART OF THE PIPELINE UPDATE FUNCTIONALITY. Update all the "easy to update" information about the object such as the extent which will be used to control the update. This propagates all the way up then back down the pipeline. As a by-product the PipelineMTime is updated.  </li>
<li>
<code>obj.PropagateUpdateExtent ()</code> - WARNING: INTERNAL METHOD - NOT FOR GENERAL USE. THIS METHOD IS PART OF THE PIPELINE UPDATE FUNCTIONALITY. The update extent for this object is propagated up the pipeline. This propagation may early terminate based on the PipelineMTime.  </li>
<li>
<code>obj.TriggerAsynchronousUpdate ()</code> - WARNING: INTERNAL METHOD - NOT FOR GENERAL USE. THIS METHOD IS PART OF THE PIPELINE UPDATE FUNCTIONALITY. Propagate back up the pipeline for ports and trigger the update on the other side of the port to allow for asynchronous parallel processing in the pipeline. This propagation may early terminate based on the PipelineMTime.  </li>
<li>
<code>obj.UpdateData ()</code> - WARNING: INTERNAL METHOD - NOT FOR GENERAL USE. THIS METHOD IS PART OF THE PIPELINE UPDATE FUNCTIONALITY. Propagate the update back up the pipeline, and perform the actual work of updating on the way down. When the propagate arrives at a port, block and wait for the asynchronous update to finish on the other side. This propagation may early terminate based on the PipelineMTime.  </li>
<li>
<code>long = obj.GetEstimatedMemorySize ()</code> - Get the estimated size of this data object itself. Should be called after UpdateInformation() and PropagateUpdateExtent() have both been called. Should be overridden in a subclass - otherwise the default is to assume that this data object requires no memory. The size is returned in kilobytes.  </li>
<li>
<code>obj.SetUpdateExtent (int piece, int numPieces, int ghostLevel)</code> - A generic way of specifying an update extent. Subclasses must decide what a piece is. When the NumberOfPieces is zero, then no data is requested, and the source will not execute.  </li>
<li>
<code>obj.SetUpdateExtent (int piece, int numPieces)</code> - Set the update extent for data objects that use 3D extents. Using this method on data objects that set extents as pieces (such as vtkPolyData or vtkUnstructuredGrid) has no real effect. Don't use the set macro to set the update extent since we don't want this object to be modified just due to a change in update extent. When the volume of the extent is zero (0, -1,..), then no data is requested, and the source will not execute.  </li>
<li>
<code>obj.SetUpdateExtent (int x0, int x1, int y0, int y1, int z0, int z1)</code> - Set the update extent for data objects that use 3D extents. Using this method on data objects that set extents as pieces (such as vtkPolyData or vtkUnstructuredGrid) has no real effect. Don't use the set macro to set the update extent since we don't want this object to be modified just due to a change in update extent. When the volume of the extent is zero (0, -1,..), then no data is requested, and the source will not execute.  </li>
<li>
<code>obj.SetUpdateExtent (int extent[6])</code> - Set the update extent for data objects that use 3D extents. Using this method on data objects that set extents as pieces (such as vtkPolyData or vtkUnstructuredGrid) has no real effect. Don't use the set macro to set the update extent since we don't want this object to be modified just due to a change in update extent. When the volume of the extent is zero (0, -1,..), then no data is requested, and the source will not execute.  </li>
<li>
<code>int = obj.GetUpdateExtent ()</code> - Set the update extent for data objects that use 3D extents. Using this method on data objects that set extents as pieces (such as vtkPolyData or vtkUnstructuredGrid) has no real effect. Don't use the set macro to set the update extent since we don't want this object to be modified just due to a change in update extent. When the volume of the extent is zero (0, -1,..), then no data is requested, and the source will not execute.  </li>
<li>
<code>obj.GetUpdateExtent (int extent[6])</code> - Set the update extent for data objects that use 3D extents. Using this method on data objects that set extents as pieces (such as vtkPolyData or vtkUnstructuredGrid) has no real effect. Don't use the set macro to set the update extent since we don't want this object to be modified just due to a change in update extent. When the volume of the extent is zero (0, -1,..), then no data is requested, and the source will not execute.  </li>
<li>
<code>int = obj.GetDataObjectType ()</code> - Used by Threaded ports to determine if they should initiate an asynchronous update (still in development).  </li>
<li>
<code>long = obj.GetUpdateTime ()</code> - Used by Threaded ports to determine if they should initiate an asynchronous update (still in development).  </li>
<li>
<code>obj.SetUpdateExtentToWholeExtent ()</code> - If the whole input extent is required to generate the requested output extent, this method can be called to set the input update extent to the whole input extent. This method assumes that the whole extent is known (that UpdateInformation has been called)  </li>
<li>
<code>long = obj.GetPipelineMTime ()</code> - Get the cumulative modified time of everything upstream. Does not include the MTime of this object.  </li>
<li>
<code>long = obj.GetActualMemorySize ()</code> - Return the actual size of the data in kilobytes. This number is valid only after the pipeline has updated. The memory size returned is guaranteed to be greater than or equal to the memory required to represent the data (e.g., extra space in arrays, etc. are not included in the return value).  </li>
<li>
<code>obj.CopyInformation (vtkDataObject data)</code> - Copy the generic information (WholeExtent ...)  </li>
<li>
<code>obj.CopyTypeSpecificInformation (vtkDataObject data)</code> - By default, there is no type specific information  </li>
<li>
<code>obj.SetUpdatePiece (int piece)</code> - Set / Get the update piece and the update number of pieces. Similar to update extent in 3D.  </li>
<li>
<code>obj.SetUpdateNumberOfPieces (int num)</code> - Set / Get the update piece and the update number of pieces. Similar to update extent in 3D.  </li>
<li>
<code>int = obj.GetUpdatePiece ()</code> - Set / Get the update piece and the update number of pieces. Similar to update extent in 3D.  </li>
<li>
<code>int = obj.GetUpdateNumberOfPieces ()</code> - Set / Get the update piece and the update number of pieces. Similar to update extent in 3D.  </li>
<li>
<code>obj.SetUpdateGhostLevel (int level)</code> - Set / Get the update ghost level and the update number of ghost levels. Similar to update extent in 3D.  </li>
<li>
<code>int = obj.GetUpdateGhostLevel ()</code> - Set / Get the update ghost level and the update number of ghost levels. Similar to update extent in 3D.  </li>
<li>
<code>obj.SetRequestExactExtent (int flag)</code> - This request flag indicates whether the requester can handle more data than requested. Right now it is used in vtkImageData. Image filters can return more data than requested. The the consumer cannot handle this (i.e. DataSetToDataSetFitler) the image will crop itself. This functionality used to be in ImageToStructuredPoints.  </li>
<li>
<code>int = obj.GetRequestExactExtent ()</code> - This request flag indicates whether the requester can handle more data than requested. Right now it is used in vtkImageData. Image filters can return more data than requested. The the consumer cannot handle this (i.e. DataSetToDataSetFitler) the image will crop itself. This functionality used to be in ImageToStructuredPoints.  </li>
<li>
<code>obj.RequestExactExtentOn ()</code> - This request flag indicates whether the requester can handle more data than requested. Right now it is used in vtkImageData. Image filters can return more data than requested. The the consumer cannot handle this (i.e. DataSetToDataSetFitler) the image will crop itself. This functionality used to be in ImageToStructuredPoints.  </li>
<li>
<code>obj.RequestExactExtentOff ()</code> - This request flag indicates whether the requester can handle more data than requested. Right now it is used in vtkImageData. Image filters can return more data than requested. The the consumer cannot handle this (i.e. DataSetToDataSetFitler) the image will crop itself. This functionality used to be in ImageToStructuredPoints.  </li>
<li>
<code>obj.SetWholeExtent (int x0, int x1, int y0, int y1, int z0, int z1)</code> - Set/Get the whole extent of this data object. The whole extent is meta data for structured data sets. It gets set by the source during the update information call.  </li>
<li>
<code>obj.SetWholeExtent (int extent[6])</code> - Set/Get the whole extent of this data object. The whole extent is meta data for structured data sets. It gets set by the source during the update information call.  </li>
<li>
<code>int = obj.GetWholeExtent ()</code> - Set/Get the whole extent of this data object. The whole extent is meta data for structured data sets. It gets set by the source during the update information call.  </li>
<li>
<code>obj.GetWholeExtent (int extent[6])</code> - Set/Get the whole extent of this data object. The whole extent is meta data for structured data sets. It gets set by the source during the update information call.  </li>
<li>
<code>obj.SetWholeBoundingBox (double x0, double x1, double y0, double y1, double z0, double z1)</code> - Set/Get the whole bounding box of this data object. The whole whole bounding box is meta data for data sets It gets set by the source during the update information call.  </li>
<li>
<code>obj.SetWholeBoundingBox (double bb[6])</code> - Set/Get the whole bounding box of this data object. The whole whole bounding box is meta data for data sets It gets set by the source during the update information call.  </li>
<li>
<code>double = obj.GetWholeBoundingBox ()</code> - Set/Get the whole bounding box of this data object. The whole whole bounding box is meta data for data sets It gets set by the source during the update information call.  </li>
<li>
<code>obj.GetWholeBoundingBox (double extent[6])</code> - Set/Get the whole bounding box of this data object. The whole whole bounding box is meta data for data sets It gets set by the source during the update information call.  </li>
<li>
<code>obj.SetMaximumNumberOfPieces (int )</code> - Set/Get the maximum number of pieces that can be requested. The maximum number of pieces is meta data for unstructured data sets. It gets set by the source during the update information call. A value of -1 indicates that there is no maximum. A value of  </li>
<li>
<code>int = obj.GetMaximumNumberOfPieces ()</code> - Set/Get the maximum number of pieces that can be requested. The maximum number of pieces is meta data for unstructured data sets. It gets set by the source during the update information call. A value of -1 indicates that there is no maximum. A value of  </li>
<li>
<code>obj.CopyInformationToPipeline (vtkInformation request, vtkInformation input, vtkInformation output, int forceCopy)</code> - Copy information about this data object to the output information from its own Information for the given request. If the second argument is not NULL then it is the pipeline information object for the input to this data object's producer. If forceCopy is true, information is copied even if it exists in the output.  </li>
<li>
<code>obj.CopyInformationToPipeline (vtkInformation request, vtkInformation input)</code> - Copy information about this data object from the PipelineInformation to its own Information for the given request.  </li>
<li>
<code>obj.CopyInformationFromPipeline (vtkInformation request)</code> - Copy information about this data object from the PipelineInformation to its own Information for the given request.  </li>
<li>
<code>obj.DataHasBeenGenerated ()</code> - This method is called by the source when it executes to generate data. It is sort of the opposite of ReleaseData. It sets the DataReleased flag to 0, and sets a new UpdateTime.  </li>
<li>
<code>obj.PrepareForNewData ()</code> - make the output data ready for new data to be inserted. For most objects we just call Initialize. But for vtkImageData we leave the old data in case the memory can be reused.  </li>
<li>
<code>obj.ShallowCopy (vtkDataObject src)</code> - Shallow and Deep copy. These copy the data, but not any of the pipeline connections.  </li>
<li>
<code>obj.DeepCopy (vtkDataObject src)</code> - Shallow and Deep copy. These copy the data, but not any of the pipeline connections.  </li>
<li>
<code>obj.SetExtentTranslator (vtkExtentTranslator translator)</code> - An object that will translate pieces into structured extents.  </li>
<li>
<code>vtkExtentTranslator = obj.GetExtentTranslator ()</code> - An object that will translate pieces into structured extents.  </li>
<li>
<code>int = obj.GetExtentType ()</code> - The ExtentType will be left as VTK_PIECES_EXTENT for data objects such as vtkPolyData and vtkUnstructuredGrid. The ExtentType will be changed to VTK_3D_EXTENT for data objects with 3D structure such as vtkImageData (and its subclass vtkStructuredPoints), vtkRectilinearGrid, and vtkStructuredGrid. The default is the have an extent in pieces, with only one piece (no streaming possible).  </li>
<li>
<code>obj.Crop ()</code> - This method crops the data object (if necesary) so that the extent matches the update extent.  </li>
<li>
<code>vtkDataSetAttributes = obj.GetAttributes (int type)</code> - Returns the attributes of the data object of the specified attribute type. The type may be: <ul>
<li>
POINT - Defined in vtkDataSet subclasses. </li>
<li>
CELL - Defined in vtkDataSet subclasses. </li>
<li>
VERTEX - Defined in vtkGraph subclasses. </li>
<li>
EDGE - Defined in vtkGraph subclasses. </li>
<li>
ROW - Defined in vtkTable. </li>
</ul>
The other attribute type, FIELD, will return NULL since field data is stored as a vtkFieldData instance, not a vtkDataSetAttributes instance. To retrieve field data, use GetAttributesAsFieldData.  </li>
<li>
<code>vtkFieldData = obj.GetAttributesAsFieldData (int type)</code> - Returns the attributes of the data object as a vtkFieldData. This returns non-null values in all the same cases as GetAttributes, in addition to the case of FIELD, which will return the field data for any vtkDataObject subclass.  </li>
<li>
<code>int = obj.GetAttributeTypeForArray (vtkAbstractArray arr)</code> - Retrieves the attribute type that an array came from. This is useful for obtaining which attribute type a input array to an algorithm came from (retrieved from GetInputAbstractArrayToProcesss).  </li>
<li>
<code>vtkIdType = obj.GetNumberOfElements (int type)</code> - Get the number of elements for a specific attribute type (POINT, CELL, etc.).  </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkfiltering.html">Visualization Toolkit Filtering Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:30 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

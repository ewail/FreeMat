<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkMultiProcessController</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkparallel_vtkmultiprocesscontroller.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkMultiProcessController </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkparallel.html">Visualization Toolkit Parallel Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>vtkMultiProcessController is used to control multiple processes in a distributed computing environment. It has methods for executing single/multiple method(s) on multiple processors, triggering registered callbacks (Remote Methods) (AddRMI(), TriggerRMI()) and communication. Please note that the communication is done using the communicator which is accessible to the user. Therefore it is possible to get the communicator with GetCommunicator() and use it to send and receive data. This is the encouraged communication method. The internal (RMI) communications are done using a second internal communicator (called RMICommunicator).</p>
<p>To create an instance of class vtkMultiProcessController, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkMultiProcessController
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkMultiProcessController has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkMultiProcessController class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkMultiProcessController = obj.NewInstance ()</code>  </li>
<li>
<code>vtkMultiProcessController = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>obj.Finalize ()</code> - This method is for cleaning up. If a subclass needs to clean up process communication (i.e. MPI) it would over ride this method.  </li>
<li>
<code>obj.Finalize (int finalizedExternally)</code> - This method is for cleaning up. If a subclass needs to clean up process communication (i.e. MPI) it would over ride this method. Provided for finalization outside vtk.  </li>
<li>
<code>obj.SetNumberOfProcesses (int num)</code> - Set the number of processes you will be using. This defaults to the maximum number available. If you set this to a value higher than the default, you will get an error.  </li>
<li>
<code>int = obj.GetNumberOfProcesses ()</code> - Set the number of processes you will be using. This defaults to the maximum number available. If you set this to a value higher than the default, you will get an error.  </li>
<li>
<code>obj.SingleMethodExecute ()</code> - Execute the SingleMethod (as define by SetSingleMethod) using this-&gt;NumberOfProcesses processes. This will only return when all the processes finish executing their methods.  </li>
<li>
<code>obj.MultipleMethodExecute ()</code> - Execute the MultipleMethods (as define by calling SetMultipleMethod for each of the required this-&gt;NumberOfProcesses methods) using this-&gt;NumberOfProcesses processes.  </li>
<li>
<code>int = obj.GetLocalProcessId ()</code> - Tells you which process [0, NumProcess) you are in.  </li>
<li>
<code>obj.CreateOutputWindow ()</code> - This method can be used to tell the controller to create a special output window in which all messages are preceded by the process id.  </li>
<li>
<code>vtkMultiProcessController = obj.CreateSubController (vtkProcessGroup group)</code> - Creates a new controller with the processes specified by the given group. The new controller will already be initialized for you. You are responsible for deleting the controller once you are done. It is invalid to pass this method a group with a different communicator than is used by this controller. This operation is collective accross all processes defined in the group. It is undefined what will happen if the group is not the same on all processes. This method must be called by all processes in the controller regardless of whether they are in the group. NULL is returned on all process not in the group.  </li>
<li>
<code>vtkMultiProcessController = obj.PartitionController (int localColor, int localKey)</code> - Partitions this controller based on a coloring. That is, each process passes in a color. All processes with the same color are grouped into the same partition. The processes are ordered by their self-assigned key. Lower keys have lower process ids. Ties are broken by the current process ids. (For example, if all the keys are 0, then the resulting processes will be ordered in the same way.) This method returns a new controller to each process that represents the local partition. This is basically the same operation as MPI_Comm_split.  </li>
<li>
<code>obj.TriggerBreakRMIs ()</code> - A conveniance method. Called on process 0 to break "ProcessRMIs" loop on all other processes.  </li>
<li>
<code>obj.TriggerRMI (int remoteProcessId, string arg, int tag)</code> - Convenience method when there is no argument.  </li>
<li>
<code>obj.TriggerRMI (int remoteProcessId, int tag)</code> - This is a convenicence method to trigger an RMI call on all the "children" of the current node. The children of the current node can be determined by drawing a binary tree starting at node 0 and then assigned nodes ids incrementally in a breadth-first fashion from left to right. This is designed to be used when trigger an RMI call on all satellites from the root node.  </li>
<li>
<code>obj.TriggerRMIOnAllChildren (string arg, int tag)</code> - This is a convenicence method to trigger an RMI call on all the "children" of the current node. The children of the current node can be determined by drawing a binary tree starting at node 0 and then assigned nodes ids incrementally in a breadth-first fashion from left to right. This is designed to be used when trigger an RMI call on all satellites from the root node.  </li>
<li>
<code>obj.TriggerRMIOnAllChildren (int tag)</code> - Calling this method gives control to the controller to start processing RMIs. Possible return values are: RMI_NO_ERROR, RMI_TAG_ERROR : rmi tag could not be received, RMI_ARG_ERROR : rmi arg could not be received. If reportErrors is false, no vtkErrorMacro is called. ProcessRMIs() calls ProcessRMIs(int) with reportErrors = 0. If dont_loop is 1, this call just process one RMI message and exits.  </li>
<li>
<code>int = obj.ProcessRMIs (int reportErrors, int dont_loop)</code> - Calling this method gives control to the controller to start processing RMIs. Possible return values are: RMI_NO_ERROR, RMI_TAG_ERROR : rmi tag could not be received, RMI_ARG_ERROR : rmi arg could not be received. If reportErrors is false, no vtkErrorMacro is called. ProcessRMIs() calls ProcessRMIs(int) with reportErrors = 0. If dont_loop is 1, this call just process one RMI message and exits.  </li>
<li>
<code>int = obj.ProcessRMIs ()</code> - Calling this method gives control to the controller to start processing RMIs. Possible return values are: RMI_NO_ERROR, RMI_TAG_ERROR : rmi tag could not be received, RMI_ARG_ERROR : rmi arg could not be received. If reportErrors is false, no vtkErrorMacro is called. ProcessRMIs() calls ProcessRMIs(int) with reportErrors = 0. If dont_loop is 1, this call just process one RMI message and exits.  </li>
<li>
<code>obj.SetBreakFlag (int )</code> - Setting this flag to 1 will cause the ProcessRMIs loop to return. This also causes vtkUpStreamPorts to return from their WaitForUpdate loops.  </li>
<li>
<code>int = obj.GetBreakFlag ()</code> - Setting this flag to 1 will cause the ProcessRMIs loop to return. This also causes vtkUpStreamPorts to return from their WaitForUpdate loops.  </li>
<li>
<code>vtkCommunicator = obj.GetCommunicator ()</code> - Returns the communicator associated with this controller. A default communicator is created in constructor.  </li>
<li>
<code>obj.Barrier ()</code> - This method can be used to synchronize processes.  </li>
<li>
<code>int = obj.Send (int data, vtkIdType length, int remoteProcessId, int tag)</code> - This method sends data to another process. Tag eliminates ambiguity when multiple sends or receives exist in the same process. It is recommended to use custom tag number over 100. vtkMultiProcessController has reserved tags between 1 and 4. vtkCommunicator has reserved tags between 10 and 16.  </li>
<li>
<code>int = obj.Send (int data, vtkIdType length, int remoteProcessId, int tag)</code> - This method sends data to another process. Tag eliminates ambiguity when multiple sends or receives exist in the same process. It is recommended to use custom tag number over 100. vtkMultiProcessController has reserved tags between 1 and 4. vtkCommunicator has reserved tags between 10 and 16.  </li>
<li>
<code>int = obj.Send (long data, vtkIdType length, int remoteProcessId, int tag)</code> - This method sends data to another process. Tag eliminates ambiguity when multiple sends or receives exist in the same process. It is recommended to use custom tag number over 100. vtkMultiProcessController has reserved tags between 1 and 4. vtkCommunicator has reserved tags between 10 and 16.  </li>
<li>
<code>int = obj.Send (string data, vtkIdType length, int remoteProcessId, int tag)</code> - This method sends data to another process. Tag eliminates ambiguity when multiple sends or receives exist in the same process. It is recommended to use custom tag number over 100. vtkMultiProcessController has reserved tags between 1 and 4. vtkCommunicator has reserved tags between 10 and 16.  </li>
<li>
<code>int = obj.Send (string data, vtkIdType length, int remoteProcessId, int tag)</code> - This method sends data to another process. Tag eliminates ambiguity when multiple sends or receives exist in the same process. It is recommended to use custom tag number over 100. vtkMultiProcessController has reserved tags between 1 and 4. vtkCommunicator has reserved tags between 10 and 16.  </li>
<li>
<code>int = obj.Send (float data, vtkIdType length, int remoteProcessId, int tag)</code> - This method sends data to another process. Tag eliminates ambiguity when multiple sends or receives exist in the same process. It is recommended to use custom tag number over 100. vtkMultiProcessController has reserved tags between 1 and 4. vtkCommunicator has reserved tags between 10 and 16.  </li>
<li>
<code>int = obj.Send (double data, vtkIdType length, int remoteProcessId, int tag)</code> - This method sends data to another process. Tag eliminates ambiguity when multiple sends or receives exist in the same process. It is recommended to use custom tag number over 100. vtkMultiProcessController has reserved tags between 1 and 4. vtkCommunicator has reserved tags between 10 and 16.  </li>
<li>
<code>int = obj.Send (vtkDataObject data, int remoteId, int tag)</code> - This method sends data to another process. Tag eliminates ambiguity when multiple sends or receives exist in the same process. It is recommended to use custom tag number over 100. vtkMultiProcessController has reserved tags between 1 and 4. vtkCommunicator has reserved tags between 10 and 16.  </li>
<li>
<code>int = obj.Send (vtkDataArray data, int remoteId, int tag)</code> - This method sends data to another process. Tag eliminates ambiguity when multiple sends or receives exist in the same process. It is recommended to use custom tag number over 100. vtkMultiProcessController has reserved tags between 1 and 4. vtkCommunicator has reserved tags between 10 and 16.  </li>
<li>
<code>int = obj.Receive (int data, vtkIdType maxlength, int remoteProcessId, int tag)</code> - This method receives data from a corresponding send. It blocks until the receive is finished. It calls methods in "data" to communicate the sending data. In the overrloads that take in a <code>maxlength</code> argument, this length is the maximum length of the message to receive. If the maxlength is less than the length of the message sent by the sender, an error will be flagged. Once a message is received, use the GetCount() method to determine the actual size of the data received.  </li>
<li>
<code>int = obj.Receive (int data, vtkIdType maxlength, int remoteProcessId, int tag)</code> - This method receives data from a corresponding send. It blocks until the receive is finished. It calls methods in "data" to communicate the sending data. In the overrloads that take in a <code>maxlength</code> argument, this length is the maximum length of the message to receive. If the maxlength is less than the length of the message sent by the sender, an error will be flagged. Once a message is received, use the GetCount() method to determine the actual size of the data received.  </li>
<li>
<code>int = obj.Receive (long data, vtkIdType maxlength, int remoteProcessId, int tag)</code> - This method receives data from a corresponding send. It blocks until the receive is finished. It calls methods in "data" to communicate the sending data. In the overrloads that take in a <code>maxlength</code> argument, this length is the maximum length of the message to receive. If the maxlength is less than the length of the message sent by the sender, an error will be flagged. Once a message is received, use the GetCount() method to determine the actual size of the data received.  </li>
<li>
<code>int = obj.Receive (string data, vtkIdType maxlength, int remoteProcessId, int tag)</code> - This method receives data from a corresponding send. It blocks until the receive is finished. It calls methods in "data" to communicate the sending data. In the overrloads that take in a <code>maxlength</code> argument, this length is the maximum length of the message to receive. If the maxlength is less than the length of the message sent by the sender, an error will be flagged. Once a message is received, use the GetCount() method to determine the actual size of the data received.  </li>
<li>
<code>int = obj.Receive (string data, vtkIdType maxlength, int remoteProcessId, int tag)</code> - This method receives data from a corresponding send. It blocks until the receive is finished. It calls methods in "data" to communicate the sending data. In the overrloads that take in a <code>maxlength</code> argument, this length is the maximum length of the message to receive. If the maxlength is less than the length of the message sent by the sender, an error will be flagged. Once a message is received, use the GetCount() method to determine the actual size of the data received.  </li>
<li>
<code>int = obj.Receive (float data, vtkIdType maxlength, int remoteProcessId, int tag)</code> - This method receives data from a corresponding send. It blocks until the receive is finished. It calls methods in "data" to communicate the sending data. In the overrloads that take in a <code>maxlength</code> argument, this length is the maximum length of the message to receive. If the maxlength is less than the length of the message sent by the sender, an error will be flagged. Once a message is received, use the GetCount() method to determine the actual size of the data received.  </li>
<li>
<code>int = obj.Receive (double data, vtkIdType maxlength, int remoteProcessId, int tag)</code> - This method receives data from a corresponding send. It blocks until the receive is finished. It calls methods in "data" to communicate the sending data. In the overrloads that take in a <code>maxlength</code> argument, this length is the maximum length of the message to receive. If the maxlength is less than the length of the message sent by the sender, an error will be flagged. Once a message is received, use the GetCount() method to determine the actual size of the data received.  </li>
<li>
<code>int = obj.Receive (vtkDataObject data, int remoteId, int tag)</code> - This method receives data from a corresponding send. It blocks until the receive is finished. It calls methods in "data" to communicate the sending data. In the overrloads that take in a <code>maxlength</code> argument, this length is the maximum length of the message to receive. If the maxlength is less than the length of the message sent by the sender, an error will be flagged. Once a message is received, use the GetCount() method to determine the actual size of the data received.  </li>
<li>
<code>int = obj.Receive (vtkDataArray data, int remoteId, int tag)</code> - This method receives data from a corresponding send. It blocks until the receive is finished. It calls methods in "data" to communicate the sending data. In the overrloads that take in a <code>maxlength</code> argument, this length is the maximum length of the message to receive. If the maxlength is less than the length of the message sent by the sender, an error will be flagged. Once a message is received, use the GetCount() method to determine the actual size of the data received.  </li>
<li>
<code>vtkDataObject = obj.ReceiveDataObject (int remoteId, int tag)</code> - This method receives data from a corresponding send. It blocks until the receive is finished. It calls methods in "data" to communicate the sending data. In the overrloads that take in a <code>maxlength</code> argument, this length is the maximum length of the message to receive. If the maxlength is less than the length of the message sent by the sender, an error will be flagged. Once a message is received, use the GetCount() method to determine the actual size of the data received.  </li>
<li>
<code>vtkIdType = obj.GetCount ()</code> - Returns the number of words received by the most recent Receive(). Note that this is not the number of bytes received, but the number of items of the data-type received by the most recent Receive() eg. if Receive(int*,..) was used, then this returns the number of ints received; if Receive(double*,..) was used, then this returns the number of doubles received etc. The return value is valid only after a successful Receive().  </li>
<li>
<code>int = obj.Broadcast (int data, vtkIdType length, int srcProcessId)</code> - Broadcast sends the array in the process with id <code>srcProcessId</code> to all of the other processes. All processes must call these method with the same arguments in order for it to complete.  </li>
<li>
<code>int = obj.Broadcast (long data, vtkIdType length, int srcProcessId)</code> - Broadcast sends the array in the process with id <code>srcProcessId</code> to all of the other processes. All processes must call these method with the same arguments in order for it to complete.  </li>
<li>
<code>int = obj.Broadcast (string data, vtkIdType length, int srcProcessId)</code> - Broadcast sends the array in the process with id <code>srcProcessId</code> to all of the other processes. All processes must call these method with the same arguments in order for it to complete.  </li>
<li>
<code>int = obj.Broadcast (string data, vtkIdType length, int srcProcessId)</code> - Broadcast sends the array in the process with id <code>srcProcessId</code> to all of the other processes. All processes must call these method with the same arguments in order for it to complete.  </li>
<li>
<code>int = obj.Broadcast (float data, vtkIdType length, int srcProcessId)</code> - Broadcast sends the array in the process with id <code>srcProcessId</code> to all of the other processes. All processes must call these method with the same arguments in order for it to complete.  </li>
<li>
<code>int = obj.Broadcast (double data, vtkIdType length, int srcProcessId)</code> - Broadcast sends the array in the process with id <code>srcProcessId</code> to all of the other processes. All processes must call these method with the same arguments in order for it to complete.  </li>
<li>
<code>int = obj.Broadcast (vtkDataObject data, int srcProcessId)</code> - Broadcast sends the array in the process with id <code>srcProcessId</code> to all of the other processes. All processes must call these method with the same arguments in order for it to complete.  </li>
<li>
<code>int = obj.Broadcast (vtkDataArray data, int srcProcessId)</code> - Gather collects arrays in the process with id <code>destProcessId</code>. Each process (including the destination) sends the contents of its send buffer to the destination process. The destination process receives the messages and stores them in rank order. The <code>length</code> argument (which must be the same on all processes) is the length of the sendBuffers. The <code>recvBuffer</code> (on te destination process) must be of length length*numProcesses. Gather is the inverse operation of Scatter.  </li>
<li>
<code>int = obj.Gather (int sendBuffer, int recvBuffer, vtkIdType length, int destProcessId)</code> - Gather collects arrays in the process with id <code>destProcessId</code>. Each process (including the destination) sends the contents of its send buffer to the destination process. The destination process receives the messages and stores them in rank order. The <code>length</code> argument (which must be the same on all processes) is the length of the sendBuffers. The <code>recvBuffer</code> (on te destination process) must be of length length*numProcesses. Gather is the inverse operation of Scatter.  </li>
<li>
<code>int = obj.Gather (long sendBuffer, long recvBuffer, vtkIdType length, int destProcessId)</code> - Gather collects arrays in the process with id <code>destProcessId</code>. Each process (including the destination) sends the contents of its send buffer to the destination process. The destination process receives the messages and stores them in rank order. The <code>length</code> argument (which must be the same on all processes) is the length of the sendBuffers. The <code>recvBuffer</code> (on te destination process) must be of length length*numProcesses. Gather is the inverse operation of Scatter.  </li>
<li>
<code>int = obj.Gather (string sendBuffer, string recvBuffer, vtkIdType length, int destProcessId)</code> - Gather collects arrays in the process with id <code>destProcessId</code>. Each process (including the destination) sends the contents of its send buffer to the destination process. The destination process receives the messages and stores them in rank order. The <code>length</code> argument (which must be the same on all processes) is the length of the sendBuffers. The <code>recvBuffer</code> (on te destination process) must be of length length*numProcesses. Gather is the inverse operation of Scatter.  </li>
<li>
<code>int = obj.Gather (string sendBuffer, string recvBuffer, vtkIdType length, int destProcessId)</code> - Gather collects arrays in the process with id <code>destProcessId</code>. Each process (including the destination) sends the contents of its send buffer to the destination process. The destination process receives the messages and stores them in rank order. The <code>length</code> argument (which must be the same on all processes) is the length of the sendBuffers. The <code>recvBuffer</code> (on te destination process) must be of length length*numProcesses. Gather is the inverse operation of Scatter.  </li>
<li>
<code>int = obj.Gather (float sendBuffer, float recvBuffer, vtkIdType length, int destProcessId)</code> - Gather collects arrays in the process with id <code>destProcessId</code>. Each process (including the destination) sends the contents of its send buffer to the destination process. The destination process receives the messages and stores them in rank order. The <code>length</code> argument (which must be the same on all processes) is the length of the sendBuffers. The <code>recvBuffer</code> (on te destination process) must be of length length*numProcesses. Gather is the inverse operation of Scatter.  </li>
<li>
<code>int = obj.Gather (double sendBuffer, double recvBuffer, vtkIdType length, int destProcessId)</code> - Gather collects arrays in the process with id <code>destProcessId</code>. Each process (including the destination) sends the contents of its send buffer to the destination process. The destination process receives the messages and stores them in rank order. The <code>length</code> argument (which must be the same on all processes) is the length of the sendBuffers. The <code>recvBuffer</code> (on te destination process) must be of length length*numProcesses. Gather is the inverse operation of Scatter.  </li>
<li>
<code>int = obj.Gather (vtkDataArray sendBuffer, vtkDataArray recvBuffer, int destProcessId)</code> - GatherV is the vector variant of Gather. It extends the functionality of Gather by allowing a varying count of data from each process. GatherV collects arrays in the process with id <code>destProcessId</code>. Each process (including the destination) sends the contents of its send buffer to the destination process. The destination process receives the messages and stores them in rank order. The <code>sendLength</code> argument defines how much the local process sends to <code>destProcessId</code> and <code>recvLengths</code> is an array containing the amount <code>destProcessId</code> receives from each process, in rank order.  </li>
<li>
<code>int = obj.Scatter (int sendBuffer, int recvBuffer, vtkIdType length, int srcProcessId)</code> - Scatter takes an array in the process with id <code>srcProcessId</code> and distributes it. Each process (including the source) receives a portion of the send buffer. Process 0 receives the first <code>length</code> values, process 1 receives the second <code>length</code> values, and so on. Scatter is the inverse operation of Gather.  </li>
<li>
<code>int = obj.Scatter (long sendBuffer, long recvBuffer, vtkIdType length, int srcProcessId)</code> - Scatter takes an array in the process with id <code>srcProcessId</code> and distributes it. Each process (including the source) receives a portion of the send buffer. Process 0 receives the first <code>length</code> values, process 1 receives the second <code>length</code> values, and so on. Scatter is the inverse operation of Gather.  </li>
<li>
<code>int = obj.Scatter (string sendBuffer, string recvBuffer, vtkIdType length, int srcProcessId)</code> - Scatter takes an array in the process with id <code>srcProcessId</code> and distributes it. Each process (including the source) receives a portion of the send buffer. Process 0 receives the first <code>length</code> values, process 1 receives the second <code>length</code> values, and so on. Scatter is the inverse operation of Gather.  </li>
<li>
<code>int = obj.Scatter (string sendBuffer, string recvBuffer, vtkIdType length, int srcProcessId)</code> - Scatter takes an array in the process with id <code>srcProcessId</code> and distributes it. Each process (including the source) receives a portion of the send buffer. Process 0 receives the first <code>length</code> values, process 1 receives the second <code>length</code> values, and so on. Scatter is the inverse operation of Gather.  </li>
<li>
<code>int = obj.Scatter (float sendBuffer, float recvBuffer, vtkIdType length, int srcProcessId)</code> - Scatter takes an array in the process with id <code>srcProcessId</code> and distributes it. Each process (including the source) receives a portion of the send buffer. Process 0 receives the first <code>length</code> values, process 1 receives the second <code>length</code> values, and so on. Scatter is the inverse operation of Gather.  </li>
<li>
<code>int = obj.Scatter (double sendBuffer, double recvBuffer, vtkIdType length, int srcProcessId)</code> - Scatter takes an array in the process with id <code>srcProcessId</code> and distributes it. Each process (including the source) receives a portion of the send buffer. Process 0 receives the first <code>length</code> values, process 1 receives the second <code>length</code> values, and so on. Scatter is the inverse operation of Gather.  </li>
<li>
<code>int = obj.Scatter (vtkDataArray sendBuffer, vtkDataArray recvBuffer, int srcProcessId)</code> - ScatterV is the vector variant of Scatter. It extends the functionality of Scatter by allowing a varying count of data to each process. ScatterV takes an array in the process with id <code>srcProcessId</code> and distributes it. Each process (including the source) receives a portion of the send buffer defined by the <code>sendLengths</code> and <code>offsets</code> arrays.  </li>
<li>
<code>int = obj.AllGather (int sendBuffer, int recvBuffer, vtkIdType length)</code> - Same as gather except that the result ends up on all processes.  </li>
<li>
<code>int = obj.AllGather (long sendBuffer, long recvBuffer, vtkIdType length)</code> - Same as gather except that the result ends up on all processes.  </li>
<li>
<code>int = obj.AllGather (string sendBuffer, string recvBuffer, vtkIdType length)</code> - Same as gather except that the result ends up on all processes.  </li>
<li>
<code>int = obj.AllGather (string sendBuffer, string recvBuffer, vtkIdType length)</code> - Same as gather except that the result ends up on all processes.  </li>
<li>
<code>int = obj.AllGather (float sendBuffer, float recvBuffer, vtkIdType length)</code> - Same as gather except that the result ends up on all processes.  </li>
<li>
<code>int = obj.AllGather (double sendBuffer, double recvBuffer, vtkIdType length)</code> - Same as gather except that the result ends up on all processes.  </li>
<li>
<code>int = obj.AllGather (vtkDataArray sendBuffer, vtkDataArray recvBuffer)</code> - Same as GatherV except that the result is placed in all processes.  </li>
<li>
<code>int = obj.Reduce (int sendBuffer, int recvBuffer, vtkIdType length, int operation, int destProcessId)</code> - Reduce an array to the given destination process. This version of Reduce takes an identifier defined in the vtkCommunicator::StandardOperations enum to define the operation.  </li>
<li>
<code>int = obj.Reduce (long sendBuffer, long recvBuffer, vtkIdType length, int operation, int destProcessId)</code> - Reduce an array to the given destination process. This version of Reduce takes an identifier defined in the vtkCommunicator::StandardOperations enum to define the operation.  </li>
<li>
<code>int = obj.Reduce (string sendBuffer, string recvBuffer, vtkIdType length, int operation, int destProcessId)</code> - Reduce an array to the given destination process. This version of Reduce takes an identifier defined in the vtkCommunicator::StandardOperations enum to define the operation.  </li>
<li>
<code>int = obj.Reduce (string sendBuffer, string recvBuffer, vtkIdType length, int operation, int destProcessId)</code> - Reduce an array to the given destination process. This version of Reduce takes an identifier defined in the vtkCommunicator::StandardOperations enum to define the operation.  </li>
<li>
<code>int = obj.Reduce (float sendBuffer, float recvBuffer, vtkIdType length, int operation, int destProcessId)</code> - Reduce an array to the given destination process. This version of Reduce takes an identifier defined in the vtkCommunicator::StandardOperations enum to define the operation.  </li>
<li>
<code>int = obj.Reduce (double sendBuffer, double recvBuffer, vtkIdType length, int operation, int destProcessId)</code> - Reduce an array to the given destination process. This version of Reduce takes an identifier defined in the vtkCommunicator::StandardOperations enum to define the operation.  </li>
<li>
<code>int = obj.Reduce (vtkDataArray sendBuffer, vtkDataArray recvBuffer, int operation, int destProcessId)</code> - Same as Reduce except that the result is placed in all of the processes.  </li>
<li>
<code>int = obj.AllReduce (int sendBuffer, int recvBuffer, vtkIdType length, int operation)</code> - Same as Reduce except that the result is placed in all of the processes.  </li>
<li>
<code>int = obj.AllReduce (long sendBuffer, long recvBuffer, vtkIdType length, int operation)</code> - Same as Reduce except that the result is placed in all of the processes.  </li>
<li>
<code>int = obj.AllReduce (string sendBuffer, string recvBuffer, vtkIdType length, int operation)</code> - Same as Reduce except that the result is placed in all of the processes.  </li>
<li>
<code>int = obj.AllReduce (string sendBuffer, string recvBuffer, vtkIdType length, int operation)</code> - Same as Reduce except that the result is placed in all of the processes.  </li>
<li>
<code>int = obj.AllReduce (float sendBuffer, float recvBuffer, vtkIdType length, int operation)</code> - Same as Reduce except that the result is placed in all of the processes.  </li>
<li>
<code>int = obj.AllReduce (double sendBuffer, double recvBuffer, vtkIdType length, int operation)</code> - Same as Reduce except that the result is placed in all of the processes.  </li>
<li>
<code>int = obj.AllReduce (vtkDataArray sendBuffer, vtkDataArray recvBuffer, int operation)</code>  </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkparallel.html">Visualization Toolkit Parallel Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:34 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

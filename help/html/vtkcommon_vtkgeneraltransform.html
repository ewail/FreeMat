<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkGeneralTransform</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkcommon_vtkgeneraltransform.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkGeneralTransform </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkcommon.html">Visualization Toolkit Common Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>vtkGeneralTransform is like vtkTransform and vtkPerspectiveTransform, but it will work with any vtkAbstractTransform as input. It is not as efficient as the other two, however, because arbitrary transformations cannot be concatenated by matrix multiplication. Transform concatenation is simulated by passing each input point through each transform in turn.</p>
<p>To create an instance of class vtkGeneralTransform, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkGeneralTransform
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkGeneralTransform has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkGeneralTransform class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkGeneralTransform = obj.NewInstance ()</code>  </li>
<li>
<code>vtkGeneralTransform = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>obj.Identity ()</code> - Set this transformation to the identity transformation. If the transform has an Input, then the transformation will be reset so that it is the same as the Input.  </li>
<li>
<code>obj.Inverse ()</code> - Invert the transformation. This will also set a flag so that the transformation will use the inverse of its Input, if an Input has been set.  </li>
<li>
<code>obj.Translate (double x, double y, double z)</code> - Create a translation matrix and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.  </li>
<li>
<code>obj.Translate (double x[3])</code> - Create a translation matrix and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.  </li>
<li>
<code>obj.Translate (float x[3])</code> - Create a translation matrix and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.  </li>
<li>
<code>obj.RotateWXYZ (double angle, double x, double y, double z)</code> - Create a rotation matrix and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics. The angle is in degrees, and (x,y,z) specifies the axis that the rotation will be performed around.  </li>
<li>
<code>obj.RotateWXYZ (double angle, double axis[3])</code> - Create a rotation matrix and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics. The angle is in degrees, and (x,y,z) specifies the axis that the rotation will be performed around.  </li>
<li>
<code>obj.RotateWXYZ (double angle, float axis[3])</code> - Create a rotation matrix and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics. The angle is in degrees, and (x,y,z) specifies the axis that the rotation will be performed around.  </li>
<li>
<code>obj.RotateX (double angle)</code> - Create a rotation matrix about the X, Y, or Z axis and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics. The angle is expressed in degrees.  </li>
<li>
<code>obj.RotateY (double angle)</code> - Create a rotation matrix about the X, Y, or Z axis and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics. The angle is expressed in degrees.  </li>
<li>
<code>obj.RotateZ (double angle)</code> - Create a rotation matrix about the X, Y, or Z axis and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics. The angle is expressed in degrees.  </li>
<li>
<code>obj.Scale (double x, double y, double z)</code> - Create a scale matrix (i.e. set the diagonal elements to x, y, z) and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.  </li>
<li>
<code>obj.Scale (double s[3])</code> - Create a scale matrix (i.e. set the diagonal elements to x, y, z) and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.  </li>
<li>
<code>obj.Scale (float s[3])</code> - Create a scale matrix (i.e. set the diagonal elements to x, y, z) and concatenate it with the current transformation according to PreMultiply or PostMultiply semantics.  </li>
<li>
<code>obj.Concatenate (vtkMatrix4x4 matrix)</code> - Concatenates the matrix with the current transformation according to PreMultiply or PostMultiply semantics.  </li>
<li>
<code>obj.Concatenate (double elements[16])</code> - Concatenates the matrix with the current transformation according to PreMultiply or PostMultiply semantics.  </li>
<li>
<code>obj.Concatenate (vtkAbstractTransform transform)</code> - Concatenate the specified transform with the current transformation according to PreMultiply or PostMultiply semantics. The concatenation is pipelined, meaning that if any of the transformations are changed, even after Concatenate() is called, those changes will be reflected when you call TransformPoint().  </li>
<li>
<code>obj.PreMultiply ()</code> - Sets the internal state of the transform to PreMultiply. All subsequent operations will occur before those already represented in the current transformation. In homogeneous matrix notation, M = M*A where M is the current transformation matrix and A is the applied matrix. The default is PreMultiply.  </li>
<li>
<code>obj.PostMultiply ()</code> - Sets the internal state of the transform to PostMultiply. All subsequent operations will occur after those already represented in the current transformation. In homogeneous matrix notation, M = A*M where M is the current transformation matrix and A is the applied matrix. The default is PreMultiply.  </li>
<li>
<code>int = obj.GetNumberOfConcatenatedTransforms ()</code> - Get the total number of transformations that are linked into this one via Concatenate() operations or via SetInput().  </li>
<li>
<code>vtkAbstractTransform = obj.GetConcatenatedTransform (int i)</code>  </li>
<li>
<code>obj.SetInput (vtkAbstractTransform input)</code> - Set the input for this transformation. This will be used as the base transformation if it is set. This method allows you to build a transform pipeline: if the input is modified, then this transformation will automatically update accordingly. Note that the InverseFlag, controlled via Inverse(), determines whether this transformation will use the Input or the inverse of the Input.  </li>
<li>
<code>vtkAbstractTransform = obj.GetInput ()</code> - Set the input for this transformation. This will be used as the base transformation if it is set. This method allows you to build a transform pipeline: if the input is modified, then this transformation will automatically update accordingly. Note that the InverseFlag, controlled via Inverse(), determines whether this transformation will use the Input or the inverse of the Input.  </li>
<li>
<code>int = obj.GetInverseFlag ()</code> - Get the inverse flag of the transformation. This controls whether it is the Input or the inverse of the Input that is used as the base transformation. The InverseFlag is flipped every time Inverse() is called. The InverseFlag is off when a transform is first created.  </li>
<li>
<code>obj.Push ()</code> - Pushes the current transformation onto the transformation stack.  </li>
<li>
<code>obj.Pop ()</code> - Deletes the transformation on the top of the stack and sets the top to the next transformation on the stack.  </li>
<li>
<code>obj.InternalTransformPoint (float in[3], float out[3])</code> - This will calculate the transformation without calling Update. Meant for use only within other VTK classes.  </li>
<li>
<code>obj.InternalTransformPoint (double in[3], double out[3])</code> - This will calculate the transformation without calling Update. Meant for use only within other VTK classes.  </li>
<li>
<code>int = obj.CircuitCheck (vtkAbstractTransform transform)</code> - Check for self-reference. Will return true if concatenating with the specified transform, setting it to be our inverse, or setting it to be our input will create a circular reference. CircuitCheck is automatically called by SetInput(), SetInverse(), and Concatenate(vtkXTransform *). Avoid using this function, it is experimental.  </li>
<li>
<code>vtkAbstractTransform = obj.MakeTransform ()</code> - Make another transform of the same type.  </li>
<li>
<code>long = obj.GetMTime ()</code> - Override GetMTime to account for input and concatenation.  </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkcommon.html">Visualization Toolkit Common Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:30 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

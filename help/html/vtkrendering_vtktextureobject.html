<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkTextureObject</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkrendering_vtktextureobject.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkTextureObject </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkrendering.html">Visualization Toolkit Rendering Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>vtkTextureObject represents an OpenGL texture object. It provides API to create textures using data already loaded into pixel buffer objects. It can also be used to create textures without uploading any data.</p>
<p>To create an instance of class vtkTextureObject, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkTextureObject
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkTextureObject has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkTextureObject class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkTextureObject = obj.NewInstance ()</code>  </li>
<li>
<code>vtkTextureObject = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>obj.SetContext (vtkRenderWindow )</code> - Get/Set the context. This does not increase the reference count of the context to avoid reference loops. SetContext() may raise an error is the OpenGL context does not support the required OpenGL extensions.  </li>
<li>
<code>vtkRenderWindow = obj.GetContext ()</code> - Get/Set the context. This does not increase the reference count of the context to avoid reference loops. SetContext() may raise an error is the OpenGL context does not support the required OpenGL extensions.  </li>
<li>
<code>int = obj.GetWidth ()</code> - Get the texture dimensions. These are the properties of the OpenGL texture this instance represents.  </li>
<li>
<code>int = obj.GetHeight ()</code> - Get the texture dimensions. These are the properties of the OpenGL texture this instance represents.  </li>
<li>
<code>int = obj.GetDepth ()</code> - Get the texture dimensions. These are the properties of the OpenGL texture this instance represents.  </li>
<li>
<code>int = obj.GetComponents ()</code> - Get the texture dimensions. These are the properties of the OpenGL texture this instance represents.  </li>
<li>
<code>int = obj.GetNumberOfDimensions ()</code>  </li>
<li>
<code>int = obj.GetTarget ()</code> - Returns OpenGL texture target to which the texture is/can be bound.  </li>
<li>
<code>int = obj.GetHandle ()</code> - Returns the OpenGL handle.  </li>
<li>
<code>obj.Bind ()</code> - Activate the texture. The texture must have been created using Create(). RenderWindow must be set before calling this.  </li>
<li>
<code>obj.UnBind ()</code> - Activate the texture. The texture must have been created using Create(). RenderWindow must be set before calling this.  </li>
<li>
<code>bool = obj.IsBound ()</code> - Tells if the texture object is bound to the active texture image unit. (a texture object can be bound to multiple texture image unit).  </li>
<li>
<code>obj.SendParameters ()</code> - Send all the texture object parameters to the hardware if not done yet. <dl class="section pre"><dt>Precondition:</dt><dd>is_bound: IsBound()  </dd></dl>
</li>
<li>
<code>bool = obj.Create1D (int numComps, vtkPixelBufferObject pbo, bool shaderSupportsTextureInt)</code> - Create a 1D texture using the PBO. Eventually we may start supporting creating a texture from subset of data in the PBO, but for simplicity we'll begin with entire PBO data. numComps must be in [1-4]. shaderSupportsTextureInt is true if the shader has an alternate implementation supporting sampler with integer values. Even if the card supports texture int, it does not mean that the implementor of the shader made a version that supports texture int.  </li>
<li>
<code>bool = obj.Create2D (int width, int height, int numComps, vtkPixelBufferObject pbo, bool shaderSupportsTextureInt)</code> - Create a 2D texture using the PBO. Eventually we may start supporting creating a texture from subset of data in the PBO, but for simplicity we'll begin with entire PBO data. numComps must be in [1-4].  </li>
<li>
<code>bool = obj.CreateDepth (int width, int height, int internalFormat, vtkPixelBufferObject pbo)</code> - Create a 2D depth texture using a PBO. <dl class="section pre"><dt>Precondition:</dt><dd>: valid_internalFormat: internalFormat&gt;=0 &amp;&amp; internalFormat&lt;NumberOfDepthFormats  </dd></dl>
</li>
<li>
<code>bool = obj.AllocateDepth (int width, int height, int internalFormat)</code> - Create a 2D depth texture but does not initialize its values.  </li>
<li>
<code>bool = obj.Allocate1D (int width, int numComps, int vtkType)</code> - Create a 1D color texture but does not initialize its values. Internal format is deduced from numComps and vtkType.  </li>
<li>
<code>bool = obj.Allocate2D (int width, int height, int numComps, int vtkType)</code> - Create a 2D color texture but does not initialize its values. Internal format is deduced from numComps and vtkType.  </li>
<li>
<code>bool = obj.Allocate3D (int width, int height, int depth, int numComps, int vtkType)</code> - Create a 3D color texture but does not initialize its values. Internal format is deduced from numComps and vtkType.  </li>
<li>
<code>bool = obj.Create3D (int width, int height, int depth, int numComps, vtkPixelBufferObject pbo, bool shaderSupportsTextureInt)</code> - Create a 3D texture using the PBO. Eventually we may start supporting creating a texture from subset of data in the PBO, but for simplicity we'll begin with entire PBO data. numComps must be in [1-4].  </li>
<li>
<code>bool = obj.Create2D (int width, int height, int numComps, int vtktype, bool shaderSupportsTextureInt)</code> - Create texture without uploading any data. To create a DEPTH_COMPONENT texture, vtktype must be set to VTK_VOID and numComps must be 1.  </li>
<li>
<code>bool = obj.Create3D (int width, int height, int depth, int numComps, int vtktype, bool shaderSupportsTextureInt)</code> - Create texture without uploading any data. To create a DEPTH_COMPONENT texture, vtktype must be set to VTK_VOID and numComps must be 1.  </li>
<li>
<code>vtkPixelBufferObject = obj.Download ()</code> - This is used to download raw data from the texture into a pixel bufer. The pixel buffer API can then be used to download the pixel buffer data to CPU arrays. The caller takes on the responsibility of deleting the returns vtkPixelBufferObject once it done with it.  </li>
<li>
<code>int = obj.GetDataType ()</code> - Get the data type for the texture as a vtk type int i.e. VTK_INT etc.  </li>
<li>
<code>int = obj.GetInternalFormat (int vtktype, int numComps, bool shaderSupportsTextureInt)</code>  </li>
<li>
<code>int = obj.GetFormat (int vtktype, int numComps, bool shaderSupportsTextureInt)</code>  </li>
<li>
<code>int = obj.GetWrapS ()</code> - Wrap mode for the first texture coordinate "s" Valid values are:<ul>
<li>Clamp</li>
<li>ClampToEdge</li>
<li>Repeat</li>
<li>ClampToBorder</li>
<li>MirroredRepeat Initial value is Repeat (as in OpenGL spec)  </li>
</ul>
</li>
<li>
<code>obj.SetWrapS (int )</code> - Wrap mode for the first texture coordinate "s" Valid values are:<ul>
<li>Clamp</li>
<li>ClampToEdge</li>
<li>Repeat</li>
<li>ClampToBorder</li>
<li>MirroredRepeat Initial value is Repeat (as in OpenGL spec)  </li>
</ul>
</li>
<li>
<code>int = obj.GetWrapT ()</code> - Wrap mode for the first texture coordinate "t" Valid values are:<ul>
<li>Clamp</li>
<li>ClampToEdge</li>
<li>Repeat</li>
<li>ClampToBorder</li>
<li>MirroredRepeat Initial value is Repeat (as in OpenGL spec)  </li>
</ul>
</li>
<li>
<code>obj.SetWrapT (int )</code> - Wrap mode for the first texture coordinate "t" Valid values are:<ul>
<li>Clamp</li>
<li>ClampToEdge</li>
<li>Repeat</li>
<li>ClampToBorder</li>
<li>MirroredRepeat Initial value is Repeat (as in OpenGL spec)  </li>
</ul>
</li>
<li>
<code>int = obj.GetWrapR ()</code> - Wrap mode for the first texture coordinate "r" Valid values are:<ul>
<li>Clamp</li>
<li>ClampToEdge</li>
<li>Repeat</li>
<li>ClampToBorder</li>
<li>MirroredRepeat Initial value is Repeat (as in OpenGL spec)  </li>
</ul>
</li>
<li>
<code>obj.SetWrapR (int )</code> - Wrap mode for the first texture coordinate "r" Valid values are:<ul>
<li>Clamp</li>
<li>ClampToEdge</li>
<li>Repeat</li>
<li>ClampToBorder</li>
<li>MirroredRepeat Initial value is Repeat (as in OpenGL spec)  </li>
</ul>
</li>
<li>
<code>int = obj.GetMinificationFilter ()</code> - Minification filter mode. Valid values are:<ul>
<li>Nearest</li>
<li>Linear</li>
<li>NearestMipmapNearest</li>
<li>NearestMipmapLinear</li>
<li>LinearMipmapNearest</li>
<li>LinearMipmapLinear Initial value is Nearest (note initial value in OpenGL spec is NearestMipMapLinear but this is error-prone because it makes the texture object incomplete. ).  </li>
</ul>
</li>
<li>
<code>obj.SetMinificationFilter (int )</code> - Minification filter mode. Valid values are:<ul>
<li>Nearest</li>
<li>Linear</li>
<li>NearestMipmapNearest</li>
<li>NearestMipmapLinear</li>
<li>LinearMipmapNearest</li>
<li>LinearMipmapLinear Initial value is Nearest (note initial value in OpenGL spec is NearestMipMapLinear but this is error-prone because it makes the texture object incomplete. ).  </li>
</ul>
</li>
<li>
<code>bool = obj.GetLinearMagnification ()</code> - Tells if the magnification mode is linear (true) or nearest (false). Initial value is false (initial value in OpenGL spec is true).  </li>
<li>
<code>obj.SetLinearMagnification (bool )</code> - Tells if the magnification mode is linear (true) or nearest (false). Initial value is false (initial value in OpenGL spec is true).  </li>
<li>
<code>obj.SetBorderColor (float , float , float , float )</code> - Border Color (RGBA). Each component is in [0.0f,1.0f]. Initial value is (0.0f,0.0f,0.0f,0.0f), as in OpenGL spec.  </li>
<li>
<code>obj.SetBorderColor (float a[4])</code> - Border Color (RGBA). Each component is in [0.0f,1.0f]. Initial value is (0.0f,0.0f,0.0f,0.0f), as in OpenGL spec.  </li>
<li>
<code>float = obj. GetBorderColor ()</code> - Border Color (RGBA). Each component is in [0.0f,1.0f]. Initial value is (0.0f,0.0f,0.0f,0.0f), as in OpenGL spec.  </li>
<li>
<code>obj.SetPriority (float )</code> - Priority of the texture object to be resident on the card for higher performance in the range [0.0f,1.0f]. Initial value is 1.0f, as in OpenGL spec.  </li>
<li>
<code>float = obj.GetPriority ()</code> - Priority of the texture object to be resident on the card for higher performance in the range [0.0f,1.0f]. Initial value is 1.0f, as in OpenGL spec.  </li>
<li>
<code>obj.SetMinLOD (float )</code> - Lower-clamp the computed LOD against this value. Any float value is valid. Initial value is -1000.0f, as in OpenGL spec.  </li>
<li>
<code>float = obj.GetMinLOD ()</code> - Lower-clamp the computed LOD against this value. Any float value is valid. Initial value is -1000.0f, as in OpenGL spec.  </li>
<li>
<code>obj.SetMaxLOD (float )</code> - Upper-clamp the computed LOD against this value. Any float value is valid. Initial value is 1000.0f, as in OpenGL spec.  </li>
<li>
<code>float = obj.GetMaxLOD ()</code> - Upper-clamp the computed LOD against this value. Any float value is valid. Initial value is 1000.0f, as in OpenGL spec.  </li>
<li>
<code>obj.SetBaseLevel (int )</code> - Level of detail of the first texture image. A texture object is a list of texture images. It is a non-negative integer value. Initial value is 0, as in OpenGL spec.  </li>
<li>
<code>int = obj.GetBaseLevel ()</code> - Level of detail of the first texture image. A texture object is a list of texture images. It is a non-negative integer value. Initial value is 0, as in OpenGL spec.  </li>
<li>
<code>obj.SetMaxLevel (int )</code> - Level of detail of the first texture image. A texture object is a list of texture images. It is a non-negative integer value. Initial value is 1000, as in OpenGL spec.  </li>
<li>
<code>int = obj.GetMaxLevel ()</code> - Level of detail of the first texture image. A texture object is a list of texture images. It is a non-negative integer value. Initial value is 1000, as in OpenGL spec.  </li>
<li>
<code>bool = obj.GetDepthTextureCompare ()</code> - Tells if the output of a texture unit with a depth texture uses comparison or not. Comparison happens between D_t the depth texture value in the range [0,1] and with R the interpolated third texture coordinate clamped to range [0,1]. The result of the comparison is noted `r'. If this flag is false, r=D_t. Initial value is false, as in OpenGL spec. Ignored if the texture object is not a depth texture.  </li>
<li>
<code>obj.SetDepthTextureCompare (bool )</code> - Tells if the output of a texture unit with a depth texture uses comparison or not. Comparison happens between D_t the depth texture value in the range [0,1] and with R the interpolated third texture coordinate clamped to range [0,1]. The result of the comparison is noted `r'. If this flag is false, r=D_t. Initial value is false, as in OpenGL spec. Ignored if the texture object is not a depth texture.  </li>
<li>
<code>int = obj.GetDepthTextureCompareFunction ()</code> - In case DepthTextureCompare is true, specify the comparison function in use. The result of the comparison is noted `r'. Valid values are:<ul>
<li>Value</li>
<li>Lequal: r=R&lt;=Dt ? 1.0 : 0.0</li>
<li>Gequal: r=R&gt;=Dt ? 1.0 : 0.0</li>
<li>Less: r=R&lt;D_t ? 1.0 : 0.0</li>
<li>Greater: r=R&gt;Dt ? 1.0 : 0.0</li>
<li>Equal: r=R==Dt ? 1.0 : 0.0</li>
<li>NotEqual: r=R!=Dt ? 1.0 : 0.0</li>
<li>AlwaysTrue: r=1.0</li>
<li>Never: r=0.0 If the magnification of minification factor are not nearest, percentage closer filtering (PCF) is used: R is compared to several D_t and r is the average of the comparisons (it is NOT the average of D_t compared once to R). Initial value is Lequal, as in OpenGL spec. Ignored if the texture object is not a depth texture.  </li>
</ul>
</li>
<li>
<code>obj.SetDepthTextureCompareFunction (int )</code> - In case DepthTextureCompare is true, specify the comparison function in use. The result of the comparison is noted `r'. Valid values are:<ul>
<li>Value</li>
<li>Lequal: r=R&lt;=Dt ? 1.0 : 0.0</li>
<li>Gequal: r=R&gt;=Dt ? 1.0 : 0.0</li>
<li>Less: r=R&lt;D_t ? 1.0 : 0.0</li>
<li>Greater: r=R&gt;Dt ? 1.0 : 0.0</li>
<li>Equal: r=R==Dt ? 1.0 : 0.0</li>
<li>NotEqual: r=R!=Dt ? 1.0 : 0.0</li>
<li>AlwaysTrue: r=1.0</li>
<li>Never: r=0.0 If the magnification of minification factor are not nearest, percentage closer filtering (PCF) is used: R is compared to several D_t and r is the average of the comparisons (it is NOT the average of D_t compared once to R). Initial value is Lequal, as in OpenGL spec. Ignored if the texture object is not a depth texture.  </li>
</ul>
</li>
<li>
<code>int = obj.GetDepthTextureMode ()</code> - Defines the mapping from depth component `r' to RGBA components. Ignored if the texture object is not a depth texture. Valid modes are:<ul>
<li>Luminance: (R,G,B,A)=(r,r,r,1)</li>
<li>Intensity: (R,G,B,A)=(r,r,r,r)</li>
<li>Alpha: (R.G.B.A)=(0,0,0,r) Initial value is Luminance, as in OpenGL spec.  </li>
</ul>
</li>
<li>
<code>obj.SetDepthTextureMode (int )</code> - Defines the mapping from depth component `r' to RGBA components. Ignored if the texture object is not a depth texture. Valid modes are:<ul>
<li>Luminance: (R,G,B,A)=(r,r,r,1)</li>
<li>Intensity: (R,G,B,A)=(r,r,r,r)</li>
<li>Alpha: (R.G.B.A)=(0,0,0,r) Initial value is Luminance, as in OpenGL spec.  </li>
</ul>
</li>
<li>
<code>bool = obj.GetGenerateMipmap ()</code> - Tells the hardware to generate mipmap textures from the first texture image at BaseLevel. Initial value is false, as in OpenGL spec.  </li>
<li>
<code>obj.SetGenerateMipmap (bool )</code> - Tells the hardware to generate mipmap textures from the first texture image at BaseLevel. Initial value is false, as in OpenGL spec.  </li>
<li>
<code>obj.CopyToFrameBuffer (int srcXmin, int srcYmin, int srcXmax, int srcYmax, int dstXmin, int dstYmin, int width, int height)</code> - Copy a sub-part of the texture (src) in the current framebuffer at location (dstXmin,dstYmin). (dstXmin,dstYmin) is the location of the lower left corner of the rectangle. width and height are the dimensions of the framebuffer.<ul>
<li>texture coordinates are sent on texture coordinate processing unit 0.</li>
<li>if the fixed-pipeline fragment shader is used, texturing has to be set on texture image unit 0 and the texture object has to be bound on texture image unit 0.</li>
<li>if a customized fragment shader is used, you are free to pick the texture image unit you want. You can even have multiple texture objects attached on multiple texture image units. In this case, you call this method only on one of them. <dl class="section pre"><dt>Precondition:</dt><dd>positive_srcXmin: srcXmin&gt;=0 </dd>
<dd>
max_srcXmax: srcXmax&lt;this-&gt;GetWidth() </dd>
<dd>
increasing_x: srcXmin&lt;=srcXmax </dd>
<dd>
positive_srcYmin: srcYmin&gt;=0 </dd>
<dd>
max_srcYmax: srcYmax&lt;this-&gt;GetHeight() </dd>
<dd>
increasing_y: srcYmin&lt;=srcYmax </dd>
<dd>
positive_dstXmin: dstXmin&gt;=0 </dd>
<dd>
positive_dstYmin: dstYmin&gt;=0 </dd>
<dd>
positive_width: width&gt;0 </dd>
<dd>
positive_height: height&gt;0 </dd>
<dd>
x_fit: destXmin+(srcXmax-srcXmin)&lt;width </dd>
<dd>
y_fit: destYmin+(srcYmax-srcYmin)&lt;height  </dd></dl>
</li>
</ul>
</li>
<li>
<code>obj.CopyFromFrameBuffer (int srcXmin, int srcYmin, int dstXmin, int dstYmin, int width, int height)</code> - Copy a sub-part of a logical buffer of the framebuffer (color or depth) to the texture object. src is the framebuffer, dst is the texture. (srcXmin,srcYmin) is the location of the lower left corner of the rectangle in the framebuffer. (dstXmin,dstYmin) is the location of the lower left corner of the rectangle in the texture. width and height specifies the size of the rectangle in pixels. If the logical buffer is a color buffer, it has to be selected first with glReadBuffer(). <dl class="section pre"><dt>Precondition:</dt><dd>is2D: GetNumberOfDimensions()==2  </dd></dl>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkrendering.html">Visualization Toolkit Rendering Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:35 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

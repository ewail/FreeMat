<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkHyperOctree</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkfiltering_vtkhyperoctree.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkHyperOctree </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkfiltering.html">Visualization Toolkit Filtering Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>An hyperoctree is a dataset where each node has either exactly 2^n children or no child at all if the node is a leaf. `n' is the dimension of the dataset (1 (binary tree), 2 (quadtree) or 3 (octree) ). The class name comes from the following paper:</p>
<pre class="fragment"> @ARTICLE{yau-srihari-1983,
  author={Mann-May Yau and Sargur N. Srihari},
  title={A Hierarchical Data Structure for Multidimensional Digital Images},
  journal={Communications of the ACM},
  month={July},
  year={1983},
  volume={26},
  number={7},
  pages={504--515}
  }</pre><p>Each node is a cell. Attributes are associated with cells, not with points. The geometry is implicitly given by the size of the root node on each axis and position of the center and the orientation. (TODO: review center position and orientation). The geometry is then not limited to an hybercube but can have a rectangular shape. Attributes are associated with leaves. For LOD (Level-Of-Detail) purpose, attributes can be computed on none-leaf nodes by computing the average values from its children (which can be leaves or not).</p>
<p>By construction, an hyperoctree is efficient in memory usage when the geometry is sparse. The LOD feature allows to cull quickly part of the dataset.</p>
<p>A couple of filters can be applied on this dataset: contour, outline, geometry.</p>
<p>3D case (octree) for each node, each child index (from 0 to 7) is encoded in the following orientation. It is easy to access each child as a cell of a grid. Note also that the binary representation is relevant, each bit code a side: bit 0 encodes -x side (0) or +x side (1) bit 1 encodes -y side (0) or +y side (1) bit 2 encodes -z side (0) or +z side (2)</p>
<ul>
<li>the -z side first</li>
<li>0: -y -x sides</li>
<li>1: -y +x sides</li>
<li>2: +y -x sides</li>
<li>3: +y +x sides <pre class="fragment">              +y
 +-+-+        ^
 |2|3|        |
 +-+-+  O +z  +-&gt; +x
 |0|1|
 +-+-+</pre></li>
</ul>
<ul>
<li>then the +z side, in counter-clockwise</li>
<li>4: -y -x sides</li>
<li>5: -y +x sides</li>
<li>6: +y -x sides</li>
<li>7: +y +x sides <pre class="fragment">              +y
 +-+-+        ^
 |6|7|        |
 +-+-+  O +z  +-&gt; +x
 |4|5|
 +-+-+</pre></li>
</ul>
<p>The cases with fewer dimensions are consistent with the octree case:</p>
<p>Quadtree: in counter-clockwise</p>
<ul>
<li>0: -y -x edges</li>
<li>1: -y +x edges</li>
<li>2: +y -x edges</li>
<li><p class="startli">3: +y +x edges </p>
<pre class="fragment">         +y
 +-+-+   ^
 |2|3|   |
 +-+-+  O+-&gt; +x
 |0|1|
 +-+-+</pre><p class="startli">Binary tree: </p>
<pre class="fragment"> +0+1+  O+-&gt; +x</pre></li>
</ul>
<p>To create an instance of class vtkHyperOctree, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkHyperOctree
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkHyperOctree has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkHyperOctree class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkHyperOctree = obj.NewInstance ()</code>  </li>
<li>
<code>vtkHyperOctree = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>int = obj.GetDataObjectType ()</code> - Return what type of dataset this is.  </li>
<li>
<code>obj.CopyStructure (vtkDataSet ds)</code> - Copy the geometric and topological structure of an input rectilinear grid object.  </li>
<li>
<code>int = obj.GetDimension ()</code> - Return the dimension of the tree (1D:binary tree(2 children), 2D:quadtree(4 children), 3D:octree (8 children)) <dl class="section post"><dt>Postcondition:</dt><dd>valid_result: result&gt;=1 &amp;&amp; result&lt;=3  </dd></dl>
</li>
<li>
<code>obj.SetDimension (int dim)</code> - Set the dimension of the tree with `dim'. See GetDimension() for details. <dl class="section pre"><dt>Precondition:</dt><dd>valid_dim: dim&gt;=1 &amp;&amp; dim&lt;=3 </dd></dl>
<dl class="section post"><dt>Postcondition:</dt><dd>dimension_is_set: GetDimension()==dim  </dd></dl>
</li>
<li>
<code>vtkIdType = obj.GetNumberOfCells ()</code> - Return the number of cells in the dual grid. <dl class="section post"><dt>Postcondition:</dt><dd>positive_result: result&gt;=0  </dd></dl>
</li>
<li>
<code>vtkIdType = obj.GetNumberOfLeaves ()</code> - Get the number of leaves in the tree.  </li>
<li>
<code>vtkIdType = obj.GetNumberOfPoints ()</code> - Return the number of points in the dual grid. <dl class="section post"><dt>Postcondition:</dt><dd>positive_result: result&gt;=0  </dd></dl>
</li>
<li>
<code>vtkIdType = obj.GetMaxNumberOfPoints (int level)</code> - Return the number of points corresponding to an hyperoctree starting at level `level' where all the leaves at at the last level. In this case, the hyperoctree is like a uniform grid. So this number is the number of points of the uniform grid. <dl class="section pre"><dt>Precondition:</dt><dd>positive_level: level&gt;=0 &amp;&amp; level&lt;this-&gt;GetNumberOfLevels() </dd></dl>
<dl class="section post"><dt>Postcondition:</dt><dd>definition: result==(2^(GetNumberOfLevels()-level-1)+1)^GetDimension()  </dd></dl>
</li>
<li>
<code>vtkIdType = obj.GetMaxNumberOfPointsOnBoundary (int level)</code> - Return the number of points corresponding to the boundary of an hyperoctree starting at level `level' where all the leaves at at the last level. In this case, the hyperoctree is like a uniform grid. So this number is the number of points of on the boundary of the uniform grid. For an octree, the boundary are the faces. For a quadtree, the boundary are the edges. <dl class="section pre"><dt>Precondition:</dt><dd>2d_or_3d: this-&gt;GetDimension()==2 || this-&gt;GetDimension()==3 </dd>
<dd>
positive_level: level&gt;=0 &amp;&amp; level&lt;this-&gt;GetNumberOfLevels() </dd></dl>
<dl class="section post"><dt>Postcondition:</dt><dd>min_result: result&gt;=GetMaxNumberOfPoints(this-&gt;GetNumberOfLevels()-1) </dd>
<dd>
max_result: result&lt;=GetMaxNumberOfPoints(level)  </dd></dl>
</li>
<li>
<code>vtkIdType = obj.GetMaxNumberOfCellsOnBoundary (int level)</code> - Return the number of cells corresponding to the boundary of a cell of level `level' where all the leaves at at the last level. <dl class="section pre"><dt>Precondition:</dt><dd>positive_level: level&gt;=0 &amp;&amp; level&lt;this-&gt;GetNumberOfLevels() </dd></dl>
<dl class="section post"><dt>Postcondition:</dt><dd>positive_result: result&gt;=0  </dd></dl>
</li>
<li>
<code>vtkIdType = obj.GetNumberOfLevels ()</code> - Return the number of levels. <dl class="section post"><dt>Postcondition:</dt><dd>result_greater_or_equal_to_one: result&gt;=1  </dd></dl>
</li>
<li>
<code>obj.SetSize (double , double , double )</code> - Set the size on each axis.  </li>
<li>
<code>obj.SetSize (double a[3])</code> - Set the size on each axis.  </li>
<li>
<code>double = obj. GetSize ()</code> - Return the size on each axis.  </li>
<li>
<code>obj.SetOrigin (double , double , double )</code> - Set the origin (position of corner (0,0,0) of the root.  </li>
<li>
<code>obj.SetOrigin (double a[3])</code> - Set the origin (position of corner (0,0,0) of the root.  </li>
<li>
<code>double = obj. GetOrigin ()</code> - Set the origin (position of corner (0,0,0) of the root. Return the origin (position of corner (0,0,0) ) of the root.  </li>
<li>
<code>vtkHyperOctreeCursor = obj.NewCellCursor ()</code> - Create a new cursor: an object that can traverse the cell of an hyperoctree. <dl class="section post"><dt>Postcondition:</dt><dd>result_exists: result!=0  </dd></dl>
</li>
<li>
<code>obj.SubdivideLeaf (vtkHyperOctreeCursor leaf)</code> - Subdivide node pointed by cursor, only if its a leaf. At the end, cursor points on the node that used to be leaf. <dl class="section pre"><dt>Precondition:</dt><dd>leaf_exists: leaf!=0 </dd>
<dd>
is_a_leaf: leaf-&gt;CurrentIsLeaf()  </dd></dl>
</li>
<li>
<code>obj.CollapseTerminalNode (vtkHyperOctreeCursor node)</code> - Collapse a node for which all children are leaves. At the end, cursor points on the leaf that used to be a node. <dl class="section pre"><dt>Precondition:</dt><dd>node_exists: node!=0 </dd>
<dd>
node_is_node: !node-&gt;CurrentIsLeaf() </dd>
<dd>
children_are_leaves: node-&gt;CurrentIsTerminalNode()  </dd></dl>
</li>
<li>
<code>double = obj.GetPoint (vtkIdType ptId)</code> - Get point coordinates with ptId such that: 0 &lt;= ptId &lt; NumberOfPoints. THIS METHOD IS NOT THREAD SAFE.  </li>
<li>
<code>obj.GetPoint (vtkIdType id, double x[3])</code> - Copy point coordinates into user provided array x[3] for specified point id. THIS METHOD IS THREAD SAFE IF FIRST CALLED FROM A SINGLE THREAD AND THE DATASET IS NOT MODIFIED  </li>
<li>
<code>vtkCell = obj.GetCell (vtkIdType cellId)</code> - Get cell with cellId such that: 0 &lt;= cellId &lt; NumberOfCells. THIS METHOD IS NOT THREAD SAFE.  </li>
<li>
<code>obj.GetCell (vtkIdType cellId, vtkGenericCell cell)</code> - Get cell with cellId such that: 0 &lt;= cellId &lt; NumberOfCells. This is a thread-safe alternative to the previous GetCell() method. THIS METHOD IS THREAD SAFE IF FIRST CALLED FROM A SINGLE THREAD AND THE DATASET IS NOT MODIFIED  </li>
<li>
<code>int = obj.GetCellType (vtkIdType cellId)</code> - Get type of cell with cellId such that: 0 &lt;= cellId &lt; NumberOfCells. THIS METHOD IS THREAD SAFE IF FIRST CALLED FROM A SINGLE THREAD AND THE DATASET IS NOT MODIFIED  </li>
<li>
<code>obj.GetCellPoints (vtkIdType cellId, vtkIdList ptIds)</code> - Topological inquiry to get points defining cell. THIS METHOD IS THREAD SAFE IF FIRST CALLED FROM A SINGLE THREAD AND THE DATASET IS NOT MODIFIED  </li>
<li>
<code>obj.GetPointCells (vtkIdType ptId, vtkIdList cellIds)</code> - Topological inquiry to get cells using point. THIS METHOD IS THREAD SAFE IF FIRST CALLED FROM A SINGLE THREAD AND THE DATASET IS NOT MODIFIED  </li>
<li>
<code>obj.GetCellNeighbors (vtkIdType cellId, vtkIdList ptIds, vtkIdList cellIds)</code> - Topological inquiry to get all cells using list of points exclusive of cell specified (e.g., cellId). Note that the list consists of only cells that use ALL the points provided. THIS METHOD IS THREAD SAFE IF FIRST CALLED FROM A SINGLE THREAD AND THE DATASET IS NOT MODIFIED  </li>
<li>
<code>vtkIdType = obj.FindPoint (double x[3])</code>  </li>
<li>
<code>obj.Initialize ()</code> - Restore data object to initial state, THIS METHOD IS NOT THREAD SAFE.  </li>
<li>
<code>int = obj.GetMaxCellSize ()</code> - Convenience method returns largest cell size in dataset. This is generally used to allocate memory for supporting data structures. This is the number of points of a cell. THIS METHOD IS THREAD SAFE  </li>
<li>
<code>obj.ShallowCopy (vtkDataObject src)</code> - Shallow and Deep copy.  </li>
<li>
<code>obj.DeepCopy (vtkDataObject src)</code> - Shallow and Deep copy.  </li>
<li>
<code>obj.GetPointsOnFace (vtkHyperOctreeCursor sibling, int face, int level, vtkHyperOctreePointsGrabber grabber)</code> - Get the points of node `sibling' on its face `face'. <dl class="section pre"><dt>Precondition:</dt><dd>sibling_exists: sibling!=0 </dd>
<dd>
sibling_not_leaf: !sibling-&gt;CurrentIsLeaf() </dd>
<dd>
sibling_3d: sibling-&gt;GetDimension()==3 </dd>
<dd>
valid_face: face&gt;=0 &amp;&amp; face&lt;6 </dd>
<dd>
valid_level_not_leaf: level&gt;=0 level&lt;(this-&gt;GetNumberOfLevels()-1)  </dd></dl>
</li>
<li>
<code>obj.GetPointsOnParentFaces (int faces[3], int level, vtkHyperOctreeCursor cursor, vtkHyperOctreePointsGrabber grabber)</code> - Get the points of the parent node of `cursor' on its faces `faces' at level `level' or deeper. <dl class="section pre"><dt>Precondition:</dt><dd>cursor_exists: cursor!=0 </dd>
<dd>
cursor_3d: cursor-&gt;GetDimension()==3 </dd>
<dd>
valid_level: level&gt;=0 </dd>
<dd>
boolean_faces: (faces[0]==0 || faces[0]==1) &amp;&amp; (faces[1]==0 || faces[1]==1) &amp;&amp; (faces[2]==0 || faces[2]==1)  </dd></dl>
</li>
<li>
<code>obj.GetPointsOnEdge (vtkHyperOctreeCursor sibling, int level, int axis, int k, int j, vtkHyperOctreePointsGrabber grabber)</code> - Get the points of node `sibling' on its edge `axis','k','j'. If axis==0, the edge is X-aligned and k gives the z coordinate and j the y-coordinate. If axis==1, the edge is Y-aligned and k gives the x coordinate and j the z coordinate. If axis==2, the edge is Z-aligned and k gives the y coordinate and j the x coordinate. <dl class="section pre"><dt>Precondition:</dt><dd>sibling_exists: sibling!=0 </dd>
<dd>
sibling_3d: sibling-&gt;GetDimension()==3 </dd>
<dd>
sibling_not_leaf: !sibling-&gt;CurrentIsLeaf() </dd>
<dd>
valid_axis: axis&gt;=0 &amp;&amp; axis&lt;3 </dd>
<dd>
valid_k: k&gt;=0 &amp;&amp; k&lt;=1 </dd>
<dd>
valid_j: j&gt;=0 &amp;&amp; j&lt;=1 </dd>
<dd>
valid_level_not_leaf: level&gt;=0 level&lt;(this-&gt;Input-&gt;GetNumberOfLevels()-1)  </dd></dl>
</li>
<li>
<code>obj.GetPointsOnParentEdge (vtkHyperOctreeCursor cursor, int level, int axis, int k, int j, vtkHyperOctreePointsGrabber grabber)</code> - Get the points of the parent node of `cursor' on its edge `axis','k','j' at level `level' or deeper. If axis==0, the edge is X-aligned and k gives the z coordinate and j the y-coordinate. If axis==1, the edge is Y-aligned and k gives the x coordinate and j the z coordinate. If axis==2, the edge is Z-aligned and k gives the y coordinate and j the x coordinate. <dl class="section pre"><dt>Precondition:</dt><dd>cursor_exists: cursor!=0 </dd>
<dd>
cursor_3d: cursor-&gt;GetDimension()==3 </dd>
<dd>
valid_level: level&gt;=0 </dd>
<dd>
valid_range_axis: axis&gt;=0 &amp;&amp; axis&lt;3 </dd>
<dd>
valid_range_k: k&gt;=0 &amp;&amp; k&lt;=1 </dd>
<dd>
valid_range_j: j&gt;=0 &amp;&amp; j&lt;=1  </dd></dl>
</li>
<li>
<code>obj.GetPointsOnEdge2D (vtkHyperOctreeCursor sibling, int edge, int level, vtkHyperOctreePointsGrabber grabber)</code> - Get the points of node `sibling' on its edge `edge'. <dl class="section pre"><dt>Precondition:</dt><dd>sibling_exists: sibling!=0 </dd>
<dd>
sibling_not_leaf: !sibling-&gt;CurrentIsLeaf() </dd>
<dd>
sibling_2d: sibling-&gt;GetDimension()==2 </dd>
<dd>
valid_edge: edge&gt;=0 &amp;&amp; edge&lt;4 </dd>
<dd>
valid_level_not_leaf: level&gt;=0 level&lt;(this-&gt;Input-&gt;GetNumberOfLevels()-1)  </dd></dl>
</li>
<li>
<code>obj.GetPointsOnParentEdge2D (vtkHyperOctreeCursor cursor, int edge, int level, vtkHyperOctreePointsGrabber grabber)</code> - Get the points of the parent node of `cursor' on its edge `edge' at level `level' or deeper. (edge=0 for -X, 1 for +X, 2 for -Y, 3 for +Y) <dl class="section pre"><dt>Precondition:</dt><dd>cursor_exists: cursor!=0 </dd>
<dd>
cursor_2d: cursor-&gt;GetDimension()==2 </dd>
<dd>
valid_level: level&gt;=0 </dd>
<dd>
valid_edge: edge&gt;=0 &amp;&amp; edge&lt;4  </dd></dl>
</li>
<li>
<code>vtkDataSetAttributes = obj.GetLeafData ()</code> - A generic way to set the leaf data attributes. This can be either point data for dual or cell data for normal grid.  </li>
<li>
<code>obj.SetDualGridFlag (int flag)</code> - Switch between returning leaves as cells, or the dual grid.  </li>
<li>
<code>int = obj.GetDualGridFlag ()</code> - Switch between returning leaves as cells, or the dual grid.  </li>
<li>
<code>long = obj.GetActualMemorySize ()</code> - Return the actual size of the data in kilobytes. This number is valid only after the pipeline has updated. The memory size returned is guaranteed to be greater than or equal to the memory required to represent the data (e.g., extra space in arrays, etc. are not included in the return value). THIS METHOD IS THREAD SAFE.  </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkfiltering.html">Visualization Toolkit Filtering Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:30 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

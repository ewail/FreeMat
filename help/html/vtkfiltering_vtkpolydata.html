<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkPolyData</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkfiltering_vtkpolydata.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkPolyData </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkfiltering.html">Visualization Toolkit Filtering Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>vtkPolyData is a data object that is a concrete implementation of vtkDataSet. vtkPolyData represents a geometric structure consisting of vertices, lines, polygons, and/or triangle strips. Point and cell attribute values (e.g., scalars, vectors, etc.) also are represented.</p>
<p>The actual cell types (vtkCellType.h) supported by vtkPolyData are: vtkVertex, vtkPolyVertex, vtkLine, vtkPolyLine, vtkTriangle, vtkQuad, vtkPolygon, and vtkTriangleStrip.</p>
<p>One important feature of vtkPolyData objects is that special traversal and data manipulation methods are available to process data. These methods are generally more efficient than vtkDataSet methods and should be used whenever possible. For example, traversing the cells in a dataset we would use GetCell(). To traverse cells with vtkPolyData we would retrieve the cell array object representing polygons (for example using GetPolys()) and then use vtkCellArray's InitTraversal() and GetNextCell() methods.</p>
<p>To create an instance of class vtkPolyData, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkPolyData
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkPolyData has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkPolyData class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkPolyData = obj.NewInstance ()</code>  </li>
<li>
<code>vtkPolyData = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>int = obj.GetDataObjectType ()</code> - Copy the geometric and topological structure of an input poly data object.  </li>
<li>
<code>obj.CopyStructure (vtkDataSet ds)</code> - Copy the geometric and topological structure of an input poly data object.  </li>
<li>
<code>vtkIdType = obj.GetNumberOfCells ()</code> - Standard vtkDataSet interface.  </li>
<li>
<code>vtkCell = obj.GetCell (vtkIdType cellId)</code> - Standard vtkDataSet interface.  </li>
<li>
<code>obj.GetCell (vtkIdType cellId, vtkGenericCell cell)</code> - Standard vtkDataSet interface.  </li>
<li>
<code>int = obj.GetCellType (vtkIdType cellId)</code> - Standard vtkDataSet interface.  </li>
<li>
<code>obj.GetCellBounds (vtkIdType cellId, double bounds[6])</code> - Standard vtkDataSet interface.  </li>
<li>
<code>obj.GetCellNeighbors (vtkIdType cellId, vtkIdList ptIds, vtkIdList cellIds)</code> - Standard vtkDataSet interface.  </li>
<li>
<code>obj.CopyCells (vtkPolyData pd, vtkIdList idList, vtkPointLocator locatorNULL)</code> - Copy cells listed in idList from pd, including points, point data, and cell data. This method assumes that point and cell data have been allocated. If you pass in a point locator, then the points won't be duplicated in the output.  </li>
<li>
<code>obj.GetCellPoints (vtkIdType cellId, vtkIdList ptIds)</code> - Copy a cells point ids into list provided. (Less efficient.)  </li>
<li>
<code>obj.GetPointCells (vtkIdType ptId, vtkIdList cellIds)</code> - Efficient method to obtain cells using a particular point. Make sure that routine BuildLinks() has been called.  </li>
<li>
<code>obj.ComputeBounds ()</code> - Compute the (X, Y, Z) bounds of the data.  </li>
<li>
<code>obj.Squeeze ()</code> - Recover extra allocated memory when creating data whose initial size is unknown. Examples include using the InsertNextCell() method, or when using the CellArray::EstimateSize() method to create vertices, lines, polygons, or triangle strips.  </li>
<li>
<code>int = obj.GetMaxCellSize ()</code> - Return the maximum cell size in this poly data.  </li>
<li>
<code>obj.SetVerts (vtkCellArray v)</code> - Set the cell array defining vertices.  </li>
<li>
<code>vtkCellArray = obj.GetVerts ()</code> - Get the cell array defining vertices. If there are no vertices, an empty array will be returned (convenience to simplify traversal).  </li>
<li>
<code>obj.SetLines (vtkCellArray l)</code> - Set the cell array defining lines.  </li>
<li>
<code>vtkCellArray = obj.GetLines ()</code> - Get the cell array defining lines. If there are no lines, an empty array will be returned (convenience to simplify traversal).  </li>
<li>
<code>obj.SetPolys (vtkCellArray p)</code> - Set the cell array defining polygons.  </li>
<li>
<code>vtkCellArray = obj.GetPolys ()</code> - Get the cell array defining polygons. If there are no polygons, an empty array will be returned (convenience to simplify traversal).  </li>
<li>
<code>obj.SetStrips (vtkCellArray s)</code> - Set the cell array defining triangle strips.  </li>
<li>
<code>vtkCellArray = obj.GetStrips ()</code> - Get the cell array defining triangle strips. If there are no triangle strips, an empty array will be returned (convenience to simplify traversal).  </li>
<li>
<code>vtkIdType = obj.GetNumberOfVerts ()</code> - Return the number of primitives of a particular type held..  </li>
<li>
<code>vtkIdType = obj.GetNumberOfLines ()</code> - Return the number of primitives of a particular type held..  </li>
<li>
<code>vtkIdType = obj.GetNumberOfPolys ()</code> - Return the number of primitives of a particular type held..  </li>
<li>
<code>vtkIdType = obj.GetNumberOfStrips ()</code> - Return the number of primitives of a particular type held..  </li>
<li>
<code>obj.Allocate (vtkIdType numCells, int extSize)</code> - Method allocates initial storage for vertex, line, polygon, and triangle strip arrays. Use this method before the method PolyData::InsertNextCell(). (Or, provide vertex, line, polygon, and triangle strip cell arrays.)  </li>
<li>
<code>obj.Allocate (vtkPolyData inPolyData, vtkIdType numCells, int extSize)</code> - Similar to the method above, this method allocates initial storage for vertex, line, polygon, and triangle strip arrays. It does this more intelligently, examining the supplied inPolyData to determine whether to allocate the verts, lines, polys, and strips arrays. (These arrays are allocated only if there is data in the corresponding arrays in the inPolyData.) Caution: if the inPolyData has no verts, and after allocating with this method an PolyData::InsertNextCell() is invoked where a vertex is inserted, bad things will happen.  </li>
<li>
<code>int = obj.InsertNextCell (int type, vtkIdList pts)</code> - Insert a cell of type VTK_VERTEX, VTK_POLY_VERTEX, VTK_LINE, VTK_POLY_LINE, VTK_TRIANGLE, VTK_QUAD, VTK_POLYGON, or VTK_TRIANGLE_STRIP. Make sure that the PolyData::Allocate() function has been called first or that vertex, line, polygon, and triangle strip arrays have been supplied. Note: will also insert VTK_PIXEL, but converts it to VTK_QUAD.  </li>
<li>
<code>obj.Reset ()</code> - Begin inserting data all over again. Memory is not freed but otherwise objects are returned to their initial state.  </li>
<li>
<code>obj.BuildCells ()</code> - Create data structure that allows random access of cells.  </li>
<li>
<code>obj.BuildLinks (int initialSize)</code> - Create upward links from points to cells that use each point. Enables topologically complex queries. Normally the links array is allocated based on the number of points in the vtkPolyData. The optional initialSize parameter can be used to allocate a larger size initially.  </li>
<li>
<code>obj.DeleteCells ()</code> - Release data structure that allows random access of the cells. This must be done before a 2nd call to BuildLinks(). DeleteCells implicitly deletes the links as well since they are no longer valid.  </li>
<li>
<code>obj.DeleteLinks ()</code> - Release the upward links from point to cells that use each point.  </li>
<li>
<code>obj.GetCellEdgeNeighbors (vtkIdType cellId, vtkIdType p1, vtkIdType p2, vtkIdList cellIds)</code> - Get the neighbors at an edge. More efficient than the general GetCellNeighbors(). Assumes links have been built (with BuildLinks()), and looks specifically for edge neighbors.  </li>
<li>
<code>int = obj.IsTriangle (int v1, int v2, int v3)</code> - Given three vertices, determine whether it's a triangle. Make sure BuildLinks() has been called first.  </li>
<li>
<code>int = obj.IsEdge (vtkIdType p1, vtkIdType p2)</code> - Determine whether two points form an edge. If they do, return non-zero. By definition PolyVertex and PolyLine have no edges since 1-dimensional edges are only found on cells 2D and higher. Edges are defined as 1-D boundary entities to cells. Make sure BuildLinks() has been called first.  </li>
<li>
<code>int = obj.IsPointUsedByCell (vtkIdType ptId, vtkIdType cellId)</code> - Determine whether a point is used by a particular cell. If it is, return non-zero. Make sure BuildCells() has been called first.  </li>
<li>
<code>obj.ReplaceCellPoint (vtkIdType cellId, vtkIdType oldPtId, vtkIdType newPtId)</code> - Replace a point in the cell connectivity list with a different point.  </li>
<li>
<code>obj.ReverseCell (vtkIdType cellId)</code> - Reverse the order of point ids defining the cell.  </li>
<li>
<code>obj.DeletePoint (vtkIdType ptId)</code> - Mark a point/cell as deleted from this vtkPolyData.  </li>
<li>
<code>obj.DeleteCell (vtkIdType cellId)</code> - Mark a point/cell as deleted from this vtkPolyData.  </li>
<li>
<code>obj.RemoveDeletedCells ()</code> - The cells marked by calls to DeleteCell are stored in the Cell Array VTK_EMPTY_CELL, but they still exist in the polys array. Calling RemoveDeletedCells will travers the poly array and remove/compact the cell array as well as any cell data thus truly removing the cells from the polydata object. WARNING. This only handles the polys at the moment  </li>
<li>
<code>int = obj.InsertNextLinkedPoint (int numLinks)</code> - Add a point to the cell data structure (after cell pointers have been built). This method adds the point and then allocates memory for the links to the cells. (To use this method, make sure points are available and BuildLinks() has been invoked.) Of the two methods below, one inserts a point coordinate and the other just makes room for cell links.  </li>
<li>
<code>int = obj.InsertNextLinkedPoint (double x[3], int numLinks)</code> - Add a point to the cell data structure (after cell pointers have been built). This method adds the point and then allocates memory for the links to the cells. (To use this method, make sure points are available and BuildLinks() has been invoked.) Of the two methods below, one inserts a point coordinate and the other just makes room for cell links.  </li>
<li>
<code>obj.RemoveCellReference (vtkIdType cellId)</code> - Remove all references to cell in cell structure. This means the links from the cell's points to the cell are deleted. Memory is not reclaimed. Use the method ResizeCellList() to resize the link list from a point to its using cells. (This operator assumes BuildLinks() has been called.)  </li>
<li>
<code>obj.AddCellReference (vtkIdType cellId)</code> - Add references to cell in cell structure. This means the links from the cell's points to the cell are modified. Memory is not extended. Use the method ResizeCellList() to resize the link list from a point to its using cells. (This operator assumes BuildLinks() has been called.)  </li>
<li>
<code>obj.RemoveReferenceToCell (vtkIdType ptId, vtkIdType cellId)</code> - Remove a reference to a cell in a particular point's link list. You may also consider using RemoveCellReference() to remove the references from all the cell's points to the cell. This operator does not reallocate memory; use the operator ResizeCellList() to do this if necessary.  </li>
<li>
<code>obj.AddReferenceToCell (vtkIdType ptId, vtkIdType cellId)</code> - Add a reference to a cell in a particular point's link list. (You may also consider using AddCellReference() to add the references from all the cell's points to the cell.) This operator does not realloc memory; use the operator ResizeCellList() to do this if necessary.  </li>
<li>
<code>obj.ResizeCellList (vtkIdType ptId, int size)</code> - Resize the list of cells using a particular point. (This operator assumes that BuildLinks() has been called.)  </li>
<li>
<code>obj.Initialize ()</code> - Restore object to initial state. Release memory back to system.  </li>
<li>
<code>int = obj.GetUpdateExtent ()</code> - We need this here to avoid hiding superclass method  </li>
<li>
<code>obj.GetUpdateExtent (int extent[6])</code> - We need this here to avoid hiding superclass method  </li>
<li>
<code>int = obj.GetPiece ()</code> - Get the piece and the number of pieces. Similar to extent in 3D.  </li>
<li>
<code>int = obj.GetNumberOfPieces ()</code> - Get the piece and the number of pieces. Similar to extent in 3D.  </li>
<li>
<code>int = obj.GetGhostLevel ()</code> - Get the ghost level.  </li>
<li>
<code>long = obj.GetActualMemorySize ()</code> - Return the actual size of the data in kilobytes. This number is valid only after the pipeline has updated. The memory size returned is guaranteed to be greater than or equal to the memory required to represent the data (e.g., extra space in arrays, etc. are not included in the return value). THIS METHOD IS THREAD SAFE.  </li>
<li>
<code>obj.ShallowCopy (vtkDataObject src)</code> - Shallow and Deep copy.  </li>
<li>
<code>obj.DeepCopy (vtkDataObject src)</code> - Shallow and Deep copy.  </li>
<li>
<code>obj.RemoveGhostCells (int level)</code> - This method will remove any cell that has a ghost level array value greater or equal to level. It does not remove unused points (yet).  </li>
<li>
<p class="startli"><code>int = obj.GetScalarFieldCriticalIndex (vtkIdType pointId, vtkDataArray scalarField)</code> - Scalar field critical point classification (for manifold 2D meshes). Reference: J. Milnor "Morse Theory", Princeton University Press, 1963.</p>
<p>Given a pointId and an attribute representing a scalar field, this member returns the index of the critical point: vtkPolyData::MINIMUM (index 0): local minimum; vtkPolyData::SADDLE (index 1): local saddle; vtkPolyData::MAXIMUM (index 2): local maximum.</p>
<p class="endli">Other returned values are: vtkPolyData::REGULAR_POINT: regular point (the gradient does not vanish); vtkPolyData::ERR_NON_MANIFOLD_STAR: the star of the considered vertex is not manifold (could not evaluate the index) vtkPolyData::ERR_INCORRECT_FIELD: the number of entries in the scalar field array is different form the number of vertices in the mesh. vtkPolyData::ERR_NO_SUCH_FIELD: the specified scalar field does not exist.  </p>
</li>
<li>
<p class="startli"><code>int = obj.GetScalarFieldCriticalIndex (vtkIdType pointId, int fieldId)</code> - Scalar field critical point classification (for manifold 2D meshes). Reference: J. Milnor "Morse Theory", Princeton University Press, 1963.</p>
<p>Given a pointId and an attribute representing a scalar field, this member returns the index of the critical point: vtkPolyData::MINIMUM (index 0): local minimum; vtkPolyData::SADDLE (index 1): local saddle; vtkPolyData::MAXIMUM (index 2): local maximum.</p>
<p class="endli">Other returned values are: vtkPolyData::REGULAR_POINT: regular point (the gradient does not vanish); vtkPolyData::ERR_NON_MANIFOLD_STAR: the star of the considered vertex is not manifold (could not evaluate the index) vtkPolyData::ERR_INCORRECT_FIELD: the number of entries in the scalar field array is different form the number of vertices in the mesh. vtkPolyData::ERR_NO_SUCH_FIELD: the specified scalar field does not exist.  </p>
</li>
<li>
<p class="startli"><code>int = obj.GetScalarFieldCriticalIndex (vtkIdType pointId, string fieldName)</code> - Scalar field critical point classification (for manifold 2D meshes). Reference: J. Milnor "Morse Theory", Princeton University Press, 1963.</p>
<p>Given a pointId and an attribute representing a scalar field, this member returns the index of the critical point: vtkPolyData::MINIMUM (index 0): local minimum; vtkPolyData::SADDLE (index 1): local saddle; vtkPolyData::MAXIMUM (index 2): local maximum.</p>
<p class="endli">Other returned values are: vtkPolyData::REGULAR_POINT: regular point (the gradient does not vanish); vtkPolyData::ERR_NON_MANIFOLD_STAR: the star of the considered vertex is not manifold (could not evaluate the index) vtkPolyData::ERR_INCORRECT_FIELD: the number of entries in the scalar field array is different form the number of vertices in the mesh. vtkPolyData::ERR_NO_SUCH_FIELD: the specified scalar field does not exist.  </p>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkfiltering.html">Visualization Toolkit Filtering Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:31 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

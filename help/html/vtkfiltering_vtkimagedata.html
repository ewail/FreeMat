<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkImageData</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkfiltering_vtkimagedata.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkImageData </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkfiltering.html">Visualization Toolkit Filtering Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>vtkImageData is a data object that is a concrete implementation of vtkDataSet. vtkImageData represents a geometric structure that is a topological and geometrical regular array of points. Examples include volumes (voxel data) and pixmaps.</p>
<p>To create an instance of class vtkImageData, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkImageData
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkImageData has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkImageData class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkImageData = obj.NewInstance ()</code>  </li>
<li>
<code>vtkImageData = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>obj.CopyStructure (vtkDataSet ds)</code> - Copy the geometric and topological structure of an input image data object.  </li>
<li>
<code>int = obj.GetDataObjectType ()</code> - Return what type of dataset this is.  </li>
<li>
<code>vtkIdType = obj.GetNumberOfCells ()</code> - Standard vtkDataSet API methods. See vtkDataSet for more information.  </li>
<li>
<code>vtkIdType = obj.GetNumberOfPoints ()</code> - Standard vtkDataSet API methods. See vtkDataSet for more information.  </li>
<li>
<code>double = obj.GetPoint (vtkIdType ptId)</code> - Standard vtkDataSet API methods. See vtkDataSet for more information.  </li>
<li>
<code>obj.GetPoint (vtkIdType id, double x[3])</code> - Standard vtkDataSet API methods. See vtkDataSet for more information.  </li>
<li>
<code>vtkCell = obj.GetCell (vtkIdType cellId)</code> - Standard vtkDataSet API methods. See vtkDataSet for more information.  </li>
<li>
<code>obj.GetCell (vtkIdType cellId, vtkGenericCell cell)</code> - Standard vtkDataSet API methods. See vtkDataSet for more information.  </li>
<li>
<code>obj.GetCellBounds (vtkIdType cellId, double bounds[6])</code> - Standard vtkDataSet API methods. See vtkDataSet for more information.  </li>
<li>
<code>vtkIdType = obj.FindPoint (double x, double y, double z)</code> - Standard vtkDataSet API methods. See vtkDataSet for more information.  </li>
<li>
<code>vtkIdType = obj.FindPoint (double x[3])</code> - Standard vtkDataSet API methods. See vtkDataSet for more information.  </li>
<li>
<code>int = obj.GetCellType (vtkIdType cellId)</code> - Standard vtkDataSet API methods. See vtkDataSet for more information.  </li>
<li>
<code>obj.GetCellPoints (vtkIdType cellId, vtkIdList ptIds)</code> - Standard vtkDataSet API methods. See vtkDataSet for more information.  </li>
<li>
<code>obj.GetPointCells (vtkIdType ptId, vtkIdList cellIds)</code> - Standard vtkDataSet API methods. See vtkDataSet for more information.  </li>
<li>
<code>obj.ComputeBounds ()</code> - Standard vtkDataSet API methods. See vtkDataSet for more information.  </li>
<li>
<code>int = obj.GetMaxCellSize ()</code> - Standard vtkDataSet API methods. See vtkDataSet for more information.  </li>
<li>
<code>obj.Initialize ()</code> - Restore data object to initial state,  </li>
<li>
<code>obj.SetDimensions (int i, int j, int k)</code> - Pass your way. This is for backward compatibility only. Use SetExtent() instead. Same as SetExtent(0, i-1, 0, j-1, 0, k-1)  </li>
<li>
<code>obj.SetDimensions (int dims[3])</code> - Pass your way. This is for backward compatibility only. Use SetExtent() instead. Same as SetExtent(0, dims[0]-1, 0, dims[1]-1, 0, dims[2]-1)  </li>
<li>
<code>int = obj.GetDimensions ()</code> - Get dimensions of this structured points dataset. It is the number of points on each axis. Dimensions are computed from Extents during this call.  </li>
<li>
<code>obj.GetDimensions (int dims[3])</code> - Get dimensions of this structured points dataset. It is the number of points on each axis. Dimensions are computed from Extents during this call.  </li>
<li>
<code>int = obj.ComputeStructuredCoordinates (double x[3], int ijk[3], double pcoords[3])</code> - Convenience function computes the structured coordinates for a point x[3]. The voxel is specified by the array ijk[3], and the parametric coordinates in the cell are specified with pcoords[3]. The function returns a 0 if the point x is outside of the volume, and a 1 if inside the volume.  </li>
<li>
<code>obj.GetVoxelGradient (int i, int j, int k, vtkDataArray s, vtkDataArray g)</code> - Given structured coordinates (i,j,k) for a voxel cell, compute the eight gradient values for the voxel corners. The order in which the gradient vectors are arranged corresponds to the ordering of the voxel points. Gradient vector is computed by central differences (except on edges of volume where forward difference is used). The scalars s are the scalars from which the gradient is to be computed. This method will treat only 3D structured point datasets (i.e., volumes).  </li>
<li>
<code>obj.GetPointGradient (int i, int j, int k, vtkDataArray s, double g[3])</code> - Given structured coordinates (i,j,k) for a point in a structured point dataset, compute the gradient vector from the scalar data at that point. The scalars s are the scalars from which the gradient is to be computed. This method will treat structured point datasets of any dimension.  </li>
<li>
<code>int = obj.GetDataDimension ()</code> - Return the dimensionality of the data.  </li>
<li>
<code>vtkIdType = obj.ComputePointId (int ijk[3])</code> - Given a location in structured coordinates (i-j-k), return the point id.  </li>
<li>
<code>vtkIdType = obj.ComputeCellId (int ijk[3])</code> - Given a location in structured coordinates (i-j-k), return the cell id.  </li>
<li>
<code>obj.SetAxisUpdateExtent (int axis, int min, int max)</code> - Set / Get the extent on just one axis  </li>
<li>
<code>obj.UpdateInformation ()</code> - Override to copy information from pipeline information to data information for backward compatibility. See vtkDataObject::UpdateInformation for details.  </li>
<li>
<code>obj.SetExtent (int extent[6])</code> - Set/Get the extent. On each axis, the extent is defined by the index of the first point and the index of the last point. The extent should be set before the "Scalars" are set or allocated. The Extent is stored in the order (X, Y, Z). The dataset extent does not have to start at (0,0,0). (0,0,0) is just the extent of the origin. The first point (the one with Id=0) is at extent (Extent[0],Extent[2],Extent[4]). As for any dataset, a data array on point data starts at Id=0.  </li>
<li>
<code>obj.SetExtent (int x1, int x2, int y1, int y2, int z1, int z2)</code> - Set/Get the extent. On each axis, the extent is defined by the index of the first point and the index of the last point. The extent should be set before the "Scalars" are set or allocated. The Extent is stored in the order (X, Y, Z). The dataset extent does not have to start at (0,0,0). (0,0,0) is just the extent of the origin. The first point (the one with Id=0) is at extent (Extent[0],Extent[2],Extent[4]). As for any dataset, a data array on point data starts at Id=0.  </li>
<li>
<code>int = obj. GetExtent ()</code> - Set/Get the extent. On each axis, the extent is defined by the index of the first point and the index of the last point. The extent should be set before the "Scalars" are set or allocated. The Extent is stored in the order (X, Y, Z). The dataset extent does not have to start at (0,0,0). (0,0,0) is just the extent of the origin. The first point (the one with Id=0) is at extent (Extent[0],Extent[2],Extent[4]). As for any dataset, a data array on point data starts at Id=0.  </li>
<li>
<code>long = obj.GetEstimatedMemorySize ()</code> - Get the estimated size of this data object itself. Should be called after UpdateInformation() and PropagateUpdateExtent() have both been called. This estimate should be fairly accurate since this is structured data.  </li>
<li>
<code>double = obj.GetScalarTypeMin ()</code> - These returns the minimum and maximum values the ScalarType can hold without overflowing.  </li>
<li>
<code>double = obj.GetScalarTypeMax ()</code> - These returns the minimum and maximum values the ScalarType can hold without overflowing.  </li>
<li>
<code>int = obj.GetScalarSize ()</code> - Set the size of the scalar type in bytes.  </li>
<li>
<code>vtkIdType = obj.GetIncrements ()</code> - Different ways to get the increments for moving around the data. GetIncrements() calls ComputeIncrements() to ensure the increments are up to date.  </li>
<li>
<code>obj.GetIncrements (vtkIdType inc[3])</code> - Different ways to get the increments for moving around the data. GetIncrements() calls ComputeIncrements() to ensure the increments are up to date.  </li>
<li>
<code>float = obj.GetScalarComponentAsFloat (int x, int y, int z, int component)</code> - For access to data from tcl  </li>
<li>
<code>obj.SetScalarComponentFromFloat (int x, int y, int z, int component, float v)</code> - For access to data from tcl  </li>
<li>
<code>double = obj.GetScalarComponentAsDouble (int x, int y, int z, int component)</code> - For access to data from tcl  </li>
<li>
<code>obj.SetScalarComponentFromDouble (int x, int y, int z, int component, double v)</code> - For access to data from tcl  </li>
<li>
<code>obj.AllocateScalars ()</code> - Allocate the vtkScalars object associated with this object.  </li>
<li>
<code>obj.CopyAndCastFrom (vtkImageData inData, int extent[6])</code> - This method is passed a input and output region, and executes the filter algorithm to fill the output from the input. It just executes a switch statement to call the correct function for the regions data types.  </li>
<li>
<code>obj.CopyAndCastFrom (vtkImageData inData, int x0, int x1, int y0, int y1, int z0, int z1)</code> - Reallocates and copies to set the Extent to the UpdateExtent. This is used internally when the exact extent is requested, and the source generated more than the update extent.  </li>
<li>
<code>obj.Crop ()</code> - Reallocates and copies to set the Extent to the UpdateExtent. This is used internally when the exact extent is requested, and the source generated more than the update extent.  </li>
<li>
<code>long = obj.GetActualMemorySize ()</code> - Return the actual size of the data in kilobytes. This number is valid only after the pipeline has updated. The memory size returned is guaranteed to be greater than or equal to the memory required to represent the data (e.g., extra space in arrays, etc. are not included in the return value). THIS METHOD IS THREAD SAFE.  </li>
<li>
<code>obj.SetSpacing (double , double , double )</code> - Set the spacing (width,height,length) of the cubical cells that compose the data set.  </li>
<li>
<code>obj.SetSpacing (double a[3])</code> - Set the spacing (width,height,length) of the cubical cells that compose the data set.  </li>
<li>
<code>double = obj. GetSpacing ()</code> - Set the spacing (width,height,length) of the cubical cells that compose the data set.  </li>
<li>
<code>obj.SetOrigin (double , double , double )</code> - Set/Get the origin of the dataset. The origin is the position in world coordinates of the point of extent (0,0,0). This point does not have to be part of the dataset, in other words, the dataset extent does not have to start at (0,0,0) and the origin can be outside of the dataset bounding box. The origin plus spacing determine the position in space of the points.  </li>
<li>
<code>obj.SetOrigin (double a[3])</code> - Set/Get the origin of the dataset. The origin is the position in world coordinates of the point of extent (0,0,0). This point does not have to be part of the dataset, in other words, the dataset extent does not have to start at (0,0,0) and the origin can be outside of the dataset bounding box. The origin plus spacing determine the position in space of the points.  </li>
<li>
<code>double = obj. GetOrigin ()</code> - Set/Get the origin of the dataset. The origin is the position in world coordinates of the point of extent (0,0,0). This point does not have to be part of the dataset, in other words, the dataset extent does not have to start at (0,0,0) and the origin can be outside of the dataset bounding box. The origin plus spacing determine the position in space of the points.  </li>
<li>
<code>obj.SetScalarTypeToFloat ()</code> - Set/Get the data scalar type (i.e VTK_DOUBLE). Note that these methods are setting and getting the pipeline scalar type. i.e. they are setting the type that the image data will be once it has executed. Until the REQUEST_DATA pass the actual scalars may be of some other type. This is for backwards compatibility  </li>
<li>
<code>obj.SetScalarTypeToDouble ()</code> - Set/Get the data scalar type (i.e VTK_DOUBLE). Note that these methods are setting and getting the pipeline scalar type. i.e. they are setting the type that the image data will be once it has executed. Until the REQUEST_DATA pass the actual scalars may be of some other type. This is for backwards compatibility  </li>
<li>
<code>obj.SetScalarTypeToInt ()</code> - Set/Get the data scalar type (i.e VTK_DOUBLE). Note that these methods are setting and getting the pipeline scalar type. i.e. they are setting the type that the image data will be once it has executed. Until the REQUEST_DATA pass the actual scalars may be of some other type. This is for backwards compatibility  </li>
<li>
<code>obj.SetScalarTypeToUnsignedInt ()</code> - Set/Get the data scalar type (i.e VTK_DOUBLE). Note that these methods are setting and getting the pipeline scalar type. i.e. they are setting the type that the image data will be once it has executed. Until the REQUEST_DATA pass the actual scalars may be of some other type. This is for backwards compatibility  </li>
<li>
<code>obj.SetScalarTypeToLong ()</code> - Set/Get the data scalar type (i.e VTK_DOUBLE). Note that these methods are setting and getting the pipeline scalar type. i.e. they are setting the type that the image data will be once it has executed. Until the REQUEST_DATA pass the actual scalars may be of some other type. This is for backwards compatibility  </li>
<li>
<code>obj.SetScalarTypeToUnsignedLong ()</code> - Set/Get the data scalar type (i.e VTK_DOUBLE). Note that these methods are setting and getting the pipeline scalar type. i.e. they are setting the type that the image data will be once it has executed. Until the REQUEST_DATA pass the actual scalars may be of some other type. This is for backwards compatibility  </li>
<li>
<code>obj.SetScalarTypeToShort ()</code> - Set/Get the data scalar type (i.e VTK_DOUBLE). Note that these methods are setting and getting the pipeline scalar type. i.e. they are setting the type that the image data will be once it has executed. Until the REQUEST_DATA pass the actual scalars may be of some other type. This is for backwards compatibility  </li>
<li>
<code>obj.SetScalarTypeToUnsignedShort ()</code> - Set/Get the data scalar type (i.e VTK_DOUBLE). Note that these methods are setting and getting the pipeline scalar type. i.e. they are setting the type that the image data will be once it has executed. Until the REQUEST_DATA pass the actual scalars may be of some other type. This is for backwards compatibility  </li>
<li>
<code>obj.SetScalarTypeToUnsignedChar ()</code> - Set/Get the data scalar type (i.e VTK_DOUBLE). Note that these methods are setting and getting the pipeline scalar type. i.e. they are setting the type that the image data will be once it has executed. Until the REQUEST_DATA pass the actual scalars may be of some other type. This is for backwards compatibility  </li>
<li>
<code>obj.SetScalarTypeToSignedChar ()</code> - Set/Get the data scalar type (i.e VTK_DOUBLE). Note that these methods are setting and getting the pipeline scalar type. i.e. they are setting the type that the image data will be once it has executed. Until the REQUEST_DATA pass the actual scalars may be of some other type. This is for backwards compatibility  </li>
<li>
<code>obj.SetScalarTypeToChar ()</code> - Set/Get the data scalar type (i.e VTK_DOUBLE). Note that these methods are setting and getting the pipeline scalar type. i.e. they are setting the type that the image data will be once it has executed. Until the REQUEST_DATA pass the actual scalars may be of some other type. This is for backwards compatibility  </li>
<li>
<code>obj.SetScalarType (int )</code> - Set/Get the data scalar type (i.e VTK_DOUBLE). Note that these methods are setting and getting the pipeline scalar type. i.e. they are setting the type that the image data will be once it has executed. Until the REQUEST_DATA pass the actual scalars may be of some other type. This is for backwards compatibility  </li>
<li>
<code>int = obj.GetScalarType ()</code> - Set/Get the data scalar type (i.e VTK_DOUBLE). Note that these methods are setting and getting the pipeline scalar type. i.e. they are setting the type that the image data will be once it has executed. Until the REQUEST_DATA pass the actual scalars may be of some other type. This is for backwards compatibility  </li>
<li>
<code>string = obj.GetScalarTypeAsString ()</code> - Set/Get the data scalar type (i.e VTK_DOUBLE). Note that these methods are setting and getting the pipeline scalar type. i.e. they are setting the type that the image data will be once it has executed. Until the REQUEST_DATA pass the actual scalars may be of some other type. This is for backwards compatibility  </li>
<li>
<code>obj.SetNumberOfScalarComponents (int n)</code> - Set/Get the number of scalar components for points. As with the SetScalarType method this is setting pipeline info.  </li>
<li>
<code>int = obj.GetNumberOfScalarComponents ()</code> - Set/Get the number of scalar components for points. As with the SetScalarType method this is setting pipeline info.  </li>
<li>
<code>obj.CopyTypeSpecificInformation (vtkDataObject image)</code>  </li>
<li>
<code>obj.CopyInformationToPipeline (vtkInformation request, vtkInformation input, vtkInformation output, int forceCopy)</code> - Override these to handle origin, spacing, scalar type, and scalar number of components. See vtkDataObject for details.  </li>
<li>
<code>obj.CopyInformationFromPipeline (vtkInformation request)</code> - Override these to handle origin, spacing, scalar type, and scalar number of components. See vtkDataObject for details.  </li>
<li>
<code>obj.PrepareForNewData ()</code> - make the output data ready for new data to be inserted. For most objects we just call Initialize. But for image data we leave the old data in case the memory can be reused.  </li>
<li>
<code>obj.ShallowCopy (vtkDataObject src)</code> - Shallow and Deep copy.  </li>
<li>
<code>obj.DeepCopy (vtkDataObject src)</code> - Shallow and Deep copy.  </li>
<li>
<code>obj.ComputeInternalExtent (int intExt, int tgtExt, int bnds)</code> - Given how many pixel are required on a side for bounrary conditions (in bnds), the target extent to traverse, compute the internal extent (the extent for this ImageData that does nto suffer from any boundary conditions) and place it in intExt  </li>
<li>
<code>int = obj.GetExtentType ()</code> - The extent type is a 3D extent  </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkfiltering.html">Visualization Toolkit Filtering Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:30 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

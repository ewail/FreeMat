<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkDataArray</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkcommon_vtkdataarray.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkDataArray </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkcommon.html">Visualization Toolkit Common Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>vtkDataArray is an abstract superclass for data array objects containing numeric data. It extends the API defined in vtkAbstractArray. vtkDataArray is an abstract superclass for data array objects. This class defines an API that all array objects must support. Note that the concrete subclasses of this class represent data in native form (char, int, etc.) and often have specialized more efficient methods for operating on this data (for example, getting pointers to data or getting/inserting data in native form). Subclasses of vtkDataArray are assumed to contain data whose components are meaningful when cast to and from double.</p>
<p>To create an instance of class vtkDataArray, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkDataArray
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkDataArray has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkDataArray class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkDataArray = obj.NewInstance ()</code>  </li>
<li>
<code>vtkDataArray = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>int = obj.IsNumeric ()</code> - Return the size, in bytes, of the lowest-level element of an array. For vtkDataArray and subclasses this is the size of the data type.  </li>
<li>
<code>int = obj.GetElementComponentSize ()</code> - Set the tuple at the ith location using the jth tuple in the source array. This method assumes that the two arrays have the same type and structure. Note that range checking and memory allocation is not performed; use in conjunction with SetNumberOfTuples() to allocate space.  </li>
<li>
<code>obj.SetTuple (vtkIdType i, vtkIdType j, vtkAbstractArray source)</code> - Set the tuple at the ith location using the jth tuple in the source array. This method assumes that the two arrays have the same type and structure. Note that range checking and memory allocation is not performed; use in conjunction with SetNumberOfTuples() to allocate space.  </li>
<li>
<code>obj.InsertTuple (vtkIdType i, vtkIdType j, vtkAbstractArray source)</code> - Insert the jth tuple in the source array, at ith location in this array. Note that memory allocation is performed as necessary to hold the data. This pure virtual function is redeclared here to avoid declaration hidden warnings.  </li>
<li>
<code>vtkIdType = obj.InsertNextTuple (vtkIdType j, vtkAbstractArray source)</code> - Insert the jth tuple in the source array, at the end in this array. Note that memory allocation is performed as necessary to hold the data. Returns the location at which the data was inserted. This pure virtual function is redeclared here to avoid declaration hidden warnings.  </li>
<li>
<code>obj.GetTuples (vtkIdList ptIds, vtkAbstractArray output)</code> - Given a list of point ids, return an array of tuples. You must insure that the output array has been previously allocated with enough space to hold the data.  </li>
<li>
<code>obj.GetTuples (vtkIdType p1, vtkIdType p2, vtkAbstractArray output)</code> - Get the tuples for the range of points ids specified (i.e., p1-&gt;p2 inclusive). You must insure that the output array has been previously allocated with enough space to hold the data.  </li>
<li>
<code>obj.InterpolateTuple (vtkIdType i, vtkIdList ptIndices, vtkAbstractArray source, double weights)</code> - Set the ith tuple in this array as the interpolated tuple value, given the ptIndices in the source array and associated interpolation weights. This method assumes that the two arrays are of the same type and strcuture.  </li>
<li>
<code>obj.InterpolateTuple (vtkIdType i, vtkIdType id1, vtkAbstractArray source1, vtkIdType id2, vtkAbstractArray source2, double t)</code>  </li>
<li>
<code>obj.GetTuple (vtkIdType i, double tuple)</code> - Get the data tuple at ith location by filling in a user-provided array, Make sure that your array is large enough to hold the NumberOfComponents amount of data being returned.  </li>
<li>
<code>double = obj.GetTuple1 (vtkIdType i)</code> - These methods are included as convenience for the wrappers. GetTuple() and SetTuple() which return/take arrays can not be used from wrapped languages. These methods can be used instead.  </li>
<li>
<code>double = obj.GetTuple2 (vtkIdType i)</code> - These methods are included as convenience for the wrappers. GetTuple() and SetTuple() which return/take arrays can not be used from wrapped languages. These methods can be used instead.  </li>
<li>
<code>double = obj.GetTuple3 (vtkIdType i)</code> - These methods are included as convenience for the wrappers. GetTuple() and SetTuple() which return/take arrays can not be used from wrapped languages. These methods can be used instead.  </li>
<li>
<code>double = obj.GetTuple4 (vtkIdType i)</code> - These methods are included as convenience for the wrappers. GetTuple() and SetTuple() which return/take arrays can not be used from wrapped languages. These methods can be used instead.  </li>
<li>
<code>double = obj.GetTuple9 (vtkIdType i)</code> - These methods are included as convenience for the wrappers. GetTuple() and SetTuple() which return/take arrays can not be used from wrapped languages. These methods can be used instead.  </li>
<li>
<code>obj.SetTuple (vtkIdType i, float tuple)</code> - Set the data tuple at ith location. Note that range checking or memory allocation is not performed; use this method in conjunction with SetNumberOfTuples() to allocate space.  </li>
<li>
<code>obj.SetTuple (vtkIdType i, double tuple)</code> - Set the data tuple at ith location. Note that range checking or memory allocation is not performed; use this method in conjunction with SetNumberOfTuples() to allocate space.  </li>
<li>
<code>obj.SetTuple1 (vtkIdType i, double value)</code> - These methods are included as convenience for the wrappers. GetTuple() and SetTuple() which return/take arrays can not be used from wrapped languages. These methods can be used instead.  </li>
<li>
<code>obj.SetTuple2 (vtkIdType i, double val0, double val1)</code> - These methods are included as convenience for the wrappers. GetTuple() and SetTuple() which return/take arrays can not be used from wrapped languages. These methods can be used instead.  </li>
<li>
<code>obj.SetTuple3 (vtkIdType i, double val0, double val1, double val2)</code> - These methods are included as convenience for the wrappers. GetTuple() and SetTuple() which return/take arrays can not be used from wrapped languages. These methods can be used instead.  </li>
<li>
<code>obj.SetTuple4 (vtkIdType i, double val0, double val1, double val2, double val3)</code> - These methods are included as convenience for the wrappers. GetTuple() and SetTuple() which return/take arrays can not be used from wrapped languages. These methods can be used instead.  </li>
<li>
<code>obj.SetTuple9 (vtkIdType i, double val0, double val1, double val2, double val3, double val4, double val5, double val6, double val7, double val8)</code> - These methods are included as convenience for the wrappers. GetTuple() and SetTuple() which return/take arrays can not be used from wrapped languages. These methods can be used instead.  </li>
<li>
<code>obj.InsertTuple (vtkIdType i, float tuple)</code> - Insert the data tuple at ith location. Note that memory allocation is performed as necessary to hold the data.  </li>
<li>
<code>obj.InsertTuple (vtkIdType i, double tuple)</code> - Insert the data tuple at ith location. Note that memory allocation is performed as necessary to hold the data.  </li>
<li>
<code>obj.InsertTuple1 (vtkIdType i, double value)</code> - These methods are included as convenience for the wrappers. InsertTuple() which takes arrays can not be used from wrapped languages. These methods can be used instead.  </li>
<li>
<code>obj.InsertTuple2 (vtkIdType i, double val0, double val1)</code> - These methods are included as convenience for the wrappers. InsertTuple() which takes arrays can not be used from wrapped languages. These methods can be used instead.  </li>
<li>
<code>obj.InsertTuple3 (vtkIdType i, double val0, double val1, double val2)</code> - These methods are included as convenience for the wrappers. InsertTuple() which takes arrays can not be used from wrapped languages. These methods can be used instead.  </li>
<li>
<code>obj.InsertTuple4 (vtkIdType i, double val0, double val1, double val2, double val3)</code> - These methods are included as convenience for the wrappers. InsertTuple() which takes arrays can not be used from wrapped languages. These methods can be used instead.  </li>
<li>
<code>obj.InsertTuple9 (vtkIdType i, double val0, double val1, double val2, double val3, double val4, double val5, double val6, double val7, double val8)</code> - These methods are included as convenience for the wrappers. InsertTuple() which takes arrays can not be used from wrapped languages. These methods can be used instead.  </li>
<li>
<code>vtkIdType = obj.InsertNextTuple (float tuple)</code> - Insert the data tuple at the end of the array and return the location at which the data was inserted. Memory is allocated as necessary to hold the data.  </li>
<li>
<code>vtkIdType = obj.InsertNextTuple (double tuple)</code> - Insert the data tuple at the end of the array and return the location at which the data was inserted. Memory is allocated as necessary to hold the data.  </li>
<li>
<code>obj.InsertNextTuple1 (double value)</code> - These methods are included as convenience for the wrappers. InsertTuple() which takes arrays can not be used from wrapped languages. These methods can be used instead.  </li>
<li>
<code>obj.InsertNextTuple2 (double val0, double val1)</code> - These methods are included as convenience for the wrappers. InsertTuple() which takes arrays can not be used from wrapped languages. These methods can be used instead.  </li>
<li>
<code>obj.InsertNextTuple3 (double val0, double val1, double val2)</code> - These methods are included as convenience for the wrappers. InsertTuple() which takes arrays can not be used from wrapped languages. These methods can be used instead.  </li>
<li>
<code>obj.InsertNextTuple4 (double val0, double val1, double val2, double val3)</code> - These methods are included as convenience for the wrappers. InsertTuple() which takes arrays can not be used from wrapped languages. These methods can be used instead.  </li>
<li>
<code>obj.InsertNextTuple9 (double val0, double val1, double val2, double val3, double val4, double val5, double val6, double val7, double val8)</code> - These methods are included as convenience for the wrappers. InsertTuple() which takes arrays can not be used from wrapped languages. These methods can be used instead.  </li>
<li>
<code>obj.RemoveTuple (vtkIdType id)</code> - These methods remove tuples from the data array. They shift data and resize array, so the data array is still valid after this operation. Note, this operation is fairly slow.  </li>
<li>
<code>obj.RemoveFirstTuple ()</code> - These methods remove tuples from the data array. They shift data and resize array, so the data array is still valid after this operation. Note, this operation is fairly slow.  </li>
<li>
<code>obj.RemoveLastTuple ()</code> - These methods remove tuples from the data array. They shift data and resize array, so the data array is still valid after this operation. Note, this operation is fairly slow.  </li>
<li>
<code>double = obj.GetComponent (vtkIdType i, int j)</code> - Return the data component at the ith tuple and jth component location. Note that i is less than NumberOfTuples and j is less than NumberOfComponents.  </li>
<li>
<code>obj.SetComponent (vtkIdType i, int j, double c)</code> - Set the data component at the ith tuple and jth component location. Note that i is less than NumberOfTuples and j is less than NumberOfComponents. Make sure enough memory has been allocated (use SetNumberOfTuples() and SetNumberOfComponents()).  </li>
<li>
<code>obj.InsertComponent (vtkIdType i, int j, double c)</code> - Insert the data component at ith tuple and jth component location. Note that memory allocation is performed as necessary to hold the data.  </li>
<li>
<code>obj.GetData (vtkIdType tupleMin, vtkIdType tupleMax, int compMin, int compMax, vtkDoubleArray data)</code> - Get the data as a double array in the range (tupleMin,tupleMax) and (compMin, compMax). The resulting double array consists of all data in the tuple range specified and only the component range specified. This process typically requires casting the data from native form into doubleing point values. This method is provided as a convenience for data exchange, and is not very fast.  </li>
<li>
<code>obj.DeepCopy (vtkAbstractArray aa)</code> - Deep copy of data. Copies data from different data arrays even if they are different types (using doubleing-point exchange).  </li>
<li>
<code>obj.DeepCopy (vtkDataArray da)</code> - Deep copy of data. Copies data from different data arrays even if they are different types (using doubleing-point exchange).  </li>
<li>
<code>obj.FillComponent (int j, double c)</code> - Fill a component of a data array with a specified value. This method sets the specified component to specified value for all tuples in the data array. This methods can be used to initialize or reinitialize a single component of a multi-component array.  </li>
<li>
<code>obj.CopyComponent (int j, vtkDataArray from, int fromComponent)</code> - Copy a component from one data array into a component on this data array. This method copies the specified component ("fromComponent") from the specified data array ("from") to the specified component ("j") over all the tuples in this data array. This method can be used to extract a component (column) from one data array and paste that data into a component on this data array.  </li>
<li>
<code>long = obj.GetActualMemorySize ()</code> - Return the memory in kilobytes consumed by this data array. Used to support streaming and reading/writing data. The value returned is guaranteed to be greater than or equal to the memory required to actually represent the data represented by this object. The information returned is valid only after the pipeline has been updated.  </li>
<li>
<code>obj.CreateDefaultLookupTable ()</code> - Create default lookup table. Generally used to create one when none is available.  </li>
<li>
<code>obj.SetLookupTable (vtkLookupTable lut)</code> - Set/get the lookup table associated with this scalar data, if any.  </li>
<li>
<code>vtkLookupTable = obj.GetLookupTable ()</code> - Set/get the lookup table associated with this scalar data, if any.  </li>
<li>
<code>obj.GetRange (double range[2], int comp)</code> - Return the range of the array values for the given component. Range is copied into the array provided. If comp is equal to -1, it returns the range of the magnitude (if the number of components is equal to 1 it still returns the range of component 0).  </li>
<li>
<code>double = obj.GetRange (int comp)</code> - Return the range of the array values for the 0th component. Range is copied into the array provided.  </li>
<li>
<code>double = obj.GetRange ()</code> - Return the range of the array values for the 0th component. Range is copied into the array provided.  </li>
<li>
<code>obj.GetRange (double range[2])</code> - These methods return the Min and Max possible range of the native data type. For example if a vtkScalars consists of unsigned char data these will return (0,255).  </li>
<li>
<code>obj.GetDataTypeRange (double range[2])</code> - These methods return the Min and Max possible range of the native data type. For example if a vtkScalars consists of unsigned char data these will return (0,255).  </li>
<li>
<code>double = obj.GetDataTypeMin ()</code> - These methods return the Min and Max possible range of the native data type. For example if a vtkScalars consists of unsigned char data these will return (0,255).  </li>
<li>
<code>double = obj.GetDataTypeMax ()</code> - These methods return the Min and Max possible range of the native data type. For example if a vtkScalars consists of unsigned char data these will return (0,255).  </li>
<li>
<code>double = obj.GetMaxNorm ()</code> - Return the maximum norm for the tuples. Note that the max. is computed everytime GetMaxNorm is called.  </li>
<li>
<code>int = obj.CopyInformation (vtkInformation infoFrom, int deep)</code> - Copy information instance. Arrays use information objects in a variety of ways. It is important to have flexibility in this regard because certain keys should not be coppied, while others must be. NOTE: Up to the implmeneter to make sure that keys not inteneded to be coppied are excluded here.  </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkcommon.html">Visualization Toolkit Common Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:30 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkWindowedSincPolyDataFilter</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkgraphics_vtkwindowedsincpolydatafilter.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkWindowedSincPolyDataFilter </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkgraphics.html">Visualization Toolkit Graphics Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>vtkWindowedSincPolyDataFiler adjust point coordinate using a windowed sinc function interpolation kernel. The effect is to "relax" the mesh, making the cells better shaped and the vertices more evenly distributed. Note that this filter operates the lines, polygons, and triangle strips composing an instance of vtkPolyData. Vertex or poly-vertex cells are never modified.</p>
<p>The algorithm proceeds as follows. For each vertex v, a topological and geometric analysis is performed to determine which vertices are connected to v, and which cells are connected to v. Then, a connectivity array is constructed for each vertex. (The connectivity array is a list of lists of vertices that directly attach to each vertex.) Next, an iteration phase begins over all vertices. For each vertex v, the coordinates of v are modified using a windowed sinc function interpolation kernel. Taubin describes this methodology is the IBM tech report RC-20404 (#90237, dated 3/12/96) "Optimal Surface Smoothing as Filter Design" G. Taubin, T. Zhang and G. Golub. (Zhang and Golub are at Stanford University).</p>
<p>This report discusses using standard signal processing low-pass filters (in particular windowed sinc functions) to smooth polyhedra. The transfer functions of the low-pass filters are approximated by Chebyshev polynomials. This facilitates applying the filters in an iterative diffusion process (as opposed to a kernel convolution). The more smoothing iterations applied, the higher the degree of polynomial approximating the low-pass filter transfer function. Each smoothing iteration, therefore, applies the next higher term of the Chebyshev filter approximation to the polyhedron. This decoupling of the filter into an iteratively applied polynomial is possible since the Chebyshev polynomials are orthogonal, i.e. increasing the order of the approximation to the filter transfer function does not alter the previously calculated coefficients for the low order terms.</p>
<p>Note: Care must be taken to avoid smoothing with too few iterations. A Chebyshev approximation with too few terms is an poor approximation. The first few smoothing iterations represent a severe scaling and translation of the data. Subsequent iterations cause the smoothed polyhedron to converge to the true location and scale of the object. We have attempted to protect against this by automatically adjusting the filter, effectively widening the pass band. This adjustment is only possible if the number of iterations is greater than 1. Note that this sacrifices some degree of smoothing for model integrity. For those interested, the filter is adjusted by searching for a value sigma such that the actual pass band is k_pb + sigma and such that the filter transfer function evaluates to unity at k_pb, i.e. f(k_pb) = 1</p>
<p>To improve the numerical stability of the solution and minimize the scaling the translation effects, the algorithm can translate and scale the position coordinates to within the unit cube [-1, 1], perform the smoothing, and translate and scale the position coordinates back to the original coordinate frame. This mode is controlled with the NormalizeCoordinatesOn() / NormalizeCoordinatesOff() methods. For legacy reasons, the default is NormalizeCoordinatesOff.</p>
<p>This implementation is currently limited to using an interpolation kernel based on Hamming windows. Other windows (such as Hann, Blackman, Kaiser, Lanczos, Gaussian, and exponential windows) could be used instead.</p>
<p>There are some special instance variables used to control the execution of this filter. (These ivars basically control what vertices can be smoothed, and the creation of the connectivity array.) The BoundarySmoothing ivar enables/disables the smoothing operation on vertices that are on the "boundary" of the mesh. A boundary vertex is one that is surrounded by a semi-cycle of polygons (or used by a single line).</p>
<p>Another important ivar is FeatureEdgeSmoothing. If this ivar is enabled, then interior vertices are classified as either "simple", "interior edge", or "fixed", and smoothed differently. (Interior vertices are manifold vertices surrounded by a cycle of polygons; or used by two line cells.) The classification is based on the number of feature edges attached to v. A feature edge occurs when the angle between the two surface normals of a polygon sharing an edge is greater than the FeatureAngle ivar. Then, vertices used by no feature edges are classified "simple", vertices used by exactly two feature edges are classified "interior edge", and all others are "fixed" vertices.</p>
<p>Once the classification is known, the vertices are smoothed differently. Corner (i.e., fixed) vertices are not smoothed at all. Simple vertices are smoothed as before . Interior edge vertices are smoothed only along their two connected edges, and only if the angle between the edges is less than the EdgeAngle ivar.</p>
<p>The total smoothing can be controlled by using two ivars. The NumberOfIterations determines the maximum number of smoothing passes. The NumberOfIterations corresponds to the degree of the polynomial that is used to approximate the windowed sinc function. Ten or twenty iterations is all the is usually necessary. Contrast this with vtkSmoothPolyDataFilter which usually requires 100 to 200 smoothing iterations. vtkSmoothPolyDataFilter is also not an approximation to an ideal low-pass filter, which can cause the geometry to shrink as the amount of smoothing increases.</p>
<p>The second ivar is the specification of the PassBand for the windowed sinc filter. By design, the PassBand is specified as a doubleing point number between 0 and 2. Lower PassBand values produce more smoothing. A good default value for the PassBand is 0.1 (for those interested, the PassBand (and frequencies) for PolyData are based on the valence of the vertices, this limits all the frequency modes in a polyhedral mesh to between 0 and 2.)</p>
<p>There are two instance variables that control the generation of error data. If the ivar GenerateErrorScalars is on, then a scalar value indicating the distance of each vertex from its original position is computed. If the ivar GenerateErrorVectors is on, then a vector representing change in position is computed.</p>
<p>To create an instance of class vtkWindowedSincPolyDataFilter, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkWindowedSincPolyDataFilter
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkWindowedSincPolyDataFilter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkWindowedSincPolyDataFilter class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkWindowedSincPolyDataFilter = obj.NewInstance ()</code>  </li>
<li>
<code>vtkWindowedSincPolyDataFilter = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>obj.SetNumberOfIterations (int )</code> - Specify the number of iterations (or degree of the polynomial approximating the windowed sinc function).  </li>
<li>
<code>int = obj.GetNumberOfIterationsMinValue ()</code> - Specify the number of iterations (or degree of the polynomial approximating the windowed sinc function).  </li>
<li>
<code>int = obj.GetNumberOfIterationsMaxValue ()</code> - Specify the number of iterations (or degree of the polynomial approximating the windowed sinc function).  </li>
<li>
<code>int = obj.GetNumberOfIterations ()</code> - Specify the number of iterations (or degree of the polynomial approximating the windowed sinc function).  </li>
<li>
<code>obj.SetPassBand (double )</code> - Set the passband value for the windowed sinc filter  </li>
<li>
<code>double = obj.GetPassBandMinValue ()</code> - Set the passband value for the windowed sinc filter  </li>
<li>
<code>double = obj.GetPassBandMaxValue ()</code> - Set the passband value for the windowed sinc filter  </li>
<li>
<code>double = obj.GetPassBand ()</code> - Set the passband value for the windowed sinc filter  </li>
<li>
<code>obj.SetNormalizeCoordinates (int )</code> - Turn on/off coordinate normalization. The positions can be translated and scaled such that they fit within a [-1, 1] prior to the smoothing computation. The default is off. The numerical stability of the solution can be improved by turning normalization on. If normalization is on, the coordinates will be rescaled to the original coordinate system after smoothing has completed.  </li>
<li>
<code>int = obj.GetNormalizeCoordinates ()</code> - Turn on/off coordinate normalization. The positions can be translated and scaled such that they fit within a [-1, 1] prior to the smoothing computation. The default is off. The numerical stability of the solution can be improved by turning normalization on. If normalization is on, the coordinates will be rescaled to the original coordinate system after smoothing has completed.  </li>
<li>
<code>obj.NormalizeCoordinatesOn ()</code> - Turn on/off coordinate normalization. The positions can be translated and scaled such that they fit within a [-1, 1] prior to the smoothing computation. The default is off. The numerical stability of the solution can be improved by turning normalization on. If normalization is on, the coordinates will be rescaled to the original coordinate system after smoothing has completed.  </li>
<li>
<code>obj.NormalizeCoordinatesOff ()</code> - Turn on/off coordinate normalization. The positions can be translated and scaled such that they fit within a [-1, 1] prior to the smoothing computation. The default is off. The numerical stability of the solution can be improved by turning normalization on. If normalization is on, the coordinates will be rescaled to the original coordinate system after smoothing has completed.  </li>
<li>
<code>obj.SetFeatureEdgeSmoothing (int )</code> - Turn on/off smoothing along sharp interior edges.  </li>
<li>
<code>int = obj.GetFeatureEdgeSmoothing ()</code> - Turn on/off smoothing along sharp interior edges.  </li>
<li>
<code>obj.FeatureEdgeSmoothingOn ()</code> - Turn on/off smoothing along sharp interior edges.  </li>
<li>
<code>obj.FeatureEdgeSmoothingOff ()</code> - Turn on/off smoothing along sharp interior edges.  </li>
<li>
<code>obj.SetFeatureAngle (double )</code> - Specify the feature angle for sharp edge identification.  </li>
<li>
<code>double = obj.GetFeatureAngleMinValue ()</code> - Specify the feature angle for sharp edge identification.  </li>
<li>
<code>double = obj.GetFeatureAngleMaxValue ()</code> - Specify the feature angle for sharp edge identification.  </li>
<li>
<code>double = obj.GetFeatureAngle ()</code> - Specify the feature angle for sharp edge identification.  </li>
<li>
<code>obj.SetEdgeAngle (double )</code> - Specify the edge angle to control smoothing along edges (either interior or boundary).  </li>
<li>
<code>double = obj.GetEdgeAngleMinValue ()</code> - Specify the edge angle to control smoothing along edges (either interior or boundary).  </li>
<li>
<code>double = obj.GetEdgeAngleMaxValue ()</code> - Specify the edge angle to control smoothing along edges (either interior or boundary).  </li>
<li>
<code>double = obj.GetEdgeAngle ()</code> - Specify the edge angle to control smoothing along edges (either interior or boundary).  </li>
<li>
<code>obj.SetBoundarySmoothing (int )</code> - Turn on/off the smoothing of vertices on the boundary of the mesh.  </li>
<li>
<code>int = obj.GetBoundarySmoothing ()</code> - Turn on/off the smoothing of vertices on the boundary of the mesh.  </li>
<li>
<code>obj.BoundarySmoothingOn ()</code> - Turn on/off the smoothing of vertices on the boundary of the mesh.  </li>
<li>
<code>obj.BoundarySmoothingOff ()</code> - Turn on/off the smoothing of vertices on the boundary of the mesh.  </li>
<li>
<code>obj.SetNonManifoldSmoothing (int )</code> - Smooth non-manifold vertices.  </li>
<li>
<code>int = obj.GetNonManifoldSmoothing ()</code> - Smooth non-manifold vertices.  </li>
<li>
<code>obj.NonManifoldSmoothingOn ()</code> - Smooth non-manifold vertices.  </li>
<li>
<code>obj.NonManifoldSmoothingOff ()</code> - Smooth non-manifold vertices.  </li>
<li>
<code>obj.SetGenerateErrorScalars (int )</code> - Turn on/off the generation of scalar distance values.  </li>
<li>
<code>int = obj.GetGenerateErrorScalars ()</code> - Turn on/off the generation of scalar distance values.  </li>
<li>
<code>obj.GenerateErrorScalarsOn ()</code> - Turn on/off the generation of scalar distance values.  </li>
<li>
<code>obj.GenerateErrorScalarsOff ()</code> - Turn on/off the generation of scalar distance values.  </li>
<li>
<code>obj.SetGenerateErrorVectors (int )</code> - Turn on/off the generation of error vectors.  </li>
<li>
<code>int = obj.GetGenerateErrorVectors ()</code> - Turn on/off the generation of error vectors.  </li>
<li>
<code>obj.GenerateErrorVectorsOn ()</code> - Turn on/off the generation of error vectors.  </li>
<li>
<code>obj.GenerateErrorVectorsOff ()</code> - Turn on/off the generation of error vectors.  </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkgraphics.html">Visualization Toolkit Graphics Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:32 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

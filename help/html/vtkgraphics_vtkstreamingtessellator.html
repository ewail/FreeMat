<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkStreamingTessellator</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkgraphics_vtkstreamingtessellator.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkStreamingTessellator </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkgraphics.html">Visualization Toolkit Graphics Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>This class is a simple algorithm that takes a single starting simplex &ndash; a tetrahedron, triangle, or line segment &ndash; and calls a function you pass it with (possibly many times) tetrahedra, triangles, or lines adaptively sampled from the one you specified. It uses an algorithm you specify to control the level of adaptivity.</p>
<p>This class does not create vtkUnstructuredGrid output because it is intended for use in mappers as well as filters. Instead, it calls the registered function with simplices as they are created.</p>
<p>The subdivision algorithm should change the vertex coordinates (it must change both geometric and, if desired, parametric coordinates) of the midpoint. These coordinates need not be changed unless the EvaluateEdge() member returns true. The vtkStreamingTessellator itself has no way of creating a more accurate midpoint vertex.</p>
<p>Here's how to use this class:</p>
<ul>
<li>Call AdaptivelySample1Facet, AdaptivelySample2Facet, or AdaptivelySample3Facet, with an edge, triangle, or tetrahedron you want tessellated.</li>
<li>The adaptive tessellator classifies each edge by passing the midpoint values to the vtkEdgeSubdivisionCriterion.</li>
<li>After each edge is classified, the tessellator subdivides edges as required until the subdivision criterion is satisfied or the maximum subdivision depth has been reached.</li>
<li>Edges, triangles, or tetrahedra connecting the vertices generated by the subdivision algorithm are processed by calling the user-defined callback functions (set with SetTetrahedronCallback(), SetTriangleCallback(), or SetEdgeCallback() ).</li>
</ul>
<p>.SECTION Warning Note that the vertices passed to AdaptivelySample3Facet, AdaptivelySample2Facet, or AdaptivelySample1Facet must be at least 6, 5, or 4 entries long, respectively! This is because the &lt;r,s,t&gt;, &lt;r,s&gt;, or &lt;r&gt; parametric coordinates of the vertices are maintained as the facet is subdivided. This information is often required by the subdivision algorithm in order to compute an error metric. You may change the number of parametric coordinates associated with each vertex using vtkStreamingTessellator::SetEmbeddingDimension().</p>
<p>.SECTION Interpolating Field Values If you wish, you may also use <code>vtkStreamingTessellator</code> to interpolate field values at newly created vertices. Interpolated field values are stored just beyond the parametric coordinates associated with a vertex. They will always be <code>double</code> values; it does not make sense to interpolate a boolean or string value and your output and subdivision subroutines may always cast to a <code>float</code> or use <code>floor()</code> to truncate an interpolated value to an integer.</p>
<p>To create an instance of class vtkStreamingTessellator, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkStreamingTessellator
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkStreamingTessellator has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkStreamingTessellator class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkStreamingTessellator = obj.NewInstance ()</code>  </li>
<li>
<code>vtkStreamingTessellator = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>obj.SetSubdivisionAlgorithm (vtkEdgeSubdivisionCriterion )</code> - Get/Set the algorithm used to determine whether an edge should be subdivided or left as-is. This is used once for each call to AdaptivelySample1Facet (which is recursive and will call itself resulting in additional edges to be checked) or three times for each call to AdaptivelySample2Facet (also recursive).  </li>
<li>
<code>vtkEdgeSubdivisionCriterion = obj.GetSubdivisionAlgorithm ()</code> - Get/Set the algorithm used to determine whether an edge should be subdivided or left as-is. This is used once for each call to AdaptivelySample1Facet (which is recursive and will call itself resulting in additional edges to be checked) or three times for each call to AdaptivelySample2Facet (also recursive).  </li>
<li>
<code>obj.SetEmbeddingDimension (int k, int d)</code> - Get/Set the number of parameter-space coordinates associated with each input and output point. The default is <em>k</em> for <em>k</em> -facets. You may specify a different dimension, <em>d</em>, for each type of <em>k</em> -facet to be processed. For example, <code>SetEmbeddingDimension</code>( <code>2</code>, <code>3</code> ) would associate <em>r</em>, <em>s</em>, and <em>t</em> coordinates with each input and output point generated by <code>AdaptivelySample2Facet</code> but does not say anything about input or output points generated by <code>AdaptivelySample1Facet</code>. Call <code>SetEmbeddingDimension</code>( <code>-1</code>, <em>d</em> ) to specify the same dimension for all possible <em>k</em> values. <em>d</em> may not exceed 8, as that would be plain silly.  </li>
<li>
<code>int = obj.GetEmbeddingDimension (int k) const</code> - Get/Set the number of parameter-space coordinates associated with each input and output point. The default is <em>k</em> for <em>k</em> -facets. You may specify a different dimension, <em>d</em>, for each type of <em>k</em> -facet to be processed. For example, <code>SetEmbeddingDimension</code>( <code>2</code>, <code>3</code> ) would associate <em>r</em>, <em>s</em>, and <em>t</em> coordinates with each input and output point generated by <code>AdaptivelySample2Facet</code> but does not say anything about input or output points generated by <code>AdaptivelySample1Facet</code>. Call <code>SetEmbeddingDimension</code>( <code>-1</code>, <em>d</em> ) to specify the same dimension for all possible <em>k</em> values. <em>d</em> may not exceed 8, as that would be plain silly.  </li>
<li>
<p class="startli"><code>obj.SetFieldSize (int k, int s)</code> - Get/Set the number of field value coordinates associated with each input and output point. The default is 0; no field values are interpolated. You may specify a different size, <em>s</em>, for each type of <em>k</em> -facet to be processed. For example, <code>SetFieldSize</code>( <code>2</code>, <code>3</code> ) would associate 3 field value coordinates with each input and output point of an <code>AdaptivelySample2Facet</code> call, but does not say anything about input or output points of <code>AdaptivelySample1Facet</code>. Call <code>SetFieldSize</code>( <code>-1</code>, <em>s</em> ) to specify the same dimension for all possible <em>k</em> values. <em>s</em> may not exceed vtkStreamingTessellator::MaxFieldSize. This is a compile-time constant that defaults to 18, which is large enough for a scalar, vector, tensor, normal, and texture coordinate to be included at each point.</p>
<p>Normally, you will not call <em>SetFieldSize()</em> directly; instead, subclasses of vtkEdgeSubdivisionCriterion, such as vtkShoeMeshSubdivisionAlgorithm, will call it for you.</p>
<p class="endli">In any event, setting <em>FieldSize</em> to a non-zero value means you must pass field values to the <code>AdaptivelySamplekFacet</code> routines; For example, </p>
<pre class="fragment">    vtkStreamingTessellator* t = vtkStreamingTessellator::New();
    t-&gt;SetFieldSize( 1, 3 );
    t-&gt;SetEmbeddingDimension( 1, 1 ); // not really required, this is the default
    double p0[3+1+3] = { x0, y0, z0, r0, fx0, fy0, fz0 };
    double p1[3+1+3] = { x1, y1, z1, r1, fx1, fy1, fz1 };
    t-&gt;AdaptivelySample1Facet( p0, p1 );</pre><p> This would adaptively sample an curve (1-facet) with geometry and a vector field at every output point on the curve.  </p>
</li>
<li>
<p class="startli"><code>int = obj.GetFieldSize (int k) const</code> - Get/Set the number of field value coordinates associated with each input and output point. The default is 0; no field values are interpolated. You may specify a different size, <em>s</em>, for each type of <em>k</em> -facet to be processed. For example, <code>SetFieldSize</code>( <code>2</code>, <code>3</code> ) would associate 3 field value coordinates with each input and output point of an <code>AdaptivelySample2Facet</code> call, but does not say anything about input or output points of <code>AdaptivelySample1Facet</code>. Call <code>SetFieldSize</code>( <code>-1</code>, <em>s</em> ) to specify the same dimension for all possible <em>k</em> values. <em>s</em> may not exceed vtkStreamingTessellator::MaxFieldSize. This is a compile-time constant that defaults to 18, which is large enough for a scalar, vector, tensor, normal, and texture coordinate to be included at each point.</p>
<p>Normally, you will not call <em>SetFieldSize()</em> directly; instead, subclasses of vtkEdgeSubdivisionCriterion, such as vtkShoeMeshSubdivisionAlgorithm, will call it for you.</p>
<p class="endli">In any event, setting <em>FieldSize</em> to a non-zero value means you must pass field values to the <code>AdaptivelySamplekFacet</code> routines; For example, </p>
<pre class="fragment">    vtkStreamingTessellator* t = vtkStreamingTessellator::New();
    t-&gt;SetFieldSize( 1, 3 );
    t-&gt;SetEmbeddingDimension( 1, 1 ); // not really required, this is the default
    double p0[3+1+3] = { x0, y0, z0, r0, fx0, fy0, fz0 };
    double p1[3+1+3] = { x1, y1, z1, r1, fx1, fy1, fz1 };
    t-&gt;AdaptivelySample1Facet( p0, p1 );</pre><p> This would adaptively sample an curve (1-facet) with geometry and a vector field at every output point on the curve.  </p>
</li>
<li>
<code>obj.SetMaximumNumberOfSubdivisions (int num_subdiv_in)</code> - Get/Set the maximum number of subdivisions that may occur.  </li>
<li>
<code>int = obj.GetMaximumNumberOfSubdivisions ()</code> - Get/Set the maximum number of subdivisions that may occur.  </li>
<li>
<p class="startli"><code>obj.AdaptivelySample3Facet (double v1, double v2, double v3, double v4) const</code> - This will adaptively subdivide the tetrahedron (3-facet), triangle (2-facet), or edge (1-facet) until the subdivision algorithm returns false for every edge or the maximum recursion depth is reached.</p>
<p>Use <code>SetMaximumNumberOfSubdivisions</code> to change the maximum recursion depth.</p>
<p>The AdaptivelySample0Facet method is provided as a convenience. Obviously, there is no way to adaptively subdivide a vertex. Instead the input vertex is passed unchanged to the output via a call to the registered VertexProcessorFunction callback.</p>
<p class="endli">.SECTION Warning This assumes that you have called SetSubdivisionAlgorithm(), SetEdgeCallback(), SetTriangleCallback(), and SetTetrahedronCallback() with valid values!  </p>
</li>
<li>
<p class="startli"><code>obj.AdaptivelySample2Facet (double v1, double v2, double v3) const</code> - This will adaptively subdivide the tetrahedron (3-facet), triangle (2-facet), or edge (1-facet) until the subdivision algorithm returns false for every edge or the maximum recursion depth is reached.</p>
<p>Use <code>SetMaximumNumberOfSubdivisions</code> to change the maximum recursion depth.</p>
<p>The AdaptivelySample0Facet method is provided as a convenience. Obviously, there is no way to adaptively subdivide a vertex. Instead the input vertex is passed unchanged to the output via a call to the registered VertexProcessorFunction callback.</p>
<p class="endli">.SECTION Warning This assumes that you have called SetSubdivisionAlgorithm(), SetEdgeCallback(), SetTriangleCallback(), and SetTetrahedronCallback() with valid values!  </p>
</li>
<li>
<p class="startli"><code>obj.AdaptivelySample1Facet (double v1, double v2) const</code> - This will adaptively subdivide the tetrahedron (3-facet), triangle (2-facet), or edge (1-facet) until the subdivision algorithm returns false for every edge or the maximum recursion depth is reached.</p>
<p>Use <code>SetMaximumNumberOfSubdivisions</code> to change the maximum recursion depth.</p>
<p>The AdaptivelySample0Facet method is provided as a convenience. Obviously, there is no way to adaptively subdivide a vertex. Instead the input vertex is passed unchanged to the output via a call to the registered VertexProcessorFunction callback.</p>
<p class="endli">.SECTION Warning This assumes that you have called SetSubdivisionAlgorithm(), SetEdgeCallback(), SetTriangleCallback(), and SetTetrahedronCallback() with valid values!  </p>
</li>
<li>
<p class="startli"><code>obj.AdaptivelySample0Facet (double v1) const</code> - This will adaptively subdivide the tetrahedron (3-facet), triangle (2-facet), or edge (1-facet) until the subdivision algorithm returns false for every edge or the maximum recursion depth is reached.</p>
<p>Use <code>SetMaximumNumberOfSubdivisions</code> to change the maximum recursion depth.</p>
<p>The AdaptivelySample0Facet method is provided as a convenience. Obviously, there is no way to adaptively subdivide a vertex. Instead the input vertex is passed unchanged to the output via a call to the registered VertexProcessorFunction callback.</p>
<p class="endli">.SECTION Warning This assumes that you have called SetSubdivisionAlgorithm(), SetEdgeCallback(), SetTriangleCallback(), and SetTetrahedronCallback() with valid values!  </p>
</li>
<li>
<p class="startli"><code>obj.ResetCounts ()</code> - Reset/access the histogram of subdivision cases encountered. The histogram may be used to examine coverage during testing as well as characterizing the tessellation algorithm's performance. You should call ResetCounts() once, at the beginning of a stream of tetrahedra. It must be called before AdaptivelySample3Facet() to prevent uninitialized memory reads.</p>
<p class="endli">These functions have no effect (and return 0) when PARAVIEW_DEBUG_TESSELLATOR has not been defined. By default, PARAVIEW_DEBUG_TESSELLATOR is not defined, and your code will be fast and efficient. Really!  </p>
</li>
<li>
<p class="startli"><code>vtkIdType = obj.GetCaseCount (int c)</code> - Reset/access the histogram of subdivision cases encountered. The histogram may be used to examine coverage during testing as well as characterizing the tessellation algorithm's performance. You should call ResetCounts() once, at the beginning of a stream of tetrahedra. It must be called before AdaptivelySample3Facet() to prevent uninitialized memory reads.</p>
<p class="endli">These functions have no effect (and return 0) when PARAVIEW_DEBUG_TESSELLATOR has not been defined. By default, PARAVIEW_DEBUG_TESSELLATOR is not defined, and your code will be fast and efficient. Really!  </p>
</li>
<li>
<code>vtkIdType = obj.GetSubcaseCount (int casenum, int sub)</code>  </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkgraphics.html">Visualization Toolkit Graphics Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:32 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

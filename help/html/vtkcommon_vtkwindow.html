<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkWindow</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkcommon_vtkwindow.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkWindow </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkcommon.html">Visualization Toolkit Common Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>vtkWindow is an abstract object to specify the behavior of a rendering window. It contains vtkViewports.</p>
<p>To create an instance of class vtkWindow, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkWindow
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkWindow has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkWindow class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkWindow = obj.NewInstance ()</code>  </li>
<li>
<code>vtkWindow = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>obj.SetWindowInfo (string )</code> - These are window system independent methods that are used to help interface vtkWindow to native windowing systems.  </li>
<li>
<code>obj.SetParentInfo (string )</code> - These are window system independent methods that are used to help interface vtkWindow to native windowing systems.  </li>
<li>
<code>int = obj.GetPosition ()</code> - Set/Get the position in screen coordinates of the rendering window.  </li>
<li>
<code>obj.SetPosition (int , int )</code> - Set/Get the position in screen coordinates of the rendering window.  </li>
<li>
<code>obj.SetPosition (int a[2])</code> - Set/Get the position in screen coordinates of the rendering window.  </li>
<li>
<code>int = obj.GetSize ()</code> - Set/Get the size of the window in screen coordinates in pixels.  </li>
<li>
<code>obj.SetSize (int , int )</code> - Set/Get the size of the window in screen coordinates in pixels.  </li>
<li>
<code>obj.SetSize (int a[2])</code> - Set/Get the size of the window in screen coordinates in pixels.  </li>
<li>
<code>obj.SetMapped (int )</code> - Keep track of whether the rendering window has been mapped to screen.  </li>
<li>
<code>int = obj.GetMapped ()</code> - Keep track of whether the rendering window has been mapped to screen.  </li>
<li>
<code>obj.MappedOn ()</code> - Keep track of whether the rendering window has been mapped to screen.  </li>
<li>
<code>obj.MappedOff ()</code> - Keep track of whether the rendering window has been mapped to screen.  </li>
<li>
<code>obj.SetErase (int )</code> - Turn on/off erasing the screen between images. This allows multiple exposure sequences if turned on. You will need to turn double buffering off or make use of the SwapBuffers methods to prevent you from swapping buffers between exposures.  </li>
<li>
<code>int = obj.GetErase ()</code> - Turn on/off erasing the screen between images. This allows multiple exposure sequences if turned on. You will need to turn double buffering off or make use of the SwapBuffers methods to prevent you from swapping buffers between exposures.  </li>
<li>
<code>obj.EraseOn ()</code> - Turn on/off erasing the screen between images. This allows multiple exposure sequences if turned on. You will need to turn double buffering off or make use of the SwapBuffers methods to prevent you from swapping buffers between exposures.  </li>
<li>
<code>obj.EraseOff ()</code> - Turn on/off erasing the screen between images. This allows multiple exposure sequences if turned on. You will need to turn double buffering off or make use of the SwapBuffers methods to prevent you from swapping buffers between exposures.  </li>
<li>
<code>obj.SetDoubleBuffer (int )</code> - Keep track of whether double buffering is on or off  </li>
<li>
<code>int = obj.GetDoubleBuffer ()</code> - Keep track of whether double buffering is on or off  </li>
<li>
<code>obj.DoubleBufferOn ()</code> - Keep track of whether double buffering is on or off  </li>
<li>
<code>obj.DoubleBufferOff ()</code> - Keep track of whether double buffering is on or off  </li>
<li>
<code>string = obj.GetWindowName ()</code> - Get name of rendering window  </li>
<li>
<code>obj.SetWindowName (string )</code> - Get name of rendering window  </li>
<li>
<code>obj.Render ()</code> - Ask each viewport owned by this Window to render its image and synchronize this process.  </li>
<li>
<code>int = obj.GetPixelData (int x, int y, int x2, int y2, int front, vtkUnsignedCharArray data)</code> - Get the pixel data of an image, transmitted as RGBRGBRGB. The front argument indicates if the front buffer should be used or the back buffer. It is the caller's responsibility to delete the resulting array. It is very important to realize that the memory in this array is organized from the bottom of the window to the top. The origin of the screen is in the lower left corner. The y axis increases as you go up the screen. So the storage of pixels is from left to right and from bottom to top. (x,y) is any corner of the rectangle. (x2,y2) is its opposite corner on the diagonal.  </li>
<li>
<code>int = obj.GetDPI ()</code> - Return a best estimate to the dots per inch of the display device being rendered (or printed).  </li>
<li>
<code>obj.SetDPI (int )</code> - Return a best estimate to the dots per inch of the display device being rendered (or printed).  </li>
<li>
<code>int = obj.GetDPIMinValue ()</code> - Return a best estimate to the dots per inch of the display device being rendered (or printed).  </li>
<li>
<code>int = obj.GetDPIMaxValue ()</code> - Return a best estimate to the dots per inch of the display device being rendered (or printed).  </li>
<li>
<code>obj.SetOffScreenRendering (int )</code> - Create a window in memory instead of on the screen. This may not be supported for every type of window and on some windows you may need to invoke this prior to the first render.  </li>
<li>
<code>int = obj.GetOffScreenRendering ()</code> - Create a window in memory instead of on the screen. This may not be supported for every type of window and on some windows you may need to invoke this prior to the first render.  </li>
<li>
<code>obj.OffScreenRenderingOn ()</code> - Create a window in memory instead of on the screen. This may not be supported for every type of window and on some windows you may need to invoke this prior to the first render.  </li>
<li>
<code>obj.OffScreenRenderingOff ()</code> - Create a window in memory instead of on the screen. This may not be supported for every type of window and on some windows you may need to invoke this prior to the first render.  </li>
<li>
<code>obj.MakeCurrent ()</code> - Make the window current. May be overridden in subclasses to do for example a glXMakeCurrent or a wglMakeCurrent.  </li>
<li>
<code>obj.SetTileScale (int , int )</code> - These methods are used by vtkWindowToImageFilter to tell a VTK window to simulate a larger window by tiling. For 3D geometry these methods have no impact. It is just in handling annotation that this information must be available to the mappers and the coordinate calculations.  </li>
<li>
<code>obj.SetTileScale (int a[2])</code> - These methods are used by vtkWindowToImageFilter to tell a VTK window to simulate a larger window by tiling. For 3D geometry these methods have no impact. It is just in handling annotation that this information must be available to the mappers and the coordinate calculations.  </li>
<li>
<code>int = obj. GetTileScale ()</code> - These methods are used by vtkWindowToImageFilter to tell a VTK window to simulate a larger window by tiling. For 3D geometry these methods have no impact. It is just in handling annotation that this information must be available to the mappers and the coordinate calculations.  </li>
<li>
<code>obj.SetTileScale (int s)</code> - These methods are used by vtkWindowToImageFilter to tell a VTK window to simulate a larger window by tiling. For 3D geometry these methods have no impact. It is just in handling annotation that this information must be available to the mappers and the coordinate calculations.  </li>
<li>
<code>obj.SetTileViewport (double , double , double , double )</code> - These methods are used by vtkWindowToImageFilter to tell a VTK window to simulate a larger window by tiling. For 3D geometry these methods have no impact. It is just in handling annotation that this information must be available to the mappers and the coordinate calculations.  </li>
<li>
<code>obj.SetTileViewport (double a[4])</code> - These methods are used by vtkWindowToImageFilter to tell a VTK window to simulate a larger window by tiling. For 3D geometry these methods have no impact. It is just in handling annotation that this information must be available to the mappers and the coordinate calculations.  </li>
<li>
<code>double = obj. GetTileViewport ()</code> - These methods are used by vtkWindowToImageFilter to tell a VTK window to simulate a larger window by tiling. For 3D geometry these methods have no impact. It is just in handling annotation that this information must be available to the mappers and the coordinate calculations.  </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkcommon.html">Visualization Toolkit Common Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:30 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkTableBasedClipDataSet</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkgraphics_vtktablebasedclipdataset.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkTableBasedClipDataSet </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkgraphics.html">Visualization Toolkit Graphics Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>vtkTableBasedClipDataSet is a filter that clips any type of dataset using either any subclass of vtkImplicitFunction or an input scalar point data array. Clipping means that it actually "cuts" through the cells of the dataset, returning everything outside the specified implicit function (or greater than the scalar value) including "pieces" of a cell (Note to compare this with vtkExtractGeometry, which pulls out entire, uncut cells). The output of this filter is a vtkUnstructuredGrid data.</p>
<p>To use this filter, you need to decide whether an implicit function or an input scalar point data array is used for clipping. For the former case, 1) define an implicit function 2) provide it to this filter via SetClipFunction() If a clipping function is not specified, or GenerateClipScalars is off( the default), the input scalar point data array is then employed for clipping.</p>
<p>You can also specify a scalar (iso-)value, which is used to decide what is inside and outside the implicit function. You can also reverse the sense of what inside/outside is by setting IVAR InsideOut. The clipping algorithm proceeds by computing an implicit function value or using the input scalar point data value for each point in the dataset. This is compared against the scalar (iso-)value to determine the inside/outside status.</p>
<p>Although this filter sometimes (but rarely) may resort to the sibling class vtkClipDataSet for handling some special grids (such as cylinders or cones with capping faces in the form of a vtkPolyData), it itself is able to deal with most grids. It is worth mentioning that vtkTableBasedClipDataSet is capable of addressing the artifacts that may occur with vtkClipDataSet due to the possibly inconsistent triagulation modes between neighboring cells. In addition, the former is much faster than the latter. Furthermore, the former produces less cells (with ratio usually being 5~6) than by the latter in the output. In other words, this filter retains the original cells (i.e., without triangulation / tetrahedralization) wherever possible. All these advantages are gained by adopting the unique clipping and triangulation tables proposed by VisIt.</p>
<p>To create an instance of class vtkTableBasedClipDataSet, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkTableBasedClipDataSet
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkTableBasedClipDataSet has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkTableBasedClipDataSet class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkTableBasedClipDataSet = obj.NewInstance ()</code>  </li>
<li>
<code>vtkTableBasedClipDataSet = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>long = obj.GetMTime ()</code> - Get the MTime for which the point locator and clip function are consdiered.  </li>
<li>
<code>obj.SetInsideOut (int )</code> - Set/Get the InsideOut flag. With this flag off, a vertex is considered inside (the implicit function or the isosurface) if the (function or scalar) value is greater than IVAR Value. With this flag on, a vertex is considered inside (the implicit function or the isosurface) if the (function or scalar) value is less than or equal to IVAR Value. This flag is off by default.  </li>
<li>
<code>int = obj.GetInsideOut ()</code> - Set/Get the InsideOut flag. With this flag off, a vertex is considered inside (the implicit function or the isosurface) if the (function or scalar) value is greater than IVAR Value. With this flag on, a vertex is considered inside (the implicit function or the isosurface) if the (function or scalar) value is less than or equal to IVAR Value. This flag is off by default.  </li>
<li>
<code>obj.InsideOutOn ()</code> - Set/Get the InsideOut flag. With this flag off, a vertex is considered inside (the implicit function or the isosurface) if the (function or scalar) value is greater than IVAR Value. With this flag on, a vertex is considered inside (the implicit function or the isosurface) if the (function or scalar) value is less than or equal to IVAR Value. This flag is off by default.  </li>
<li>
<code>obj.InsideOutOff ()</code> - Set/Get the InsideOut flag. With this flag off, a vertex is considered inside (the implicit function or the isosurface) if the (function or scalar) value is greater than IVAR Value. With this flag on, a vertex is considered inside (the implicit function or the isosurface) if the (function or scalar) value is less than or equal to IVAR Value. This flag is off by default.  </li>
<li>
<code>obj.SetValue (double )</code> - Set/Get the clipping value of the implicit function (if an implicit function is applied) or scalar data array (if a scalar data array is used), with 0.0 as the default value. This value is ignored if flag UseValueAsOffset is true AND a clip function is defined.  </li>
<li>
<code>double = obj.GetValue ()</code> - Set/Get the clipping value of the implicit function (if an implicit function is applied) or scalar data array (if a scalar data array is used), with 0.0 as the default value. This value is ignored if flag UseValueAsOffset is true AND a clip function is defined.  </li>
<li>
<code>obj.SetUseValueAsOffset (bool )</code> - Set/Get flag UseValueAsOffset, with true as the default value. With this flag on, IVAR Value is used as an offset parameter to the implicit function. Value is used only when clipping using a scalar array.  </li>
<li>
<code>bool = obj.GetUseValueAsOffset ()</code> - Set/Get flag UseValueAsOffset, with true as the default value. With this flag on, IVAR Value is used as an offset parameter to the implicit function. Value is used only when clipping using a scalar array.  </li>
<li>
<code>obj.UseValueAsOffsetOn ()</code> - Set/Get flag UseValueAsOffset, with true as the default value. With this flag on, IVAR Value is used as an offset parameter to the implicit function. Value is used only when clipping using a scalar array.  </li>
<li>
<code>obj.UseValueAsOffsetOff ()</code> - Set/Get flag UseValueAsOffset, with true as the default value. With this flag on, IVAR Value is used as an offset parameter to the implicit function. Value is used only when clipping using a scalar array.  </li>
<li>
<code>obj.SetClipFunction (vtkImplicitFunction )</code>  </li>
<li>
<code>vtkImplicitFunction = obj.GetClipFunction ()</code>  </li>
<li>
<code>obj.SetGenerateClipScalars (int )</code> - Set/Get flag GenerateClipScalars, with 0 as the default value. With this flag on, the scalar point data values obtained by evaluating the implicit function will be exported to the output. Note that this flag requries that an implicit function be provided.  </li>
<li>
<code>int = obj.GetGenerateClipScalars ()</code> - Set/Get flag GenerateClipScalars, with 0 as the default value. With this flag on, the scalar point data values obtained by evaluating the implicit function will be exported to the output. Note that this flag requries that an implicit function be provided.  </li>
<li>
<code>obj.GenerateClipScalarsOn ()</code> - Set/Get flag GenerateClipScalars, with 0 as the default value. With this flag on, the scalar point data values obtained by evaluating the implicit function will be exported to the output. Note that this flag requries that an implicit function be provided.  </li>
<li>
<code>obj.GenerateClipScalarsOff ()</code> - Set/Get flag GenerateClipScalars, with 0 as the default value. With this flag on, the scalar point data values obtained by evaluating the implicit function will be exported to the output. Note that this flag requries that an implicit function be provided.  </li>
<li>
<code>obj.SetLocator (vtkIncrementalPointLocator locator)</code> - Set/Get a point locator locator for merging duplicate points. By default, an instance of vtkMergePoints is used. Note that this IVAR is provided in this class only because this filter may resort to its sibling class vtkClipDataSet when processing some special grids (such as cylinders or cones with capping faces in the form of a vtkPolyData) while the latter requires a point locator. This filter itself does not need a locator.  </li>
<li>
<code>vtkIncrementalPointLocator = obj.GetLocator ()</code> - Set/Get a point locator locator for merging duplicate points. By default, an instance of vtkMergePoints is used. Note that this IVAR is provided in this class only because this filter may resort to its sibling class vtkClipDataSet when processing some special grids (such as cylinders or cones with capping faces in the form of a vtkPolyData) while the latter requires a point locator. This filter itself does not need a locator.  </li>
<li>
<code>obj.SetMergeTolerance (double )</code> - Set/Get the tolerance used for merging duplicate points near the clipping intersection cells. This tolerance may prevent the generation of degenerate primitives. Note that only 3D cells actually use this IVAR.  </li>
<li>
<code>double = obj.GetMergeToleranceMinValue ()</code> - Set/Get the tolerance used for merging duplicate points near the clipping intersection cells. This tolerance may prevent the generation of degenerate primitives. Note that only 3D cells actually use this IVAR.  </li>
<li>
<code>double = obj.GetMergeToleranceMaxValue ()</code> - Set/Get the tolerance used for merging duplicate points near the clipping intersection cells. This tolerance may prevent the generation of degenerate primitives. Note that only 3D cells actually use this IVAR.  </li>
<li>
<code>double = obj.GetMergeTolerance ()</code> - Set/Get the tolerance used for merging duplicate points near the clipping intersection cells. This tolerance may prevent the generation of degenerate primitives. Note that only 3D cells actually use this IVAR.  </li>
<li>
<code>obj.CreateDefaultLocator ()</code> - Create a default point locator when none is specified. The point locator is used to merge coincident points.  </li>
<li>
<code>obj.SetGenerateClippedOutput (int )</code> - Set/Get whether a second output is generated. The second output contains the polygonal data that is clipped away by the iso-surface.  </li>
<li>
<code>int = obj.GetGenerateClippedOutput ()</code> - Set/Get whether a second output is generated. The second output contains the polygonal data that is clipped away by the iso-surface.  </li>
<li>
<code>obj.GenerateClippedOutputOn ()</code> - Set/Get whether a second output is generated. The second output contains the polygonal data that is clipped away by the iso-surface.  </li>
<li>
<code>obj.GenerateClippedOutputOff ()</code> - Set/Get whether a second output is generated. The second output contains the polygonal data that is clipped away by the iso-surface.  </li>
<li>
<code>vtkUnstructuredGrid = obj.GetClippedOutput ()</code> - Return the clipped output.  </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkgraphics.html">Visualization Toolkit Graphics Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:32 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

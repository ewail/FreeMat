<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FreeMat: vtkPlaneWidget</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">FreeMat
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vtkwidgets_vtkplanewidget.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">vtkPlaneWidget </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Section: <a class="el" href="sec_vtkwidgets.html">Visualization Toolkit Widget Classes</a> </p>
<h1><a class="anchor" id="Usage"></a>
Usage</h1>
<p>This 3D widget defines a finite (bounded) plane that can be interactively placed in a scene. The plane has four handles (at its corner vertices), a normal vector, and the plane itself. The handles are used to resize the plane; the normal vector to rotate it, and the plane can be picked and translated. Selecting the plane while pressing CTRL makes it spin around the normal. A nice feature of the object is that the vtkPlaneWidget, like any 3D widget, will work with the current interactor style. That is, if vtkPlaneWidget does not handle an event, then all other registered observers (including the interactor style) have an opportunity to process the event. Otherwise, the vtkPlaneWidget will terminate the processing of the event that it handles.</p>
<p>To use this object, just invoke SetInteractor() with the argument of the method a vtkRenderWindowInteractor. You may also wish to invoke "PlaceWidget()" to initially position the widget. If the "i" key (for "interactor") is pressed, the vtkPlaneWidget will appear. (See superclass documentation for information about changing this behavior.) By grabbing the one of the four handles (use the left mouse button), the plane can be resized. By grabbing the plane itself, the entire plane can be arbitrarily translated. Pressing CTRL while grabbing the plane will spin the plane around the normal. If you select the normal vector, the plane can be arbitrarily rotated. Selecting any part of the widget with the middle mouse button enables translation of the plane along its normal. (Once selected using middle mouse, moving the mouse in the direction of the normal translates the plane in the direction of the normal; moving in the direction opposite the normal translates the plane in the direction opposite the normal.) Scaling (about the center of the plane) is achieved by using the right mouse button. By moving the mouse "up" the render window the plane will be made bigger; by moving "down" the render window the widget will be made smaller. Events that occur outside of the widget (i.e., no part of the widget is picked) are propagated to any other registered obsevers (such as the interaction style). Turn off the widget by pressing the "i" key again (or invoke the Off() method).</p>
<p>The vtkPlaneWidget has several methods that can be used in conjunction with other VTK objects. The Set/GetResolution() methods control the number of subdivisions of the plane; the GetPolyData() method can be used to get the polygonal representation and can be used for things like seeding stream lines. GetPlane() can be used to update a vtkPlane implicit function. Typical usage of the widget is to make use of the StartInteractionEvent, InteractionEvent, and EndInteractionEvent events. The InteractionEvent is called on mouse motion; the other two events are called on button down and button up (either left or right button).</p>
<p>Some additional features of this class include the ability to control the properties of the widget. You can set the properties of the selected and unselected representations of the plane. For example, you can set the property for the handles and plane. In addition there are methods to constrain the plane so that it is perpendicular to the x-y-z axes.</p>
<p>To create an instance of class vtkPlaneWidget, simply invoke its constructor as follows </p>
<pre class="fragment">  obj = vtkPlaneWidget
</pre> <h1><a class="anchor" id="Methods"></a>
Methods</h1>
<p>The class vtkPlaneWidget has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <code>obj</code> is an instance of the vtkPlaneWidget class. </p>
<ul>
<li>
<code>string = obj.GetClassName ()</code>  </li>
<li>
<code>int = obj.IsA (string name)</code>  </li>
<li>
<code>vtkPlaneWidget = obj.NewInstance ()</code>  </li>
<li>
<code>vtkPlaneWidget = obj.SafeDownCast (vtkObject o)</code>  </li>
<li>
<code>obj.SetEnabled (int )</code> - Methods that satisfy the superclass' API.  </li>
<li>
<code>obj.PlaceWidget (double bounds[6])</code> - Methods that satisfy the superclass' API.  </li>
<li>
<code>obj.PlaceWidget ()</code> - Methods that satisfy the superclass' API.  </li>
<li>
<code>obj.PlaceWidget (double xmin, double xmax, double ymin, double ymax, double zmin, double zmax)</code> - Set/Get the resolution (number of subdivisions) of the plane.  </li>
<li>
<code>obj.SetResolution (int r)</code> - Set/Get the resolution (number of subdivisions) of the plane.  </li>
<li>
<code>int = obj.GetResolution ()</code> - Set/Get the resolution (number of subdivisions) of the plane.  </li>
<li>
<code>obj.SetOrigin (double x, double y, double z)</code> - Set/Get the origin of the plane.  </li>
<li>
<code>obj.SetOrigin (double x[3])</code> - Set/Get the origin of the plane.  </li>
<li>
<code>double = obj.GetOrigin ()</code> - Set/Get the origin of the plane.  </li>
<li>
<code>obj.GetOrigin (double xyz[3])</code> - Set/Get the origin of the plane.  </li>
<li>
<code>obj.SetPoint1 (double x, double y, double z)</code> - Set/Get the position of the point defining the first axis of the plane.  </li>
<li>
<code>obj.SetPoint1 (double x[3])</code> - Set/Get the position of the point defining the first axis of the plane.  </li>
<li>
<code>double = obj.GetPoint1 ()</code> - Set/Get the position of the point defining the first axis of the plane.  </li>
<li>
<code>obj.GetPoint1 (double xyz[3])</code> - Set/Get the position of the point defining the first axis of the plane.  </li>
<li>
<code>obj.SetPoint2 (double x, double y, double z)</code> - Set/Get the position of the point defining the second axis of the plane.  </li>
<li>
<code>obj.SetPoint2 (double x[3])</code> - Set/Get the position of the point defining the second axis of the plane.  </li>
<li>
<code>double = obj.GetPoint2 ()</code> - Set/Get the position of the point defining the second axis of the plane.  </li>
<li>
<code>obj.GetPoint2 (double xyz[3])</code> - Set/Get the position of the point defining the second axis of the plane.  </li>
<li>
<code>obj.SetCenter (double x, double y, double z)</code> - Get the center of the plane.  </li>
<li>
<code>obj.SetCenter (double x[3])</code> - Get the center of the plane.  </li>
<li>
<code>double = obj.GetCenter ()</code> - Get the center of the plane.  </li>
<li>
<code>obj.GetCenter (double xyz[3])</code> - Get the center of the plane.  </li>
<li>
<code>obj.SetNormal (double x, double y, double z)</code> - Get the normal to the plane.  </li>
<li>
<code>obj.SetNormal (double x[3])</code> - Get the normal to the plane.  </li>
<li>
<code>double = obj.GetNormal ()</code> - Get the normal to the plane.  </li>
<li>
<code>obj.GetNormal (double xyz[3])</code> - Get the normal to the plane.  </li>
<li>
<code>obj.SetRepresentation (int )</code> - Control how the plane appears when GetPolyData() is invoked. If the mode is "outline", then just the outline of the plane is shown. If the mode is "wireframe" then the plane is drawn with the outline plus the interior mesh (corresponding to the resolution specified). If the mode is "surface" then the plane is drawn as a surface.  </li>
<li>
<code>int = obj.GetRepresentationMinValue ()</code> - Control how the plane appears when GetPolyData() is invoked. If the mode is "outline", then just the outline of the plane is shown. If the mode is "wireframe" then the plane is drawn with the outline plus the interior mesh (corresponding to the resolution specified). If the mode is "surface" then the plane is drawn as a surface.  </li>
<li>
<code>int = obj.GetRepresentationMaxValue ()</code> - Control how the plane appears when GetPolyData() is invoked. If the mode is "outline", then just the outline of the plane is shown. If the mode is "wireframe" then the plane is drawn with the outline plus the interior mesh (corresponding to the resolution specified). If the mode is "surface" then the plane is drawn as a surface.  </li>
<li>
<code>int = obj.GetRepresentation ()</code> - Control how the plane appears when GetPolyData() is invoked. If the mode is "outline", then just the outline of the plane is shown. If the mode is "wireframe" then the plane is drawn with the outline plus the interior mesh (corresponding to the resolution specified). If the mode is "surface" then the plane is drawn as a surface.  </li>
<li>
<code>obj.SetRepresentationToOff ()</code> - Control how the plane appears when GetPolyData() is invoked. If the mode is "outline", then just the outline of the plane is shown. If the mode is "wireframe" then the plane is drawn with the outline plus the interior mesh (corresponding to the resolution specified). If the mode is "surface" then the plane is drawn as a surface.  </li>
<li>
<code>obj.SetRepresentationToOutline ()</code> - Control how the plane appears when GetPolyData() is invoked. If the mode is "outline", then just the outline of the plane is shown. If the mode is "wireframe" then the plane is drawn with the outline plus the interior mesh (corresponding to the resolution specified). If the mode is "surface" then the plane is drawn as a surface.  </li>
<li>
<code>obj.SetRepresentationToWireframe ()</code> - Control how the plane appears when GetPolyData() is invoked. If the mode is "outline", then just the outline of the plane is shown. If the mode is "wireframe" then the plane is drawn with the outline plus the interior mesh (corresponding to the resolution specified). If the mode is "surface" then the plane is drawn as a surface.  </li>
<li>
<code>obj.SetRepresentationToSurface ()</code> - Force the plane widget to be aligned with one of the x-y-z axes. Remember that when the state changes, a ModifiedEvent is invoked. This can be used to snap the plane to the axes if it is orginally not aligned.  </li>
<li>
<code>obj.SetNormalToXAxis (int )</code> - Force the plane widget to be aligned with one of the x-y-z axes. Remember that when the state changes, a ModifiedEvent is invoked. This can be used to snap the plane to the axes if it is orginally not aligned.  </li>
<li>
<code>int = obj.GetNormalToXAxis ()</code> - Force the plane widget to be aligned with one of the x-y-z axes. Remember that when the state changes, a ModifiedEvent is invoked. This can be used to snap the plane to the axes if it is orginally not aligned.  </li>
<li>
<code>obj.NormalToXAxisOn ()</code> - Force the plane widget to be aligned with one of the x-y-z axes. Remember that when the state changes, a ModifiedEvent is invoked. This can be used to snap the plane to the axes if it is orginally not aligned.  </li>
<li>
<code>obj.NormalToXAxisOff ()</code> - Force the plane widget to be aligned with one of the x-y-z axes. Remember that when the state changes, a ModifiedEvent is invoked. This can be used to snap the plane to the axes if it is orginally not aligned.  </li>
<li>
<code>obj.SetNormalToYAxis (int )</code> - Force the plane widget to be aligned with one of the x-y-z axes. Remember that when the state changes, a ModifiedEvent is invoked. This can be used to snap the plane to the axes if it is orginally not aligned.  </li>
<li>
<code>int = obj.GetNormalToYAxis ()</code> - Force the plane widget to be aligned with one of the x-y-z axes. Remember that when the state changes, a ModifiedEvent is invoked. This can be used to snap the plane to the axes if it is orginally not aligned.  </li>
<li>
<code>obj.NormalToYAxisOn ()</code> - Force the plane widget to be aligned with one of the x-y-z axes. Remember that when the state changes, a ModifiedEvent is invoked. This can be used to snap the plane to the axes if it is orginally not aligned.  </li>
<li>
<code>obj.NormalToYAxisOff ()</code> - Force the plane widget to be aligned with one of the x-y-z axes. Remember that when the state changes, a ModifiedEvent is invoked. This can be used to snap the plane to the axes if it is orginally not aligned.  </li>
<li>
<code>obj.SetNormalToZAxis (int )</code> - Force the plane widget to be aligned with one of the x-y-z axes. Remember that when the state changes, a ModifiedEvent is invoked. This can be used to snap the plane to the axes if it is orginally not aligned.  </li>
<li>
<code>int = obj.GetNormalToZAxis ()</code> - Force the plane widget to be aligned with one of the x-y-z axes. Remember that when the state changes, a ModifiedEvent is invoked. This can be used to snap the plane to the axes if it is orginally not aligned.  </li>
<li>
<code>obj.NormalToZAxisOn ()</code> - Force the plane widget to be aligned with one of the x-y-z axes. Remember that when the state changes, a ModifiedEvent is invoked. This can be used to snap the plane to the axes if it is orginally not aligned.  </li>
<li>
<code>obj.NormalToZAxisOff ()</code> - Force the plane widget to be aligned with one of the x-y-z axes. Remember that when the state changes, a ModifiedEvent is invoked. This can be used to snap the plane to the axes if it is orginally not aligned.  </li>
<li>
<code>obj.GetPolyData (vtkPolyData pd)</code> - Grab the polydata (including points) that defines the plane. The polydata consists of (res+1)*(res+1) points, and res*res quadrilateral polygons, where res is the resolution of the plane. These point values are guaranteed to be up-to-date when either the InteractionEvent or EndInteraction events are invoked. The user provides the vtkPolyData and the points and polyplane are added to it.  </li>
<li>
<code>obj.GetPlane (vtkPlane plane)</code> - Get the planes describing the implicit function defined by the plane widget. The user must provide the instance of the class vtkPlane. Note that vtkPlane is a subclass of vtkImplicitFunction, meaning that it can be used by a variety of filters to perform clipping, cutting, and selection of data.  </li>
<li>
<code>vtkPolyDataAlgorithm = obj.GetPolyDataAlgorithm ()</code> - Satisfies superclass API. This returns a pointer to the underlying PolyData. Make changes to this before calling the initial PlaceWidget() to have the initial placement follow suit. Or, make changes after the widget has been initialised and call UpdatePlacement() to realise.  </li>
<li>
<code>obj.UpdatePlacement (void )</code> - Satisfies superclass API. This will change the state of the widget to match changes that have been made to the underlying PolyDataSource  </li>
<li>
<code>vtkProperty = obj.GetHandleProperty ()</code> - Get the handle properties (the little balls are the handles). The properties of the handles when selected and normal can be manipulated.  </li>
<li>
<code>vtkProperty = obj.GetSelectedHandleProperty ()</code> - Get the handle properties (the little balls are the handles). The properties of the handles when selected and normal can be manipulated.  </li>
<li>
<code>obj.SetPlaneProperty (vtkProperty )</code> - Get the plane properties. The properties of the plane when selected and unselected can be manipulated.  </li>
<li>
<code>vtkProperty = obj.GetPlaneProperty ()</code> - Get the plane properties. The properties of the plane when selected and unselected can be manipulated.  </li>
<li>
<code>vtkProperty = obj.GetSelectedPlaneProperty ()</code> - Get the plane properties. The properties of the plane when selected and unselected can be manipulated.  </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">FreeMat Documentation</a></li><li class="navelem"><a class="el" href="sec_vtkwidgets.html">Visualization Toolkit Widget Classes</a></li>
    <li class="footer">Generated on Thu Jul 25 2013 17:18:36 for FreeMat by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.1 </li>
  </ul>
</div>
</body>
</html>

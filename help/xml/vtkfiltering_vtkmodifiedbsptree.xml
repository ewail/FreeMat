<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.1.1">
  <compounddef id="vtkfiltering_vtkmodifiedbsptree" kind="page">
    <compoundname>vtkfiltering_vtkmodifiedbsptree</compoundname>
    <title>vtkModifiedBSPTree</title>
    <detaileddescription>
<para>Section: <ref refid="sec_vtkfiltering_1sec_vtkfiltering" kindref="member">Visualization Toolkit Filtering Classes</ref> </para><sect1 id="vtkwidgets_vtkxyplotwidget_1Usage">
<title>Usage</title>
<para>vtkModifiedBSPTree creates an evenly balanced BSP tree using a top down implementation. Axis aligned split planes are found which evenly divide cells into two buckets. Generally a split plane will intersect some cells and these are usually stored in both child nodes of the current parent. (Or split into separate cells which we cannot consider in this case). Storing cells in multiple buckets creates problems associated with multiple tests against rays and increases the required storage as complex meshes will have many cells straddling a split plane (and further splits may cause multiple copies of these).</para><para>During a discussion with Arno Formella in 1998 he suggested using a third child node to store objects which straddle split planes. I&apos;ve not seen this published (Yes! - see below), but thought it worth trying. This implementation of the BSP tree creates a third child node for storing cells lying across split planes, the third cell may overlap the other two, but the two &apos;proper&apos; nodes otherwise conform to usual BSP rules.</para><para>The advantage of this implementation is cells only ever lie in one node and mailbox testing is avoided. All BBoxes are axis aligned and a ray cast uses an efficient search strategy based on near/far nodes and rejects all BBoxes using simple tests.</para><para>For fast raytracing, 6 copies of cell lists are stored in each leaf node each list is in axis sorted order +/- x,y,z and cells are always tested in the direction of the ray dominant axis. Once an intersection is found any cell or BBox with a closest point further than the I-point can be instantly rejected and raytracing stops as soon as no nodes can be closer than the current best intersection point.</para><para>The addition of the &apos;middle&apos; node upsets the optimal balance of the tree, but is a minor overhead during the raytrace. Each child node is contracted such that it tightly fits all cells inside it, enabling further ray/box rejections.</para><para>This class is intented for persons requiring many ray tests and is optimized for this purpose. As no cell ever lies in more than one leaf node, and parent nodes do not maintain cell lists, the memory overhead of the sorted cell lists is 6*num_cells*4 for 6 lists of ints, each num_cells in length. The memory requirement of the nodes themselves is usually of minor significance.</para><para>Subdividision is controlled by MaxCellsPerNode - any node with more than this number will be subdivided providing a good split plane can be found and the max depth is not exceeded.</para><para>The average cells per leaf will usually be around half the MaxCellsPerNode, though the middle node is usually sparsely populated and lowers the average slightly. The middle node will not be created when not needed. Subdividing down to very small cells per node is not generally suggested as then the 6 stored cell lists are effectively redundant.</para><para>Values of MaxcellsPerNode of around 16-&gt;128 depending on dataset size will usually give good results.</para><para>Cells are only sorted into 6 lists once - before tree creation, each node segments the lists and passes them down to the new child nodes whilst maintaining sorted order. This makes for an efficient subdivision strategy.</para><para>NB. The following reference has been sent to me {formella-1995-ray, author = &quot;Arno Formella and Christian Gill&quot;, title = &quot;{Ray Tracing: A Quantitative Analysis and a New
                   Practical Algorithm}&quot;, journal = &quot;{The Visual Computer}&quot;, year = &quot;{1995}&quot;, month = dec, pages = &quot;{465--476}&quot;, volume = &quot;{11}&quot;, number = &quot;{9}&quot;, publisher = &quot;{Springer}&quot;, keywords = &quot;{ray tracing, space subdivision, plane traversal,
                    octree, clustering, benchmark scenes}&quot;, annote = "{We present a new method to accelerate the process of finding nearest ray<ndash/>object intersections in ray tracing. The algorithm consumes an amount of memory more or less linear in the number of objects. The basic ideas can be characterized with a modified BSP<ndash/>tree and plane traversal. Plane traversal is a fast linear time algorithm to find the closest intersection point in a list of bounding volumes hit by a ray. We use plane traversal at every node of the high outdegree BSP<ndash/>tree. Our implementation is competitive to fast ray tracing programs. We present a benchmark suite which allows for an extensive comparison of ray tracing algorithms.}", }</para><para>.SECTION Thanks John Biddiscombe for developing and contributing this class</para><para><heading level="2">.SECTION ToDo</heading>
</para><para>Implement intersection heap for testing rays against transparent objects</para><para><heading level="2">.SECTION Style</heading>
</para><para>This class is currently maintained by J. Biddiscombe who has specially requested that the code style not be modified to the kitware standard. Please respect the contribution of this class by keeping the style as close as possible to the author&apos;s original.</para><para>To create an instance of class vtkModifiedBSPTree, simply invoke its constructor as follows <verbatim>  obj = vtkModifiedBSPTree
</verbatim> </para></sect1>
<sect1 id="vtkwidgets_vtkxyplotwidget_1Methods">
<title>Methods</title>
<para>The class vtkModifiedBSPTree has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <computeroutput>obj</computeroutput> is an instance of the vtkModifiedBSPTree class. <itemizedlist>
<listitem>
<para><computeroutput>string = obj.GetClassName ()</computeroutput> - Standard Type-Macro  </para></listitem>
<listitem>
<para><computeroutput>int = obj.IsA (string name)</computeroutput> - Standard Type-Macro  </para></listitem>
<listitem>
<para><computeroutput>vtkModifiedBSPTree = obj.NewInstance ()</computeroutput> - Standard Type-Macro  </para></listitem>
<listitem>
<para><computeroutput>vtkModifiedBSPTree = obj.SafeDownCast (vtkObject o)</computeroutput> - Standard Type-Macro  </para></listitem>
<listitem>
<para><computeroutput>obj.FreeSearchStructure ()</computeroutput> - Free tree memory  </para></listitem>
<listitem>
<para><computeroutput>obj.BuildLocator ()</computeroutput> - Build Tree  </para></listitem>
</itemizedlist>
</para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>

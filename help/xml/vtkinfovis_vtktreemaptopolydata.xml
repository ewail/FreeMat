<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.1.1">
  <compounddef id="vtkinfovis_vtktreemaptopolydata" kind="page">
    <compoundname>vtkinfovis_vtktreemaptopolydata</compoundname>
    <title>vtkTreeMapToPolyData</title>
    <detaileddescription>
<para>Section: <ref refid="sec_vtkinfovis_1sec_vtkinfovis" kindref="member">Visualization Toolkit Infovis Classes</ref> </para><sect1 id="vtkwidgets_vtkxyplotwidget_1Usage">
<title>Usage</title>
<para>This algorithm requires that the vtkTreeMapLayout filter has already applied to the data in order to create the quadruple array (min x, max x, min y, max y) of bounds for each vertex of the tree.</para><para>To create an instance of class vtkTreeMapToPolyData, simply invoke its constructor as follows <verbatim>  obj = vtkTreeMapToPolyData
</verbatim> </para></sect1>
<sect1 id="vtkwidgets_vtkxyplotwidget_1Methods">
<title>Methods</title>
<para>The class vtkTreeMapToPolyData has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <computeroutput>obj</computeroutput> is an instance of the vtkTreeMapToPolyData class. <itemizedlist>
<listitem>
<para><computeroutput>string = obj.GetClassName ()</computeroutput>  </para></listitem>
<listitem>
<para><computeroutput>int = obj.IsA (string name)</computeroutput>  </para></listitem>
<listitem>
<para><computeroutput>vtkTreeMapToPolyData = obj.NewInstance ()</computeroutput>  </para></listitem>
<listitem>
<para><computeroutput>vtkTreeMapToPolyData = obj.SafeDownCast (vtkObject o)</computeroutput>  </para></listitem>
<listitem>
<para><computeroutput>obj.SetRectanglesArrayName (string name)</computeroutput> - The field containing the level of each tree node. This can be added using vtkTreeLevelsFilter before this filter. If this is not present, the filter simply calls tree-&gt;GetLevel(v) for each vertex, which will produce the same result, but may not be as efficient.  </para></listitem>
<listitem>
<para><computeroutput>obj.SetLevelArrayName (string name)</computeroutput> - The spacing along the z-axis between tree map levels.  </para></listitem>
<listitem>
<para><computeroutput>double = obj.GetLevelDeltaZ ()</computeroutput> - The spacing along the z-axis between tree map levels.  </para></listitem>
<listitem>
<para><computeroutput>obj.SetLevelDeltaZ (double )</computeroutput> - The spacing along the z-axis between tree map levels.  </para></listitem>
<listitem>
<para><computeroutput>bool = obj.GetAddNormals ()</computeroutput> - The spacing along the z-axis between tree map levels.  </para></listitem>
<listitem>
<para><computeroutput>obj.SetAddNormals (bool )</computeroutput> - The spacing along the z-axis between tree map levels.  </para></listitem>
<listitem>
<para><computeroutput>int = obj.FillInputPortInformation (int port, vtkInformation info)</computeroutput>  </para></listitem>
</itemizedlist>
</para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>

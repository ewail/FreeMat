<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.1.1">
  <compounddef id="vtkinfovis_vtkpcastatistics" kind="page">
    <compoundname>vtkinfovis_vtkpcastatistics</compoundname>
    <title>vtkPCAStatistics</title>
    <detaileddescription>
<para>Section: <ref refid="sec_vtkinfovis_1sec_vtkinfovis" kindref="member">Visualization Toolkit Infovis Classes</ref> </para><sect1 id="vtkwidgets_vtkxyplotwidget_1Usage">
<title>Usage</title>
<para>This class derives from the multi-correlative statistics algorithm and uses the covariance matrix and Cholesky decomposition computed by it. However, when it finalizes the statistics in Learn mode, the PCA class computes the SVD of the covariance matrix in order to obtain its eigenvectors.</para><para>In the assess mode, the input data are<itemizedlist>
<listitem><para>projected into the basis defined by the eigenvectors,</para></listitem><listitem><para>the energy associated with each datum is computed,</para></listitem><listitem><para>or some combination thereof. Additionally, the user may specify some threshold energy or eigenvector entry below which the basis is truncated. This allows projection into a lower-dimensional state while minimizing (in a least squares sense) the projection error.</para></listitem></itemizedlist>
</para><para>.SECTION Thanks Thanks to David Thompson, Philippe Pebay and Jackson Mayo from Sandia National Laboratories for implementing this class.</para><para>To create an instance of class vtkPCAStatistics, simply invoke its constructor as follows <verbatim>  obj = vtkPCAStatistics
</verbatim> </para></sect1>
<sect1 id="vtkwidgets_vtkxyplotwidget_1Methods">
<title>Methods</title>
<para>The class vtkPCAStatistics has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the VTK sources, and may not be completely intelligible. When in doubt, consult the VTK website. In the methods listed below, <computeroutput>obj</computeroutput> is an instance of the vtkPCAStatistics class. <itemizedlist>
<listitem>
<para><computeroutput>string = obj.GetClassName ()</computeroutput>  </para></listitem>
<listitem>
<para><computeroutput>int = obj.IsA (string name)</computeroutput>  </para></listitem>
<listitem>
<para><computeroutput>vtkPCAStatistics = obj.NewInstance ()</computeroutput>  </para></listitem>
<listitem>
<para><computeroutput>vtkPCAStatistics = obj.SafeDownCast (vtkObject o)</computeroutput>  </para></listitem>
<listitem>
<para><computeroutput>obj.SetNormalizationScheme (int )</computeroutput> - This determines how (or if) the covariance matrix <emphasis>cov</emphasis> is normalized before PCA.</para><para>When set to NONE, no normalization is performed. This is the default.</para><para>When set to TRIANGLE_SPECIFIED, each entry cov(i,j) is divided by V(i,j). The list V of normalization factors must be set using the SetNormalization method before the filter is executed.</para><para>When set to DIAGONAL_SPECIFIED, each entry cov(i,j) is divided by sqrt(V(i)*V(j)). The list V of normalization factors must be set using the SetNormalization method before the filter is executed.</para><para>When set to DIAGONAL_VARIANCE, each entry cov(i,j) is divided by sqrt(cov(i,i)*cov(j,j)). <bold>Warning</bold>: Although this is accepted practice in some fields, some people think you should not turn this option on unless there is a good physically-based reason for doing so. Much better instead to determine how component magnitudes should be compared using physical reasoning and use DIAGONAL_SPECIFIED, TRIANGLE_SPECIFIED, or perform some pre-processing to shift and scale input data columns appropriately than to expect magical results from a shady normalization hack.  </para></listitem>
<listitem>
<para><computeroutput>int = obj.GetNormalizationScheme ()</computeroutput> - This determines how (or if) the covariance matrix <emphasis>cov</emphasis> is normalized before PCA.</para><para>When set to NONE, no normalization is performed. This is the default.</para><para>When set to TRIANGLE_SPECIFIED, each entry cov(i,j) is divided by V(i,j). The list V of normalization factors must be set using the SetNormalization method before the filter is executed.</para><para>When set to DIAGONAL_SPECIFIED, each entry cov(i,j) is divided by sqrt(V(i)*V(j)). The list V of normalization factors must be set using the SetNormalization method before the filter is executed.</para><para>When set to DIAGONAL_VARIANCE, each entry cov(i,j) is divided by sqrt(cov(i,i)*cov(j,j)). <bold>Warning</bold>: Although this is accepted practice in some fields, some people think you should not turn this option on unless there is a good physically-based reason for doing so. Much better instead to determine how component magnitudes should be compared using physical reasoning and use DIAGONAL_SPECIFIED, TRIANGLE_SPECIFIED, or perform some pre-processing to shift and scale input data columns appropriately than to expect magical results from a shady normalization hack.  </para></listitem>
<listitem>
<para><computeroutput>obj.SetNormalizationSchemeByName (string sname)</computeroutput> - This determines how (or if) the covariance matrix <emphasis>cov</emphasis> is normalized before PCA.</para><para>When set to NONE, no normalization is performed. This is the default.</para><para>When set to TRIANGLE_SPECIFIED, each entry cov(i,j) is divided by V(i,j). The list V of normalization factors must be set using the SetNormalization method before the filter is executed.</para><para>When set to DIAGONAL_SPECIFIED, each entry cov(i,j) is divided by sqrt(V(i)*V(j)). The list V of normalization factors must be set using the SetNormalization method before the filter is executed.</para><para>When set to DIAGONAL_VARIANCE, each entry cov(i,j) is divided by sqrt(cov(i,i)*cov(j,j)). <bold>Warning</bold>: Although this is accepted practice in some fields, some people think you should not turn this option on unless there is a good physically-based reason for doing so. Much better instead to determine how component magnitudes should be compared using physical reasoning and use DIAGONAL_SPECIFIED, TRIANGLE_SPECIFIED, or perform some pre-processing to shift and scale input data columns appropriately than to expect magical results from a shady normalization hack.  </para></listitem>
<listitem>
<para><computeroutput>string = obj.GetNormalizationSchemeName (int scheme)</computeroutput> - This determines how (or if) the covariance matrix <emphasis>cov</emphasis> is normalized before PCA.</para><para>When set to NONE, no normalization is performed. This is the default.</para><para>When set to TRIANGLE_SPECIFIED, each entry cov(i,j) is divided by V(i,j). The list V of normalization factors must be set using the SetNormalization method before the filter is executed.</para><para>When set to DIAGONAL_SPECIFIED, each entry cov(i,j) is divided by sqrt(V(i)*V(j)). The list V of normalization factors must be set using the SetNormalization method before the filter is executed.</para><para>When set to DIAGONAL_VARIANCE, each entry cov(i,j) is divided by sqrt(cov(i,i)*cov(j,j)). <bold>Warning</bold>: Although this is accepted practice in some fields, some people think you should not turn this option on unless there is a good physically-based reason for doing so. Much better instead to determine how component magnitudes should be compared using physical reasoning and use DIAGONAL_SPECIFIED, TRIANGLE_SPECIFIED, or perform some pre-processing to shift and scale input data columns appropriately than to expect magical results from a shady normalization hack.  </para></listitem>
<listitem>
<para><computeroutput>vtkTable = obj.GetSpecifiedNormalization ()</computeroutput> - These methods allow you to set/get values used to normalize the covariance matrix before PCA. The normalization values apply to all requests, so you do not specify a single vector but a 3-column table.</para><para>The first two columns contain the names of columns from input 0 and the third column contains the value to normalize the corresponding entry in the covariance matrix. The table must always have 3 columns even when the NormalizationScheme is DIAGONAL_SPECIFIED. When only diagonal entries are to be used, only table rows where the first two columns are identical to one another will be employed. If there are multiple rows specifying different values for the same pair of columns, the entry nearest the bottom of the table takes precedence.</para><para>These functions are actually convenience methods that set/get the third input of the filter. Because the table is the third input, you may use other filters to produce a table of normalizations and have the pipeline take care of updates.</para><para>Any missing entries will be set to 1.0 and a warning issued. An error will occur if the third input to the filter is not set and the NormalizationScheme is DIAGONAL_SPECIFIED or TRIANGLE_SPECIFIED.  </para></listitem>
<listitem>
<para><computeroutput>obj.SetSpecifiedNormalization (vtkTable )</computeroutput> - These methods allow you to set/get values used to normalize the covariance matrix before PCA. The normalization values apply to all requests, so you do not specify a single vector but a 3-column table.</para><para>The first two columns contain the names of columns from input 0 and the third column contains the value to normalize the corresponding entry in the covariance matrix. The table must always have 3 columns even when the NormalizationScheme is DIAGONAL_SPECIFIED. When only diagonal entries are to be used, only table rows where the first two columns are identical to one another will be employed. If there are multiple rows specifying different values for the same pair of columns, the entry nearest the bottom of the table takes precedence.</para><para>These functions are actually convenience methods that set/get the third input of the filter. Because the table is the third input, you may use other filters to produce a table of normalizations and have the pipeline take care of updates.</para><para>Any missing entries will be set to 1.0 and a warning issued. An error will occur if the third input to the filter is not set and the NormalizationScheme is DIAGONAL_SPECIFIED or TRIANGLE_SPECIFIED.  </para></listitem>
<listitem>
<para><computeroutput>obj.SetBasisScheme (int )</computeroutput> - This variable controls the dimensionality of output tuples in Assess mode. Consider the case where you have requested a PCA on D columns.</para><para>When set to vtkPCAStatistics::FULL_BASIS, the entire set of basis vectors is used to derive new coordinates for each tuple being assessed. In this mode, you are guaranteed to have output tuples of the same dimension as the input tuples. (That dimension is D, so there will be D additional columns added to the table for the request.)</para><para>When set to vtkPCAStatistics::FIXED_BASIS_SIZE, only the first N basis vectors are used to derive new coordinates for each tuple being assessed. In this mode, you are guaranteed to have output tuples of dimension min(N,D). You must set N prior to assessing data using the SetFixedBasisSize() method. When N &lt; D, this turns the PCA into a projection (instead of change of basis).</para><para>When set to vtkPCAStatistics::FIXED_BASIS_ENERGY, the number of basis vectors used to derive new coordinates for each tuple will be the minimum number of columns N that satisfy <formula id="185">\[ \frac{\sum_{i=1}^{N} \lambda_i}{\sum_{i=1}^{D} \lambda_i} &lt; T \]</formula> You must set T prior to assessing data using the SetFixedBasisEnergy() method. When T &lt; 1, this turns the PCA into a projection (instead of change of basis).</para><para>By default BasisScheme is set to vtkPCAStatistics::FULL_BASIS.  </para></listitem>
<listitem>
<para><computeroutput>int = obj.GetBasisScheme ()</computeroutput> - This variable controls the dimensionality of output tuples in Assess mode. Consider the case where you have requested a PCA on D columns.</para><para>When set to vtkPCAStatistics::FULL_BASIS, the entire set of basis vectors is used to derive new coordinates for each tuple being assessed. In this mode, you are guaranteed to have output tuples of the same dimension as the input tuples. (That dimension is D, so there will be D additional columns added to the table for the request.)</para><para>When set to vtkPCAStatistics::FIXED_BASIS_SIZE, only the first N basis vectors are used to derive new coordinates for each tuple being assessed. In this mode, you are guaranteed to have output tuples of dimension min(N,D). You must set N prior to assessing data using the SetFixedBasisSize() method. When N &lt; D, this turns the PCA into a projection (instead of change of basis).</para><para>When set to vtkPCAStatistics::FIXED_BASIS_ENERGY, the number of basis vectors used to derive new coordinates for each tuple will be the minimum number of columns N that satisfy <formula id="185">\[ \frac{\sum_{i=1}^{N} \lambda_i}{\sum_{i=1}^{D} \lambda_i} &lt; T \]</formula> You must set T prior to assessing data using the SetFixedBasisEnergy() method. When T &lt; 1, this turns the PCA into a projection (instead of change of basis).</para><para>By default BasisScheme is set to vtkPCAStatistics::FULL_BASIS.  </para></listitem>
<listitem>
<para><computeroutput>string = obj.GetBasisSchemeName (int schemeIndex)</computeroutput> - This variable controls the dimensionality of output tuples in Assess mode. Consider the case where you have requested a PCA on D columns.</para><para>When set to vtkPCAStatistics::FULL_BASIS, the entire set of basis vectors is used to derive new coordinates for each tuple being assessed. In this mode, you are guaranteed to have output tuples of the same dimension as the input tuples. (That dimension is D, so there will be D additional columns added to the table for the request.)</para><para>When set to vtkPCAStatistics::FIXED_BASIS_SIZE, only the first N basis vectors are used to derive new coordinates for each tuple being assessed. In this mode, you are guaranteed to have output tuples of dimension min(N,D). You must set N prior to assessing data using the SetFixedBasisSize() method. When N &lt; D, this turns the PCA into a projection (instead of change of basis).</para><para>When set to vtkPCAStatistics::FIXED_BASIS_ENERGY, the number of basis vectors used to derive new coordinates for each tuple will be the minimum number of columns N that satisfy <formula id="185">\[ \frac{\sum_{i=1}^{N} \lambda_i}{\sum_{i=1}^{D} \lambda_i} &lt; T \]</formula> You must set T prior to assessing data using the SetFixedBasisEnergy() method. When T &lt; 1, this turns the PCA into a projection (instead of change of basis).</para><para>By default BasisScheme is set to vtkPCAStatistics::FULL_BASIS.  </para></listitem>
<listitem>
<para><computeroutput>obj.SetBasisSchemeByName (string schemeName)</computeroutput> - This variable controls the dimensionality of output tuples in Assess mode. Consider the case where you have requested a PCA on D columns.</para><para>When set to vtkPCAStatistics::FULL_BASIS, the entire set of basis vectors is used to derive new coordinates for each tuple being assessed. In this mode, you are guaranteed to have output tuples of the same dimension as the input tuples. (That dimension is D, so there will be D additional columns added to the table for the request.)</para><para>When set to vtkPCAStatistics::FIXED_BASIS_SIZE, only the first N basis vectors are used to derive new coordinates for each tuple being assessed. In this mode, you are guaranteed to have output tuples of dimension min(N,D). You must set N prior to assessing data using the SetFixedBasisSize() method. When N &lt; D, this turns the PCA into a projection (instead of change of basis).</para><para>When set to vtkPCAStatistics::FIXED_BASIS_ENERGY, the number of basis vectors used to derive new coordinates for each tuple will be the minimum number of columns N that satisfy <formula id="185">\[ \frac{\sum_{i=1}^{N} \lambda_i}{\sum_{i=1}^{D} \lambda_i} &lt; T \]</formula> You must set T prior to assessing data using the SetFixedBasisEnergy() method. When T &lt; 1, this turns the PCA into a projection (instead of change of basis).</para><para>By default BasisScheme is set to vtkPCAStatistics::FULL_BASIS.  </para></listitem>
<listitem>
<para><computeroutput>obj.SetFixedBasisSize (int )</computeroutput> - The number of basis vectors to use. See SetBasisScheme() for more information. When FixedBasisSize &lt;= 0 (the default), the fixed basis size scheme is equivalent to the full basis scheme.  </para></listitem>
<listitem>
<para><computeroutput>int = obj.GetFixedBasisSize ()</computeroutput> - The number of basis vectors to use. See SetBasisScheme() for more information. When FixedBasisSize &lt;= 0 (the default), the fixed basis size scheme is equivalent to the full basis scheme.  </para></listitem>
<listitem>
<para><computeroutput>obj.SetFixedBasisEnergy (double )</computeroutput> - The minimum energy the new basis should use, as a fraction. See SetBasisScheme() for more information. When FixedBasisEnergy &gt;= 1 (the default), the fixed basis energy scheme is equivalent to the full basis scheme.  </para></listitem>
<listitem>
<para><computeroutput>double = obj.GetFixedBasisEnergyMinValue ()</computeroutput> - The minimum energy the new basis should use, as a fraction. See SetBasisScheme() for more information. When FixedBasisEnergy &gt;= 1 (the default), the fixed basis energy scheme is equivalent to the full basis scheme.  </para></listitem>
<listitem>
<para><computeroutput>double = obj.GetFixedBasisEnergyMaxValue ()</computeroutput> - The minimum energy the new basis should use, as a fraction. See SetBasisScheme() for more information. When FixedBasisEnergy &gt;= 1 (the default), the fixed basis energy scheme is equivalent to the full basis scheme.  </para></listitem>
<listitem>
<para><computeroutput>double = obj.GetFixedBasisEnergy ()</computeroutput> - The minimum energy the new basis should use, as a fraction. See SetBasisScheme() for more information. When FixedBasisEnergy &gt;= 1 (the default), the fixed basis energy scheme is equivalent to the full basis scheme.  </para></listitem>
</itemizedlist>
</para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>

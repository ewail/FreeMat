
\begin{DoxyItemize}
\item \hyperlink{array_arrayfun}{A\-R\-R\-A\-Y\-F\-U\-N Apply a Function To Elements of an Array}  
\item \hyperlink{array_assign}{A\-S\-S\-I\-G\-N Making assignments}  
\item \hyperlink{array_cell}{C\-E\-L\-L Cell Array of Empty Matrices}  
\item \hyperlink{array_cellfun}{C\-E\-L\-L\-F\-U\-N Appy a Function To Elements of a Cell Array}  
\item \hyperlink{array_circshift}{C\-I\-R\-C\-S\-H\-I\-F\-T Circularly Shift an Array}  
\item \hyperlink{array_cond}{C\-O\-N\-D Condition Number of a Matrix}  
\item \hyperlink{array_det}{D\-E\-T Determinant of a Matrix}  
\item \hyperlink{array_diag}{D\-I\-A\-G Diagonal Matrix Construction/\-Extraction}  
\item \hyperlink{array_expm}{E\-X\-P\-M Matrix Exponential}  
\item \hyperlink{array_eye}{E\-Y\-E Identity Matrix}  
\item \hyperlink{array_find}{F\-I\-N\-D Find Non-\/zero Elements of An Array}  
\item \hyperlink{array_flipdim}{F\-L\-I\-P\-D\-I\-M Reverse a Matrix Along a Given Dimension}  
\item \hyperlink{array_fliplr}{F\-L\-I\-P\-L\-R Reverse the Columns of a Matrix}  
\item \hyperlink{array_flipud}{F\-L\-I\-P\-U\-D Reverse the Columns of a Matrix}  
\item \hyperlink{array_ipermute}{I\-P\-E\-R\-M\-U\-T\-E Array Inverse Permutation Function}  
\item \hyperlink{array_isfloat}{I\-S\-F\-L\-O\-A\-T Test for Floating Point Array}  
\item \hyperlink{array_isinteger}{I\-S\-I\-N\-T\-E\-G\-E\-R Test for Integer Array}  
\item \hyperlink{array_linspace}{L\-I\-N\-S\-P\-A\-C\-E Linearly Spaced Vector}  
\item \hyperlink{array_logspace}{L\-O\-G\-S\-P\-A\-C\-E Logarithmically Spaced Vector}  
\item \hyperlink{array_meshgrid}{M\-E\-S\-H\-G\-R\-I\-D Generate Grid Mesh For Plots}  
\item \hyperlink{array_nan}{N\-A\-N Not-\/a-\/\-Number Constant}  
\item \hyperlink{array_ndgrid}{N\-D\-G\-R\-I\-D Generate N-\/\-Dimensional Grid}  
\item \hyperlink{array_nonzeros}{N\-O\-N\-Z\-E\-R\-O\-S Retrieve Nonzero Matrix Entries}  
\item \hyperlink{array_norm}{N\-O\-R\-M Norm Calculation}  
\item \hyperlink{array_num2str}{N\-U\-M2\-S\-T\-R Convert Numbers To Strings}  
\item \hyperlink{array_ones}{O\-N\-E\-S Array of Ones}  
\item \hyperlink{array_permute}{P\-E\-R\-M\-U\-T\-E Array Permutation Function}  
\item \hyperlink{array_pinv}{P\-I\-N\-V Moore-\/\-Penrose Pseudoinverse}  
\item \hyperlink{array_rank}{R\-A\-N\-K Calculate the Rank of a Matrix}  
\item \hyperlink{array_rcond}{R\-C\-O\-N\-D Reciprocal Condition Number Estimate}  
\item \hyperlink{array_repmat}{R\-E\-P\-M\-A\-T Array Replication Function}  
\item \hyperlink{array_reshape}{R\-E\-S\-H\-A\-P\-E Reshape An Array}  
\item \hyperlink{array_rref}{R\-R\-E\-F Reduced Row Echelon Form of a Matrix}  
\item \hyperlink{array_shiftdim}{S\-H\-I\-F\-T\-D\-I\-M Shift Array Dimensions Function}  
\item \hyperlink{array_sort}{S\-O\-R\-T Sort }  
\item \hyperlink{array_squeeze}{S\-Q\-U\-E\-E\-Z\-E Remove Singleton Dimensions of an Array}  
\item \hyperlink{array_subsref}{S\-U\-B\-S\-R\-E\-F Array Dereferencing}  
\item \hyperlink{array_trace}{T\-R\-A\-C\-E Sum Diagonal Elements of an Array}  
\item \hyperlink{array_transpose}{T\-R\-A\-N\-S\-P\-O\-S\-E Matrix Transpose }  
\item \hyperlink{array_tril}{T\-R\-I\-L Lower Triangular Matrix Function}  
\item \hyperlink{array_triu}{T\-R\-I\-U Upper Triangular Matrix Function}  
\item \hyperlink{array_unique}{U\-N\-I\-Q\-U\-E Unique}  
\item \hyperlink{array_xnrm2}{X\-N\-R\-M2 B\-L\-A\-S Norm Calculation}  
\item \hyperlink{array_zeros}{Z\-E\-R\-O\-S Array of Zeros}  
\end{DoxyItemize}\hypertarget{array_arrayfun}{}\section{A\-R\-R\-A\-Y\-F\-U\-N Apply a Function To Elements of an Array}\label{array_arrayfun}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The {\ttfamily arrayfun} function is used to apply a function handle to each element of an input array (or arrays), and to collect the outputs into an array. The general syntax for its use is \begin{DoxyVerb}   y = arrayfun(fun, x)
\end{DoxyVerb}
 where {\ttfamily x} is an N-\/dimensional array. In this case, each element of the output {\ttfamily y\-\_\-i} is defined as {\ttfamily fun(x\-\_\-i)}. You can also supply multiple arguments to {\ttfamily arrayfun}, provided all of the arguments are the same size \begin{DoxyVerb}   y = arrayfun(fun, x, z,...)
\end{DoxyVerb}
 in which case each output {\ttfamily y\-\_\-i = fun(x\-\_\-i,z\-\_\-i,...)}.

If the function returns multiple outputs, then {\ttfamily arrayfun} can be called with multiple outputs, in which case each output goes to a separate array output \begin{DoxyVerb}   [y1,y2,...] = arrayfun(fun, x, z, ...)
\end{DoxyVerb}
 The assumption is that the output types for each call to {\ttfamily fun} is the same across the inputs.

Finally, some hints can be provided to {\ttfamily arrayfun} using the syntax \begin{DoxyVerb}   [y1,y2,...] = arrayfun(fun, x, z, ..., 'param', value, 'param', value)
\end{DoxyVerb}
 where {\ttfamily param} and {\ttfamily value} take on the following possible values\-: 
\begin{DoxyItemize}
\item {\ttfamily 'Uniform\-Output'} -\/ if the {\ttfamily value} is {\ttfamily true} then each output of {\ttfamily fun} must be a scalar, and the outputs are concatenated into an array the same size as the input arrays. If the {\ttfamily value} is {\ttfamily false} then the outputs are encapsulated into a cell array, with each entry in the cell array containing the call to {\ttfamily fun(x\-\_\-i,z\-\_\-i,...)}.  
\item {\ttfamily 'Error\-Handler'} -\/ in this case {\ttfamily value} is a function handle that gets called when {\ttfamily fun} throws an error. If {\ttfamily 'Error\-Handler'} is not specified, then {\ttfamily arrayfun} allows the error to propogate (i.\-e., and exception is thrown).  
\end{DoxyItemize}\hypertarget{array_assign}{}\section{A\-S\-S\-I\-G\-N Making assignments}\label{array_assign}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Free\-Mat assignments take a number of different forms, depending on the type of the variable you want to make an assignment to. For numerical arrays and strings, the form of an assignment is either \begin{DoxyVerb}  a(ndx) = val
\end{DoxyVerb}
 where {\ttfamily ndx} is a set of vector indexing coordinates. This means that the values {\ttfamily ndx} takes reference the elements of {\ttfamily a} in column order. So, if, for example {\ttfamily a} is an {\ttfamily N x M} matrix, the first column has vector indices {\ttfamily 1,2,...,N}, and the second column has indices {\ttfamily N+1,N+2,...,2\-N}, and so on. Alternately, you can use multi-\/dimensional indexing to make an assignment\-: \begin{DoxyVerb}  a(ndx_1,ndx_2,..,ndx_m) = val
\end{DoxyVerb}
 where each indexing expression {\ttfamily ndx\-\_\-i} corresponds to the {\ttfamily i-\/th} dimension of {\ttfamily a}. In both cases, (vector or multi-\/dimensional indexing), the right hand side {\ttfamily val} must either be a scalar, an empty matrix, or of the same size as the indices. If {\ttfamily val} is an empty matrix, the assignment acts like a delete. Note that the type of {\ttfamily a} may be modified by the assignment. So, for example, assigning a {\ttfamily double} value to an element of a {\ttfamily float} array {\ttfamily a} will cause the array {\ttfamily a} to become {\ttfamily double}.

For cell arrays, the above forms of assignment will still work, but only if {\ttfamily val} is also a cell array. If you want to assign the contents of a cell in a cell array, you must use one of the two following forms, either \begin{DoxyVerb}  a{ndx} = val
\end{DoxyVerb}
 or \begin{DoxyVerb}  a{ndx_1,ndx_2,...,ndx_m} = val
\end{DoxyVerb}
 which will modify the contents of the cell. \hypertarget{array_cell}{}\section{C\-E\-L\-L Cell Array of Empty Matrices}\label{array_cell}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Creates a cell array of empty matrix entres. Two seperate syntaxes are possible. The first syntax specifies the array dimensions as a sequence of scalar dimensions\-: \begin{DoxyVerb}   y = cell(d1,d2,...,dn).
\end{DoxyVerb}
 The resulting array has the given dimensions, and is filled with all zeros. The type of {\ttfamily y} is {\ttfamily cell}, a cell array.

The second syntax specifies the array dimensions as a vector, where each element in the vector specifies a dimension length\-: \begin{DoxyVerb}   y = cell([d1,d2,...,dn]).
\end{DoxyVerb}
 This syntax is more convenient for calling {\ttfamily zeros} using a variable for the argument. In both cases, specifying only one dimension results in a square matrix output. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
The following examples demonstrate generation of some zero arrays using the first form.


\begin{DoxyVerbInclude}
--> cell(2,3,2)

ans = 

(:,:,1) = 
 [] [] [] 
 [] [] [] 

(:,:,2) = 
 [] [] [] 
 [] [] [] 

--> cell(1,3)

ans = 
 [] [] [] 
\end{DoxyVerbInclude}


The same expressions, using the second form.


\begin{DoxyVerbInclude}
--> cell([2,6])

ans = 
 [] [] [] [] [] [] 
 [] [] [] [] [] [] 

--> cell([1,3])

ans = 
 [] [] [] 
\end{DoxyVerbInclude}
 \hypertarget{array_cellfun}{}\section{C\-E\-L\-L\-F\-U\-N Appy a Function To Elements of a Cell Array}\label{array_cellfun}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The {\ttfamily cellfun} function is used to apply a function handle (or anonymous function) to each element of a cell array and to collect the outputs into an array. The general syntax for its use is \begin{DoxyVerb}   y = cellfun(fun, x)
\end{DoxyVerb}
 where {\ttfamily x} is an N-\/dimensional array. In this case, each element of the output {\ttfamily y\-\_\-i} is defined as {\ttfamily fun(x\{i\})}. You can also supply multiple arguments to {\ttfamily cellfun}, provided all of the arguments are the same size \begin{DoxyVerb}   y = cellfun(fun, x, z, ...)
\end{DoxyVerb}
 in which case each output {\ttfamily y\-\_\-i} is defined as {\ttfamily fun(x\{i\},z\{i\},...)}. Note that unlike {\ttfamily arrayfun}, the {\ttfamily cellfun} function will allow for different types (if there are overloaded versions of the function {\ttfamily fun}) for each element.

If the function returns multiple outputs, then {\ttfamily arrayfun} can be called with multiple outputs, in which case each output goes to a separate array output \begin{DoxyVerb}   [y1,y2,...] = cellfun(fun, x, z, ...)
\end{DoxyVerb}
 The assumption is that the output types for each call to {\ttfamily fun} is the same across the inputs.

Finally, some hints can be provided to {\ttfamily cellfun} using the syntax \begin{DoxyVerb}   [y1,y2,...] = cellfun(fun, x, z, ..., 'param', value, 'param', value)
\end{DoxyVerb}
 where {\ttfamily param} and {\ttfamily value} take on the following possible values\-: 
\begin{DoxyItemize}
\item {\ttfamily 'Uniform\-Output'} -\/ if the {\ttfamily value} is {\ttfamily true} then each output of {\ttfamily fun} must be a scalar, and the outputs are concatenated into an array the same size as the input arrays. If the {\ttfamily value} is {\ttfamily false} then the outputs are encapsulated into a cell array, with each entry in the cell array containing the call to {\ttfamily fun(x\-\_\-i,z\-\_\-i,...)}.  
\item {\ttfamily 'Error\-Handler'} -\/ in this case {\ttfamily value} is a function handle that gets called when {\ttfamily fun} throws an error. If {\ttfamily 'Error\-Handler'} is not specified, then {\ttfamily arrayfun} allows the error to propogate (i.\-e., and exception is thrown).  
\end{DoxyItemize}\hypertarget{array_circshift}{}\section{C\-I\-R\-C\-S\-H\-I\-F\-T Circularly Shift an Array}\label{array_circshift}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{typecast_dec2bin_USAGE}{}\subsection{U\-S\-A\-G\-E}\label{typecast_dec2bin_USAGE}
Applies a circular shift along each dimension of a given array. The syntax for its use is \begin{DoxyVerb}   y = circshift(x,shiftvec)
\end{DoxyVerb}
 where {\ttfamily x} is an n-\/dimensional array, and {\ttfamily shiftvec} is a vector of integers, each of which specify how much to shift {\ttfamily x} along the corresponding dimension. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
The following examples show some uses of {\ttfamily circshift} on N-\/dimensional arrays.


\begin{DoxyVerbInclude}
--> x = int32(rand(4,5)*10)

x = 
  4  8  3  2  9 
  0  8  0  5  3 
  9  1  5  8  2 
  4  5 10  3  7 

--> circshift(x,[1,0])

ans = 
  4  5 10  3  7 
  4  8  3  2  9 
  0  8  0  5  3 
  9  1  5  8  2 

--> circshift(x,[0,-1])

ans = 
  8  3  2  9  4 
  8  0  5  3  0 
  1  5  8  2  9 
  5 10  3  7  4 

--> circshift(x,[2,2])

ans = 
  8  2  9  1  5 
  3  7  4  5 10 
  2  9  4  8  3 
  5  3  0  8  0 

--> x = int32(rand(4,5,3)*10)

x = 

(:,:,1) = 
  2  7  7  3 10 
  2  2  3  7  0 
  4  8  1  4  0 
 10  2  7  8  9 

(:,:,2) = 
  5  7 10  9  4 
  0  3  5  0  4 
  4  5  1  3  6 
  9  1  5  1  5 

(:,:,3) = 
  1  5  6  9  2 
  8 10  6  5  7 
  6  2  1  6  8 
  1  9  6  5  3 

--> circshift(x,[1,0,0])

ans = 

(:,:,1) = 
 10  2  7  8  9 
  2  7  7  3 10 
  2  2  3  7  0 
  4  8  1  4  0 

(:,:,2) = 
  9  1  5  1  5 
  5  7 10  9  4 
  0  3  5  0  4 
  4  5  1  3  6 

(:,:,3) = 
  1  9  6  5  3 
  1  5  6  9  2 
  8 10  6  5  7 
  6  2  1  6  8 

--> circshift(x,[0,-1,0])

ans = 

(:,:,1) = 
  7  7  3 10  2 
  2  3  7  0  2 
  8  1  4  0  4 
  2  7  8  9 10 

(:,:,2) = 
  7 10  9  4  5 
  3  5  0  4  0 
  5  1  3  6  4 
  1  5  1  5  9 

(:,:,3) = 
  5  6  9  2  1 
 10  6  5  7  8 
  2  1  6  8  6 
  9  6  5  3  1 

--> circshift(x,[0,0,-1])

ans = 

(:,:,1) = 
  5  7 10  9  4 
  0  3  5  0  4 
  4  5  1  3  6 
  9  1  5  1  5 

(:,:,2) = 
  1  5  6  9  2 
  8 10  6  5  7 
  6  2  1  6  8 
  1  9  6  5  3 

(:,:,3) = 
  2  7  7  3 10 
  2  2  3  7  0 
  4  8  1  4  0 
 10  2  7  8  9 

--> circshift(x,[2,-3,1])

ans = 

(:,:,1) = 
  6  8  6  2  1 
  5  3  1  9  6 
  9  2  1  5  6 
  5  7  8 10  6 

(:,:,2) = 
  4  0  4  8  1 
  8  9 10  2  7 
  3 10  2  7  7 
  7  0  2  2  3 

(:,:,3) = 
  3  6  4  5  1 
  1  5  9  1  5 
  9  4  5  7 10 
  0  4  0  3  5 
\end{DoxyVerbInclude}
 \hypertarget{array_cond}{}\section{C\-O\-N\-D Condition Number of a Matrix}\label{array_cond}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Calculates the condition number of a matrix. To compute the 2-\/norm condition number of a matrix (ratio of largest to smallest singular values), use the syntax \begin{DoxyVerb}   y = cond(A)
\end{DoxyVerb}
 where A is a matrix. If you want to compute the condition number in a different norm (e.\-g., the 1-\/norm), use the second syntax \begin{DoxyVerb}   y = cond(A,p)
\end{DoxyVerb}
 where {\ttfamily p} is the norm to use when computing the condition number. The following choices of {\ttfamily p} are supported 
\begin{DoxyItemize}
\item {\ttfamily p = 1} returns the 1-\/norm, or the max column sum of A  
\item {\ttfamily p = 2} returns the 2-\/norm (largest singular value of A)  
\item {\ttfamily p = inf} returns the infinity norm, or the max row sum of A  
\item {\ttfamily p = 'fro'} returns the Frobenius-\/norm (vector Euclidean norm, or R\-M\-S value)  
\end{DoxyItemize}\hypertarget{transforms_svd_Function}{}\subsection{Internals}\label{transforms_svd_Function}
The condition number is defined as \[ \frac{\|A\|_p}{\|A^{-1}\|_p} \] This equation is precisely how the condition number is computed for the case {\ttfamily p $\sim$= 2}. For the {\ttfamily p=2} case, the condition number can be computed much more efficiently using the ratio of the largest and smallest singular values. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
The condition number of this matrix is large


\begin{DoxyVerbInclude}
--> A = [1,1;0,1e-15]

A = 
    1.0000    1.0000 
         0    0.0000 

--> cond(A)

ans = 
 2.0000e+15 

--> cond(A,1)

ans = 
 2000000000000002 
\end{DoxyVerbInclude}


You can also (for the case {\ttfamily p=1} use {\ttfamily rcond} to calculate an estimate of the condition number


\begin{DoxyVerbInclude}
--> 1/rcond(A)

ans = 
 2.0000e+15 
\end{DoxyVerbInclude}
 \hypertarget{array_det}{}\section{D\-E\-T Determinant of a Matrix}\label{array_det}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Calculates the determinant of a matrix. Note that for all but very small problems, the determinant is not particularly useful. The condition number {\ttfamily cond} gives a more reasonable estimate as to the suitability of a matrix for inversion than comparing {\ttfamily det(\-A)} to zero. In any case, the syntax for its use is \begin{DoxyVerb}  y = det(A)
\end{DoxyVerb}
 where A is a square matrix. \hypertarget{transforms_svd_Function}{}\subsection{Internals}\label{transforms_svd_Function}
The determinant is calculated via the {\ttfamily L\-U} decomposition. Note that the determinant of a product of matrices is the product of the determinants. Then, we have that \[ L U = P A \] where {\ttfamily L} is lower triangular with 1s on the main diagonal, {\ttfamily U} is upper triangular, and {\ttfamily P} is a row-\/permutation matrix. Taking the determinant of both sides yields \[ |L U| = |L| |U| = |U| = |P A| = |P| |A| \] where we have used the fact that the determinant of {\ttfamily L} is 1. The determinant of {\ttfamily P} (which is a row exchange matrix) is either 1 or -\/1. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Here we assemble a random matrix and compute its determinant


\begin{DoxyVerbInclude}
--> A = rand(5);
--> det(A)

ans = 
   -0.0489 
\end{DoxyVerbInclude}


Then, we exchange two rows of {\ttfamily A} to demonstrate how the determinant changes sign (but the magnitude is the same)


\begin{DoxyVerbInclude}
--> B = A([2,1,3,4,5],:);
--> det(B)

ans = 
    0.0489 
\end{DoxyVerbInclude}
 \hypertarget{array_diag}{}\section{D\-I\-A\-G Diagonal Matrix Construction/\-Extraction}\label{array_diag}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The {\ttfamily diag} function is used to either construct a diagonal matrix from a vector, or return the diagonal elements of a matrix as a vector. The general syntax for its use is \begin{DoxyVerb}  y = diag(x,n)
\end{DoxyVerb}
 If {\ttfamily x} is a matrix, then {\ttfamily y} returns the {\ttfamily n}-\/th diagonal. If {\ttfamily n} is omitted, it is assumed to be zero. Conversely, if {\ttfamily x} is a vector, then {\ttfamily y} is a matrix with {\ttfamily x} set to the {\ttfamily n}-\/th diagonal. \hypertarget{variables_matrix_Examples}{}\subsection{Examples}\label{variables_matrix_Examples}
Here is an example of {\ttfamily diag} being used to extract a diagonal from a matrix.


\begin{DoxyVerbInclude}
--> A = int32(10*rand(4,5))

A = 
  5  8  8  3  6 
  4  8  4  3  7 
  9  5  8  4  2 
  1  0 10  0  4 

--> diag(A)

ans = 
 5 
 8 
 8 
 0 

--> diag(A,1)

ans = 
 8 
 4 
 4 
 4 
\end{DoxyVerbInclude}


Here is an example of the second form of {\ttfamily diag}, being used to construct a diagonal matrix.


\begin{DoxyVerbInclude}
--> x = int32(10*rand(1,3))

x = 
 6 3 9 

--> diag(x)

ans = 
 6 0 0 
 0 3 0 
 0 0 9 

--> diag(x,-1)

ans = 
 0 0 0 0 
 6 0 0 0 
 0 3 0 0 
 0 0 9 0 
\end{DoxyVerbInclude}
 \hypertarget{array_expm}{}\section{E\-X\-P\-M Matrix Exponential}\label{array_expm}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Calculates {\ttfamily e$^\wedge$\-A} for a square, full rank matrix {\ttfamily A}. The syntax for its use is \begin{DoxyVerb}   y = expm(A)
\end{DoxyVerb}
 Internally, {\ttfamily expm} is mapped to a simple {\ttfamily e$^\wedge$\-A} expression (which in turn uses the eigenvalue expansion of {\ttfamily A} to compute the exponential). \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
An example of {\ttfamily expm}


\begin{DoxyVerbInclude}
--> A = [1 1 0; 0 0 2; 0 0 -1]

A = 
  1  1  0 
  0  0  2 
  0  0 -1 

--> expm(A)

ans = 
    2.7183    1.7183    1.0862 
         0    1.0000    1.2642 
         0         0    0.3679 
\end{DoxyVerbInclude}
 \hypertarget{array_eye}{}\section{E\-Y\-E Identity Matrix}\label{array_eye}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{typecast_dec2bin_USAGE}{}\subsection{U\-S\-A\-G\-E}\label{typecast_dec2bin_USAGE}
Creates an identity matrix of the specified size. The syntax for its use is \begin{DoxyVerb}   y = eye(n)
\end{DoxyVerb}
 where {\ttfamily n} is the size of the identity matrix. The type of the output matrix is {\ttfamily float}. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
The following example demonstrates the identity matrix.


\begin{DoxyVerbInclude}
--> eye(3)

ans = 
 1 0 0 
 0 1 0 
 0 0 1 
\end{DoxyVerbInclude}
 \hypertarget{array_find}{}\section{F\-I\-N\-D Find Non-\/zero Elements of An Array}\label{array_find}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Returns a vector that contains the indicies of all non-\/zero elements in an array. The usage is \begin{DoxyVerb}   y = find(x)
\end{DoxyVerb}
 The indices returned are generalized column indices, meaning that if the array {\ttfamily x} is of size {\ttfamily \mbox{[}d1,d2,...,dn\mbox{]}}, and the element {\ttfamily x(i1,i2,...,in)} is nonzero, then {\ttfamily y} will contain the integer \[ i_1 + (i_2-1) d_1 + (i_3-1) d_1 d_2 + \dots \] The second syntax for the {\ttfamily find} command is \begin{DoxyVerb}   [r,c] = find(x)
\end{DoxyVerb}
 which returns the row and column index of the nonzero entries of {\ttfamily x}. The third syntax for the {\ttfamily find} command also returns the values \begin{DoxyVerb}   [r,c,v] = find(x).
\end{DoxyVerb}
 Note that if the argument is a row vector, then the returned vectors are also row vectors. This form is particularly useful for converting sparse matrices into I\-J\-V form.

The {\ttfamily find} command also supports some additional arguments. Each of the above forms can be combined with an integer indicating how many results to return\-: \begin{DoxyVerb}   y = find(x,k)
\end{DoxyVerb}
 where {\ttfamily k} is the maximum number of results to return. This form will return the first {\ttfamily k} results. You can also specify an optional flag indicating whether to take the first or last {\ttfamily k} values\-: \begin{DoxyVerb}   y = find(x,k,'first')
   y = find(x,k,'last')
\end{DoxyVerb}
 in the case of the {\ttfamily 'last'} argument, the last {\ttfamily k} values are returned. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Some simple examples of its usage, and some common uses of {\ttfamily find} in Free\-Mat programs.


\begin{DoxyVerbInclude}
--> a = [1,2,5,2,4];
--> find(a==2)

ans = 
 2 4 
\end{DoxyVerbInclude}


Here is an example of using find to replace elements of {\ttfamily A} that are {\ttfamily 0} with the number {\ttfamily 5}.


\begin{DoxyVerbInclude}
--> A = [1,0,3;0,2,1;3,0,0]

A = 
 1 0 3 
 0 2 1 
 3 0 0 

--> n = find(A==0)

n = 
 2 
 4 
 6 
 9 

--> A(n) = 5

A = 
 1 5 3 
 5 2 1 
 3 5 5 
\end{DoxyVerbInclude}


Incidentally, a better way to achieve the same concept is\-:


\begin{DoxyVerbInclude}
--> A = [1,0,3;0,2,1;3,0,0]

A = 
 1 0 3 
 0 2 1 
 3 0 0 

--> A(A==0) = 5

A = 
 1 5 3 
 5 2 1 
 3 5 5 
\end{DoxyVerbInclude}


Now, we can also return the indices as row and column indices using the two argument form of {\ttfamily find}\-:


\begin{DoxyVerbInclude}
--> A = [1,0,3;0,2,1;3,0,0]

A = 
 1 0 3 
 0 2 1 
 3 0 0 

--> [r,c] = find(A)
r = 
 1 
 3 
 2 
 1 
 2 

c = 
 1 
 1 
 2 
 3 
 3 
\end{DoxyVerbInclude}


Or the three argument form of {\ttfamily find}, which returns the value also\-:


\begin{DoxyVerbInclude}
--> [r,c,v] = find(A)
r = 
 1 
 3 
 2 
 1 
 2 

c = 
 1 
 1 
 2 
 3 
 3 

v = 
 1 
 3 
 2 
 3 
 1 
\end{DoxyVerbInclude}
 \hypertarget{array_flipdim}{}\section{F\-L\-I\-P\-D\-I\-M Reverse a Matrix Along a Given Dimension}\label{array_flipdim}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{typecast_dec2bin_USAGE}{}\subsection{U\-S\-A\-G\-E}\label{typecast_dec2bin_USAGE}
Reverses an array along the given dimension. The syntax for its use is \begin{DoxyVerb}   y = flipdim(x,n)
\end{DoxyVerb}
 where {\ttfamily x} is matrix, and {\ttfamily n} is the dimension to reverse. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
The following examples show some uses of {\ttfamily flipdim} on N-\/dimensional arrays.


\begin{DoxyVerbInclude}
--> x = int32(rand(4,5,3)*10)

x = 

(:,:,1) = 
  5  2  4  2  8 
  7  6  6  6  7 
  7  0  1  1  0 
  3  2  1  9  9 

(:,:,2) = 
 10  6  3  3  1 
  1  2  5  7 10 
  9  7  5  1  4 
  3 10  4  4  3 

(:,:,3) = 
  3  6  5  8  9 
  9  8  5  3  0 
  1  7  9  4  8 
  4  6  4  9  5 

--> flipdim(x,1)

ans = 

(:,:,1) = 
  3  2  1  9  9 
  7  0  1  1  0 
  7  6  6  6  7 
  5  2  4  2  8 

(:,:,2) = 
  3 10  4  4  3 
  9  7  5  1  4 
  1  2  5  7 10 
 10  6  3  3  1 

(:,:,3) = 
  4  6  4  9  5 
  1  7  9  4  8 
  9  8  5  3  0 
  3  6  5  8  9 

--> flipdim(x,2)

ans = 

(:,:,1) = 
  8  2  4  2  5 
  7  6  6  6  7 
  0  1  1  0  7 
  9  9  1  2  3 

(:,:,2) = 
  1  3  3  6 10 
 10  7  5  2  1 
  4  1  5  7  9 
  3  4  4 10  3 

(:,:,3) = 
  9  8  5  6  3 
  0  3  5  8  9 
  8  4  9  7  1 
  5  9  4  6  4 

--> flipdim(x,3)

ans = 

(:,:,1) = 
  3  6  5  8  9 
  9  8  5  3  0 
  1  7  9  4  8 
  4  6  4  9  5 

(:,:,2) = 
 10  6  3  3  1 
  1  2  5  7 10 
  9  7  5  1  4 
  3 10  4  4  3 

(:,:,3) = 
  5  2  4  2  8 
  7  6  6  6  7 
  7  0  1  1  0 
  3  2  1  9  9 
\end{DoxyVerbInclude}
 \hypertarget{array_fliplr}{}\section{F\-L\-I\-P\-L\-R Reverse the Columns of a Matrix}\label{array_fliplr}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{typecast_dec2bin_USAGE}{}\subsection{U\-S\-A\-G\-E}\label{typecast_dec2bin_USAGE}
Reverses the columns of a matrix. The syntax for its use is \begin{DoxyVerb}   y = fliplr(x)
\end{DoxyVerb}
 where {\ttfamily x} is matrix. If {\ttfamily x} is an N-\/dimensional array then the second dimension is reversed. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
The following example shows {\ttfamily fliplr} applied to a 2\-D matrix.


\begin{DoxyVerbInclude}
--> x = int32(rand(4)*10)

x = 
  6  4  7  4 
  8  5  4  1 
  5  8  7  9 
  1 10  9  9 

--> fliplr(x)

ans = 
  4  7  4  6 
  1  4  5  8 
  9  7  8  5 
  9  9 10  1 
\end{DoxyVerbInclude}


For a 3\-D array, note how the columns in each slice are flipped.


\begin{DoxyVerbInclude}
--> x = int32(rand(4,4,3)*10)

x = 

(:,:,1) = 
  4  8  1  8 
  1  5  5  2 
  2 10  5  8 
  4  8  2  1 

(:,:,2) = 
  0  3  4  1 
  6  6 10  8 
  4  3  3  6 
  2  9  7  3 

(:,:,3) = 
  6  5  1  1 
  6  8 10  3 
  4  3  7  9 
  9  4  4  3 

--> fliplr(x)

ans = 

(:,:,1) = 
  8  1  8  4 
  2  5  5  1 
  8  5 10  2 
  1  2  8  4 

(:,:,2) = 
  1  4  3  0 
  8 10  6  6 
  6  3  3  4 
  3  7  9  2 

(:,:,3) = 
  1  1  5  6 
  3 10  8  6 
  9  7  3  4 
  3  4  4  9 
\end{DoxyVerbInclude}
 \hypertarget{array_flipud}{}\section{F\-L\-I\-P\-U\-D Reverse the Columns of a Matrix}\label{array_flipud}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{typecast_dec2bin_USAGE}{}\subsection{U\-S\-A\-G\-E}\label{typecast_dec2bin_USAGE}
Reverses the rows of a matrix. The syntax for its use is \begin{DoxyVerb}   y = flipud(x)
\end{DoxyVerb}
 where {\ttfamily x} is matrix. If {\ttfamily x} is an N-\/dimensional array then the first dimension is reversed. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
The following example shows {\ttfamily flipud} applied to a 2\-D matrix.


\begin{DoxyVerbInclude}
--> x = int32(rand(4)*10)

x = 
 9 4 5 3 
 8 9 7 4 
 4 8 6 3 
 6 7 0 9 

--> flipud(x)

ans = 
 6 7 0 9 
 4 8 6 3 
 8 9 7 4 
 9 4 5 3 
\end{DoxyVerbInclude}


For a 3\-D array, note how the rows in each slice are flipped.


\begin{DoxyVerbInclude}
--> x = int32(rand(4,4,3)*10)

x = 

(:,:,1) = 
  7  4  3  3 
  0 10 10  6 
  2  8  1  8 
  1  1  9  8 

(:,:,2) = 
  4  4  3  2 
  4  4  7  1 
  4  9  9  8 
  5  5  1  6 

(:,:,3) = 
  9  7  7  5 
  8  9  5  6 
  5 10  6  8 
  4  2  8  3 

--> flipud(x)

ans = 

(:,:,1) = 
  1  1  9  8 
  2  8  1  8 
  0 10 10  6 
  7  4  3  3 

(:,:,2) = 
  5  5  1  6 
  4  9  9  8 
  4  4  7  1 
  4  4  3  2 

(:,:,3) = 
  4  2  8  3 
  5 10  6  8 
  8  9  5  6 
  9  7  7  5 
\end{DoxyVerbInclude}
 \hypertarget{array_ipermute}{}\section{I\-P\-E\-R\-M\-U\-T\-E Array Inverse Permutation Function}\label{array_ipermute}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The {\ttfamily ipermute} function rearranges the contents of an array according to the inverse of the specified permutation vector. The syntax for its use is \begin{DoxyVerb}   y = ipermute(x,p)
\end{DoxyVerb}
 where {\ttfamily p} is a permutation vector -\/ i.\-e., a vector containing the integers {\ttfamily 1...ndims(x)} each occuring exactly once. The resulting array {\ttfamily y} contains the same data as the array {\ttfamily x}, but ordered according to the inverse of the given permutation. This function and the {\ttfamily permute} function are inverses of each other. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
First we create a large multi-\/dimensional array, then permute it and then inverse permute it, to retrieve the original array\-:


\begin{DoxyVerbInclude}
--> A = randn(13,5,7,2);
--> size(A)

ans = 
 13  5  7  2 

--> B = permute(A,[3,4,2,1]);
--> size(B)

ans = 
  7  2  5 13 

--> C = ipermute(B,[3,4,2,1]);
--> size(C)

ans = 
 13  5  7  2 

--> any(A~=C)

ans = 

(:,:,1,1) = 
 0 0 0 0 0 

(:,:,2,1) = 
 0 0 0 0 0 

(:,:,3,1) = 
 0 0 0 0 0 

(:,:,4,1) = 
 0 0 0 0 0 

(:,:,5,1) = 
 0 0 0 0 0 

(:,:,6,1) = 
 0 0 0 0 0 

(:,:,7,1) = 
 0 0 0 0 0 

(:,:,1,2) = 
 0 0 0 0 0 

(:,:,2,2) = 
 0 0 0 0 0 

(:,:,3,2) = 
 0 0 0 0 0 

(:,:,4,2) = 
 0 0 0 0 0 

(:,:,5,2) = 
 0 0 0 0 0 

(:,:,6,2) = 
 0 0 0 0 0 

(:,:,7,2) = 
 0 0 0 0 0 
\end{DoxyVerbInclude}
 \hypertarget{array_isfloat}{}\section{I\-S\-F\-L\-O\-A\-T Test for Floating Point Array}\label{array_isfloat}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The syntax for {\ttfamily isfloat} is \begin{DoxyVerb}   x = isfloat(y)
\end{DoxyVerb}
 and it returns a logical 1 if the argument is a floating point array (i.\-e., a {\ttfamily single} or {\ttfamily double}), and a logical 0 otherwise. \hypertarget{array_isinteger}{}\section{I\-S\-I\-N\-T\-E\-G\-E\-R Test for Integer Array}\label{array_isinteger}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The syntax for {\ttfamily isinteger} is \begin{DoxyVerb}  x = isinteger(y)
\end{DoxyVerb}
 and it returns a logical 1 if the argument is an integer. The decision of whether the argument is an integer or not is made based on the class of {\ttfamily y}, not on its value. \hypertarget{array_linspace}{}\section{L\-I\-N\-S\-P\-A\-C\-E Linearly Spaced Vector}\label{array_linspace}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Generates a row vector with the specified number of elements, with entries uniformly spaced between two specified endpoints. The syntax for its use is either \begin{DoxyVerb}   y = linspace(a,b,count)
\end{DoxyVerb}
 or, for a default {\ttfamily count = 100}, \begin{DoxyVerb}   y = linspace(a,b);
\end{DoxyVerb}
 \hypertarget{variables_matrix_Examples}{}\subsection{Examples}\label{variables_matrix_Examples}
Here is a simple example of using {\ttfamily linspace}


\begin{DoxyVerbInclude}
--> x = linspace(0,1,5)

x = 
         0    0.2500    0.5000    0.7500    1.0000 
\end{DoxyVerbInclude}
 \hypertarget{array_logspace}{}\section{L\-O\-G\-S\-P\-A\-C\-E Logarithmically Spaced Vector}\label{array_logspace}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Generates a row vector with the specified number number of elements, with entries logarithmically spaced between two specified endpoints. The syntax for its use is either \begin{DoxyVerb}    y = logspace(a,b,count)
\end{DoxyVerb}
 or, for a default {\ttfamily count = 50}, \begin{DoxyVerb}    y = logspace(a,b)
\end{DoxyVerb}
 A third special use is when \begin{DoxyVerb}    y = logspace(a,pi)
\end{DoxyVerb}
 where it generates points between {\ttfamily 10$^\wedge$a} and {\ttfamily pi}

Contributed by Paulo Xavier Candeias under G\-P\-L. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Here is an example of the use of {\ttfamily logspace}


\begin{DoxyVerbInclude}
--> logspace(1,2,3)

ans = 
   10.0000   31.6228  100.0000 
\end{DoxyVerbInclude}
 \hypertarget{array_meshgrid}{}\section{M\-E\-S\-H\-G\-R\-I\-D Generate Grid Mesh For Plots}\label{array_meshgrid}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The {\ttfamily meshgrid} function generates arrays that can be used for the generation of surface plots. The syntax is one of \begin{DoxyVerb}  [X,Y] = meshgrid(x)
  [X,Y] = meshgrid(x,y)
  [X,Y,Z] = meshgrid(x,y,z)
\end{DoxyVerb}
 where {\ttfamily x,y,z} are vectors, and {\ttfamily X,Y,Z} are matrices. In the first case {\ttfamily \mbox{[}X,Y\mbox{]} = meshgrid(x)}, the rows of {\ttfamily X} and the columns of {\ttfamily Y} contain copies of the vector {\ttfamily x}. In the second case {\ttfamily \mbox{[}X,Y\mbox{]} = meshgrid(x,y)}, the rows of {\ttfamily X} contain copies of {\ttfamily x}, and the columns of {\ttfamily Y} contain copies of {\ttfamily y}. In the third case, each input is copied along the row, column or slice direction of the corresponding output variable. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
In the first example\-:


\begin{DoxyVerbInclude}
--> [X,Y] = meshgrid(-2:.4:2)
X = 

 Columns 1 to 7

   -2.0000   -1.6000   -1.2000   -0.8000   -0.4000    0.0000    0.4000 
   -2.0000   -1.6000   -1.2000   -0.8000   -0.4000    0.0000    0.4000 
   -2.0000   -1.6000   -1.2000   -0.8000   -0.4000    0.0000    0.4000 
   -2.0000   -1.6000   -1.2000   -0.8000   -0.4000    0.0000    0.4000 
   -2.0000   -1.6000   -1.2000   -0.8000   -0.4000    0.0000    0.4000 
   -2.0000   -1.6000   -1.2000   -0.8000   -0.4000    0.0000    0.4000 
   -2.0000   -1.6000   -1.2000   -0.8000   -0.4000    0.0000    0.4000 
   -2.0000   -1.6000   -1.2000   -0.8000   -0.4000    0.0000    0.4000 
   -2.0000   -1.6000   -1.2000   -0.8000   -0.4000    0.0000    0.4000 
   -2.0000   -1.6000   -1.2000   -0.8000   -0.4000    0.0000    0.4000 
   -2.0000   -1.6000   -1.2000   -0.8000   -0.4000    0.0000    0.4000 

 Columns 8 to 11

    0.8000    1.2000    1.6000    2.0000 
    0.8000    1.2000    1.6000    2.0000 
    0.8000    1.2000    1.6000    2.0000 
    0.8000    1.2000    1.6000    2.0000 
    0.8000    1.2000    1.6000    2.0000 
    0.8000    1.2000    1.6000    2.0000 
    0.8000    1.2000    1.6000    2.0000 
    0.8000    1.2000    1.6000    2.0000 
    0.8000    1.2000    1.6000    2.0000 
    0.8000    1.2000    1.6000    2.0000 
    0.8000    1.2000    1.6000    2.0000 

Y = 

 Columns 1 to 7

   -2.0000   -2.0000   -2.0000   -2.0000   -2.0000   -2.0000   -2.0000 
   -1.6000   -1.6000   -1.6000   -1.6000   -1.6000   -1.6000   -1.6000 
   -1.2000   -1.2000   -1.2000   -1.2000   -1.2000   -1.2000   -1.2000 
   -0.8000   -0.8000   -0.8000   -0.8000   -0.8000   -0.8000   -0.8000 
   -0.4000   -0.4000   -0.4000   -0.4000   -0.4000   -0.4000   -0.4000 
    0.0000    0.0000    0.0000    0.0000    0.0000    0.0000    0.0000 
    0.4000    0.4000    0.4000    0.4000    0.4000    0.4000    0.4000 
    0.8000    0.8000    0.8000    0.8000    0.8000    0.8000    0.8000 
    1.2000    1.2000    1.2000    1.2000    1.2000    1.2000    1.2000 
    1.6000    1.6000    1.6000    1.6000    1.6000    1.6000    1.6000 
    2.0000    2.0000    2.0000    2.0000    2.0000    2.0000    2.0000 

 Columns 8 to 11

   -2.0000   -2.0000   -2.0000   -2.0000 
   -1.6000   -1.6000   -1.6000   -1.6000 
   -1.2000   -1.2000   -1.2000   -1.2000 
   -0.8000   -0.8000   -0.8000   -0.8000 
   -0.4000   -0.4000   -0.4000   -0.4000 
    0.0000    0.0000    0.0000    0.0000 
    0.4000    0.4000    0.4000    0.4000 
    0.8000    0.8000    0.8000    0.8000 
    1.2000    1.2000    1.2000    1.2000 
    1.6000    1.6000    1.6000    1.6000 
    2.0000    2.0000    2.0000    2.0000 
\end{DoxyVerbInclude}


Next, we use different vectors for {\ttfamily X} and for {\ttfamily Y}\-:


\begin{DoxyVerbInclude}
--> [X,Y] = meshgrid([1,2,3,4],[6,7,8])
X = 
 1 2 3 4 
 1 2 3 4 
 1 2 3 4 

Y = 
 6 6 6 6 
 7 7 7 7 
 8 8 8 8 
\end{DoxyVerbInclude}
 \hypertarget{array_nan}{}\section{N\-A\-N Not-\/a-\/\-Number Constant}\label{array_nan}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Returns a value that represents ``not-\/a-\/number'' for both 32 and 64-\/bit floating point values. This constant is meant to represent the result of arithmetic operations whose output cannot be meaningfully defined (like zero divided by zero). There are several forms for the {\ttfamily Na\-N} function. The first form returns a double precision {\ttfamily Na\-N}. \begin{DoxyVerb}   y = nan
\end{DoxyVerb}
 The next form takes a class name that can be either {\ttfamily 'double'} \begin{DoxyVerb}   y = nan('double')
\end{DoxyVerb}
 or {\ttfamily 'single'}\-: \begin{DoxyVerb}   y = nan('single')
\end{DoxyVerb}
 With a single parameter it generates a square matrix of {\ttfamily nan}s. \begin{DoxyVerb}   y = nan(n)
\end{DoxyVerb}
 Alternatively, you can specify the dimensions of the array via \begin{DoxyVerb}   y = nan(m,n,p,...)
\end{DoxyVerb}
 or \begin{DoxyVerb}   y = nan([m,n,p,...])
\end{DoxyVerb}
 Finally, you can add a classname of either {\ttfamily 'single'} or {\ttfamily 'double'}. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
The following examples demonstrate a few calculations with the not-\/a-\/number constant.


\begin{DoxyVerbInclude}
--> nan*0

ans = 
 NaN 

--> nan-nan

ans = 
 NaN 
\end{DoxyVerbInclude}


Note that {\ttfamily Na\-N}s are preserved under type conversion to floating point types (i.\-e., {\ttfamily float}, {\ttfamily double}, {\ttfamily complex} and {\ttfamily dcomplex} types), but not integer types.


\begin{DoxyVerbInclude}
--> uint32(nan)

ans = 
 0 

--> complex(nan)

ans = 
 NaN 
\end{DoxyVerbInclude}
 \hypertarget{array_ndgrid}{}\section{N\-D\-G\-R\-I\-D Generate N-\/\-Dimensional Grid}\label{array_ndgrid}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Generates N-\/dimensional grids, each of which is constant in all but one dimension. The syntax for its use is either \begin{DoxyVerb}   [y1, y2, ..., ym] = ndgrid(x1, x2, ..., xn)
\end{DoxyVerb}
 where {\ttfamily m $<$= n} or \begin{DoxyVerb}   [y1, y2, ..., ym] = ndgrid(x1)
\end{DoxyVerb}
 which is equivalent to the first form, with {\ttfamily x1=x2=...=xn}. Each output {\ttfamily yi} is an {\ttfamily n}-\/dimensional array, with values such that \[ y_i(d_1,\ldots,d_{i-1},d_{i},d_{i+1},\ldots,d_m) = x_i(d_{i}) \] {\ttfamily ndgrid} is useful for evaluating multivariate functionals over a range of arguments. It is a generalization of {\ttfamily meshgrid}, except that {\ttfamily meshgrid} transposes the dimensions corresponding to the first two arguments to better fit graphical applications. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Here is a simple {\ttfamily ndgrid} example


\begin{DoxyVerbInclude}
--> [a,b] = ndgrid(1:2,3:5)
a = 
 1 1 1 
 2 2 2 

b = 
 3 4 5 
 3 4 5 

--> [a,b,c] = ndgrid(1:2,3:5,0:1)
a = 

(:,:,1) = 
 1 1 1 
 2 2 2 

(:,:,2) = 
 1 1 1 
 2 2 2 

b = 

(:,:,1) = 
 3 4 5 
 3 4 5 

(:,:,2) = 
 3 4 5 
 3 4 5 

c = 

(:,:,1) = 
 0 0 0 
 0 0 0 

(:,:,2) = 
 1 1 1 
 1 1 1 
\end{DoxyVerbInclude}


Here we use the second form


\begin{DoxyVerbInclude}
--> [a,b,c] = ndgrid(1:3)
a = 

(:,:,1) = 
 1 1 1 
 2 2 2 
 3 3 3 

(:,:,2) = 
 1 1 1 
 2 2 2 
 3 3 3 

(:,:,3) = 
 1 1 1 
 2 2 2 
 3 3 3 

b = 

(:,:,1) = 
 1 2 3 
 1 2 3 
 1 2 3 

(:,:,2) = 
 1 2 3 
 1 2 3 
 1 2 3 

(:,:,3) = 
 1 2 3 
 1 2 3 
 1 2 3 

c = 

(:,:,1) = 
 1 1 1 
 1 1 1 
 1 1 1 

(:,:,2) = 
 2 2 2 
 2 2 2 
 2 2 2 

(:,:,3) = 
 3 3 3 
 3 3 3 
 3 3 3 
\end{DoxyVerbInclude}
 \hypertarget{array_nonzeros}{}\section{N\-O\-N\-Z\-E\-R\-O\-S Retrieve Nonzero Matrix Entries}\label{array_nonzeros}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{typecast_dec2bin_USAGE}{}\subsection{U\-S\-A\-G\-E}\label{typecast_dec2bin_USAGE}
Returns a dense column vector containing the nonzero elements of the argument matrix. The syntax for its use is \begin{DoxyVerb}   y = nonzeros(x)
\end{DoxyVerb}
 where {\ttfamily x} is the argument array. The argument matrix may be sparse as well as dense. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Here is an example of using {\ttfamily nonzeros} on a sparse matrix.


\begin{DoxyVerbInclude}
--> a = rand(8); a(a>0.2) = 0;
--> A = sparse(a)

A = 
 1 1 0.0596135
 7 1 0.0283717
 8 1 0.0337801
 5 2 0.0700267
 1 4 0.0881058
 4 4 0.00699947
 5 4 0.0494723
 8 5 0.0420057
 4 6 0.153486
 7 6 0.0654851
 1 7 0.174397
 4 7 0.0684673
 2 8 0.13853
--> nonzeros(A)

ans = 
    0.0596 
    0.0284 
    0.0338 
    0.0700 
    0.0881 
    0.0070 
    0.0495 
    0.0420 
    0.1535 
    0.0655 
    0.1744 
    0.0685 
    0.1385 
\end{DoxyVerbInclude}
 \hypertarget{array_norm}{}\section{N\-O\-R\-M Norm Calculation}\label{array_norm}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Calculates the norm of a matrix. There are two ways to use the {\ttfamily norm} function. The general syntax is \begin{DoxyVerb}   y = norm(A,p)
\end{DoxyVerb}
 where {\ttfamily A} is the matrix to analyze, and {\ttfamily p} is the type norm to compute. The following choices of {\ttfamily p} are supported 
\begin{DoxyItemize}
\item {\ttfamily p = 1} returns the 1-\/norm, or the max column sum of A  
\item {\ttfamily p = 2} returns the 2-\/norm (largest singular value of A)  
\item {\ttfamily p = inf} returns the infinity norm, or the max row sum of A  
\item {\ttfamily p = 'fro'} returns the Frobenius-\/norm (vector Euclidean norm, or R\-M\-S value)  
\end{DoxyItemize}For a vector, the regular norm calculations are performed\-: 
\begin{DoxyItemize}
\item {\ttfamily 1 $<$= p $<$ inf} returns {\ttfamily sum(abs(\-A).$^\wedge$p)$^\wedge$(1/p)}  
\item {\ttfamily p} unspecified returns {\ttfamily norm(\-A,2)}  
\item {\ttfamily p = inf} returns max(abs(\-A))  
\item {\ttfamily p = -\/inf} returns min(abs(\-A))  
\end{DoxyItemize}\hypertarget{variables_matrix_Examples}{}\subsection{Examples}\label{variables_matrix_Examples}
Here are the various norms calculated for a sample matrix


\begin{DoxyVerbInclude}
--> A = float(rand(3,4))

A = 
    0.8462    0.9465    0.6874    0.8668 
    0.1218    0.9206    0.5877    0.5837 
    0.7081    0.6608    0.2035    0.5083 

--> norm(A,1)

ans = 
    2.5280 

--> norm(A,2)

ans = 
    2.2997 

--> norm(A,inf)

ans = 
    3.3470 

--> norm(A,'fro')

ans = 
    2.3712 
\end{DoxyVerbInclude}


Next, we calculate some vector norms.


\begin{DoxyVerbInclude}
--> A = float(rand(4,1))

A = 
    0.3458 
    0.1427 
    0.3998 
    0.7194 

--> norm(A,1)

ans = 
    1.6078 

--> norm(A,2)

ans = 
    0.9041 

--> norm(A,7)

ans = 
    0.7217 

--> norm(A,inf)

ans = 
    0.7194 

--> norm(A,-inf)

ans = 
    0.1427 
\end{DoxyVerbInclude}
 \hypertarget{array_num2str}{}\section{N\-U\-M2\-S\-T\-R Convert Numbers To Strings}\label{array_num2str}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Converts an array into its string representation. The general syntax for this function is \begin{DoxyVerb}   s = num2str(X)
\end{DoxyVerb}
 where {\ttfamily s} is a string (or string matrix) and {\ttfamily X} is an array. By default, the {\ttfamily num2str} function uses 4 digits of precision and an exponent if required. If you want more digits of precision, you can specify the precition via the form \begin{DoxyVerb}   s = num2str(X, precision)
\end{DoxyVerb}
 where {\ttfamily precision} is the number of digits to include in the string representation. For more control over the format of the output, you can also specify a format specifier (see {\ttfamily printf} for more details). \begin{DoxyVerb}   s = num2str(X, format)
\end{DoxyVerb}
 where {\ttfamily format} is the specifier string. \hypertarget{array_ones}{}\section{O\-N\-E\-S Array of Ones}\label{array_ones}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Creates an array of ones of the specified size. Two seperate syntaxes are possible. The first syntax specifies the array dimensions as a sequence of scalar dimensions\-: \begin{DoxyVerb}   y = ones(d1,d2,...,dn).
\end{DoxyVerb}
 The resulting array has the given dimensions, and is filled with all ones. The type of {\ttfamily y} is {\ttfamily float}, a 32-\/bit floating point array. To get arrays of other types, use the typecast functions (e.\-g., {\ttfamily uint8}, {\ttfamily int8}, etc.).

The second syntax specifies the array dimensions as a vector, where each element in the vector specifies a dimension length\-: \begin{DoxyVerb}   y = ones([d1,d2,...,dn]).
\end{DoxyVerb}
 This syntax is more convenient for calling {\ttfamily ones} using a variable for the argument. In both cases, specifying only one dimension results in a square matrix output. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
The following examples demonstrate generation of some arrays of ones using the first form.


\begin{DoxyVerbInclude}
--> ones(2,3,2)

ans = 

(:,:,1) = 
 1 1 1 
 1 1 1 

(:,:,2) = 
 1 1 1 
 1 1 1 

--> ones(1,3)

ans = 
 1 1 1 
\end{DoxyVerbInclude}


The same expressions, using the second form.


\begin{DoxyVerbInclude}
--> ones([2,6])

ans = 
 1 1 1 1 1 1 
 1 1 1 1 1 1 

--> ones([1,3])

ans = 
 1 1 1 
\end{DoxyVerbInclude}


Finally, an example of using the type casting function {\ttfamily uint16} to generate an array of 16-\/bit unsigned integers with a value of 1.


\begin{DoxyVerbInclude}
--> uint16(ones(3))

ans = 
 1 1 1 
 1 1 1 
 1 1 1 
\end{DoxyVerbInclude}
 \hypertarget{array_permute}{}\section{P\-E\-R\-M\-U\-T\-E Array Permutation Function}\label{array_permute}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The {\ttfamily permute} function rearranges the contents of an array according to the specified permutation vector. The syntax for its use is \begin{DoxyVerb}    y = permute(x,p)
\end{DoxyVerb}
 where {\ttfamily p} is a permutation vector -\/ i.\-e., a vector containing the integers {\ttfamily 1...ndims(x)} each occuring exactly once. The resulting array {\ttfamily y} contains the same data as the array {\ttfamily x}, but ordered according to the permutation. This function is a generalization of the matrix transpose operation. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Here we use {\ttfamily permute} to transpose a simple matrix (note that permute also works for sparse matrices)\-:


\begin{DoxyVerbInclude}
--> A = [1,2;4,5]

A = 
 1 2 
 4 5 

--> permute(A,[2,1])

ans = 
 1 4 
 2 5 

--> A'

ans = 
 1 4 
 2 5 
\end{DoxyVerbInclude}


Now we permute a larger n-\/dimensional array\-:


\begin{DoxyVerbInclude}
--> A = randn(13,5,7,2);
--> size(A)

ans = 
 13  5  7  2 

--> B = permute(A,[3,4,2,1]);
--> size(B)

ans = 
  7  2  5 13 
\end{DoxyVerbInclude}
 \hypertarget{array_pinv}{}\section{P\-I\-N\-V Moore-\/\-Penrose Pseudoinverse}\label{array_pinv}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Calculates the Moore-\/\-Penrose pseudoinverse of a matrix. The general syntax for its use is \begin{DoxyVerb}   y = pinv(A,tol)
\end{DoxyVerb}
 or for a default specification of the tolerance {\ttfamily tol}, \begin{DoxyVerb}   y = pinv(A)
\end{DoxyVerb}
 For any {\ttfamily m x n} matrix {\ttfamily A}, the Moore-\/\-Penrose pseudoinverse is the unique {\ttfamily n x m} matrix {\ttfamily B} that satisfies the following four conditions 
\begin{DoxyItemize}
\item {\ttfamily A B A = A}  
\item {\ttfamily B A B = B}  
\item {\ttfamily (A B)' = A B}  
\item {\ttfamily (B A)' = B A}  
\end{DoxyItemize}Also, it is true that {\ttfamily B y} is the minimum norm, least squares solution to {\ttfamily A x = y}. The Moore-\/\-Penrose pseudoinverse is computed from the singular value decomposition of {\ttfamily A}, with singular values smaller than {\ttfamily tol} being treated as zeros. If {\ttfamily tol} is not specified then it is chosen as \begin{DoxyVerb}  tol = max(size(A)) * norm(A) * teps(A).
\end{DoxyVerb}
 \hypertarget{transforms_svd_Function}{}\subsection{Internals}\label{transforms_svd_Function}
The calculation of the M\-P pseudo-\/inverse is almost trivial once the svd of the matrix is available. First, for a real, diagonal matrix with positive entries, the pseudo-\/inverse is simply \[ \left(\Sigma^{+}\right)_{ii} = \begin{cases} 1/\sigma_{ii} & \sigma_{ii} > 0 \\ 0 & \mathrm{else} \end{cases} \] One can quickly verify that this choice of matrix satisfies the four properties of the pseudoinverse. Then, the pseudoinverse of a general matrix {\ttfamily A = U S V'} is defined as \[ A^{+} = V S^{+} U' \] and again, using the facts that {\ttfamily U' U = I} and {\ttfamily V V' = I}, one can quickly verify that this choice of pseudoinverse satisfies the four defining properties of the M\-P pseudoinverse. Note that in practice, the diagonal pseudoinverse {\ttfamily S$^\wedge$\{+\}} is computed with a threshold (the {\ttfamily tol} argument to {\ttfamily pinv}) so that singular values smaller than {\ttfamily tol} are treated like zeros. \hypertarget{variables_matrix_Examples}{}\subsection{Examples}\label{variables_matrix_Examples}
Consider a simple {\ttfamily 1 x 2} matrix example, and note the various Moore-\/\-Penrose conditions\-:


\begin{DoxyVerbInclude}
--> A = float(rand(1,2))

A = 
    0.4840    0.0187 

--> B = pinv(A)

B = 
    2.0630 
    0.0796 

--> A*B*A

ans = 
    0.4840    0.0187 

--> B*A*B

ans = 
    2.0630 
    0.0796 

--> A*B

ans = 
    1.0000 

--> B*A

ans = 
    0.9985    0.0385 
    0.0385    0.0015 
\end{DoxyVerbInclude}


To demonstrate that {\ttfamily pinv} returns the least squares solution, consider the following very simple case


\begin{DoxyVerbInclude}
--> A = float([1;1;1;1])

A = 
 1 
 1 
 1 
 1 
\end{DoxyVerbInclude}


The least squares solution to {\ttfamily A x = b} is just {\ttfamily x = mean(b)}, and computing the {\ttfamily pinv} of {\ttfamily A} demonstrates this


\begin{DoxyVerbInclude}
--> pinv(A)

ans = 
    0.2500    0.2500    0.2500    0.2500 
\end{DoxyVerbInclude}


Similarly, we can demonstrate the minimum norm solution with the following simple case


\begin{DoxyVerbInclude}
--> A = float([1,1])

A = 
 1 1 
\end{DoxyVerbInclude}


The solutions of {\ttfamily A x = 5} are those {\ttfamily x\-\_\-1} and {\ttfamily x\-\_\-2} such that {\ttfamily x\-\_\-1 + x\-\_\-2 = 5}. The norm of {\ttfamily x} is {\ttfamily x\-\_\-1$^\wedge$ + x\-\_\-2$^\wedge$2}, which is {\ttfamily x\-\_\-1$^\wedge$2 + (5-\/x\-\_\-1)$^\wedge$2}, which is minimized for {\ttfamily x\-\_\-1 = x\-\_\-2 = 2.\-5}\-:


\begin{DoxyVerbInclude}
--> pinv(A) * 5.0

ans = 
    2.5000 
    2.5000 
\end{DoxyVerbInclude}
 \hypertarget{array_rank}{}\section{R\-A\-N\-K Calculate the Rank of a Matrix}\label{array_rank}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Returns the rank of a matrix. There are two ways to use the {\ttfamily rank} function is \begin{DoxyVerb}   y = rank(A,tol)
\end{DoxyVerb}
 where {\ttfamily tol} is the tolerance to use when computing the rank. The second form is \begin{DoxyVerb}   y = rank(A)
\end{DoxyVerb}
 in which case the tolerance {\ttfamily tol} is chosen as \begin{DoxyVerb}   tol = max(size(A))*max(s)*eps,
\end{DoxyVerb}
 where {\ttfamily s} is the vector of singular values of {\ttfamily A}. The rank is computed using the singular value decomposition {\ttfamily svd}. \hypertarget{variables_matrix_Examples}{}\subsection{Examples}\label{variables_matrix_Examples}
Some examples of matrix rank calculations


\begin{DoxyVerbInclude}
--> rank([1,3,2;4,5,6])

ans = 
 2 

--> rank([1,2,3;2,4,6])

ans = 
 1 
\end{DoxyVerbInclude}


Here we construct an ill-\/conditioned matrix, and show the use of the {\ttfamily tol} argument.


\begin{DoxyVerbInclude}
--> A = [1,0;0,eps/2]

A = 
    1.0000         0 
         0    0.0000 

--> rank(A)

ans = 
 1 

--> rank(A,eps/8)

ans = 
 2 
\end{DoxyVerbInclude}
 \hypertarget{array_rcond}{}\section{R\-C\-O\-N\-D Reciprocal Condition Number Estimate}\label{array_rcond}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The {\ttfamily rcond} function is a Free\-Mat wrapper around L\-A\-P\-A\-C\-Ks function {\ttfamily X\-G\-E\-C\-O\-N}, which estimates the 1-\/norm condition number (reciprocal). For the details of the algorithm see the L\-A\-P\-A\-C\-K documentation. The syntax for its use is \begin{DoxyVerb}   x = rcond(A)
\end{DoxyVerb}
 where {\ttfamily A} is a matrix. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Here is the reciprocal condition number for a random square matrix


\begin{DoxyVerbInclude}
--> A = rand(30);
--> rcond(A)

ans = 
 4.4279e-04 
\end{DoxyVerbInclude}


And here we calculate the same value using the definition of (reciprocal) condition number


\begin{DoxyVerbInclude}
--> 1/(norm(A,1)*norm(inv(A),1))

ans = 
 4.3595e-04 
\end{DoxyVerbInclude}


Note that the values are very similar. L\-A\-P\-A\-C\-Ks {\ttfamily rcond} function is far more efficient than the explicit calculation (which is also used by the {\ttfamily cond} function. \hypertarget{array_repmat}{}\section{R\-E\-P\-M\-A\-T Array Replication Function}\label{array_repmat}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The {\ttfamily repmat} function replicates an array the specified number of times. The source and destination arrays may be multidimensional. There are three distinct syntaxes for the {\ttfamily repmap} function. The first form\-: \begin{DoxyVerb}  y = repmat(x,n)
\end{DoxyVerb}
 replicates the array {\ttfamily x} on an {\ttfamily n-\/times-\/n} tiling, to create a matrix {\ttfamily y} that has {\ttfamily n} times as many rows and columns as {\ttfamily x}. The output {\ttfamily y} will match {\ttfamily x} in all remaining dimensions. The second form is \begin{DoxyVerb}  y = repmat(x,m,n)
\end{DoxyVerb}
 And creates a tiling of {\ttfamily x} with {\ttfamily m} copies of {\ttfamily x} in the row direction, and {\ttfamily n} copies of {\ttfamily x} in the column direction. The final form is the most general \begin{DoxyVerb}  y = repmat(x,[m n p...])
\end{DoxyVerb}
 where the supplied vector indicates the replication factor in each dimension. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Here is an example of using the {\ttfamily repmat} function to replicate a row 5 times. Note that the same effect can be accomplished (although somewhat less efficiently) by a multiplication.


\begin{DoxyVerbInclude}
--> x = [1 2 3 4]

x = 
 1 2 3 4 

--> y = repmat(x,[5,1])

y = 
 1 2 3 4 
 1 2 3 4 
 1 2 3 4 
 1 2 3 4 
 1 2 3 4 
\end{DoxyVerbInclude}


The {\ttfamily repmat} function can also be used to create a matrix of scalars or to provide replication in arbitrary dimensions. Here we use it to replicate a 2\-D matrix into a 3\-D volume.


\begin{DoxyVerbInclude}
--> x = [1 2;3 4]

x = 
 1 2 
 3 4 

--> y = repmat(x,[1,1,3])

y = 

(:,:,1) = 
 1 2 
 3 4 

(:,:,2) = 
 1 2 
 3 4 

(:,:,3) = 
 1 2 
 3 4 
\end{DoxyVerbInclude}
 \hypertarget{array_reshape}{}\section{R\-E\-S\-H\-A\-P\-E Reshape An Array}\label{array_reshape}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Reshapes an array from one size to another. Two seperate syntaxes are possible. The first syntax specifies the array dimensions as a sequence of scalar dimensions\-: \begin{DoxyVerb}   y = reshape(x,d1,d2,...,dn).
\end{DoxyVerb}
 The resulting array has the given dimensions, and is filled with the contents of {\ttfamily x}. The type of {\ttfamily y} is the same as {\ttfamily x}.

As a special case, you can specify exactly one of the dimensions as an empty matrix {\ttfamily \mbox{[}\mbox{]}}, in which case Free\-Mat will compute the size required in that dimension to make the reshape work. The syntax for this version is \begin{DoxyVerb}   y = reshape(x,d1,...,da,[],db,...,dn)
\end{DoxyVerb}


The second syntax specifies the array dimensions as a vector, where each element in the vector specifies a dimension length\-: \begin{DoxyVerb}   y = reshape(x,[d1,d2,...,dn]).
\end{DoxyVerb}
 This syntax is more convenient for calling {\ttfamily reshape} using a variable for the argument. The {\ttfamily reshape} function requires that the length of {\ttfamily x} equal the product of the {\ttfamily di} values. Note that arrays are stored in column format, which means that elements in {\ttfamily x} are transferred to the new array {\ttfamily y} starting with the first column first element, then proceeding to the last element of the first column, then the first element of the second column, etc. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Here are several examples of the use of {\ttfamily reshape} applied to various arrays. The first example reshapes a row vector into a matrix.


\begin{DoxyVerbInclude}
--> a = uint8(1:6)

a = 
 1 2 3 4 5 6 

--> reshape(a,2,3)

ans = 
 1 3 5 
 2 4 6 
\end{DoxyVerbInclude}


The second example reshapes a longer row vector into a volume with two planes.


\begin{DoxyVerbInclude}
--> a = uint8(1:12)

a = 
  1  2  3  4  5  6  7  8  9 10 11 12 

--> reshape(a,[2,3,2])

ans = 

(:,:,1) = 
  1  3  5 
  2  4  6 

(:,:,2) = 
  7  9 11 
  8 10 12 
\end{DoxyVerbInclude}


The third example reshapes a matrix into another matrix.


\begin{DoxyVerbInclude}
--> a = [1,6,7;3,4,2]

a = 
 1 6 7 
 3 4 2 

--> reshape(a,3,2)

ans = 
 1 4 
 3 7 
 6 2 
\end{DoxyVerbInclude}
 \hypertarget{array_rref}{}\section{R\-R\-E\-F Reduced Row Echelon Form of a Matrix}\label{array_rref}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Calculates the reduced row echelon form of a matrix using Gauss Jordan elimination with partial pivoting. The generic syntax for {\ttfamily rref} is \begin{DoxyVerb}   R = rref(A)
\end{DoxyVerb}
 A default tolerance of {\ttfamily max(size(\-A))$\ast$eps$\ast$norm(A,inf)} is used to detect negligible column elements. The second form of {\ttfamily rref} returns a vector {\ttfamily k} as well as {\ttfamily R} \begin{DoxyVerb}  [R,k] = rref(A)
\end{DoxyVerb}
 where {\ttfamily k} is a vector that correponds to the columns of {\ttfamily A} used as pivot columns. If you want to control the tolerance used to identify negligible elements, you can use the form \begin{DoxyVerb}  [R,k] = rref(A, tolerance)
\end{DoxyVerb}
 This implementation of {\ttfamily rref} is based on the one from the matcompat lib for octave. It is copyright Paul Kienzle, and distributed under the G\-N\-U G\-P\-L. \hypertarget{array_shiftdim}{}\section{S\-H\-I\-F\-T\-D\-I\-M Shift Array Dimensions Function}\label{array_shiftdim}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The {\ttfamily shiftdim} function is used to shift the dimensions of an array. The general syntax for the {\ttfamily shiftdim} function is \begin{DoxyVerb}   y = shiftdim(x,n)
\end{DoxyVerb}
 where {\ttfamily x} is a multidimensional array, and {\ttfamily n} is an integer. If {\ttfamily n} is a positive integer, then {\ttfamily shiftdim} circularly shifts the dimensions of {\ttfamily x} to the left, wrapping the dimensions around as necessary. If {\ttfamily n} is a negative integer, then {\ttfamily shiftdim} shifts the dimensions of {\ttfamily x} to the right, introducing singleton dimensions as necessary. In its second form\-: \begin{DoxyVerb}  [y,n] = shiftdim(x)
\end{DoxyVerb}
 the {\ttfamily shiftdim} function will shift away (to the left) the leading singleton dimensions of {\ttfamily x} until the leading dimension is not a singleton dimension (recall that a singleton dimension {\ttfamily p} is one for which {\ttfamily size(x,p) == 1}). \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Here are some simple examples of using {\ttfamily shiftdim} to remove the singleton dimensions of an array, and then restore them\-:


\begin{DoxyVerbInclude}
--> x = uint8(10*randn(1,1,1,3,2));
--> [y,n] = shiftdim(x);
--> n

ans = 
 3 

--> size(y)

ans = 
 3 2 

--> c = shiftdim(y,-n);
--> size(c)

ans = 
 1 1 1 3 2 

--> any(c~=x)

ans = 

(:,:,1,1,1) = 
 0 

(:,:,1,1,2) = 
 0 
\end{DoxyVerbInclude}


Note that these operations (where shifting involves only singleton dimensions) do not actually cause data to be resorted, only the size of the arrays change. This is not true for the following example, which triggers a call to {\ttfamily permute}\-:


\begin{DoxyVerbInclude}
--> z = shiftdim(x,4);
\end{DoxyVerbInclude}


Note that {\ttfamily z} is now the transpose of {\ttfamily x}


\begin{DoxyVerbInclude}
--> squeeze(x)

ans = 
 11  1 
  0  0 
  0  8 

--> squeeze(z)

ans = 
 11  0  0 
  1  0  8 
\end{DoxyVerbInclude}
 \hypertarget{array_sort}{}\section{S\-O\-R\-T Sort}\label{array_sort}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Sorts an n-\/dimensional array along the specified dimensional. The first form sorts the array along the first non-\/singular dimension. \begin{DoxyVerb}  B = sort(A)
\end{DoxyVerb}
 Alternately, the dimension along which to sort can be explicitly specified \begin{DoxyVerb}  B = sort(A,dim)
\end{DoxyVerb}
 Free\-Mat does not support vector arguments for {\ttfamily dim} -\/ if you need {\ttfamily A} to be sorted along multiple dimensions (i.\-e., row first, then columns), make multiple calls to {\ttfamily sort}. Also, the direction of the sort can be specified using the {\ttfamily mode} argument \begin{DoxyVerb}  B = sort(A,dim,mode)
\end{DoxyVerb}
 where {\ttfamily mode = 'ascend'} means to sort the data in ascending order (the default), and {\ttfamily mode = 'descend'} means to sort the data into descending order.

When two outputs are requested from {\ttfamily sort}, the indexes are also returned. Thus, for \begin{DoxyVerb}  [B,IX] = sort(A)
  [B,IX] = sort(A,dim)
  [B,IX] = sort(A,dim,mode)
\end{DoxyVerb}
 an array {\ttfamily I\-X} of the same size as {\ttfamily A}, where {\ttfamily I\-X} records the indices of {\ttfamily A} (along the sorting dimension) corresponding to the output array {\ttfamily B}.

Two additional issues worth noting. First, a cell array can be sorted if each cell contains a {\ttfamily string}, in which case the strings are sorted by lexical order. The second issue is that Free\-Mat uses the same method as M\-A\-T\-L\-A\-B to sort complex numbers. In particular, a complex number {\ttfamily a} is less than another complex number {\ttfamily b} if {\ttfamily abs(a) $<$ abs(b)}. If the magnitudes are the same then we test the angle of {\ttfamily a}, i.\-e. {\ttfamily angle(a) $<$ angle(b)}, where {\ttfamily angle(a)} is the phase of {\ttfamily a} between {\ttfamily -\/pi,pi}. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Here are some examples of sorting on numerical arrays.


\begin{DoxyVerbInclude}
--> A = int32(10*rand(4,3))

A = 
 8 2 8 
 0 5 5 
 2 5 7 
 3 7 1 

--> [B,IX] = sort(A)
B = 
 0 2 1 
 2 5 5 
 3 5 7 
 8 7 8 

IX = 
 2 1 4 
 3 2 2 
 4 3 3 
 1 4 1 

--> [B,IX] = sort(A,2)
B = 
 2 8 8 
 0 5 5 
 2 5 7 
 1 3 7 

IX = 
 2 1 3 
 1 2 3 
 1 2 3 
 3 1 2 

--> [B,IX] = sort(A,1,'descend')
B = 
 8 7 8 
 3 5 7 
 2 5 5 
 0 2 1 

IX = 
 1 4 1 
 4 2 3 
 3 3 2 
 2 1 4 
\end{DoxyVerbInclude}


Here we sort a cell array of strings.


\begin{DoxyVerbInclude}
--> a = {'hello','abba','goodbye','jockey','cake'}

a = 
 [hello] [abba] [goodbye] [jockey] [cake] 

--> b = sort(a)

b = 
 [abba] [cake] [goodbye] [hello] [jockey] 
\end{DoxyVerbInclude}
 \hypertarget{array_squeeze}{}\section{S\-Q\-U\-E\-E\-Z\-E Remove Singleton Dimensions of an Array}\label{array_squeeze}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This function removes the singleton dimensions of an array. The syntax for its use is \begin{DoxyVerb}   y = squeeze(x)
\end{DoxyVerb}
 where {\ttfamily x} is a multidimensional array. Generally speaking, if {\ttfamily x} is of size {\ttfamily d1 x 1 x d2 x ...}, then {\ttfamily squeeze(x)} is of size {\ttfamily d1 x d2 x ...}, i.\-e., each dimension of {\ttfamily x} that was singular (size 1) is squeezed out. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Here is a many dimensioned, ungainly array, both before and after squeezing;


\begin{DoxyVerbInclude}
--> x = zeros(1,4,3,1,1,2);
--> size(x)

ans = 
 1 4 3 1 1 2 

--> y = squeeze(x);
--> size(y)

ans = 
 4 3 2 
\end{DoxyVerbInclude}
 \hypertarget{array_subsref}{}\section{S\-U\-B\-S\-R\-E\-F Array Dereferencing}\label{array_subsref}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This function can be used to index into basic array types (or structures). It provides a functional interface to execute complex indexing expressions such as {\ttfamily a.\-b(3)\{5\}} at run time (i.\-e. while executing a script or a function) without resorting to using {\ttfamily eval}. Note that this function should be overloaded for use with user defined classes, and that it cannot be overloaeded for base types. The basic syntax of the function is\-: \begin{DoxyVerb}   b = subsref(a,s)
\end{DoxyVerb}
 where {\ttfamily s} is a structure array with two fields. The first field is 
\begin{DoxyItemize}
\item {\ttfamily type} is a string containing either {\ttfamily '()'} or {\ttfamily '\{\}'} or {\ttfamily '.'} depending on the form of the call.  
\item {\ttfamily subs} is a cell array or string containing the the subscript information.  
\end{DoxyItemize}When multiple indexing experssions are combined together such as {\ttfamily b = a(5).foo\{\-:\}}, the {\ttfamily s} array should contain the following entries \begin{DoxyVerb}  s(1).type = '()'  s(1).subs = {5}
  s(2).type = '.'   s(2).subs = 'foo'
  s(3).type = '{}'  s(3).subs = ':'
\end{DoxyVerb}
 \hypertarget{array_trace}{}\section{T\-R\-A\-C\-E Sum Diagonal Elements of an Array}\label{array_trace}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Returns the sum of the diagonal elements of a square matrix. The general syntax for its use is \begin{DoxyVerb}   y = trace(x)
\end{DoxyVerb}
 where x is a square matrix. \hypertarget{array_transpose}{}\section{T\-R\-A\-N\-S\-P\-O\-S\-E Matrix Transpose}\label{array_transpose}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Performs a (nonconjugate) transpose of a matrix. The syntax for its use is \begin{DoxyVerb}    y = transpose(x)
\end{DoxyVerb}
 and is a synonym for {\ttfamily y = x.'}. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Here is an example of the transpose of a complex matrix. Note that the entries are not conjugated.


\begin{DoxyVerbInclude}
--> A = [1+i,2+i;3-2*i,4+2*i]

A = 
   1.0000 +  1.0000i   2.0000 +  1.0000i 
   3.0000 -  2.0000i   4.0000 +  2.0000i 

--> transpose(A)

ans = 
   1.0000 +  1.0000i   3.0000 -  2.0000i 
   2.0000 +  1.0000i   4.0000 +  2.0000i 
\end{DoxyVerbInclude}
 \hypertarget{array_tril}{}\section{T\-R\-I\-L Lower Triangular Matrix Function}\label{array_tril}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Returns the lower triangular matrix of a square matrix. The general syntax for its use is \begin{DoxyVerb}   y = tril(x)
\end{DoxyVerb}
 where $|$x$|$ is a square matrix. This returns the lower triangular matrix (i.\-e.\-: all cells on or above the diagonal are set to 0). You can also specify a different diagonal using the alternate form \begin{DoxyVerb}   y = tril(x,n)
\end{DoxyVerb}
 where n is the diagonal offset. In this mode, the diagonal specified is not set to zero in the returned matrix (e.\-g.\-: tril(x) and tril(x,-\/1)) will return the same value. \hypertarget{array_triu}{}\section{T\-R\-I\-U Upper Triangular Matrix Function}\label{array_triu}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Returns the upper triangular matrix of a square matrix. The general syntax for its use is \begin{DoxyVerb}   y = triu(x)
\end{DoxyVerb}
 where x is a square matrix. This returns the upper triangular matrix (i.\-e.\-: all elements on or below the diagonal are set to 0). You can also specify a different diagonal using the alternate form \begin{DoxyVerb}   y = triu(x,n)
\end{DoxyVerb}
 where n is the diagonal offset. In this mode, the diagonal specified is not set to zero in the returned matrix (e.\-g.\-: tril(x) and tril(x,1)) will return the same value. \hypertarget{array_unique}{}\section{U\-N\-I\-Q\-U\-E Unique}\label{array_unique}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Returns a vector containing the unique elements of an array. The first form is simply \begin{DoxyVerb}   y = unique(x)
\end{DoxyVerb}
 where {\ttfamily x} is either a numerical array or a cell-\/array of strings. The result is sorted in increasing order. You can also retrieve two sets of index vectors \begin{DoxyVerb}   [y, m, n] = unique(x)
\end{DoxyVerb}
 such that {\ttfamily y = x(m)} and {\ttfamily x = y(n)}. If the argument {\ttfamily x} is a matrix, you can also indicate that Free\-Mat should look for unique rows in the matrix via \begin{DoxyVerb}   y = unique(x,'rows')
\end{DoxyVerb}
 and \begin{DoxyVerb}   [y, m, n] = unique(x,'rows')
\end{DoxyVerb}
 \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Here is an example in row mode


\begin{DoxyVerbInclude}
--> A = randi(1,3*ones(15,3))

A = 
 2 3 2 
 2 1 1 
 2 2 3 
 2 1 3 
 2 2 3 
 2 1 2 
 1 2 2 
 1 1 1 
 3 1 3 
 2 2 2 
 1 3 3 
 1 2 3 
 3 1 1 
 3 3 1 
 2 3 3 

--> unique(A,'rows')

ans = 
 1 1 1 
 1 2 2 
 1 2 3 
 1 3 3 
 2 1 1 
 2 1 2 
 2 1 3 
 2 2 2 
 2 2 3 
 2 3 2 
 2 3 3 
 3 1 1 
 3 1 3 
 3 3 1 

--> [b,m,n] = unique(A,'rows');
--> b

ans = 
 1 1 1 
 1 2 2 
 1 2 3 
 1 3 3 
 2 1 1 
 2 1 2 
 2 1 3 
 2 2 2 
 2 2 3 
 2 3 2 
 2 3 3 
 3 1 1 
 3 1 3 
 3 3 1 

--> A(m,:)

ans = 
 1 1 1 
 1 2 2 
 1 2 3 
 1 3 3 
 2 1 1 
 2 1 2 
 2 1 3 
 2 2 2 
 2 2 3 
 2 3 2 
 2 3 3 
 3 1 1 
 3 1 3 
 3 3 1 

--> b(n,:)

ans = 
 2 3 2 
 2 1 1 
 2 2 3 
 2 1 3 
 2 2 3 
 2 1 2 
 1 2 2 
 1 1 1 
 3 1 3 
 2 2 2 
 1 3 3 
 1 2 3 
 3 1 1 
 3 3 1 
 2 3 3 
\end{DoxyVerbInclude}


Here is an example in vector mode


\begin{DoxyVerbInclude}
--> A = randi(1,5*ones(10,1))

A = 
 5 
 5 
 5 
 3 
 5 
 3 
 4 
 1 
 3 
 2 

--> unique(A)

ans = 
 1 
 2 
 3 
 4 
 5 

--> [b,m,n] = unique(A,'rows');
--> b

ans = 
 1 
 2 
 3 
 4 
 5 

--> A(m)

ans = 
 1 
 2 
 3 
 4 
 5 

--> b(n)

ans = 
 5 
 5 
 5 
 3 
 5 
 3 
 4 
 1 
 3 
 2 
\end{DoxyVerbInclude}


For cell arrays of strings.


\begin{DoxyVerbInclude}
--> A = {'hi','bye','good','tell','hi','bye'}

A = 
 [hi] [bye] [good] [tell] [hi] [bye] 

--> unique(A)

ans = 
 [bye] [good] [hi] [tell] 
\end{DoxyVerbInclude}
 \hypertarget{array_xnrm2}{}\section{X\-N\-R\-M2 B\-L\-A\-S Norm Calculation}\label{array_xnrm2}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Calculates the 2-\/norm of a vector. The syntax for its use is \begin{DoxyVerb}   y = xnrm2(A)
\end{DoxyVerb}
 where {\ttfamily A} is the n-\/dimensional array to analyze. This form uses the underlying B\-L\-A\-S implementation to compute the 2-\/norm. \hypertarget{array_zeros}{}\section{Z\-E\-R\-O\-S Array of Zeros}\label{array_zeros}
Section\-: \hyperlink{sec_array}{Array Generation and Manipulations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Creates an array of zeros of the specified size. Two seperate syntaxes are possible. The first syntax specifies the array dimensions as a sequence of scalar dimensions\-: \begin{DoxyVerb}   y = zeros(d1,d2,...,dn).
\end{DoxyVerb}
 The resulting array has the given dimensions, and is filled with all zeros. The type of {\ttfamily y} is {\ttfamily double}, a 64-\/bit floating point array. To get arrays of other types, use the typecast functions (e.\-g., {\ttfamily uint8}, {\ttfamily int8}, etc.). An alternative syntax is to use the following notation\-: \begin{DoxyVerb}   y = zeros(d1,d2,...,dn,classname)
\end{DoxyVerb}
 where {\ttfamily classname} is one of 'double', 'single', 'int8', 'uint8', 'int16', 'uint16', 'int32', 'uint32', 'int64', 'uint64', 'float', 'logical'.

The second syntax specifies the array dimensions as a vector, where each element in the vector specifies a dimension length\-: \begin{DoxyVerb}   y = zeros([d1,d2,...,dn]),
\end{DoxyVerb}
 or \begin{DoxyVerb}   y = zeros([d1,d2,...,dn],classname).
\end{DoxyVerb}
 This syntax is more convenient for calling {\ttfamily zeros} using a variable for the argument. In both cases, specifying only one dimension results in a square matrix output. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
The following examples demonstrate generation of some zero arrays using the first form.


\begin{DoxyVerbInclude}
--> zeros(2,3,2)

ans = 

(:,:,1) = 
 0 0 0 
 0 0 0 

(:,:,2) = 
 0 0 0 
 0 0 0 

--> zeros(1,3)

ans = 
 0 0 0 
\end{DoxyVerbInclude}


The same expressions, using the second form.


\begin{DoxyVerbInclude}
--> zeros([2,6])

ans = 
 0 0 0 0 0 0 
 0 0 0 0 0 0 

--> zeros([1,3])

ans = 
 0 0 0 
\end{DoxyVerbInclude}


Finally, an example of using the type casting function {\ttfamily uint16} to generate an array of 16-\/bit unsigned integers with zero values.


\begin{DoxyVerbInclude}
--> uint16(zeros(3))

ans = 
 0 0 0 
 0 0 0 
 0 0 0 
\end{DoxyVerbInclude}


Here we use the second syntax where the class of the output is specified explicitly


\begin{DoxyVerbInclude}
--> zeros(3,'int16')

ans = 
 0 0 0 
 0 0 0 
 0 0 0 
\end{DoxyVerbInclude}
 

\begin{DoxyItemize}
\item \hyperlink{vtkparallel_vtkbranchextenttranslator}{vtk\-Branch\-Extent\-Translator}  
\item \hyperlink{vtkparallel_vtkcachinginterpolatedvelocityfield}{vtk\-Caching\-Interpolated\-Velocity\-Field}  
\item \hyperlink{vtkparallel_vtkcollectgraph}{vtk\-Collect\-Graph}  
\item \hyperlink{vtkparallel_vtkcollectpolydata}{vtk\-Collect\-Poly\-Data}  
\item \hyperlink{vtkparallel_vtkcollecttable}{vtk\-Collect\-Table}  
\item \hyperlink{vtkparallel_vtkcommunicator}{vtk\-Communicator}  
\item \hyperlink{vtkparallel_vtkcompositer}{vtk\-Compositer}  
\item \hyperlink{vtkparallel_vtkcompositerendermanager}{vtk\-Composite\-Render\-Manager}  
\item \hyperlink{vtkparallel_vtkcompresscompositer}{vtk\-Compress\-Compositer}  
\item \hyperlink{vtkparallel_vtkcutmaterial}{vtk\-Cut\-Material}  
\item \hyperlink{vtkparallel_vtkdistributeddatafilter}{vtk\-Distributed\-Data\-Filter}  
\item \hyperlink{vtkparallel_vtkdistributedstreamtracer}{vtk\-Distributed\-Stream\-Tracer}  
\item \hyperlink{vtkparallel_vtkdummycommunicator}{vtk\-Dummy\-Communicator}  
\item \hyperlink{vtkparallel_vtkdummycontroller}{vtk\-Dummy\-Controller}  
\item \hyperlink{vtkparallel_vtkduplicatepolydata}{vtk\-Duplicate\-Poly\-Data}  
\item \hyperlink{vtkparallel_vtkensightwriter}{vtk\-En\-Sight\-Writer}  
\item \hyperlink{vtkparallel_vtkexodusiiwriter}{vtk\-Exodus\-I\-I\-Writer}  
\item \hyperlink{vtkparallel_vtkextractcthpart}{vtk\-Extract\-C\-T\-H\-Part}  
\item \hyperlink{vtkparallel_vtkextractpiece}{vtk\-Extract\-Piece}  
\item \hyperlink{vtkparallel_vtkextractuserdefinedpiece}{vtk\-Extract\-User\-Defined\-Piece}  
\item \hyperlink{vtkparallel_vtkimagerendermanager}{vtk\-Image\-Render\-Manager}  
\item \hyperlink{vtkparallel_vtkmemorylimitimagedatastreamer}{vtk\-Memory\-Limit\-Image\-Data\-Streamer}  
\item \hyperlink{vtkparallel_vtkmpiimagereader}{vtk\-M\-P\-I\-Image\-Reader}  
\item \hyperlink{vtkparallel_vtkmultiprocesscontroller}{vtk\-Multi\-Process\-Controller}  
\item \hyperlink{vtkparallel_vtkparallelfactory}{vtk\-Parallel\-Factory}  
\item \hyperlink{vtkparallel_vtkparallelrendermanager}{vtk\-Parallel\-Render\-Manager}  
\item \hyperlink{vtkparallel_vtkpassthroughfilter}{vtk\-Pass\-Through\-Filter}  
\item \hyperlink{vtkparallel_vtkpcelldatatopointdata}{vtk\-P\-Cell\-Data\-To\-Point\-Data}  
\item \hyperlink{vtkparallel_vtkpchacoreader}{vtk\-P\-Chaco\-Reader}  
\item \hyperlink{vtkparallel_vtkpcosmohalofinder}{vtk\-P\-Cosmo\-Halo\-Finder}  
\item \hyperlink{vtkparallel_vtkpcosmoreader}{vtk\-P\-Cosmo\-Reader}  
\item \hyperlink{vtkparallel_vtkpdatasetreader}{vtk\-P\-Data\-Set\-Reader}  
\item \hyperlink{vtkparallel_vtkpdatasetwriter}{vtk\-P\-Data\-Set\-Writer}  
\item \hyperlink{vtkparallel_vtkpextractarraysovertime}{vtk\-P\-Extract\-Arrays\-Over\-Time}  
\item \hyperlink{vtkparallel_vtkpiecerequestfilter}{vtk\-Piece\-Request\-Filter}  
\item \hyperlink{vtkparallel_vtkpiecescalars}{vtk\-Piece\-Scalars}  
\item \hyperlink{vtkparallel_vtkpimagewriter}{vtk\-P\-Image\-Writer}  
\item \hyperlink{vtkparallel_vtkpkdtree}{vtk\-P\-Kd\-Tree}  
\item \hyperlink{vtkparallel_vtkplinearextrusionfilter}{vtk\-P\-Linear\-Extrusion\-Filter}  
\item \hyperlink{vtkparallel_vtkpnrrdreader}{vtk\-P\-Nrrd\-Reader}  
\item \hyperlink{vtkparallel_vtkpopenfoamreader}{vtk\-P\-Open\-F\-O\-A\-M\-Reader}  
\item \hyperlink{vtkparallel_vtkpopreader}{vtk\-P\-O\-P\-Reader}  
\item \hyperlink{vtkparallel_vtkpoutlinecornerfilter}{vtk\-P\-Outline\-Corner\-Filter}  
\item \hyperlink{vtkparallel_vtkpoutlinefilter}{vtk\-P\-Outline\-Filter}  
\item \hyperlink{vtkparallel_vtkppolydatanormals}{vtk\-P\-Poly\-Data\-Normals}  
\item \hyperlink{vtkparallel_vtkpprobefilter}{vtk\-P\-Probe\-Filter}  
\item \hyperlink{vtkparallel_vtkpreflectionfilter}{vtk\-P\-Reflection\-Filter}  
\item \hyperlink{vtkparallel_vtkprocess}{vtk\-Process}  
\item \hyperlink{vtkparallel_vtkprocessgroup}{vtk\-Process\-Group}  
\item \hyperlink{vtkparallel_vtkprocessidscalars}{vtk\-Process\-Id\-Scalars}  
\item \hyperlink{vtkparallel_vtkpslacreader}{vtk\-P\-S\-L\-A\-C\-Reader}  
\item \hyperlink{vtkparallel_vtkpstreamtracer}{vtk\-P\-Stream\-Tracer}  
\item \hyperlink{vtkparallel_vtkptabletostructuredgrid}{vtk\-P\-Table\-To\-Structured\-Grid}  
\item \hyperlink{vtkparallel_vtkrectilineargridoutlinefilter}{vtk\-Rectilinear\-Grid\-Outline\-Filter}  
\item \hyperlink{vtkparallel_vtksocketcommunicator}{vtk\-Socket\-Communicator}  
\item \hyperlink{vtkparallel_vtksocketcontroller}{vtk\-Socket\-Controller}  
\item \hyperlink{vtkparallel_vtksubcommunicator}{vtk\-Sub\-Communicator}  
\item \hyperlink{vtkparallel_vtksubgroup}{vtk\-Sub\-Group}  
\item \hyperlink{vtkparallel_vtktemporalfractal}{vtk\-Temporal\-Fractal}  
\item \hyperlink{vtkparallel_vtktemporalinterpolatedvelocityfield}{vtk\-Temporal\-Interpolated\-Velocity\-Field}  
\item \hyperlink{vtkparallel_vtktemporalstreamtracer}{vtk\-Temporal\-Stream\-Tracer}  
\item \hyperlink{vtkparallel_vtktransmitimagedatapiece}{vtk\-Transmit\-Image\-Data\-Piece}  
\item \hyperlink{vtkparallel_vtktransmitpolydatapiece}{vtk\-Transmit\-Poly\-Data\-Piece}  
\item \hyperlink{vtkparallel_vtktransmitrectilineargridpiece}{vtk\-Transmit\-Rectilinear\-Grid\-Piece}  
\item \hyperlink{vtkparallel_vtktransmitstructuredgridpiece}{vtk\-Transmit\-Structured\-Grid\-Piece}  
\item \hyperlink{vtkparallel_vtktransmitunstructuredgridpiece}{vtk\-Transmit\-Unstructured\-Grid\-Piece}  
\item \hyperlink{vtkparallel_vtktreecompositer}{vtk\-Tree\-Compositer}  
\item \hyperlink{vtkparallel_vtkvpicreader}{vtk\-V\-P\-I\-C\-Reader}  
\item \hyperlink{vtkparallel_vtkwindbladereader}{vtk\-Wind\-Blade\-Reader}  
\item \hyperlink{vtkparallel_vtkxmlphierarchicalboxdatawriter}{vtk\-X\-M\-L\-P\-Hierarchical\-Box\-Data\-Writer}  
\item \hyperlink{vtkparallel_vtkxmlpmultiblockdatawriter}{vtk\-X\-M\-L\-P\-Multi\-Block\-Data\-Writer}  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkbranchextenttranslator}{}\section{vtk\-Branch\-Extent\-Translator}\label{vtkparallel_vtkbranchextenttranslator}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Branch\-Extent\-Translator is like extent translator, but it uses an alternative source as a whole extent. The whole extent passed is assumed to be a subextent of the original source. we simply take the intersection of the split extent and the whole extdent passed in. We are attempting to make branching pipelines request consistent extents with the same piece requests.

To create an instance of class vtk\-Branch\-Extent\-Translator, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkBranchExtentTranslator
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Branch\-Extent\-Translator has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Branch\-Extent\-Translator class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Branch\-Extent\-Translator = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Branch\-Extent\-Translator = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Original\-Source (vtk\-Image\-Data )} -\/ This is the original upstream image source.  
\item {\ttfamily vtk\-Image\-Data = obj.\-Get\-Original\-Source ()} -\/ This is the original upstream image source.  
\item {\ttfamily int = obj.\-Piece\-To\-Extent ()} -\/ Generates the extent from the pieces.  
\item {\ttfamily obj.\-Set\-Assigned\-Piece (int )} -\/ This unstructured extent/piece is store here for the users convenience. It is not used internally. The intent was to let an \char`\"{}assignment\char`\"{} be made when the translator/first source is created. The translator/assignment can be used for any new filter that uses the original source as output. Branches will then have the same assignment.  
\item {\ttfamily int = obj.\-Get\-Assigned\-Piece ()} -\/ This unstructured extent/piece is store here for the users convenience. It is not used internally. The intent was to let an \char`\"{}assignment\char`\"{} be made when the translator/first source is created. The translator/assignment can be used for any new filter that uses the original source as output. Branches will then have the same assignment.  
\item {\ttfamily obj.\-Set\-Assigned\-Number\-Of\-Pieces (int )} -\/ This unstructured extent/piece is store here for the users convenience. It is not used internally. The intent was to let an \char`\"{}assignment\char`\"{} be made when the translator/first source is created. The translator/assignment can be used for any new filter that uses the original source as output. Branches will then have the same assignment.  
\item {\ttfamily int = obj.\-Get\-Assigned\-Number\-Of\-Pieces ()} -\/ This unstructured extent/piece is store here for the users convenience. It is not used internally. The intent was to let an \char`\"{}assignment\char`\"{} be made when the translator/first source is created. The translator/assignment can be used for any new filter that uses the original source as output. Branches will then have the same assignment.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkcachinginterpolatedvelocityfield}{}\section{vtk\-Caching\-Interpolated\-Velocity\-Field}\label{vtkparallel_vtkcachinginterpolatedvelocityfield}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Caching\-Interpolated\-Velocity\-Field acts as a continuous velocity field by performing cell interpolation on the underlying vtk\-Data\-Set. This is a concrete sub-\/class of vtk\-Function\-Set with Number\-Of\-Independent\-Variables = 4 (x,y,z,t) and Number\-Of\-Functions = 3 (u,v,w). Normally, every time an evaluation is performed, the cell which contains the point (x,y,z) has to be found by calling Find\-Cell. This is a computationally expensive operation. In certain cases, the cell search can be avoided or shortened by providing a guess for the cell id. For example, in streamline integration, the next evaluation is usually in the same or a neighbour cell. For this reason, vtk\-Caching\-Interpolated\-Velocity\-Field stores the last cell id. If caching is turned on, it uses this id as the starting point.

To create an instance of class vtk\-Caching\-Interpolated\-Velocity\-Field, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkCachingInterpolatedVelocityField
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Caching\-Interpolated\-Velocity\-Field has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Caching\-Interpolated\-Velocity\-Field class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Caching\-Interpolated\-Velocity\-Field = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Caching\-Interpolated\-Velocity\-Field = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Function\-Values (double x, double f)} -\/ Evaluate the velocity field, f=\{u,v,w\}, at \{x, y, z\}. returns 1 if valid, 0 if test failed  
\item {\ttfamily int = obj.\-Inside\-Test (double x)} -\/ Evaluate the velocity field, f=\{u,v,w\}, at \{x, y, z\}. returns 1 if valid, 0 if test failed  
\item {\ttfamily obj.\-Set\-Data\-Set (int I, vtk\-Data\-Set dataset, bool staticdataset, vtk\-Abstract\-Cell\-Locator locator)} -\/ Add a dataset used by the interpolation function evaluation.  
\item {\ttfamily string = obj.\-Get\-Vectors\-Selection ()} -\/ If you want to work with an arbitrary vector array, then set its name here. By default this in N\-U\-L\-L and the filter will use the active vector array.  
\item {\ttfamily obj.\-Select\-Vectors (string field\-Name)} -\/ Return the cell id cached from last evaluation.  
\item {\ttfamily obj.\-Set\-Last\-Cell\-Info (vtk\-Id\-Type c, int datasetindex)} -\/ Return the cell id cached from last evaluation.  
\item {\ttfamily obj.\-Clear\-Last\-Cell\-Info ()} -\/ Set the last cell id to -\/1 so that the next search does not start from the previous cell  
\item {\ttfamily int = obj.\-Get\-Last\-Weights (double w)} -\/ Returns the interpolation weights/pcoords cached from last evaluation if the cached cell is valid (returns 1). Otherwise, it does not change w and returns 0.  
\item {\ttfamily int = obj.\-Get\-Last\-Local\-Coordinates (double pcoords\mbox{[}3\mbox{]})} -\/ Returns the interpolation weights/pcoords cached from last evaluation if the cached cell is valid (returns 1). Otherwise, it does not change w and returns 0.  
\item {\ttfamily int = obj.\-Get\-Cell\-Cache\-Hit ()} -\/ Caching statistics.  
\item {\ttfamily int = obj.\-Get\-Data\-Set\-Cache\-Hit ()} -\/ Caching statistics.  
\item {\ttfamily int = obj.\-Get\-Cache\-Miss ()} -\/ Caching statistics.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkcollectgraph}{}\section{vtk\-Collect\-Graph}\label{vtkparallel_vtkcollectgraph}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This filter has code to collect a graph from across processes onto vertex 0. Collection can be turned on or off using the \char`\"{}\-Pass\-Through\char`\"{} flag.

To create an instance of class vtk\-Collect\-Graph, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkCollectGraph
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Collect\-Graph has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Collect\-Graph class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Collect\-Graph = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Collect\-Graph = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Controller (vtk\-Multi\-Process\-Controller )} -\/ By defualt this filter uses the global controller, but this method can be used to set another instead.  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Get\-Controller ()} -\/ By defualt this filter uses the global controller, but this method can be used to set another instead.  
\item {\ttfamily obj.\-Set\-Socket\-Controller (vtk\-Socket\-Controller )} -\/ When this filter is being used in client-\/server mode, this is the controller used to communicate between client and server. Client should not set the other controller.  
\item {\ttfamily vtk\-Socket\-Controller = obj.\-Get\-Socket\-Controller ()} -\/ When this filter is being used in client-\/server mode, this is the controller used to communicate between client and server. Client should not set the other controller.  
\item {\ttfamily obj.\-Set\-Pass\-Through (int )} -\/ To collect or just copy input to output. Off (collect) by default.  
\item {\ttfamily int = obj.\-Get\-Pass\-Through ()} -\/ To collect or just copy input to output. Off (collect) by default.  
\item {\ttfamily obj.\-Pass\-Through\-On ()} -\/ To collect or just copy input to output. Off (collect) by default.  
\item {\ttfamily obj.\-Pass\-Through\-Off ()} -\/ To collect or just copy input to output. Off (collect) by default.  
\item {\ttfamily obj.\-Set\-Output\-Type (int )} -\/ Directedness flag, used to signal whether the output graph is directed or undirected. D\-I\-R\-E\-C\-T\-E\-D\-\_\-\-O\-U\-T\-P\-U\-T expects that this filter is generating a directed graph. U\-N\-D\-I\-R\-E\-C\-T\-E\-D\-\_\-\-O\-U\-T\-P\-U\-T expects that this filter is generating an undirected graph. D\-I\-R\-E\-C\-T\-E\-D\-\_\-\-O\-U\-T\-P\-U\-T and U\-N\-D\-I\-R\-E\-C\-T\-E\-D\-\_\-\-O\-U\-T\-P\-U\-T flags should only be set on the client filter. Server filters should be set to U\-S\-E\-\_\-\-I\-N\-P\-U\-T\-\_\-\-T\-Y\-P\-E since they have valid input and the directedness is determined from the input type.  
\item {\ttfamily int = obj.\-Get\-Output\-Type ()} -\/ Directedness flag, used to signal whether the output graph is directed or undirected. D\-I\-R\-E\-C\-T\-E\-D\-\_\-\-O\-U\-T\-P\-U\-T expects that this filter is generating a directed graph. U\-N\-D\-I\-R\-E\-C\-T\-E\-D\-\_\-\-O\-U\-T\-P\-U\-T expects that this filter is generating an undirected graph. D\-I\-R\-E\-C\-T\-E\-D\-\_\-\-O\-U\-T\-P\-U\-T and U\-N\-D\-I\-R\-E\-C\-T\-E\-D\-\_\-\-O\-U\-T\-P\-U\-T flags should only be set on the client filter. Server filters should be set to U\-S\-E\-\_\-\-I\-N\-P\-U\-T\-\_\-\-T\-Y\-P\-E since they have valid input and the directedness is determined from the input type.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkcollectpolydata}{}\section{vtk\-Collect\-Poly\-Data}\label{vtkparallel_vtkcollectpolydata}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This filter has code to collect polydat from across processes onto node 0. Collection can be turned on or off using the \char`\"{}\-Pass\-Through\char`\"{} flag.

To create an instance of class vtk\-Collect\-Poly\-Data, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkCollectPolyData
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Collect\-Poly\-Data has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Collect\-Poly\-Data class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Collect\-Poly\-Data = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Collect\-Poly\-Data = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Controller (vtk\-Multi\-Process\-Controller )} -\/ By defualt this filter uses the global controller, but this method can be used to set another instead.  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Get\-Controller ()} -\/ By defualt this filter uses the global controller, but this method can be used to set another instead.  
\item {\ttfamily obj.\-Set\-Socket\-Controller (vtk\-Socket\-Controller )} -\/ When this filter is being used in client-\/server mode, this is the controller used to communicate between client and server. Client should not set the other controller.  
\item {\ttfamily vtk\-Socket\-Controller = obj.\-Get\-Socket\-Controller ()} -\/ When this filter is being used in client-\/server mode, this is the controller used to communicate between client and server. Client should not set the other controller.  
\item {\ttfamily obj.\-Set\-Pass\-Through (int )} -\/ To collect or just copy input to output. Off (collect) by default.  
\item {\ttfamily int = obj.\-Get\-Pass\-Through ()} -\/ To collect or just copy input to output. Off (collect) by default.  
\item {\ttfamily obj.\-Pass\-Through\-On ()} -\/ To collect or just copy input to output. Off (collect) by default.  
\item {\ttfamily obj.\-Pass\-Through\-Off ()} -\/ To collect or just copy input to output. Off (collect) by default.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkcollecttable}{}\section{vtk\-Collect\-Table}\label{vtkparallel_vtkcollecttable}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This filter has code to collect a table from across processes onto node 0. Collection can be turned on or off using the \char`\"{}\-Pass\-Through\char`\"{} flag.

To create an instance of class vtk\-Collect\-Table, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkCollectTable
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Collect\-Table has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Collect\-Table class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Collect\-Table = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Collect\-Table = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Controller (vtk\-Multi\-Process\-Controller )} -\/ By defualt this filter uses the global controller, but this method can be used to set another instead.  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Get\-Controller ()} -\/ By defualt this filter uses the global controller, but this method can be used to set another instead.  
\item {\ttfamily obj.\-Set\-Socket\-Controller (vtk\-Socket\-Controller )} -\/ When this filter is being used in client-\/server mode, this is the controller used to communicate between client and server. Client should not set the other controller.  
\item {\ttfamily vtk\-Socket\-Controller = obj.\-Get\-Socket\-Controller ()} -\/ When this filter is being used in client-\/server mode, this is the controller used to communicate between client and server. Client should not set the other controller.  
\item {\ttfamily obj.\-Set\-Pass\-Through (int )} -\/ To collect or just copy input to output. Off (collect) by default.  
\item {\ttfamily int = obj.\-Get\-Pass\-Through ()} -\/ To collect or just copy input to output. Off (collect) by default.  
\item {\ttfamily obj.\-Pass\-Through\-On ()} -\/ To collect or just copy input to output. Off (collect) by default.  
\item {\ttfamily obj.\-Pass\-Through\-Off ()} -\/ To collect or just copy input to output. Off (collect) by default.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkcommunicator}{}\section{vtk\-Communicator}\label{vtkparallel_vtkcommunicator}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This is an abstact class which contains functionality for sending and receiving inter-\/process messages. It contains methods for marshaling an object into a string (currently used by the M\-P\-I communicator but not the shared memory communicator).

To create an instance of class vtk\-Communicator, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkCommunicator
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Communicator has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Communicator class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Communicator = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Communicator = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Number\-Of\-Processes (int num)} -\/ Set the number of processes you will be using. This defaults to the maximum number available. If you set this to a value higher than the default, you will get an error.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Processes ()} -\/ Set the number of processes you will be using. This defaults to the maximum number available. If you set this to a value higher than the default, you will get an error.  
\item {\ttfamily int = obj.\-Get\-Local\-Process\-Id ()} -\/ Tells you which process \mbox{[}0, Num\-Process) you are in.  
\item {\ttfamily int = obj.\-Send (vtk\-Data\-Object data, int remote\-Handle, int tag)} -\/ This method sends a data object to a destination. Tag eliminates ambiguity and is used to match sends to receives.  
\item {\ttfamily int = obj.\-Send (vtk\-Data\-Array data, int remote\-Handle, int tag)} -\/ This method sends a data array to a destination. Tag eliminates ambiguity and is used to match sends to receives.  
\item {\ttfamily int = obj.\-Send (int data, vtk\-Id\-Type length, int remote\-Handle, int tag)} -\/ Convenience methods for sending data arrays.  
\item {\ttfamily int = obj.\-Send (int data, vtk\-Id\-Type length, int remote\-Handle, int tag)} -\/ Convenience methods for sending data arrays.  
\item {\ttfamily int = obj.\-Send (long data, vtk\-Id\-Type length, int remote\-Handle, int tag)} -\/ Convenience methods for sending data arrays.  
\item {\ttfamily int = obj.\-Send (string data, vtk\-Id\-Type length, int remote\-Handle, int tag)} -\/ Convenience methods for sending data arrays.  
\item {\ttfamily int = obj.\-Send (string data, vtk\-Id\-Type length, int remote\-Handle, int tag)} -\/ Convenience methods for sending data arrays.  
\item {\ttfamily int = obj.\-Send (float data, vtk\-Id\-Type length, int remote\-Handle, int tag)} -\/ Convenience methods for sending data arrays.  
\item {\ttfamily int = obj.\-Send (double data, vtk\-Id\-Type length, int remote\-Handle, int tag)} -\/ Convenience methods for sending data arrays.  
\item {\ttfamily int = obj.\-Receive (vtk\-Data\-Object data, int remote\-Handle, int tag)} -\/ This method receives a data object from a corresponding send. It blocks until the receive is finished.  
\item {\ttfamily vtk\-Data\-Object = obj.\-Receive\-Data\-Object (int remote\-Handle, int tag)} -\/ The caller does not have to know the data type before this call is made. It returns the newly created object.  
\item {\ttfamily int = obj.\-Receive (vtk\-Data\-Array data, int remote\-Handle, int tag)} -\/ This method receives a data array from a corresponding send. It blocks until the receive is finished.  
\item {\ttfamily int = obj.\-Receive (int data, vtk\-Id\-Type maxlength, int remote\-Handle, int tag)} -\/ Convenience methods for receiving data arrays.  
\item {\ttfamily int = obj.\-Receive (int data, vtk\-Id\-Type maxlength, int remote\-Handle, int tag)} -\/ Convenience methods for receiving data arrays.  
\item {\ttfamily int = obj.\-Receive (long data, vtk\-Id\-Type maxlength, int remote\-Handle, int tag)} -\/ Convenience methods for receiving data arrays.  
\item {\ttfamily int = obj.\-Receive (string data, vtk\-Id\-Type maxlength, int remote\-Handle, int tag)} -\/ Convenience methods for receiving data arrays.  
\item {\ttfamily int = obj.\-Receive (string data, vtk\-Id\-Type maxlength, int remote\-Handle, int tag)} -\/ Convenience methods for receiving data arrays.  
\item {\ttfamily int = obj.\-Receive (float data, vtk\-Id\-Type maxlength, int remote\-Handle, int tag)} -\/ Convenience methods for receiving data arrays.  
\item {\ttfamily int = obj.\-Receive (double data, vtk\-Id\-Type maxlength, int remote\-Handle, int tag)} -\/ Convenience methods for receiving data arrays.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Count ()} -\/ Returns the number of words received by the most recent Receive(). Note that this is not the number of bytes received, but the number of items of the data-\/type received by the most recent Receive() eg. if Receive(int$\ast$,..) was used, then this returns the number of ints received; if Receive(double$\ast$,..) was used, then this returns the number of doubles received etc. The return value is valid only after a successful Receive().  
\item {\ttfamily obj.\-Barrier ()} -\/ Will block the processes until all other processes reach the Barrier function.  
\item {\ttfamily int = obj.\-Broadcast (int data, vtk\-Id\-Type length, int src\-Process\-Id)} -\/ Broadcast sends the array in the process with id {\ttfamily src\-Process\-Id} to all of the other processes. All processes must call these method with the same arguments in order for it to complete.  
\item {\ttfamily int = obj.\-Broadcast (long data, vtk\-Id\-Type length, int src\-Process\-Id)} -\/ Broadcast sends the array in the process with id {\ttfamily src\-Process\-Id} to all of the other processes. All processes must call these method with the same arguments in order for it to complete.  
\item {\ttfamily int = obj.\-Broadcast (string data, vtk\-Id\-Type length, int src\-Process\-Id)} -\/ Broadcast sends the array in the process with id {\ttfamily src\-Process\-Id} to all of the other processes. All processes must call these method with the same arguments in order for it to complete.  
\item {\ttfamily int = obj.\-Broadcast (string data, vtk\-Id\-Type length, int src\-Process\-Id)} -\/ Broadcast sends the array in the process with id {\ttfamily src\-Process\-Id} to all of the other processes. All processes must call these method with the same arguments in order for it to complete.  
\item {\ttfamily int = obj.\-Broadcast (float data, vtk\-Id\-Type length, int src\-Process\-Id)} -\/ Broadcast sends the array in the process with id {\ttfamily src\-Process\-Id} to all of the other processes. All processes must call these method with the same arguments in order for it to complete.  
\item {\ttfamily int = obj.\-Broadcast (double data, vtk\-Id\-Type length, int src\-Process\-Id)} -\/ Broadcast sends the array in the process with id {\ttfamily src\-Process\-Id} to all of the other processes. All processes must call these method with the same arguments in order for it to complete.  
\item {\ttfamily int = obj.\-Broadcast (vtk\-Data\-Object data, int src\-Process\-Id)} -\/ Broadcast sends the array in the process with id {\ttfamily src\-Process\-Id} to all of the other processes. All processes must call these method with the same arguments in order for it to complete.  
\item {\ttfamily int = obj.\-Broadcast (vtk\-Data\-Array data, int src\-Process\-Id)} -\/ Broadcast sends the array in the process with id {\ttfamily src\-Process\-Id} to all of the other processes. All processes must call these method with the same arguments in order for it to complete.  
\item {\ttfamily int = obj.\-Gather (int send\-Buffer, int recv\-Buffer, vtk\-Id\-Type length, int dest\-Process\-Id)} -\/ Gather collects arrays in the process with id {\ttfamily dest\-Process\-Id}. Each process (including the destination) sends the contents of its send buffer to the destination process. The destination process receives the messages and stores them in rank order. The {\ttfamily length} argument (which must be the same on all processes) is the length of the send\-Buffers. The {\ttfamily recv\-Buffer} (on te destination process) must be of length length$\ast$num\-Processes. Gather is the inverse operation of Scatter.  
\item {\ttfamily int = obj.\-Gather (long send\-Buffer, long recv\-Buffer, vtk\-Id\-Type length, int dest\-Process\-Id)} -\/ Gather collects arrays in the process with id {\ttfamily dest\-Process\-Id}. Each process (including the destination) sends the contents of its send buffer to the destination process. The destination process receives the messages and stores them in rank order. The {\ttfamily length} argument (which must be the same on all processes) is the length of the send\-Buffers. The {\ttfamily recv\-Buffer} (on te destination process) must be of length length$\ast$num\-Processes. Gather is the inverse operation of Scatter.  
\item {\ttfamily int = obj.\-Gather (string send\-Buffer, string recv\-Buffer, vtk\-Id\-Type length, int dest\-Process\-Id)} -\/ Gather collects arrays in the process with id {\ttfamily dest\-Process\-Id}. Each process (including the destination) sends the contents of its send buffer to the destination process. The destination process receives the messages and stores them in rank order. The {\ttfamily length} argument (which must be the same on all processes) is the length of the send\-Buffers. The {\ttfamily recv\-Buffer} (on te destination process) must be of length length$\ast$num\-Processes. Gather is the inverse operation of Scatter.  
\item {\ttfamily int = obj.\-Gather (string send\-Buffer, string recv\-Buffer, vtk\-Id\-Type length, int dest\-Process\-Id)} -\/ Gather collects arrays in the process with id {\ttfamily dest\-Process\-Id}. Each process (including the destination) sends the contents of its send buffer to the destination process. The destination process receives the messages and stores them in rank order. The {\ttfamily length} argument (which must be the same on all processes) is the length of the send\-Buffers. The {\ttfamily recv\-Buffer} (on te destination process) must be of length length$\ast$num\-Processes. Gather is the inverse operation of Scatter.  
\item {\ttfamily int = obj.\-Gather (float send\-Buffer, float recv\-Buffer, vtk\-Id\-Type length, int dest\-Process\-Id)} -\/ Gather collects arrays in the process with id {\ttfamily dest\-Process\-Id}. Each process (including the destination) sends the contents of its send buffer to the destination process. The destination process receives the messages and stores them in rank order. The {\ttfamily length} argument (which must be the same on all processes) is the length of the send\-Buffers. The {\ttfamily recv\-Buffer} (on te destination process) must be of length length$\ast$num\-Processes. Gather is the inverse operation of Scatter.  
\item {\ttfamily int = obj.\-Gather (double send\-Buffer, double recv\-Buffer, vtk\-Id\-Type length, int dest\-Process\-Id)} -\/ Gather collects arrays in the process with id {\ttfamily dest\-Process\-Id}. Each process (including the destination) sends the contents of its send buffer to the destination process. The destination process receives the messages and stores them in rank order. The {\ttfamily length} argument (which must be the same on all processes) is the length of the send\-Buffers. The {\ttfamily recv\-Buffer} (on te destination process) must be of length length$\ast$num\-Processes. Gather is the inverse operation of Scatter.  
\item {\ttfamily int = obj.\-Gather (vtk\-Data\-Array send\-Buffer, vtk\-Data\-Array recv\-Buffer, int dest\-Process\-Id)} -\/ Gather collects arrays in the process with id {\ttfamily dest\-Process\-Id}. Each process (including the destination) sends the contents of its send buffer to the destination process. The destination process receives the messages and stores them in rank order. The {\ttfamily length} argument (which must be the same on all processes) is the length of the send\-Buffers. The {\ttfamily recv\-Buffer} (on te destination process) must be of length length$\ast$num\-Processes. Gather is the inverse operation of Scatter.  
\item {\ttfamily int = obj.\-Scatter (int send\-Buffer, int recv\-Buffer, vtk\-Id\-Type length, int src\-Process\-Id)} -\/ Scatter takes an array in the process with id {\ttfamily src\-Process\-Id} and distributes it. Each process (including the source) receives a portion of the send buffer. Process 0 receives the first {\ttfamily length} values, process 1 receives the second {\ttfamily length} values, and so on. Scatter is the inverse operation of Gather.  
\item {\ttfamily int = obj.\-Scatter (long send\-Buffer, long recv\-Buffer, vtk\-Id\-Type length, int src\-Process\-Id)} -\/ Scatter takes an array in the process with id {\ttfamily src\-Process\-Id} and distributes it. Each process (including the source) receives a portion of the send buffer. Process 0 receives the first {\ttfamily length} values, process 1 receives the second {\ttfamily length} values, and so on. Scatter is the inverse operation of Gather.  
\item {\ttfamily int = obj.\-Scatter (string send\-Buffer, string recv\-Buffer, vtk\-Id\-Type length, int src\-Process\-Id)} -\/ Scatter takes an array in the process with id {\ttfamily src\-Process\-Id} and distributes it. Each process (including the source) receives a portion of the send buffer. Process 0 receives the first {\ttfamily length} values, process 1 receives the second {\ttfamily length} values, and so on. Scatter is the inverse operation of Gather.  
\item {\ttfamily int = obj.\-Scatter (string send\-Buffer, string recv\-Buffer, vtk\-Id\-Type length, int src\-Process\-Id)} -\/ Scatter takes an array in the process with id {\ttfamily src\-Process\-Id} and distributes it. Each process (including the source) receives a portion of the send buffer. Process 0 receives the first {\ttfamily length} values, process 1 receives the second {\ttfamily length} values, and so on. Scatter is the inverse operation of Gather.  
\item {\ttfamily int = obj.\-Scatter (float send\-Buffer, float recv\-Buffer, vtk\-Id\-Type length, int src\-Process\-Id)} -\/ Scatter takes an array in the process with id {\ttfamily src\-Process\-Id} and distributes it. Each process (including the source) receives a portion of the send buffer. Process 0 receives the first {\ttfamily length} values, process 1 receives the second {\ttfamily length} values, and so on. Scatter is the inverse operation of Gather.  
\item {\ttfamily int = obj.\-Scatter (double send\-Buffer, double recv\-Buffer, vtk\-Id\-Type length, int src\-Process\-Id)} -\/ Scatter takes an array in the process with id {\ttfamily src\-Process\-Id} and distributes it. Each process (including the source) receives a portion of the send buffer. Process 0 receives the first {\ttfamily length} values, process 1 receives the second {\ttfamily length} values, and so on. Scatter is the inverse operation of Gather.  
\item {\ttfamily int = obj.\-Scatter (vtk\-Data\-Array send\-Buffer, vtk\-Data\-Array recv\-Buffer, int src\-Process\-Id)} -\/ Scatter takes an array in the process with id {\ttfamily src\-Process\-Id} and distributes it. Each process (including the source) receives a portion of the send buffer. Process 0 receives the first {\ttfamily length} values, process 1 receives the second {\ttfamily length} values, and so on. Scatter is the inverse operation of Gather.  
\item {\ttfamily int = obj.\-All\-Gather (int send\-Buffer, int recv\-Buffer, vtk\-Id\-Type length)} -\/ Same as gather except that the result ends up on all processes.  
\item {\ttfamily int = obj.\-All\-Gather (long send\-Buffer, long recv\-Buffer, vtk\-Id\-Type length)} -\/ Same as gather except that the result ends up on all processes.  
\item {\ttfamily int = obj.\-All\-Gather (string send\-Buffer, string recv\-Buffer, vtk\-Id\-Type length)} -\/ Same as gather except that the result ends up on all processes.  
\item {\ttfamily int = obj.\-All\-Gather (string send\-Buffer, string recv\-Buffer, vtk\-Id\-Type length)} -\/ Same as gather except that the result ends up on all processes.  
\item {\ttfamily int = obj.\-All\-Gather (float send\-Buffer, float recv\-Buffer, vtk\-Id\-Type length)} -\/ Same as gather except that the result ends up on all processes.  
\item {\ttfamily int = obj.\-All\-Gather (double send\-Buffer, double recv\-Buffer, vtk\-Id\-Type length)} -\/ Same as gather except that the result ends up on all processes.  
\item {\ttfamily int = obj.\-All\-Gather (vtk\-Data\-Array send\-Buffer, vtk\-Data\-Array recv\-Buffer)} -\/ Same as gather except that the result ends up on all processes.  
\item {\ttfamily int = obj.\-Reduce (int send\-Buffer, int recv\-Buffer, vtk\-Id\-Type length, int operation, int dest\-Process\-Id)} -\/ Reduce an array to the given destination process. This version of Reduce takes an identifier defined in the vtk\-Communicator\-::\-Standard\-Operations enum to define the operation.  
\item {\ttfamily int = obj.\-Reduce (long send\-Buffer, long recv\-Buffer, vtk\-Id\-Type length, int operation, int dest\-Process\-Id)} -\/ Reduce an array to the given destination process. This version of Reduce takes an identifier defined in the vtk\-Communicator\-::\-Standard\-Operations enum to define the operation.  
\item {\ttfamily int = obj.\-Reduce (string send\-Buffer, string recv\-Buffer, vtk\-Id\-Type length, int operation, int dest\-Process\-Id)} -\/ Reduce an array to the given destination process. This version of Reduce takes an identifier defined in the vtk\-Communicator\-::\-Standard\-Operations enum to define the operation.  
\item {\ttfamily int = obj.\-Reduce (string send\-Buffer, string recv\-Buffer, vtk\-Id\-Type length, int operation, int dest\-Process\-Id)} -\/ Reduce an array to the given destination process. This version of Reduce takes an identifier defined in the vtk\-Communicator\-::\-Standard\-Operations enum to define the operation.  
\item {\ttfamily int = obj.\-Reduce (float send\-Buffer, float recv\-Buffer, vtk\-Id\-Type length, int operation, int dest\-Process\-Id)} -\/ Reduce an array to the given destination process. This version of Reduce takes an identifier defined in the vtk\-Communicator\-::\-Standard\-Operations enum to define the operation.  
\item {\ttfamily int = obj.\-Reduce (double send\-Buffer, double recv\-Buffer, vtk\-Id\-Type length, int operation, int dest\-Process\-Id)} -\/ Reduce an array to the given destination process. This version of Reduce takes an identifier defined in the vtk\-Communicator\-::\-Standard\-Operations enum to define the operation.  
\item {\ttfamily int = obj.\-Reduce (vtk\-Data\-Array send\-Buffer, vtk\-Data\-Array recv\-Buffer, int operation, int dest\-Process\-Id)} -\/ Reduce an array to the given destination process. This version of Reduce takes an identifier defined in the vtk\-Communicator\-::\-Standard\-Operations enum to define the operation.  
\item {\ttfamily int = obj.\-All\-Reduce (int send\-Buffer, int recv\-Buffer, vtk\-Id\-Type length, int operation)} -\/ Same as Reduce except that the result is placed in all of the processes.  
\item {\ttfamily int = obj.\-All\-Reduce (long send\-Buffer, long recv\-Buffer, vtk\-Id\-Type length, int operation)} -\/ Same as Reduce except that the result is placed in all of the processes.  
\item {\ttfamily int = obj.\-All\-Reduce (string send\-Buffer, string recv\-Buffer, vtk\-Id\-Type length, int operation)} -\/ Same as Reduce except that the result is placed in all of the processes.  
\item {\ttfamily int = obj.\-All\-Reduce (string send\-Buffer, string recv\-Buffer, vtk\-Id\-Type length, int operation)} -\/ Same as Reduce except that the result is placed in all of the processes.  
\item {\ttfamily int = obj.\-All\-Reduce (float send\-Buffer, float recv\-Buffer, vtk\-Id\-Type length, int operation)} -\/ Same as Reduce except that the result is placed in all of the processes.  
\item {\ttfamily int = obj.\-All\-Reduce (double send\-Buffer, double recv\-Buffer, vtk\-Id\-Type length, int operation)} -\/ Same as Reduce except that the result is placed in all of the processes.  
\item {\ttfamily int = obj.\-All\-Reduce (vtk\-Data\-Array send\-Buffer, vtk\-Data\-Array recv\-Buffer, int operation)} -\/ Same as Reduce except that the result is placed in all of the processes.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkcompositer}{}\section{vtk\-Compositer}\label{vtkparallel_vtkcompositer}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Compositer operates in multiple processes. Each compositer has a render window. They use vtk\-Multi\-Process\-Controllers to communicate the color and depth buffer to process 0's render window. It will not handle transparency well.

To create an instance of class vtk\-Compositer, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkCompositer
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Compositer has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Compositer class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Compositer = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Compositer = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Composite\-Buffer (vtk\-Data\-Array p\-Buf, vtk\-Float\-Array z\-Buf, vtk\-Data\-Array p\-Tmp, vtk\-Float\-Array z\-Tmp)} -\/ This method gets called on every process. The final image gets put into p\-Buf and z\-Buf.  
\item {\ttfamily obj.\-Set\-Controller (vtk\-Multi\-Process\-Controller )} -\/ Access to the controller.  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Get\-Controller ()} -\/ Access to the controller.  
\item {\ttfamily obj.\-Set\-Number\-Of\-Processes (int )} -\/ A hack to get a sub world until I can get communicators working.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Processes ()} -\/ A hack to get a sub world until I can get communicators working.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkcompositerendermanager}{}\section{vtk\-Composite\-Render\-Manager}\label{vtkparallel_vtkcompositerendermanager}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Composite\-Render\-Manager is a subclass of vtk\-Parallel\-Render\-Manager that uses compositing to do parallel rendering. This class has replaced vtk\-Composite\-Manager.

To create an instance of class vtk\-Composite\-Render\-Manager, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkCompositeRenderManager
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Composite\-Render\-Manager has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Composite\-Render\-Manager class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Composite\-Render\-Manager = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Composite\-Render\-Manager = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Compositer (vtk\-Compositer c)} -\/ Set/\-Get the composite algorithm.  
\item {\ttfamily vtk\-Compositer = obj.\-Get\-Compositer ()} -\/ Set/\-Get the composite algorithm.  
\item {\ttfamily double = obj.\-Get\-Image\-Processing\-Time ()} -\/ Get rendering metrics.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkcompresscompositer}{}\section{vtk\-Compress\-Compositer}\label{vtkparallel_vtkcompresscompositer}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Compress\-Compositer operates in multiple processes. Each compositer has a render window. They use vtk\-Multi\-Process\-Controller to communicate the color and depth buffer to process 0's render window. It will not handle transparency. Compositing is run length encoding of background pixels.

S\-E\-C\-T\-I\-O\-N See Also vtk\-Composite\-Manager.

To create an instance of class vtk\-Compress\-Compositer, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkCompressCompositer
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Compress\-Compositer has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Compress\-Compositer class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Compress\-Compositer = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Compress\-Compositer = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Composite\-Buffer (vtk\-Data\-Array p\-Buf, vtk\-Float\-Array z\-Buf, vtk\-Data\-Array p\-Tmp, vtk\-Float\-Array z\-Tmp)}  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkcutmaterial}{}\section{vtk\-Cut\-Material}\label{vtkparallel_vtkcutmaterial}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Cut\-Material computes a cut plane based on an up vector, center of the bounding box and the location of the maximum variable value. These computed values are available so that they can be used to set the camera for the best view of the plane.

To create an instance of class vtk\-Cut\-Material, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkCutMaterial
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Cut\-Material has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Cut\-Material class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Cut\-Material = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Cut\-Material = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Material\-Array\-Name (string )} -\/ Cell array that contains the material values.  
\item {\ttfamily string = obj.\-Get\-Material\-Array\-Name ()} -\/ Cell array that contains the material values.  
\item {\ttfamily obj.\-Set\-Material (int )} -\/ Material to probe.  
\item {\ttfamily int = obj.\-Get\-Material ()} -\/ Material to probe.  
\item {\ttfamily obj.\-Set\-Array\-Name (string )} -\/ For now, we just use the cell values. The array name to cut.  
\item {\ttfamily string = obj.\-Get\-Array\-Name ()} -\/ For now, we just use the cell values. The array name to cut.  
\item {\ttfamily obj.\-Set\-Up\-Vector (double , double , double )} -\/ The last piece of information that specifies the plane.  
\item {\ttfamily obj.\-Set\-Up\-Vector (double a\mbox{[}3\mbox{]})} -\/ The last piece of information that specifies the plane.  
\item {\ttfamily double = obj. Get\-Up\-Vector ()} -\/ The last piece of information that specifies the plane.  
\item {\ttfamily double = obj. Get\-Maximum\-Point ()} -\/ Accesses to the values computed during the execute method. They could be used to get a good camera view for the resulting plane.  
\item {\ttfamily double = obj. Get\-Center\-Point ()} -\/ Accesses to the values computed during the execute method. They could be used to get a good camera view for the resulting plane.  
\item {\ttfamily double = obj. Get\-Normal ()} -\/ Accesses to the values computed during the execute method. They could be used to get a good camera view for the resulting plane.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkdistributeddatafilter}{}\section{vtk\-Distributed\-Data\-Filter}\label{vtkparallel_vtkdistributeddatafilter}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This filter redistributes data among processors in a parallel application into spatially contiguous vtk\-Unstructured\-Grids. The execution model anticipated is that all processes read in part of a large vtk\-Data\-Set. Each process sets the input of filter to be that Data\-Set. When executed, this filter builds in parallel a k-\/d tree, decomposing the space occupied by the distributed Data\-Set into spatial regions. It assigns each spatial region to a processor. The data is then redistributed and the output is a single vtk\-Unstructured\-Grid containing the cells in the process' assigned regions.

This filter is sometimes called \char`\"{}\-D3\char`\"{} for \char`\"{}distributed data decomposition\char`\"{}.

Enhancement\-: You can set the k-\/d tree decomposition, rather than have D3 compute it. This allows you to divide a dataset using the decomposition computed for another dataset. Obtain a description of the k-\/d tree cuts this way\-:

vtk\-B\-S\-P\-Cuts $\ast$cuts = D3\-Object1-\/$>$Get\-Cuts()

And set it this way\-:

D3\-Object2-\/$>$Set\-Cuts(cuts)

It is desirable to have a field array of global node I\-Ds for two reasons\-:


\begin{DoxyEnumerate}
\item When merging together sub grids that were distributed across processors, global node I\-Ds can be used to remove duplicate points and significantly reduce the size of the resulting output grid. If no such array is available, D3 will use a tolerance to merge points, which is much slower.
\end{DoxyEnumerate}


\begin{DoxyEnumerate}
\item If ghost cells have been requested, D3 requires a global node I\-D array in order to request and transfer ghost cells in parallel among the processors. If there is no global node I\-D array, D3 will in parallel create a global node I\-D array, and the time to do this can be significant.
\end{DoxyEnumerate}

If you know the name of a global node I\-D array in the input dataset, set that name with this method. If you leave it unset, D3 will search the input data set for certain common names of global node I\-D arrays. If none is found, and ghost cells have been requested, D3 will create a temporary global node I\-D array before aquiring ghost cells. It is also desirable to have global element I\-Ds. However, if they don't exist D3 can create them relatively quickly. Set the name of the global element I\-D array if you have it. If it is not set, D3 will search for it using common names. If still not found, D3 will create a temporary array of global element I\-Ds.

To create an instance of class vtk\-Distributed\-Data\-Filter, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkDistributedDataFilter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Distributed\-Data\-Filter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Distributed\-Data\-Filter class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Distributed\-Data\-Filter = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Distributed\-Data\-Filter = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Controller (vtk\-Multi\-Process\-Controller c)} -\/ Set/\-Get the communicator object  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Get\-Controller ()} -\/ Set/\-Get the communicator object  
\item {\ttfamily vtk\-P\-Kd\-Tree = obj.\-Get\-Kdtree ()}  
\item {\ttfamily obj.\-Retain\-Kdtree\-On ()}  
\item {\ttfamily obj.\-Retain\-Kdtree\-Off ()}  
\item {\ttfamily int = obj.\-Get\-Retain\-Kdtree ()}  
\item {\ttfamily obj.\-Set\-Retain\-Kdtree (int )}  
\item {\ttfamily obj.\-Include\-All\-Intersecting\-Cells\-On ()}  
\item {\ttfamily obj.\-Include\-All\-Intersecting\-Cells\-Off ()}  
\item {\ttfamily int = obj.\-Get\-Include\-All\-Intersecting\-Cells ()}  
\item {\ttfamily obj.\-Set\-Include\-All\-Intersecting\-Cells (int )}  
\item {\ttfamily obj.\-Clip\-Cells\-On ()}  
\item {\ttfamily obj.\-Clip\-Cells\-Off ()}  
\item {\ttfamily int = obj.\-Get\-Clip\-Cells ()}  
\item {\ttfamily obj.\-Set\-Clip\-Cells (int )}  
\item {\ttfamily obj.\-Set\-Boundary\-Mode (int mode)} -\/ Handling of Clip\-Cells and Include\-All\-Intersecting\-Cells.  
\item {\ttfamily obj.\-Set\-Boundary\-Mode\-To\-Assign\-To\-One\-Region ()} -\/ Handling of Clip\-Cells and Include\-All\-Intersecting\-Cells.  
\item {\ttfamily obj.\-Set\-Boundary\-Mode\-To\-Assign\-To\-All\-Intersecting\-Regions ()} -\/ Handling of Clip\-Cells and Include\-All\-Intersecting\-Cells.  
\item {\ttfamily obj.\-Set\-Boundary\-Mode\-To\-Split\-Boundary\-Cells ()} -\/ Handling of Clip\-Cells and Include\-All\-Intersecting\-Cells.  
\item {\ttfamily int = obj.\-Get\-Boundary\-Mode ()} -\/ Handling of Clip\-Cells and Include\-All\-Intersecting\-Cells.  
\item {\ttfamily obj.\-Use\-Minimal\-Memory\-On ()}  
\item {\ttfamily obj.\-Use\-Minimal\-Memory\-Off ()}  
\item {\ttfamily int = obj.\-Get\-Use\-Minimal\-Memory ()}  
\item {\ttfamily obj.\-Set\-Use\-Minimal\-Memory (int )}  
\item {\ttfamily obj.\-Timing\-On ()}  
\item {\ttfamily obj.\-Timing\-Off ()}  
\item {\ttfamily obj.\-Set\-Timing (int )}  
\item {\ttfamily int = obj.\-Get\-Timing ()}  
\item {\ttfamily vtk\-B\-S\-P\-Cuts = obj.\-Get\-Cuts ()} -\/ You can set the k-\/d tree decomposition, rather than have D3 compute it. This allows you to divide a dataset using the decomposition computed for another dataset. Obtain a description of the k-\/d tree cuts this way\-:

vtk\-B\-S\-P\-Cuts $\ast$cuts = D3\-Object1-\/$>$Get\-Cuts()

And set it this way\-:

D3\-Object2-\/$>$Set\-Cuts(cuts)  
\item {\ttfamily obj.\-Set\-Cuts (vtk\-B\-S\-P\-Cuts cuts)} -\/ You can set the k-\/d tree decomposition, rather than have D3 compute it. This allows you to divide a dataset using the decomposition computed for another dataset. Obtain a description of the k-\/d tree cuts this way\-:

vtk\-B\-S\-P\-Cuts $\ast$cuts = D3\-Object1-\/$>$Get\-Cuts()

And set it this way\-:

D3\-Object2-\/$>$Set\-Cuts(cuts)  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkdistributedstreamtracer}{}\section{vtk\-Distributed\-Stream\-Tracer}\label{vtkparallel_vtkdistributedstreamtracer}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This filter integrates streamlines on a distributed dataset. It is essentially a serial algorithm\-: only one process is active at one time and it is not more efficient than a single process integration. It is useful when the data is too large to be on one process and has to be kept distributed.

To create an instance of class vtk\-Distributed\-Stream\-Tracer, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkDistributedStreamTracer
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Distributed\-Stream\-Tracer has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Distributed\-Stream\-Tracer class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Distributed\-Stream\-Tracer = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Distributed\-Stream\-Tracer = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkdummycommunicator}{}\section{vtk\-Dummy\-Communicator}\label{vtkparallel_vtkdummycommunicator}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This is a dummy communicator, which can be used by applications that always require a controller but are also compiled on systems without threads or M\-P\-I. Because there is always only one process, no real communication takes place.

To create an instance of class vtk\-Dummy\-Communicator, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkDummyCommunicator
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Dummy\-Communicator has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Dummy\-Communicator class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Dummy\-Communicator = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Dummy\-Communicator = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkdummycontroller}{}\section{vtk\-Dummy\-Controller}\label{vtkparallel_vtkdummycontroller}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This is a dummy controller which can be used by applications which always require a controller but are also compile on systems without threads or mpi.

To create an instance of class vtk\-Dummy\-Controller, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkDummyController
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Dummy\-Controller has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Dummy\-Controller class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Dummy\-Controller = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Dummy\-Controller = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Finalize ()} -\/ This method is for setting up the processes.  
\item {\ttfamily obj.\-Finalize (int )} -\/ This method always returns 0.  
\item {\ttfamily int = obj.\-Get\-Local\-Process\-Id ()} -\/ Directly calls the single method.  
\item {\ttfamily obj.\-Single\-Method\-Execute ()} -\/ Directly calls the single method.  
\item {\ttfamily obj.\-Multiple\-Method\-Execute ()} -\/ Directly calls multiple method 0.  
\item {\ttfamily obj.\-Create\-Output\-Window ()} -\/ If you don't need any special functionality from the controller, you can swap out the dummy communicator for another one.  
\item {\ttfamily vtk\-Communicator = obj.\-Get\-Communicator ()} -\/ If you don't need any special functionality from the controller, you can swap out the dummy communicator for another one.  
\item {\ttfamily vtk\-Communicator = obj.\-Get\-R\-M\-I\-Communicator ()} -\/ If you don't need any special functionality from the controller, you can swap out the dummy communicator for another one.  
\item {\ttfamily obj.\-Set\-Communicator (vtk\-Communicator )} -\/ If you don't need any special functionality from the controller, you can swap out the dummy communicator for another one.  
\item {\ttfamily obj.\-Set\-R\-M\-I\-Communicator (vtk\-Communicator )} -\/ If you don't need any special functionality from the controller, you can swap out the dummy communicator for another one.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkduplicatepolydata}{}\section{vtk\-Duplicate\-Poly\-Data}\label{vtkparallel_vtkduplicatepolydata}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This filter collects poly data and duplicates it on every node. Converts data parallel so every node has a complete copy of the data. The filter is used at the end of a pipeline for driving a tiled display.

To create an instance of class vtk\-Duplicate\-Poly\-Data, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkDuplicatePolyData
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Duplicate\-Poly\-Data has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Duplicate\-Poly\-Data class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Duplicate\-Poly\-Data = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Duplicate\-Poly\-Data = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Controller (vtk\-Multi\-Process\-Controller )} -\/ By defualt this filter uses the global controller, but this method can be used to set another instead.  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Get\-Controller ()} -\/ By defualt this filter uses the global controller, but this method can be used to set another instead.  
\item {\ttfamily obj.\-Initialize\-Schedule (int num\-Procs)}  
\item {\ttfamily obj.\-Set\-Synchronous (int )} -\/ This flag causes sends and receives to be matched. When this flag is off, two sends occur then two receives. I want to see if it makes a difference in performance. The flag is on by default.  
\item {\ttfamily int = obj.\-Get\-Synchronous ()} -\/ This flag causes sends and receives to be matched. When this flag is off, two sends occur then two receives. I want to see if it makes a difference in performance. The flag is on by default.  
\item {\ttfamily obj.\-Synchronous\-On ()} -\/ This flag causes sends and receives to be matched. When this flag is off, two sends occur then two receives. I want to see if it makes a difference in performance. The flag is on by default.  
\item {\ttfamily obj.\-Synchronous\-Off ()} -\/ This flag causes sends and receives to be matched. When this flag is off, two sends occur then two receives. I want to see if it makes a difference in performance. The flag is on by default.  
\item {\ttfamily vtk\-Socket\-Controller = obj.\-Get\-Socket\-Controller ()} -\/ This duplicate filter works in client server mode when this controller is set. We have a client flag to diferentiate the client and server because the socket controller is odd\-: Proth processes think their id is 0.  
\item {\ttfamily obj.\-Set\-Socket\-Controller (vtk\-Socket\-Controller controller)} -\/ This duplicate filter works in client server mode when this controller is set. We have a client flag to diferentiate the client and server because the socket controller is odd\-: Proth processes think their id is 0.  
\item {\ttfamily obj.\-Set\-Client\-Flag (int )} -\/ This duplicate filter works in client server mode when this controller is set. We have a client flag to diferentiate the client and server because the socket controller is odd\-: Proth processes think their id is 0.  
\item {\ttfamily int = obj.\-Get\-Client\-Flag ()} -\/ This duplicate filter works in client server mode when this controller is set. We have a client flag to diferentiate the client and server because the socket controller is odd\-: Proth processes think their id is 0.  
\item {\ttfamily long = obj.\-Get\-Memory\-Size ()} -\/ This returns to size of the output (on this process). This method is not really used. It is needed to have the same A\-P\-I as vtk\-Collect\-Poly\-Data.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkensightwriter}{}\section{vtk\-En\-Sight\-Writer}\label{vtkparallel_vtkensightwriter}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-En\-Sight\-Writer is a source object that writes binary unstructured grid data files in En\-Sight format. See En\-Sight Manual for format details

To create an instance of class vtk\-En\-Sight\-Writer, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkEnSightWriter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-En\-Sight\-Writer has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-En\-Sight\-Writer class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-En\-Sight\-Writer = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-En\-Sight\-Writer = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Process\-Number (int )}  
\item {\ttfamily int = obj.\-Get\-Process\-Number ()}  
\item {\ttfamily obj.\-Set\-Path (string )} -\/ Specify path of En\-Sight data files to write.  
\item {\ttfamily string = obj.\-Get\-Path ()} -\/ Specify path of En\-Sight data files to write.  
\item {\ttfamily obj.\-Set\-Base\-Name (string )} -\/ Specify base name of En\-Sight data files to write.  
\item {\ttfamily string = obj.\-Get\-Base\-Name ()} -\/ Specify base name of En\-Sight data files to write.  
\item {\ttfamily obj.\-Set\-File\-Name (string )} -\/ Specify the path and base name of the output files.  
\item {\ttfamily string = obj.\-Get\-File\-Name ()} -\/ Specify the path and base name of the output files.  
\item {\ttfamily obj.\-Set\-Time\-Step (int )}  
\item {\ttfamily int = obj.\-Get\-Time\-Step ()}  
\item {\ttfamily obj.\-Set\-Ghost\-Level (int )}  
\item {\ttfamily int = obj.\-Get\-Ghost\-Level ()}  
\item {\ttfamily obj.\-Set\-Transient\-Geometry (bool )}  
\item {\ttfamily bool = obj.\-Get\-Transient\-Geometry ()}  
\item {\ttfamily obj.\-Set\-Number\-Of\-Blocks (int )}  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Blocks ()}  
\item {\ttfamily obj.\-Set\-Block\-I\-Ds (int val)}  
\item {\ttfamily obj.\-Set\-Input (vtk\-Unstructured\-Grid input)} -\/ Specify the input data or filter.  
\item {\ttfamily vtk\-Unstructured\-Grid = obj.\-Get\-Input ()} -\/ Specify the input data or filter.  
\item {\ttfamily obj.\-Write\-Case\-File (int Total\-Time\-Steps)}  
\item {\ttfamily obj.\-Write\-S\-O\-S\-Case\-File (int Num\-Procs)}  
\item {\ttfamily obj.\-Set\-Model\-Metadata (vtk\-Model\-Metadata model)}  
\item {\ttfamily vtk\-Model\-Metadata = obj.\-Get\-Model\-Metadata ()}  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkexodusiiwriter}{}\section{vtk\-Exodus\-I\-I\-Writer}\label{vtkparallel_vtkexodusiiwriter}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This is a vtk\-Writer that writes it's vtk\-Unstructured\-Grid input out to an Exodus I\-I file. Go to \href{http://endo.sandia.gov/SEACAS/}{\tt http\-://endo.\-sandia.\-gov/\-S\-E\-A\-C\-A\-S/} for more information about the Exodus I\-I format.

Exodus files contain much information that is not captured in a vtk\-Unstructured\-Grid, such as time steps, information lines, node sets, and side sets. This information can be stored in a vtk\-Model\-Metadata object.

The vtk\-Exodus\-Reader and vtk\-P\-Exodus\-Reader can create a vtk\-Model\-Metadata object and embed it in a vtk\-Unstructured\-Grid in a series of field arrays. This writer searches for these field arrays and will use the metadata contained in them when creating the new Exodus I\-I file.

You can also explicitly give the vtk\-Exodus\-I\-I\-Writer a vtk\-Model\-Metadata object to use when writing the file.

In the absence of the information provided by vtk\-Model\-Metadata, if this writer is not part of a parallel application, we will use reasonable defaults for all the values in the output Exodus file. If you don't provide a block I\-D element array, we'll create a block for each cell type that appears in the unstructured grid.

However if this writer is part of a parallel application (hence writing out a distributed Exodus file), then we need at the very least a list of all the block I\-Ds that appear in the file. And we need the element array of block I\-Ds for the input unstructured grid.

In the absense of a vtk\-Model\-Metadata object, you can also provide time step information which we will include in the output Exodus file.

.S\-E\-C\-T\-I\-O\-N Caveats If the input floating point field arrays and point locations are all floats or all doubles, this class will operate more efficiently. Mixing floats and doubles will slow you down, because Exodus I\-I requires that we write only floats or only doubles.

We use the terms \char`\"{}point\char`\"{} and \char`\"{}node\char`\"{} interchangeably. Also, we use the terms \char`\"{}element\char`\"{} and \char`\"{}cell\char`\"{} interchangeably.

To create an instance of class vtk\-Exodus\-I\-I\-Writer, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkExodusIIWriter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Exodus\-I\-I\-Writer has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Exodus\-I\-I\-Writer class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Exodus\-I\-I\-Writer = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Exodus\-I\-I\-Writer = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Model\-Metadata (vtk\-Model\-Metadata )}  
\item {\ttfamily vtk\-Model\-Metadata = obj.\-Get\-Model\-Metadata ()}  
\item {\ttfamily obj.\-Set\-File\-Name (string )}  
\item {\ttfamily string = obj.\-Get\-File\-Name ()}  
\item {\ttfamily obj.\-Set\-Store\-Doubles (int )}  
\item {\ttfamily int = obj.\-Get\-Store\-Doubles ()}  
\item {\ttfamily obj.\-Set\-Ghost\-Level (int )}  
\item {\ttfamily int = obj.\-Get\-Ghost\-Level ()}  
\item {\ttfamily obj.\-Set\-Write\-Out\-Block\-Id\-Array (int )}  
\item {\ttfamily int = obj.\-Get\-Write\-Out\-Block\-Id\-Array ()}  
\item {\ttfamily obj.\-Write\-Out\-Block\-Id\-Array\-On ()}  
\item {\ttfamily obj.\-Write\-Out\-Block\-Id\-Array\-Off ()}  
\item {\ttfamily obj.\-Set\-Write\-Out\-Global\-Node\-Id\-Array (int )}  
\item {\ttfamily int = obj.\-Get\-Write\-Out\-Global\-Node\-Id\-Array ()}  
\item {\ttfamily obj.\-Write\-Out\-Global\-Node\-Id\-Array\-On ()}  
\item {\ttfamily obj.\-Write\-Out\-Global\-Node\-Id\-Array\-Off ()}  
\item {\ttfamily obj.\-Set\-Write\-Out\-Global\-Element\-Id\-Array (int )}  
\item {\ttfamily int = obj.\-Get\-Write\-Out\-Global\-Element\-Id\-Array ()}  
\item {\ttfamily obj.\-Write\-Out\-Global\-Element\-Id\-Array\-On ()}  
\item {\ttfamily obj.\-Write\-Out\-Global\-Element\-Id\-Array\-Off ()}  
\item {\ttfamily obj.\-Set\-Write\-All\-Time\-Steps (int )}  
\item {\ttfamily int = obj.\-Get\-Write\-All\-Time\-Steps ()}  
\item {\ttfamily obj.\-Write\-All\-Time\-Steps\-On ()}  
\item {\ttfamily obj.\-Write\-All\-Time\-Steps\-Off ()}  
\item {\ttfamily obj.\-Set\-Block\-Id\-Array\-Name (string )}  
\item {\ttfamily string = obj.\-Get\-Block\-Id\-Array\-Name ()}  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkextractcthpart}{}\section{vtk\-Extract\-C\-T\-H\-Part}\label{vtkparallel_vtkextractcthpart}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Extract\-C\-T\-H\-Part is a filter that is specialized for creating visualization of a C\-T\-H simulation. First it converts the cell data to point data. It contours the selected volume fraction at a value of 0.\-5. The user has the option of clipping the part with a plane. Clipped surfaces of the part are generated.

To create an instance of class vtk\-Extract\-C\-T\-H\-Part, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkExtractCTHPart
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Extract\-C\-T\-H\-Part has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Extract\-C\-T\-H\-Part class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Extract\-C\-T\-H\-Part = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Extract\-C\-T\-H\-Part = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Remove\-Double\-Volume\-Array\-Names ()} -\/ Names of cell volume fraction arrays to extract.  
\item {\ttfamily obj.\-Remove\-Float\-Volume\-Array\-Names ()} -\/ Names of cell volume fraction arrays to extract.  
\item {\ttfamily obj.\-Remove\-Unsigned\-Char\-Volume\-Array\-Names ()} -\/ Names of cell volume fraction arrays to extract.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Volume\-Array\-Names ()} -\/ Names of cell volume fraction arrays to extract.  
\item {\ttfamily string = obj.\-Get\-Volume\-Array\-Name (int idx)} -\/ Names of cell volume fraction arrays to extract.  
\item {\ttfamily obj.\-Remove\-All\-Volume\-Array\-Names ()} -\/ Names of cell volume fraction arrays to extract. for backwards compatibility  
\item {\ttfamily obj.\-Add\-Double\-Volume\-Array\-Name (string array\-Name)}  
\item {\ttfamily obj.\-Add\-Float\-Volume\-Array\-Name (string array\-Name)}  
\item {\ttfamily obj.\-Add\-Unsigned\-Char\-Volume\-Array\-Name (string array\-Name)}  
\item {\ttfamily obj.\-Add\-Volume\-Array\-Name (string array\-Name)}  
\item {\ttfamily obj.\-Set\-Clip\-Plane (vtk\-Plane clip\-Plane)} -\/ Set, get or maninpulate the implicit clipping plane.  
\item {\ttfamily vtk\-Plane = obj.\-Get\-Clip\-Plane ()} -\/ Set, get or maninpulate the implicit clipping plane.  
\item {\ttfamily long = obj.\-Get\-M\-Time ()} -\/ Look at clip plane to compute M\-Time.  
\item {\ttfamily obj.\-Set\-Controller (vtk\-Multi\-Process\-Controller controller)} -\/ Set the controller used to coordinate parallel processing.  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Get\-Controller ()} -\/ Return the controller used to coordinate parallel processing. By default, it is the global controller.  
\item {\ttfamily obj.\-Set\-Volume\-Fraction\-Surface\-Value (double )} -\/ Set and get the volume fraction surface value. This value should be between 0 and 1  
\item {\ttfamily double = obj.\-Get\-Volume\-Fraction\-Surface\-Value\-Min\-Value ()} -\/ Set and get the volume fraction surface value. This value should be between 0 and 1  
\item {\ttfamily double = obj.\-Get\-Volume\-Fraction\-Surface\-Value\-Max\-Value ()} -\/ Set and get the volume fraction surface value. This value should be between 0 and 1  
\item {\ttfamily double = obj.\-Get\-Volume\-Fraction\-Surface\-Value ()} -\/ Set and get the volume fraction surface value. This value should be between 0 and 1  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkextractpiece}{}\section{vtk\-Extract\-Piece}\label{vtkparallel_vtkextractpiece}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Extract\-Piece returns the appropriate piece of each sub-\/dataset in the vtk\-Composite\-Data\-Set. This filter can handle sub-\/datasets of type vtk\-Image\-Data, vtk\-Poly\-Data, vtk\-Rectilinear\-Grid, vtk\-Structured\-Grid, and vtk\-Unstructured\-Grid; it does not handle sub-\/grids of type vtk\-Composite\-Data\-Set.

To create an instance of class vtk\-Extract\-Piece, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkExtractPiece
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Extract\-Piece has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Extract\-Piece class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Extract\-Piece = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Extract\-Piece = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkextractuserdefinedpiece}{}\section{vtk\-Extract\-User\-Defined\-Piece}\label{vtkparallel_vtkextractuserdefinedpiece}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Provided a function that determines which cells are zero-\/level cells (\char`\"{}the piece\char`\"{}), this class outputs the piece with the requested number of ghost levels. The only difference between this class and the class it is derived from is that the zero-\/level cells are specified by a function you provide, instead of determined by dividing up the cells based on cell Id.

To create an instance of class vtk\-Extract\-User\-Defined\-Piece, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkExtractUserDefinedPiece
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Extract\-User\-Defined\-Piece has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Extract\-User\-Defined\-Piece class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Extract\-User\-Defined\-Piece = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Extract\-User\-Defined\-Piece = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkimagerendermanager}{}\section{vtk\-Image\-Render\-Manager}\label{vtkparallel_vtkimagerendermanager}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Image\-Render\-Manager is a subclass of vtk\-Parallel\-Render\-Manager that uses R\-G\-B\-A compositing (blending) to do parallel rendering. This is the exact opposite of vtk\-Composite\-Render\-Manager. It actually does nothing special. It relies on the rendering pipeline to be initialized with a vtk\-Composite\-R\-G\-B\-A\-Pass. Compositing makes sense only for renderers in layer 0.

To create an instance of class vtk\-Image\-Render\-Manager, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkImageRenderManager
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Image\-Render\-Manager has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Image\-Render\-Manager class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Image\-Render\-Manager = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Image\-Render\-Manager = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkmemorylimitimagedatastreamer}{}\section{vtk\-Memory\-Limit\-Image\-Data\-Streamer}\label{vtkparallel_vtkmemorylimitimagedatastreamer}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
To satisfy a request, this filter calls update on its input many times with smaller update extents. All processing up stream streams smaller pieces.

To create an instance of class vtk\-Memory\-Limit\-Image\-Data\-Streamer, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkMemoryLimitImageDataStreamer
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Memory\-Limit\-Image\-Data\-Streamer has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Memory\-Limit\-Image\-Data\-Streamer class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Memory\-Limit\-Image\-Data\-Streamer = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Memory\-Limit\-Image\-Data\-Streamer = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Memory\-Limit (long )} -\/ Set / Get the memory limit in kilobytes.  
\item {\ttfamily long = obj.\-Get\-Memory\-Limit ()} -\/ Set / Get the memory limit in kilobytes.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkmpiimagereader}{}\section{vtk\-M\-P\-I\-Image\-Reader}\label{vtkparallel_vtkmpiimagereader}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-M\-P\-I\-Image\-Reader provides the mechanism to read a brick of bytes (or shorts, or ints, or floats, or doubles, ...) from a file or series of files. You can use it to read raw image data from files. You may also be able to subclass this to read simple file formats.

What distinguishes this class from vtk\-Image\-Reader and vtk\-Image\-Reader2 is that it performs synchronized parallel I/\-O using the M\-P\-I\-I\-O layer. This can make a huge difference in file read times, especially when reading in parallel from a parallel file system.

Dispite the name of this class, vtk\-M\-P\-I\-Image\-Reader will work even if M\-P\-I is not available. If M\-P\-I is not available or M\-P\-I\-I\-O is not available or the given Controller is not a vtk\-M\-P\-I\-Controller (or N\-U\-L\-L), then this class will silently work exactly like its superclass. The point is that you can safely use this class in applications that may or may not be compiled with M\-P\-I (or may or may not actually be run with M\-P\-I).

To create an instance of class vtk\-M\-P\-I\-Image\-Reader, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkMPIImageReader
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-M\-P\-I\-Image\-Reader has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-M\-P\-I\-Image\-Reader class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-M\-P\-I\-Image\-Reader = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-M\-P\-I\-Image\-Reader = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Get\-Controller ()} -\/ Get/set the multi process controller to use for coordinated reads. By default, set to the global controller.  
\item {\ttfamily obj.\-Set\-Controller (vtk\-Multi\-Process\-Controller )} -\/ Get/set the multi process controller to use for coordinated reads. By default, set to the global controller.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkmultiprocesscontroller}{}\section{vtk\-Multi\-Process\-Controller}\label{vtkparallel_vtkmultiprocesscontroller}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Multi\-Process\-Controller is used to control multiple processes in a distributed computing environment. It has methods for executing single/multiple method(s) on multiple processors, triggering registered callbacks (Remote Methods) (Add\-R\-M\-I(), Trigger\-R\-M\-I()) and communication. Please note that the communication is done using the communicator which is accessible to the user. Therefore it is possible to get the communicator with Get\-Communicator() and use it to send and receive data. This is the encouraged communication method. The internal (R\-M\-I) communications are done using a second internal communicator (called R\-M\-I\-Communicator).

To create an instance of class vtk\-Multi\-Process\-Controller, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkMultiProcessController
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Multi\-Process\-Controller has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Multi\-Process\-Controller class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Finalize ()} -\/ This method is for cleaning up. If a subclass needs to clean up process communication (i.\-e. M\-P\-I) it would over ride this method.  
\item {\ttfamily obj.\-Finalize (int finalized\-Externally)} -\/ This method is for cleaning up. If a subclass needs to clean up process communication (i.\-e. M\-P\-I) it would over ride this method. Provided for finalization outside vtk.  
\item {\ttfamily obj.\-Set\-Number\-Of\-Processes (int num)} -\/ Set the number of processes you will be using. This defaults to the maximum number available. If you set this to a value higher than the default, you will get an error.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Processes ()} -\/ Set the number of processes you will be using. This defaults to the maximum number available. If you set this to a value higher than the default, you will get an error.  
\item {\ttfamily obj.\-Single\-Method\-Execute ()} -\/ Execute the Single\-Method (as define by Set\-Single\-Method) using this-\/$>$Number\-Of\-Processes processes. This will only return when all the processes finish executing their methods.  
\item {\ttfamily obj.\-Multiple\-Method\-Execute ()} -\/ Execute the Multiple\-Methods (as define by calling Set\-Multiple\-Method for each of the required this-\/$>$Number\-Of\-Processes methods) using this-\/$>$Number\-Of\-Processes processes.  
\item {\ttfamily int = obj.\-Get\-Local\-Process\-Id ()} -\/ Tells you which process \mbox{[}0, Num\-Process) you are in.  
\item {\ttfamily obj.\-Create\-Output\-Window ()} -\/ This method can be used to tell the controller to create a special output window in which all messages are preceded by the process id.  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Create\-Sub\-Controller (vtk\-Process\-Group group)} -\/ Creates a new controller with the processes specified by the given group. The new controller will already be initialized for you. You are responsible for deleting the controller once you are done. It is invalid to pass this method a group with a different communicator than is used by this controller. This operation is collective accross all processes defined in the group. It is undefined what will happen if the group is not the same on all processes. This method must be called by all processes in the controller regardless of whether they are in the group. N\-U\-L\-L is returned on all process not in the group.  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Partition\-Controller (int local\-Color, int local\-Key)} -\/ Partitions this controller based on a coloring. That is, each process passes in a color. All processes with the same color are grouped into the same partition. The processes are ordered by their self-\/assigned key. Lower keys have lower process ids. Ties are broken by the current process ids. (For example, if all the keys are 0, then the resulting processes will be ordered in the same way.) This method returns a new controller to each process that represents the local partition. This is basically the same operation as M\-P\-I\-\_\-\-Comm\-\_\-split.  
\item {\ttfamily obj.\-Trigger\-Break\-R\-M\-Is ()} -\/ A conveniance method. Called on process 0 to break \char`\"{}\-Process\-R\-M\-Is\char`\"{} loop on all other processes.  
\item {\ttfamily obj.\-Trigger\-R\-M\-I (int remote\-Process\-Id, string arg, int tag)} -\/ Convenience method when there is no argument.  
\item {\ttfamily obj.\-Trigger\-R\-M\-I (int remote\-Process\-Id, int tag)} -\/ This is a convenicence method to trigger an R\-M\-I call on all the \char`\"{}children\char`\"{} of the current node. The children of the current node can be determined by drawing a binary tree starting at node 0 and then assigned nodes ids incrementally in a breadth-\/first fashion from left to right. This is designed to be used when trigger an R\-M\-I call on all satellites from the root node.  
\item {\ttfamily obj.\-Trigger\-R\-M\-I\-On\-All\-Children (string arg, int tag)} -\/ This is a convenicence method to trigger an R\-M\-I call on all the \char`\"{}children\char`\"{} of the current node. The children of the current node can be determined by drawing a binary tree starting at node 0 and then assigned nodes ids incrementally in a breadth-\/first fashion from left to right. This is designed to be used when trigger an R\-M\-I call on all satellites from the root node.  
\item {\ttfamily obj.\-Trigger\-R\-M\-I\-On\-All\-Children (int tag)} -\/ Calling this method gives control to the controller to start processing R\-M\-Is. Possible return values are\-: R\-M\-I\-\_\-\-N\-O\-\_\-\-E\-R\-R\-O\-R, R\-M\-I\-\_\-\-T\-A\-G\-\_\-\-E\-R\-R\-O\-R \-: rmi tag could not be received, R\-M\-I\-\_\-\-A\-R\-G\-\_\-\-E\-R\-R\-O\-R \-: rmi arg could not be received. If report\-Errors is false, no vtk\-Error\-Macro is called. Process\-R\-M\-Is() calls Process\-R\-M\-Is(int) with report\-Errors = 0. If dont\-\_\-loop is 1, this call just process one R\-M\-I message and exits.  
\item {\ttfamily int = obj.\-Process\-R\-M\-Is (int report\-Errors, int dont\-\_\-loop)} -\/ Calling this method gives control to the controller to start processing R\-M\-Is. Possible return values are\-: R\-M\-I\-\_\-\-N\-O\-\_\-\-E\-R\-R\-O\-R, R\-M\-I\-\_\-\-T\-A\-G\-\_\-\-E\-R\-R\-O\-R \-: rmi tag could not be received, R\-M\-I\-\_\-\-A\-R\-G\-\_\-\-E\-R\-R\-O\-R \-: rmi arg could not be received. If report\-Errors is false, no vtk\-Error\-Macro is called. Process\-R\-M\-Is() calls Process\-R\-M\-Is(int) with report\-Errors = 0. If dont\-\_\-loop is 1, this call just process one R\-M\-I message and exits.  
\item {\ttfamily int = obj.\-Process\-R\-M\-Is ()} -\/ Calling this method gives control to the controller to start processing R\-M\-Is. Possible return values are\-: R\-M\-I\-\_\-\-N\-O\-\_\-\-E\-R\-R\-O\-R, R\-M\-I\-\_\-\-T\-A\-G\-\_\-\-E\-R\-R\-O\-R \-: rmi tag could not be received, R\-M\-I\-\_\-\-A\-R\-G\-\_\-\-E\-R\-R\-O\-R \-: rmi arg could not be received. If report\-Errors is false, no vtk\-Error\-Macro is called. Process\-R\-M\-Is() calls Process\-R\-M\-Is(int) with report\-Errors = 0. If dont\-\_\-loop is 1, this call just process one R\-M\-I message and exits.  
\item {\ttfamily obj.\-Set\-Break\-Flag (int )} -\/ Setting this flag to 1 will cause the Process\-R\-M\-Is loop to return. This also causes vtk\-Up\-Stream\-Ports to return from their Wait\-For\-Update loops.  
\item {\ttfamily int = obj.\-Get\-Break\-Flag ()} -\/ Setting this flag to 1 will cause the Process\-R\-M\-Is loop to return. This also causes vtk\-Up\-Stream\-Ports to return from their Wait\-For\-Update loops.  
\item {\ttfamily vtk\-Communicator = obj.\-Get\-Communicator ()} -\/ Returns the communicator associated with this controller. A default communicator is created in constructor.  
\item {\ttfamily obj.\-Barrier ()} -\/ This method can be used to synchronize processes.  
\item {\ttfamily int = obj.\-Send (int data, vtk\-Id\-Type length, int remote\-Process\-Id, int tag)} -\/ This method sends data to another process. Tag eliminates ambiguity when multiple sends or receives exist in the same process. It is recommended to use custom tag number over 100. vtk\-Multi\-Process\-Controller has reserved tags between 1 and 4. vtk\-Communicator has reserved tags between 10 and 16.  
\item {\ttfamily int = obj.\-Send (int data, vtk\-Id\-Type length, int remote\-Process\-Id, int tag)} -\/ This method sends data to another process. Tag eliminates ambiguity when multiple sends or receives exist in the same process. It is recommended to use custom tag number over 100. vtk\-Multi\-Process\-Controller has reserved tags between 1 and 4. vtk\-Communicator has reserved tags between 10 and 16.  
\item {\ttfamily int = obj.\-Send (long data, vtk\-Id\-Type length, int remote\-Process\-Id, int tag)} -\/ This method sends data to another process. Tag eliminates ambiguity when multiple sends or receives exist in the same process. It is recommended to use custom tag number over 100. vtk\-Multi\-Process\-Controller has reserved tags between 1 and 4. vtk\-Communicator has reserved tags between 10 and 16.  
\item {\ttfamily int = obj.\-Send (string data, vtk\-Id\-Type length, int remote\-Process\-Id, int tag)} -\/ This method sends data to another process. Tag eliminates ambiguity when multiple sends or receives exist in the same process. It is recommended to use custom tag number over 100. vtk\-Multi\-Process\-Controller has reserved tags between 1 and 4. vtk\-Communicator has reserved tags between 10 and 16.  
\item {\ttfamily int = obj.\-Send (string data, vtk\-Id\-Type length, int remote\-Process\-Id, int tag)} -\/ This method sends data to another process. Tag eliminates ambiguity when multiple sends or receives exist in the same process. It is recommended to use custom tag number over 100. vtk\-Multi\-Process\-Controller has reserved tags between 1 and 4. vtk\-Communicator has reserved tags between 10 and 16.  
\item {\ttfamily int = obj.\-Send (float data, vtk\-Id\-Type length, int remote\-Process\-Id, int tag)} -\/ This method sends data to another process. Tag eliminates ambiguity when multiple sends or receives exist in the same process. It is recommended to use custom tag number over 100. vtk\-Multi\-Process\-Controller has reserved tags between 1 and 4. vtk\-Communicator has reserved tags between 10 and 16.  
\item {\ttfamily int = obj.\-Send (double data, vtk\-Id\-Type length, int remote\-Process\-Id, int tag)} -\/ This method sends data to another process. Tag eliminates ambiguity when multiple sends or receives exist in the same process. It is recommended to use custom tag number over 100. vtk\-Multi\-Process\-Controller has reserved tags between 1 and 4. vtk\-Communicator has reserved tags between 10 and 16.  
\item {\ttfamily int = obj.\-Send (vtk\-Data\-Object data, int remote\-Id, int tag)} -\/ This method sends data to another process. Tag eliminates ambiguity when multiple sends or receives exist in the same process. It is recommended to use custom tag number over 100. vtk\-Multi\-Process\-Controller has reserved tags between 1 and 4. vtk\-Communicator has reserved tags between 10 and 16.  
\item {\ttfamily int = obj.\-Send (vtk\-Data\-Array data, int remote\-Id, int tag)} -\/ This method sends data to another process. Tag eliminates ambiguity when multiple sends or receives exist in the same process. It is recommended to use custom tag number over 100. vtk\-Multi\-Process\-Controller has reserved tags between 1 and 4. vtk\-Communicator has reserved tags between 10 and 16.  
\item {\ttfamily int = obj.\-Receive (int data, vtk\-Id\-Type maxlength, int remote\-Process\-Id, int tag)} -\/ This method receives data from a corresponding send. It blocks until the receive is finished. It calls methods in \char`\"{}data\char`\"{} to communicate the sending data. In the overrloads that take in a {\ttfamily maxlength} argument, this length is the maximum length of the message to receive. If the maxlength is less than the length of the message sent by the sender, an error will be flagged. Once a message is received, use the Get\-Count() method to determine the actual size of the data received.  
\item {\ttfamily int = obj.\-Receive (int data, vtk\-Id\-Type maxlength, int remote\-Process\-Id, int tag)} -\/ This method receives data from a corresponding send. It blocks until the receive is finished. It calls methods in \char`\"{}data\char`\"{} to communicate the sending data. In the overrloads that take in a {\ttfamily maxlength} argument, this length is the maximum length of the message to receive. If the maxlength is less than the length of the message sent by the sender, an error will be flagged. Once a message is received, use the Get\-Count() method to determine the actual size of the data received.  
\item {\ttfamily int = obj.\-Receive (long data, vtk\-Id\-Type maxlength, int remote\-Process\-Id, int tag)} -\/ This method receives data from a corresponding send. It blocks until the receive is finished. It calls methods in \char`\"{}data\char`\"{} to communicate the sending data. In the overrloads that take in a {\ttfamily maxlength} argument, this length is the maximum length of the message to receive. If the maxlength is less than the length of the message sent by the sender, an error will be flagged. Once a message is received, use the Get\-Count() method to determine the actual size of the data received.  
\item {\ttfamily int = obj.\-Receive (string data, vtk\-Id\-Type maxlength, int remote\-Process\-Id, int tag)} -\/ This method receives data from a corresponding send. It blocks until the receive is finished. It calls methods in \char`\"{}data\char`\"{} to communicate the sending data. In the overrloads that take in a {\ttfamily maxlength} argument, this length is the maximum length of the message to receive. If the maxlength is less than the length of the message sent by the sender, an error will be flagged. Once a message is received, use the Get\-Count() method to determine the actual size of the data received.  
\item {\ttfamily int = obj.\-Receive (string data, vtk\-Id\-Type maxlength, int remote\-Process\-Id, int tag)} -\/ This method receives data from a corresponding send. It blocks until the receive is finished. It calls methods in \char`\"{}data\char`\"{} to communicate the sending data. In the overrloads that take in a {\ttfamily maxlength} argument, this length is the maximum length of the message to receive. If the maxlength is less than the length of the message sent by the sender, an error will be flagged. Once a message is received, use the Get\-Count() method to determine the actual size of the data received.  
\item {\ttfamily int = obj.\-Receive (float data, vtk\-Id\-Type maxlength, int remote\-Process\-Id, int tag)} -\/ This method receives data from a corresponding send. It blocks until the receive is finished. It calls methods in \char`\"{}data\char`\"{} to communicate the sending data. In the overrloads that take in a {\ttfamily maxlength} argument, this length is the maximum length of the message to receive. If the maxlength is less than the length of the message sent by the sender, an error will be flagged. Once a message is received, use the Get\-Count() method to determine the actual size of the data received.  
\item {\ttfamily int = obj.\-Receive (double data, vtk\-Id\-Type maxlength, int remote\-Process\-Id, int tag)} -\/ This method receives data from a corresponding send. It blocks until the receive is finished. It calls methods in \char`\"{}data\char`\"{} to communicate the sending data. In the overrloads that take in a {\ttfamily maxlength} argument, this length is the maximum length of the message to receive. If the maxlength is less than the length of the message sent by the sender, an error will be flagged. Once a message is received, use the Get\-Count() method to determine the actual size of the data received.  
\item {\ttfamily int = obj.\-Receive (vtk\-Data\-Object data, int remote\-Id, int tag)} -\/ This method receives data from a corresponding send. It blocks until the receive is finished. It calls methods in \char`\"{}data\char`\"{} to communicate the sending data. In the overrloads that take in a {\ttfamily maxlength} argument, this length is the maximum length of the message to receive. If the maxlength is less than the length of the message sent by the sender, an error will be flagged. Once a message is received, use the Get\-Count() method to determine the actual size of the data received.  
\item {\ttfamily int = obj.\-Receive (vtk\-Data\-Array data, int remote\-Id, int tag)} -\/ This method receives data from a corresponding send. It blocks until the receive is finished. It calls methods in \char`\"{}data\char`\"{} to communicate the sending data. In the overrloads that take in a {\ttfamily maxlength} argument, this length is the maximum length of the message to receive. If the maxlength is less than the length of the message sent by the sender, an error will be flagged. Once a message is received, use the Get\-Count() method to determine the actual size of the data received.  
\item {\ttfamily vtk\-Data\-Object = obj.\-Receive\-Data\-Object (int remote\-Id, int tag)} -\/ This method receives data from a corresponding send. It blocks until the receive is finished. It calls methods in \char`\"{}data\char`\"{} to communicate the sending data. In the overrloads that take in a {\ttfamily maxlength} argument, this length is the maximum length of the message to receive. If the maxlength is less than the length of the message sent by the sender, an error will be flagged. Once a message is received, use the Get\-Count() method to determine the actual size of the data received.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Count ()} -\/ Returns the number of words received by the most recent Receive(). Note that this is not the number of bytes received, but the number of items of the data-\/type received by the most recent Receive() eg. if Receive(int$\ast$,..) was used, then this returns the number of ints received; if Receive(double$\ast$,..) was used, then this returns the number of doubles received etc. The return value is valid only after a successful Receive().  
\item {\ttfamily int = obj.\-Broadcast (int data, vtk\-Id\-Type length, int src\-Process\-Id)} -\/ Broadcast sends the array in the process with id {\ttfamily src\-Process\-Id} to all of the other processes. All processes must call these method with the same arguments in order for it to complete.  
\item {\ttfamily int = obj.\-Broadcast (long data, vtk\-Id\-Type length, int src\-Process\-Id)} -\/ Broadcast sends the array in the process with id {\ttfamily src\-Process\-Id} to all of the other processes. All processes must call these method with the same arguments in order for it to complete.  
\item {\ttfamily int = obj.\-Broadcast (string data, vtk\-Id\-Type length, int src\-Process\-Id)} -\/ Broadcast sends the array in the process with id {\ttfamily src\-Process\-Id} to all of the other processes. All processes must call these method with the same arguments in order for it to complete.  
\item {\ttfamily int = obj.\-Broadcast (string data, vtk\-Id\-Type length, int src\-Process\-Id)} -\/ Broadcast sends the array in the process with id {\ttfamily src\-Process\-Id} to all of the other processes. All processes must call these method with the same arguments in order for it to complete.  
\item {\ttfamily int = obj.\-Broadcast (float data, vtk\-Id\-Type length, int src\-Process\-Id)} -\/ Broadcast sends the array in the process with id {\ttfamily src\-Process\-Id} to all of the other processes. All processes must call these method with the same arguments in order for it to complete.  
\item {\ttfamily int = obj.\-Broadcast (double data, vtk\-Id\-Type length, int src\-Process\-Id)} -\/ Broadcast sends the array in the process with id {\ttfamily src\-Process\-Id} to all of the other processes. All processes must call these method with the same arguments in order for it to complete.  
\item {\ttfamily int = obj.\-Broadcast (vtk\-Data\-Object data, int src\-Process\-Id)} -\/ Broadcast sends the array in the process with id {\ttfamily src\-Process\-Id} to all of the other processes. All processes must call these method with the same arguments in order for it to complete.  
\item {\ttfamily int = obj.\-Broadcast (vtk\-Data\-Array data, int src\-Process\-Id)} -\/ Gather collects arrays in the process with id {\ttfamily dest\-Process\-Id}. Each process (including the destination) sends the contents of its send buffer to the destination process. The destination process receives the messages and stores them in rank order. The {\ttfamily length} argument (which must be the same on all processes) is the length of the send\-Buffers. The {\ttfamily recv\-Buffer} (on te destination process) must be of length length$\ast$num\-Processes. Gather is the inverse operation of Scatter.  
\item {\ttfamily int = obj.\-Gather (int send\-Buffer, int recv\-Buffer, vtk\-Id\-Type length, int dest\-Process\-Id)} -\/ Gather collects arrays in the process with id {\ttfamily dest\-Process\-Id}. Each process (including the destination) sends the contents of its send buffer to the destination process. The destination process receives the messages and stores them in rank order. The {\ttfamily length} argument (which must be the same on all processes) is the length of the send\-Buffers. The {\ttfamily recv\-Buffer} (on te destination process) must be of length length$\ast$num\-Processes. Gather is the inverse operation of Scatter.  
\item {\ttfamily int = obj.\-Gather (long send\-Buffer, long recv\-Buffer, vtk\-Id\-Type length, int dest\-Process\-Id)} -\/ Gather collects arrays in the process with id {\ttfamily dest\-Process\-Id}. Each process (including the destination) sends the contents of its send buffer to the destination process. The destination process receives the messages and stores them in rank order. The {\ttfamily length} argument (which must be the same on all processes) is the length of the send\-Buffers. The {\ttfamily recv\-Buffer} (on te destination process) must be of length length$\ast$num\-Processes. Gather is the inverse operation of Scatter.  
\item {\ttfamily int = obj.\-Gather (string send\-Buffer, string recv\-Buffer, vtk\-Id\-Type length, int dest\-Process\-Id)} -\/ Gather collects arrays in the process with id {\ttfamily dest\-Process\-Id}. Each process (including the destination) sends the contents of its send buffer to the destination process. The destination process receives the messages and stores them in rank order. The {\ttfamily length} argument (which must be the same on all processes) is the length of the send\-Buffers. The {\ttfamily recv\-Buffer} (on te destination process) must be of length length$\ast$num\-Processes. Gather is the inverse operation of Scatter.  
\item {\ttfamily int = obj.\-Gather (string send\-Buffer, string recv\-Buffer, vtk\-Id\-Type length, int dest\-Process\-Id)} -\/ Gather collects arrays in the process with id {\ttfamily dest\-Process\-Id}. Each process (including the destination) sends the contents of its send buffer to the destination process. The destination process receives the messages and stores them in rank order. The {\ttfamily length} argument (which must be the same on all processes) is the length of the send\-Buffers. The {\ttfamily recv\-Buffer} (on te destination process) must be of length length$\ast$num\-Processes. Gather is the inverse operation of Scatter.  
\item {\ttfamily int = obj.\-Gather (float send\-Buffer, float recv\-Buffer, vtk\-Id\-Type length, int dest\-Process\-Id)} -\/ Gather collects arrays in the process with id {\ttfamily dest\-Process\-Id}. Each process (including the destination) sends the contents of its send buffer to the destination process. The destination process receives the messages and stores them in rank order. The {\ttfamily length} argument (which must be the same on all processes) is the length of the send\-Buffers. The {\ttfamily recv\-Buffer} (on te destination process) must be of length length$\ast$num\-Processes. Gather is the inverse operation of Scatter.  
\item {\ttfamily int = obj.\-Gather (double send\-Buffer, double recv\-Buffer, vtk\-Id\-Type length, int dest\-Process\-Id)} -\/ Gather collects arrays in the process with id {\ttfamily dest\-Process\-Id}. Each process (including the destination) sends the contents of its send buffer to the destination process. The destination process receives the messages and stores them in rank order. The {\ttfamily length} argument (which must be the same on all processes) is the length of the send\-Buffers. The {\ttfamily recv\-Buffer} (on te destination process) must be of length length$\ast$num\-Processes. Gather is the inverse operation of Scatter.  
\item {\ttfamily int = obj.\-Gather (vtk\-Data\-Array send\-Buffer, vtk\-Data\-Array recv\-Buffer, int dest\-Process\-Id)} -\/ Gather\-V is the vector variant of Gather. It extends the functionality of Gather by allowing a varying count of data from each process. Gather\-V collects arrays in the process with id {\ttfamily dest\-Process\-Id}. Each process (including the destination) sends the contents of its send buffer to the destination process. The destination process receives the messages and stores them in rank order. The {\ttfamily send\-Length} argument defines how much the local process sends to {\ttfamily dest\-Process\-Id} and {\ttfamily recv\-Lengths} is an array containing the amount {\ttfamily dest\-Process\-Id} receives from each process, in rank order.  
\item {\ttfamily int = obj.\-Scatter (int send\-Buffer, int recv\-Buffer, vtk\-Id\-Type length, int src\-Process\-Id)} -\/ Scatter takes an array in the process with id {\ttfamily src\-Process\-Id} and distributes it. Each process (including the source) receives a portion of the send buffer. Process 0 receives the first {\ttfamily length} values, process 1 receives the second {\ttfamily length} values, and so on. Scatter is the inverse operation of Gather.  
\item {\ttfamily int = obj.\-Scatter (long send\-Buffer, long recv\-Buffer, vtk\-Id\-Type length, int src\-Process\-Id)} -\/ Scatter takes an array in the process with id {\ttfamily src\-Process\-Id} and distributes it. Each process (including the source) receives a portion of the send buffer. Process 0 receives the first {\ttfamily length} values, process 1 receives the second {\ttfamily length} values, and so on. Scatter is the inverse operation of Gather.  
\item {\ttfamily int = obj.\-Scatter (string send\-Buffer, string recv\-Buffer, vtk\-Id\-Type length, int src\-Process\-Id)} -\/ Scatter takes an array in the process with id {\ttfamily src\-Process\-Id} and distributes it. Each process (including the source) receives a portion of the send buffer. Process 0 receives the first {\ttfamily length} values, process 1 receives the second {\ttfamily length} values, and so on. Scatter is the inverse operation of Gather.  
\item {\ttfamily int = obj.\-Scatter (string send\-Buffer, string recv\-Buffer, vtk\-Id\-Type length, int src\-Process\-Id)} -\/ Scatter takes an array in the process with id {\ttfamily src\-Process\-Id} and distributes it. Each process (including the source) receives a portion of the send buffer. Process 0 receives the first {\ttfamily length} values, process 1 receives the second {\ttfamily length} values, and so on. Scatter is the inverse operation of Gather.  
\item {\ttfamily int = obj.\-Scatter (float send\-Buffer, float recv\-Buffer, vtk\-Id\-Type length, int src\-Process\-Id)} -\/ Scatter takes an array in the process with id {\ttfamily src\-Process\-Id} and distributes it. Each process (including the source) receives a portion of the send buffer. Process 0 receives the first {\ttfamily length} values, process 1 receives the second {\ttfamily length} values, and so on. Scatter is the inverse operation of Gather.  
\item {\ttfamily int = obj.\-Scatter (double send\-Buffer, double recv\-Buffer, vtk\-Id\-Type length, int src\-Process\-Id)} -\/ Scatter takes an array in the process with id {\ttfamily src\-Process\-Id} and distributes it. Each process (including the source) receives a portion of the send buffer. Process 0 receives the first {\ttfamily length} values, process 1 receives the second {\ttfamily length} values, and so on. Scatter is the inverse operation of Gather.  
\item {\ttfamily int = obj.\-Scatter (vtk\-Data\-Array send\-Buffer, vtk\-Data\-Array recv\-Buffer, int src\-Process\-Id)} -\/ Scatter\-V is the vector variant of Scatter. It extends the functionality of Scatter by allowing a varying count of data to each process. Scatter\-V takes an array in the process with id {\ttfamily src\-Process\-Id} and distributes it. Each process (including the source) receives a portion of the send buffer defined by the {\ttfamily send\-Lengths} and {\ttfamily offsets} arrays.  
\item {\ttfamily int = obj.\-All\-Gather (int send\-Buffer, int recv\-Buffer, vtk\-Id\-Type length)} -\/ Same as gather except that the result ends up on all processes.  
\item {\ttfamily int = obj.\-All\-Gather (long send\-Buffer, long recv\-Buffer, vtk\-Id\-Type length)} -\/ Same as gather except that the result ends up on all processes.  
\item {\ttfamily int = obj.\-All\-Gather (string send\-Buffer, string recv\-Buffer, vtk\-Id\-Type length)} -\/ Same as gather except that the result ends up on all processes.  
\item {\ttfamily int = obj.\-All\-Gather (string send\-Buffer, string recv\-Buffer, vtk\-Id\-Type length)} -\/ Same as gather except that the result ends up on all processes.  
\item {\ttfamily int = obj.\-All\-Gather (float send\-Buffer, float recv\-Buffer, vtk\-Id\-Type length)} -\/ Same as gather except that the result ends up on all processes.  
\item {\ttfamily int = obj.\-All\-Gather (double send\-Buffer, double recv\-Buffer, vtk\-Id\-Type length)} -\/ Same as gather except that the result ends up on all processes.  
\item {\ttfamily int = obj.\-All\-Gather (vtk\-Data\-Array send\-Buffer, vtk\-Data\-Array recv\-Buffer)} -\/ Same as Gather\-V except that the result is placed in all processes.  
\item {\ttfamily int = obj.\-Reduce (int send\-Buffer, int recv\-Buffer, vtk\-Id\-Type length, int operation, int dest\-Process\-Id)} -\/ Reduce an array to the given destination process. This version of Reduce takes an identifier defined in the vtk\-Communicator\-::\-Standard\-Operations enum to define the operation.  
\item {\ttfamily int = obj.\-Reduce (long send\-Buffer, long recv\-Buffer, vtk\-Id\-Type length, int operation, int dest\-Process\-Id)} -\/ Reduce an array to the given destination process. This version of Reduce takes an identifier defined in the vtk\-Communicator\-::\-Standard\-Operations enum to define the operation.  
\item {\ttfamily int = obj.\-Reduce (string send\-Buffer, string recv\-Buffer, vtk\-Id\-Type length, int operation, int dest\-Process\-Id)} -\/ Reduce an array to the given destination process. This version of Reduce takes an identifier defined in the vtk\-Communicator\-::\-Standard\-Operations enum to define the operation.  
\item {\ttfamily int = obj.\-Reduce (string send\-Buffer, string recv\-Buffer, vtk\-Id\-Type length, int operation, int dest\-Process\-Id)} -\/ Reduce an array to the given destination process. This version of Reduce takes an identifier defined in the vtk\-Communicator\-::\-Standard\-Operations enum to define the operation.  
\item {\ttfamily int = obj.\-Reduce (float send\-Buffer, float recv\-Buffer, vtk\-Id\-Type length, int operation, int dest\-Process\-Id)} -\/ Reduce an array to the given destination process. This version of Reduce takes an identifier defined in the vtk\-Communicator\-::\-Standard\-Operations enum to define the operation.  
\item {\ttfamily int = obj.\-Reduce (double send\-Buffer, double recv\-Buffer, vtk\-Id\-Type length, int operation, int dest\-Process\-Id)} -\/ Reduce an array to the given destination process. This version of Reduce takes an identifier defined in the vtk\-Communicator\-::\-Standard\-Operations enum to define the operation.  
\item {\ttfamily int = obj.\-Reduce (vtk\-Data\-Array send\-Buffer, vtk\-Data\-Array recv\-Buffer, int operation, int dest\-Process\-Id)} -\/ Same as Reduce except that the result is placed in all of the processes.  
\item {\ttfamily int = obj.\-All\-Reduce (int send\-Buffer, int recv\-Buffer, vtk\-Id\-Type length, int operation)} -\/ Same as Reduce except that the result is placed in all of the processes.  
\item {\ttfamily int = obj.\-All\-Reduce (long send\-Buffer, long recv\-Buffer, vtk\-Id\-Type length, int operation)} -\/ Same as Reduce except that the result is placed in all of the processes.  
\item {\ttfamily int = obj.\-All\-Reduce (string send\-Buffer, string recv\-Buffer, vtk\-Id\-Type length, int operation)} -\/ Same as Reduce except that the result is placed in all of the processes.  
\item {\ttfamily int = obj.\-All\-Reduce (string send\-Buffer, string recv\-Buffer, vtk\-Id\-Type length, int operation)} -\/ Same as Reduce except that the result is placed in all of the processes.  
\item {\ttfamily int = obj.\-All\-Reduce (float send\-Buffer, float recv\-Buffer, vtk\-Id\-Type length, int operation)} -\/ Same as Reduce except that the result is placed in all of the processes.  
\item {\ttfamily int = obj.\-All\-Reduce (double send\-Buffer, double recv\-Buffer, vtk\-Id\-Type length, int operation)} -\/ Same as Reduce except that the result is placed in all of the processes.  
\item {\ttfamily int = obj.\-All\-Reduce (vtk\-Data\-Array send\-Buffer, vtk\-Data\-Array recv\-Buffer, int operation)}  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkparallelfactory}{}\section{vtk\-Parallel\-Factory}\label{vtkparallel_vtkparallelfactory}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
To create an instance of class vtk\-Parallel\-Factory, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkParallelFactory
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Parallel\-Factory has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Parallel\-Factory class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Parallel\-Factory = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Parallel\-Factory = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily string = obj.\-Get\-V\-T\-K\-Source\-Version ()}  
\item {\ttfamily string = obj.\-Get\-Description ()}  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkparallelrendermanager}{}\section{vtk\-Parallel\-Render\-Manager}\label{vtkparallel_vtkparallelrendermanager}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Parallel\-Render\-Manager operates in multiple processes. It provides proper renderers and render windows for performing the parallel rendering correctly. It can also attach itself to render windows and propagate rendering events and camera views.

.S\-E\-C\-T\-I\-O\-N Note\-: Many parallel rendering schemes do not correctly handle transparency. Unless otherwise documented, assume a sub class does not.

.S\-E\-C\-T\-I\-O\-N To\-Do\-: Synchronization/barrier primitives.

Query ranges of scalar values of objects in addition to the boundry in three-\/space

To create an instance of class vtk\-Parallel\-Render\-Manager, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkParallelRenderManager
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Parallel\-Render\-Manager has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Parallel\-Render\-Manager class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Parallel\-Render\-Manager = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Parallel\-Render\-Manager = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Render\-Window = obj.\-Make\-Render\-Window ()} -\/ Builds a vtk\-Render\-Window compatible with this render manager. The user program is responsible for registering the render window with the Set\-Render\-Window method and calling Delete. It is not advisable to use a parallel render manager with a render window that was not built with this method.  
\item {\ttfamily vtk\-Renderer = obj.\-Make\-Renderer ()} -\/ Builds a vtk\-Renderer compatible with this render manager. (Should we also register it?) The user program is responsible for calling Delete. It is not advisable to use a parallel render manager with a renderer that was not built with this method.  
\item {\ttfamily vtk\-Render\-Window = obj.\-Get\-Render\-Window ()} -\/ Set/\-Get the Render\-Window to use for compositing. We add a start and end observer to the window.  
\item {\ttfamily obj.\-Set\-Render\-Window (vtk\-Render\-Window ren\-Win)} -\/ Set/\-Get the Render\-Window to use for compositing. We add a start and end observer to the window.  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Get\-Controller ()} -\/ Set/\-Get the vtk\-Multi\-Process\-Controller which will handle communications for the parallel rendering.  
\item {\ttfamily obj.\-Set\-Controller (vtk\-Multi\-Process\-Controller controller)} -\/ Set/\-Get the vtk\-Multi\-Process\-Controller which will handle communications for the parallel rendering.  
\item {\ttfamily obj.\-Initialize\-Pieces ()} -\/ This method sets the piece and number of pieces for each actor with a polydata mapper.  
\item {\ttfamily obj.\-Initialize\-Off\-Screen ()} -\/ Make all rendering windows not viewable set as off screen rendering. To make all renderwindows on screen rendering again, call Off\-Screen\-Rendering\-Off on all the render windows. This class assumes the window on root node is the only one viewable. Subclasses should change this as necessary.  
\item {\ttfamily obj.\-Start\-Interactor ()} -\/ Initializes the R\-M\-Is and then, if on root node, starts the interactor on the attached render window. Otherwise, starts processing R\-M\-Is. When the interactor returns, it breaks the R\-M\-I listening on all other processors.  
\item {\ttfamily obj.\-Start\-Services ()} -\/ If on node other than root, starts serving R\-M\-I requests for parallel renders.  
\item {\ttfamily obj.\-Stop\-Services ()} -\/ If on root node, stops the R\-M\-I processing on all service nodes.  
\item {\ttfamily obj.\-Start\-Render ()} -\/ Callbacks that initialize and finish rendering and other tasks.  
\item {\ttfamily obj.\-End\-Render ()} -\/ Callbacks that initialize and finish rendering and other tasks.  
\item {\ttfamily obj.\-Satellite\-Start\-Render ()} -\/ Callbacks that initialize and finish rendering and other tasks.  
\item {\ttfamily obj.\-Satellite\-End\-Render ()} -\/ Callbacks that initialize and finish rendering and other tasks.  
\item {\ttfamily obj.\-Render\-R\-M\-I ()} -\/ Callbacks that initialize and finish rendering and other tasks.  
\item {\ttfamily obj.\-Reset\-Camera (vtk\-Renderer ren)} -\/ Callbacks that initialize and finish rendering and other tasks.  
\item {\ttfamily obj.\-Reset\-Camera\-Clipping\-Range (vtk\-Renderer ren)} -\/ Callbacks that initialize and finish rendering and other tasks.  
\item {\ttfamily obj.\-Compute\-Visible\-Prop\-Bounds\-R\-M\-I (int render\-Id)} -\/ Callbacks that initialize and finish rendering and other tasks.  
\item {\ttfamily obj.\-Initialize\-R\-M\-Is ()}  
\item {\ttfamily obj.\-Reset\-All\-Cameras ()} -\/ Resets the camera of each renderer contained in the Render\-Window. Should only be called in the \char`\"{}root\char`\"{} process, and all remote processes must be processing R\-M\-Is for this method to complete.  
\item {\ttfamily obj.\-Compute\-Visible\-Prop\-Bounds (vtk\-Renderer ren, double bounds\mbox{[}6\mbox{]})} -\/ Calculates the bounds by gathering information from all processes.  
\item {\ttfamily obj.\-Set\-Parallel\-Rendering (int )} -\/ Turns on/off parallel rendering. When on (the default) the object responds to render events of the attached window, propagates the render event to other processors, and otherwise enables the parallel rendering process.  
\item {\ttfamily int = obj.\-Get\-Parallel\-Rendering ()} -\/ Turns on/off parallel rendering. When on (the default) the object responds to render events of the attached window, propagates the render event to other processors, and otherwise enables the parallel rendering process.  
\item {\ttfamily obj.\-Parallel\-Rendering\-On ()} -\/ Turns on/off parallel rendering. When on (the default) the object responds to render events of the attached window, propagates the render event to other processors, and otherwise enables the parallel rendering process.  
\item {\ttfamily obj.\-Parallel\-Rendering\-Off ()} -\/ Turns on/off parallel rendering. When on (the default) the object responds to render events of the attached window, propagates the render event to other processors, and otherwise enables the parallel rendering process.  
\item {\ttfamily obj.\-Set\-Render\-Event\-Propagation (int )} -\/ Turns on/off render event propagation. When on (the default) and Parallel\-Rendering is on, process 0 will send an R\-M\-I call to all remote processes to perform a synchronized render. When off, render must be manually called on each process.  
\item {\ttfamily int = obj.\-Get\-Render\-Event\-Propagation ()} -\/ Turns on/off render event propagation. When on (the default) and Parallel\-Rendering is on, process 0 will send an R\-M\-I call to all remote processes to perform a synchronized render. When off, render must be manually called on each process.  
\item {\ttfamily obj.\-Render\-Event\-Propagation\-On ()} -\/ Turns on/off render event propagation. When on (the default) and Parallel\-Rendering is on, process 0 will send an R\-M\-I call to all remote processes to perform a synchronized render. When off, render must be manually called on each process.  
\item {\ttfamily obj.\-Render\-Event\-Propagation\-Off ()} -\/ Turns on/off render event propagation. When on (the default) and Parallel\-Rendering is on, process 0 will send an R\-M\-I call to all remote processes to perform a synchronized render. When off, render must be manually called on each process.  
\item {\ttfamily obj.\-Set\-Use\-Compositing (int )} -\/ This is used for tiled display rendering. When data has been duplicated on all processes, then we do not need to compositing. Cameras and renders are still propagated though.  
\item {\ttfamily int = obj.\-Get\-Use\-Compositing ()} -\/ This is used for tiled display rendering. When data has been duplicated on all processes, then we do not need to compositing. Cameras and renders are still propagated though.  
\item {\ttfamily obj.\-Use\-Compositing\-On ()} -\/ This is used for tiled display rendering. When data has been duplicated on all processes, then we do not need to compositing. Cameras and renders are still propagated though.  
\item {\ttfamily obj.\-Use\-Compositing\-Off ()} -\/ This is used for tiled display rendering. When data has been duplicated on all processes, then we do not need to compositing. Cameras and renders are still propagated though.  
\item {\ttfamily obj.\-Set\-Image\-Reduction\-Factor (double factor)} -\/ Set/\-Get the reduction factor (for sort-\/last based parallel renderers). The size of rendered image is divided by the reduction factor and then is blown up to the size of the current vtk\-Render\-Window. Setting higher reduction factors enables shorter image transfer times (which is often the bottleneck) but will greatly reduce image quality. A reduction factor of 2 or greater should only be used for intermediate images in interactive applications. A reduction factor of 1 (or less) will result in no change in image quality. A parallel render manager may ignore the image reduction factor if it will result in little or no performance enhancements (eg. it does not do image space manipulations).  
\item {\ttfamily double = obj.\-Get\-Image\-Reduction\-Factor ()} -\/ Set/\-Get the reduction factor (for sort-\/last based parallel renderers). The size of rendered image is divided by the reduction factor and then is blown up to the size of the current vtk\-Render\-Window. Setting higher reduction factors enables shorter image transfer times (which is often the bottleneck) but will greatly reduce image quality. A reduction factor of 2 or greater should only be used for intermediate images in interactive applications. A reduction factor of 1 (or less) will result in no change in image quality. A parallel render manager may ignore the image reduction factor if it will result in little or no performance enhancements (eg. it does not do image space manipulations).  
\item {\ttfamily obj.\-Set\-Max\-Image\-Reduction\-Factor (double )}  
\item {\ttfamily double = obj.\-Get\-Max\-Image\-Reduction\-Factor ()}  
\item {\ttfamily obj.\-Set\-Image\-Reduction\-Factor\-For\-Update\-Rate (double Desired\-Update\-Rate)} -\/ Sets the Reduction\-Factor based on the given desired update rate and the rendering metrics taken from the last time Update\-Server\-Info was called. Note that if Auto\-Reduction\-Factor is on, this function is called with the desired update rate of the render window automatically.  
\item {\ttfamily obj.\-Set\-Auto\-Image\-Reduction\-Factor (int )} -\/ If on, the Reduction\-Factor is automatically adjusted to best meet the the Desired\-Update\-Rate in the current Render\-Window based on metrics from the last render.  
\item {\ttfamily int = obj.\-Get\-Auto\-Image\-Reduction\-Factor ()} -\/ If on, the Reduction\-Factor is automatically adjusted to best meet the the Desired\-Update\-Rate in the current Render\-Window based on metrics from the last render.  
\item {\ttfamily obj.\-Auto\-Image\-Reduction\-Factor\-On ()} -\/ If on, the Reduction\-Factor is automatically adjusted to best meet the the Desired\-Update\-Rate in the current Render\-Window based on metrics from the last render.  
\item {\ttfamily obj.\-Auto\-Image\-Reduction\-Factor\-Off ()} -\/ If on, the Reduction\-Factor is automatically adjusted to best meet the the Desired\-Update\-Rate in the current Render\-Window based on metrics from the last render.  
\item {\ttfamily double = obj.\-Get\-Render\-Time ()} -\/ Get rendering metrics.  
\item {\ttfamily double = obj.\-Get\-Image\-Processing\-Time ()} -\/ Get rendering metrics.  
\item {\ttfamily int = obj.\-Get\-Sync\-Render\-Window\-Renderers ()} -\/ By default, the state of all renderers in the root's render window is propagated to the rest of the processes. In order for this to work, all render windows must have the same renderers in the same order. If this is not the case, you can turn off the Sync\-Render\-Window\-Renderers. When this flag is off, the list of renderers held by this parallel render manager (initially empty) is synced. You can modify the list of renderers with the Add\-Renderer, Remove\-Renderer, and Remove\-All\-Renderers methods.  
\item {\ttfamily obj.\-Set\-Sync\-Render\-Window\-Renderers (int )} -\/ By default, the state of all renderers in the root's render window is propagated to the rest of the processes. In order for this to work, all render windows must have the same renderers in the same order. If this is not the case, you can turn off the Sync\-Render\-Window\-Renderers. When this flag is off, the list of renderers held by this parallel render manager (initially empty) is synced. You can modify the list of renderers with the Add\-Renderer, Remove\-Renderer, and Remove\-All\-Renderers methods.  
\item {\ttfamily obj.\-Sync\-Render\-Window\-Renderers\-On ()} -\/ By default, the state of all renderers in the root's render window is propagated to the rest of the processes. In order for this to work, all render windows must have the same renderers in the same order. If this is not the case, you can turn off the Sync\-Render\-Window\-Renderers. When this flag is off, the list of renderers held by this parallel render manager (initially empty) is synced. You can modify the list of renderers with the Add\-Renderer, Remove\-Renderer, and Remove\-All\-Renderers methods.  
\item {\ttfamily obj.\-Sync\-Render\-Window\-Renderers\-Off ()} -\/ By default, the state of all renderers in the root's render window is propagated to the rest of the processes. In order for this to work, all render windows must have the same renderers in the same order. If this is not the case, you can turn off the Sync\-Render\-Window\-Renderers. When this flag is off, the list of renderers held by this parallel render manager (initially empty) is synced. You can modify the list of renderers with the Add\-Renderer, Remove\-Renderer, and Remove\-All\-Renderers methods.  
\item {\ttfamily obj.\-Add\-Renderer (vtk\-Renderer )} -\/ By default, the state of all renderers in the root's render window is propagated to the rest of the processes. In order for this to work, all render windows must have the same renderers in the same order. If this is not the case, you can turn off the Sync\-Render\-Window\-Renderers. When this flag is off, the list of renderers held by this parallel render manager (initially empty) is synced. You can modify the list of renderers with the Add\-Renderer, Remove\-Renderer, and Remove\-All\-Renderers methods.  
\item {\ttfamily obj.\-Remove\-Renderer (vtk\-Renderer )} -\/ By default, the state of all renderers in the root's render window is propagated to the rest of the processes. In order for this to work, all render windows must have the same renderers in the same order. If this is not the case, you can turn off the Sync\-Render\-Window\-Renderers. When this flag is off, the list of renderers held by this parallel render manager (initially empty) is synced. You can modify the list of renderers with the Add\-Renderer, Remove\-Renderer, and Remove\-All\-Renderers methods.  
\item {\ttfamily obj.\-Remove\-All\-Renderers ()} -\/ By default, the state of all renderers in the root's render window is propagated to the rest of the processes. In order for this to work, all render windows must have the same renderers in the same order. If this is not the case, you can turn off the Sync\-Render\-Window\-Renderers. When this flag is off, the list of renderers held by this parallel render manager (initially empty) is synced. You can modify the list of renderers with the Add\-Renderer, Remove\-Renderer, and Remove\-All\-Renderers methods.  
\item {\ttfamily obj.\-Set\-Write\-Back\-Images (int )} -\/ If on (the default), the result of any image space manipulations are written back to the render window frame buffer. If off, the image stored in the frame buffer may not be correct. Either way, the correct frame buffer images may be read with vtk\-Parallel\-Render\-Manager\-::\-Get\-Pixel\-Data. Turning Write\-Back\-Images off may result in a speedup if the render window is not visible to the user and images are read back for further processing or transit.  
\item {\ttfamily int = obj.\-Get\-Write\-Back\-Images ()} -\/ If on (the default), the result of any image space manipulations are written back to the render window frame buffer. If off, the image stored in the frame buffer may not be correct. Either way, the correct frame buffer images may be read with vtk\-Parallel\-Render\-Manager\-::\-Get\-Pixel\-Data. Turning Write\-Back\-Images off may result in a speedup if the render window is not visible to the user and images are read back for further processing or transit.  
\item {\ttfamily obj.\-Write\-Back\-Images\-On ()} -\/ If on (the default), the result of any image space manipulations are written back to the render window frame buffer. If off, the image stored in the frame buffer may not be correct. Either way, the correct frame buffer images may be read with vtk\-Parallel\-Render\-Manager\-::\-Get\-Pixel\-Data. Turning Write\-Back\-Images off may result in a speedup if the render window is not visible to the user and images are read back for further processing or transit.  
\item {\ttfamily obj.\-Write\-Back\-Images\-Off ()} -\/ If on (the default), the result of any image space manipulations are written back to the render window frame buffer. If off, the image stored in the frame buffer may not be correct. Either way, the correct frame buffer images may be read with vtk\-Parallel\-Render\-Manager\-::\-Get\-Pixel\-Data. Turning Write\-Back\-Images off may result in a speedup if the render window is not visible to the user and images are read back for further processing or transit.  
\item {\ttfamily obj.\-Set\-Magnify\-Images (int )} -\/ If on (the default), when the Image\-Reduction\-Factor is greater than 1 and Write\-Back\-Images is on, the image will be magnified to fill the entire render window.  
\item {\ttfamily int = obj.\-Get\-Magnify\-Images ()} -\/ If on (the default), when the Image\-Reduction\-Factor is greater than 1 and Write\-Back\-Images is on, the image will be magnified to fill the entire render window.  
\item {\ttfamily obj.\-Magnify\-Images\-On ()} -\/ If on (the default), when the Image\-Reduction\-Factor is greater than 1 and Write\-Back\-Images is on, the image will be magnified to fill the entire render window.  
\item {\ttfamily obj.\-Magnify\-Images\-Off ()} -\/ If on (the default), when the Image\-Reduction\-Factor is greater than 1 and Write\-Back\-Images is on, the image will be magnified to fill the entire render window.  
\item {\ttfamily obj.\-Set\-Magnify\-Image\-Method (int method)} -\/ Sets the method used to magnify images. Nearest simply replicates each pixel enough times to fill the image. Linear performs linear interpolation between the pixels.  
\item {\ttfamily int = obj.\-Get\-Magnify\-Image\-Method ()} -\/ Sets the method used to magnify images. Nearest simply replicates each pixel enough times to fill the image. Linear performs linear interpolation between the pixels.  
\item {\ttfamily obj.\-Set\-Magnify\-Image\-Method\-To\-Nearest ()} -\/ Sets the method used to magnify images. Nearest simply replicates each pixel enough times to fill the image. Linear performs linear interpolation between the pixels.  
\item {\ttfamily obj.\-Set\-Magnify\-Image\-Method\-To\-Linear ()} -\/ Convenience functions for magnifying images.  
\item {\ttfamily obj.\-Magnify\-Image (vtk\-Unsigned\-Char\-Array full\-Image, int full\-Image\-Size\mbox{[}2\mbox{]}, vtk\-Unsigned\-Char\-Array reduced\-Image, int reduced\-Image\-Size\mbox{[}2\mbox{]}, int full\-Image\-Viewport\mbox{[}4\mbox{]}N\-U\-L\-L, int reduced\-Image\-Viewport\mbox{[}4\mbox{]}N\-U\-L\-L)} -\/ Convenience functions for magnifying images.  
\item {\ttfamily obj.\-Get\-Pixel\-Data (vtk\-Unsigned\-Char\-Array data)} -\/ The most appropriate way to retrieve full size image data after a render. Will work regardless of whether Write\-Back\-Images or Magnify\-Image is on or off. The data returned may be a shallow copy of an internal array. Therefore, the data may be invalid after the next render or if the Parallel\-Render\-Manager is destroyed.  
\item {\ttfamily obj.\-Get\-Pixel\-Data (int x1, int y1, int x2, int y2, vtk\-Unsigned\-Char\-Array data)} -\/ The most appropriate way to retrieve full size image data after a render. Will work regardless of whether Write\-Back\-Images or Magnify\-Image is on or off. The data returned may be a shallow copy of an internal array. Therefore, the data may be invalid after the next render or if the Parallel\-Render\-Manager is destroyed.  
\item {\ttfamily obj.\-Get\-Reduced\-Pixel\-Data (vtk\-Unsigned\-Char\-Array data)} -\/ The most appropriate way to retrieve reduced size image data after a render. Will work regardless of whether Write\-Back\-Images or Magnify\-Image is on or off. The data returned may be a shallow copy of an internal array. Therefore, the data may be invalid after the next render or if the Parallel\-Render\-Manager is destroyed.  
\item {\ttfamily obj.\-Get\-Reduced\-Pixel\-Data (int x1, int y1, int x2, int y2, vtk\-Unsigned\-Char\-Array data)} -\/ The most appropriate way to retrieve reduced size image data after a render. Will work regardless of whether Write\-Back\-Images or Magnify\-Image is on or off. The data returned may be a shallow copy of an internal array. Therefore, the data may be invalid after the next render or if the Parallel\-Render\-Manager is destroyed.  
\item {\ttfamily int = obj. Get\-Full\-Image\-Size ()} -\/ Returns the full image size calculated at the last render.  
\item {\ttfamily int = obj. Get\-Reduced\-Image\-Size ()} -\/ Returns the reduced image size calculated at the last render.  
\item {\ttfamily obj.\-Tile\-Windows (int xsize, int ysize, int n\-Columns)} -\/ Given the x and y size of the render windows, reposition them in a tile of n columns.  
\item {\ttfamily obj.\-Set\-Use\-R\-G\-B\-A (int )} -\/ Get/\-Set if all Images must use R\-G\-B\-A instead of R\-G\-B. By default, this flag is on.  
\item {\ttfamily int = obj.\-Get\-Use\-R\-G\-B\-A ()} -\/ Get/\-Set if all Images must use R\-G\-B\-A instead of R\-G\-B. By default, this flag is on.  
\item {\ttfamily obj.\-Set\-Force\-Render\-Window\-Size (int )} -\/ If Force\-Render\-Window\-Size is set to true, the render manager will use the Render\-Window\-Size ivar instead of getting the size from the render window.  
\item {\ttfamily int = obj.\-Get\-Force\-Render\-Window\-Size ()} -\/ If Force\-Render\-Window\-Size is set to true, the render manager will use the Render\-Window\-Size ivar instead of getting the size from the render window.  
\item {\ttfamily obj.\-Set\-Forced\-Render\-Window\-Size (int , int )} -\/ If Force\-Render\-Window\-Size is set to true, the render manager will use the Size ivar instead of getting the size from the render window.  
\item {\ttfamily obj.\-Set\-Forced\-Render\-Window\-Size (int a\mbox{[}2\mbox{]})} -\/ If Force\-Render\-Window\-Size is set to true, the render manager will use the Size ivar instead of getting the size from the render window.  
\item {\ttfamily int = obj. Get\-Forced\-Render\-Window\-Size ()} -\/ If Force\-Render\-Window\-Size is set to true, the render manager will use the Size ivar instead of getting the size from the render window.  
\item {\ttfamily obj.\-Start\-Service ()} -\/  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkpassthroughfilter}{}\section{vtk\-Pass\-Through\-Filter}\label{vtkparallel_vtkpassthroughfilter}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This filter shallow copies it's input to it's output. It is normally used by P\-V\-Sources with multiple outputs as the V\-T\-K filter in the dummy connection objects at each output.

To create an instance of class vtk\-Pass\-Through\-Filter, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPassThroughFilter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Pass\-Through\-Filter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Pass\-Through\-Filter class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Pass\-Through\-Filter = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Pass\-Through\-Filter = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkpcelldatatopointdata}{}\section{vtk\-P\-Cell\-Data\-To\-Point\-Data}\label{vtkparallel_vtkpcelldatatopointdata}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Like it super class, this filter averages the cell data around a point to get new point data. This subclass requests a layer of ghost cells to make the results invariant to pieces. There is a \char`\"{}\-Piece\-Invariant\char`\"{} flag that lets the user change the behavior of the filter to that of its superclass.

To create an instance of class vtk\-P\-Cell\-Data\-To\-Point\-Data, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPCellDataToPointData
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-P\-Cell\-Data\-To\-Point\-Data has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-P\-Cell\-Data\-To\-Point\-Data class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-P\-Cell\-Data\-To\-Point\-Data = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-P\-Cell\-Data\-To\-Point\-Data = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Piece\-Invariant (int )} -\/ To get piece invariance, this filter has to request an extra ghost level. By default piece invariance is on.  
\item {\ttfamily int = obj.\-Get\-Piece\-Invariant ()} -\/ To get piece invariance, this filter has to request an extra ghost level. By default piece invariance is on.  
\item {\ttfamily obj.\-Piece\-Invariant\-On ()} -\/ To get piece invariance, this filter has to request an extra ghost level. By default piece invariance is on.  
\item {\ttfamily obj.\-Piece\-Invariant\-Off ()} -\/ To get piece invariance, this filter has to request an extra ghost level. By default piece invariance is on.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkpchacoreader}{}\section{vtk\-P\-Chaco\-Reader}\label{vtkparallel_vtkpchacoreader}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-P\-Chaco\-Reader is a unstructured grid source object that reads Chaco files. The file is read by process 0 and converted into a vtk\-Unstructured\-Grid. The vtk\-Distributed\-Data\-Filter is invoked to divide the grid among the processes.

To create an instance of class vtk\-P\-Chaco\-Reader, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPChacoReader
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-P\-Chaco\-Reader has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-P\-Chaco\-Reader class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-P\-Chaco\-Reader = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-P\-Chaco\-Reader = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Controller (vtk\-Multi\-Process\-Controller c)}  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Get\-Controller ()}  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkpcosmohalofinder}{}\section{vtk\-P\-Cosmo\-Halo\-Finder}\label{vtkparallel_vtkpcosmohalofinder}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-P\-Cosmo\-Halo\-Finder is a filter object that operates on the unstructured grid of all particles and assigns each particle a halo id.

To create an instance of class vtk\-P\-Cosmo\-Halo\-Finder, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPCosmoHaloFinder
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-P\-Cosmo\-Halo\-Finder has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-P\-Cosmo\-Halo\-Finder class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-P\-Cosmo\-Halo\-Finder = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-P\-Cosmo\-Halo\-Finder = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Get\-Controller ()} -\/ Set the communicator object for interprocess communication  
\item {\ttfamily obj.\-Set\-Controller (vtk\-Multi\-Process\-Controller )} -\/ Set the communicator object for interprocess communication  
\item {\ttfamily obj.\-Set\-N\-P (int )} -\/ Specify the number of seeded particles in one dimension (total = np$^\wedge$3)  
\item {\ttfamily int = obj.\-Get\-N\-P ()} -\/ Specify the number of seeded particles in one dimension (total = np$^\wedge$3)  
\item {\ttfamily obj.\-Set\-R\-L (float )} -\/ Specify the physical box dimensions size (r\-L) (default 91)  
\item {\ttfamily float = obj.\-Get\-R\-L ()} -\/ Specify the physical box dimensions size (r\-L) (default 91)  
\item {\ttfamily obj.\-Set\-Overlap (float )} -\/ Specify the ghost cell spacing (edge boundary of box) (default 5)  
\item {\ttfamily float = obj.\-Get\-Overlap ()} -\/ Specify the ghost cell spacing (edge boundary of box) (default 5)  
\item {\ttfamily obj.\-Set\-P\-Min (int )} -\/ Specify the minimum number of particles for a halo (pmin)  
\item {\ttfamily int = obj.\-Get\-P\-Min ()} -\/ Specify the minimum number of particles for a halo (pmin)  
\item {\ttfamily obj.\-Set\-B\-B (float )} -\/ Specify the linking length (bb)  
\item {\ttfamily float = obj.\-Get\-B\-B ()} -\/ Specify the linking length (bb)  
\item {\ttfamily obj.\-Set\-Particle\-Mass (float )} -\/ Specify the particle mass  
\item {\ttfamily float = obj.\-Get\-Particle\-Mass ()} -\/ Specify the particle mass  
\item {\ttfamily obj.\-Set\-Copy\-Halo\-Data\-To\-Particles (int )} -\/ Copy the halo information to the original particles (Default on)  
\item {\ttfamily int = obj.\-Get\-Copy\-Halo\-Data\-To\-Particles ()} -\/ Copy the halo information to the original particles (Default on)  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkpcosmoreader}{}\section{vtk\-P\-Cosmo\-Reader}\label{vtkparallel_vtkpcosmoreader}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-P\-Cosmo\-Reader creates a vtk\-Unstructured\-Grid from a binary cosmology file. The file contains fields for\-: x\-\_\-position, x\-\_\-velocity (float) y\-\_\-position, y\-\_\-velocity (float) z-\/position, z\-\_\-velocity (float) mass (float) identification tag (integer)

If the file contains particle information x,y,z is the location of the particle in simulation space with a velocity vector and a mass which will be the same for all particles.

To create an instance of class vtk\-P\-Cosmo\-Reader, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPCosmoReader
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-P\-Cosmo\-Reader has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-P\-Cosmo\-Reader class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-P\-Cosmo\-Reader = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-P\-Cosmo\-Reader = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-File\-Name (string )} -\/ Specify the name of the cosmology particle binary file to read  
\item {\ttfamily string = obj.\-Get\-File\-Name ()} -\/ Specify the name of the cosmology particle binary file to read  
\item {\ttfamily obj.\-Set\-R\-L (float )} -\/ Specify the physical box dimensions size (r\-L) (default 91)  
\item {\ttfamily float = obj.\-Get\-R\-L ()} -\/ Specify the physical box dimensions size (r\-L) (default 91)  
\item {\ttfamily obj.\-Set\-Overlap (float )} -\/ Specify the ghost cell spacing (edge boundary of box) (default 5)  
\item {\ttfamily float = obj.\-Get\-Overlap ()} -\/ Specify the ghost cell spacing (edge boundary of box) (default 5)  
\item {\ttfamily obj.\-Set\-Read\-Mode (int )} -\/ Set the read mode (0 = one-\/to-\/one, 1 = default, round-\/robin)  
\item {\ttfamily int = obj.\-Get\-Read\-Mode ()} -\/ Set the read mode (0 = one-\/to-\/one, 1 = default, round-\/robin)  
\item {\ttfamily obj.\-Set\-Cosmo\-Format (int )} -\/ Set the filetype to Gadget or Cosmo read mode (0 = Gadget, 1 = default, Cosmo)  
\item {\ttfamily int = obj.\-Get\-Cosmo\-Format ()} -\/ Set the filetype to Gadget or Cosmo read mode (0 = Gadget, 1 = default, Cosmo)  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Get\-Controller ()} -\/ Set the communicator object for interprocess communication  
\item {\ttfamily obj.\-Set\-Controller (vtk\-Multi\-Process\-Controller )} -\/ Set the communicator object for interprocess communication  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkpdatasetreader}{}\section{vtk\-P\-Data\-Set\-Reader}\label{vtkparallel_vtkpdatasetreader}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-P\-Data\-Set\-Reader will read a piece of a file, it takes as input a metadata file that lists all of the files in a data set.

To create an instance of class vtk\-P\-Data\-Set\-Reader, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPDataSetReader
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-P\-Data\-Set\-Reader has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-P\-Data\-Set\-Reader class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-P\-Data\-Set\-Reader = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-P\-Data\-Set\-Reader = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-File\-Name (string )} -\/ This file to open and read.  
\item {\ttfamily string = obj.\-Get\-File\-Name ()} -\/ This file to open and read.  
\item {\ttfamily int = obj.\-Get\-Data\-Type ()} -\/ This is set when Update\-Information is called. It shows the type of the output.  
\item {\ttfamily int = obj.\-Can\-Read\-File (string filename)} -\/ Called to determine if the file can be read by the reader.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkpdatasetwriter}{}\section{vtk\-P\-Data\-Set\-Writer}\label{vtkparallel_vtkpdatasetwriter}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-P\-Data\-Set\-Writer will write a piece of a file, and will also create a metadata file that lists all of the files in a data set.

To create an instance of class vtk\-P\-Data\-Set\-Writer, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPDataSetWriter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-P\-Data\-Set\-Writer has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-P\-Data\-Set\-Writer class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-P\-Data\-Set\-Writer = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-P\-Data\-Set\-Writer = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Write ()} -\/ Write the pvtk file and cooresponding vtk files.  
\item {\ttfamily obj.\-Set\-Number\-Of\-Pieces (int num)} -\/ This is how many pieces the whole data set will be divided into.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Pieces ()} -\/ This is how many pieces the whole data set will be divided into.  
\item {\ttfamily obj.\-Set\-Ghost\-Level (int )} -\/ Extra ghost cells will be written out to each piece file if this value is larger than 0.  
\item {\ttfamily int = obj.\-Get\-Ghost\-Level ()} -\/ Extra ghost cells will be written out to each piece file if this value is larger than 0.  
\item {\ttfamily obj.\-Set\-Start\-Piece (int )} -\/ This is the range of pieces that that this writer is responsible for writing. All pieces must be written by some process. The process that writes piece 0 also writes the pvtk file that lists all the piece file names.  
\item {\ttfamily int = obj.\-Get\-Start\-Piece ()} -\/ This is the range of pieces that that this writer is responsible for writing. All pieces must be written by some process. The process that writes piece 0 also writes the pvtk file that lists all the piece file names.  
\item {\ttfamily obj.\-Set\-End\-Piece (int )} -\/ This is the range of pieces that that this writer is responsible for writing. All pieces must be written by some process. The process that writes piece 0 also writes the pvtk file that lists all the piece file names.  
\item {\ttfamily int = obj.\-Get\-End\-Piece ()} -\/ This is the range of pieces that that this writer is responsible for writing. All pieces must be written by some process. The process that writes piece 0 also writes the pvtk file that lists all the piece file names.  
\item {\ttfamily obj.\-Set\-File\-Pattern (string )} -\/ This file pattern uses the file name and piece number to contruct a file name for the piece file.  
\item {\ttfamily string = obj.\-Get\-File\-Pattern ()} -\/ This file pattern uses the file name and piece number to contruct a file name for the piece file.  
\item {\ttfamily obj.\-Set\-Use\-Relative\-File\-Names (int )} -\/ This flag determines whether to use absolute paths for the piece files. By default the pieces are put in the main directory, and the piece file names in the meta data pvtk file are relative to this directory. This should make moving the whole lot to another directory, an easier task.  
\item {\ttfamily int = obj.\-Get\-Use\-Relative\-File\-Names ()} -\/ This flag determines whether to use absolute paths for the piece files. By default the pieces are put in the main directory, and the piece file names in the meta data pvtk file are relative to this directory. This should make moving the whole lot to another directory, an easier task.  
\item {\ttfamily obj.\-Use\-Relative\-File\-Names\-On ()} -\/ This flag determines whether to use absolute paths for the piece files. By default the pieces are put in the main directory, and the piece file names in the meta data pvtk file are relative to this directory. This should make moving the whole lot to another directory, an easier task.  
\item {\ttfamily obj.\-Use\-Relative\-File\-Names\-Off ()} -\/ This flag determines whether to use absolute paths for the piece files. By default the pieces are put in the main directory, and the piece file names in the meta data pvtk file are relative to this directory. This should make moving the whole lot to another directory, an easier task.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkpextractarraysovertime}{}\section{vtk\-P\-Extract\-Arrays\-Over\-Time}\label{vtkparallel_vtkpextractarraysovertime}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-P\-Extract\-Arrays\-Over\-Time is a parallelized version of vtk\-Extract\-Arrays\-Over\-Time. vtk\-Extract\-Arrays\-Over\-Time extract point or cell data given a selection. For every cell or point extracted, vtk\-Extract\-Arrays\-Over\-Time create a vtk\-Table that is placed in an appropriately named block in an output multi-\/block dataset. For global-\/id based selections or location based selections, it's possible that over time the cell/point moves across processes. This filter ensures that such extractions spread across processes are combined correctly into a single vtk\-Table. This filter produces a valid output on the root node alone, all other nodes, simply have empty multi-\/block dataset with number of blocks matching the root (to ensure that all processes have the same structure).

To create an instance of class vtk\-P\-Extract\-Arrays\-Over\-Time, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPExtractArraysOverTime
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-P\-Extract\-Arrays\-Over\-Time has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-P\-Extract\-Arrays\-Over\-Time class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-P\-Extract\-Arrays\-Over\-Time = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-P\-Extract\-Arrays\-Over\-Time = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Controller (vtk\-Multi\-Process\-Controller )} -\/ Set and get the controller.  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Get\-Controller ()} -\/ Set and get the controller.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkpiecerequestfilter}{}\section{vtk\-Piece\-Request\-Filter}\label{vtkparallel_vtkpiecerequestfilter}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Sends the piece and number of pieces to upstream filters; passes the input to the output unmodified.

To create an instance of class vtk\-Piece\-Request\-Filter, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPieceRequestFilter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Piece\-Request\-Filter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Piece\-Request\-Filter class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Piece\-Request\-Filter = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Piece\-Request\-Filter = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Number\-Of\-Pieces (int )} -\/ The total number of pieces.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Pieces\-Min\-Value ()} -\/ The total number of pieces.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Pieces\-Max\-Value ()} -\/ The total number of pieces.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Pieces ()} -\/ The total number of pieces.  
\item {\ttfamily obj.\-Set\-Piece (int )} -\/ The piece to extract.  
\item {\ttfamily int = obj.\-Get\-Piece\-Min\-Value ()} -\/ The piece to extract.  
\item {\ttfamily int = obj.\-Get\-Piece\-Max\-Value ()} -\/ The piece to extract.  
\item {\ttfamily int = obj.\-Get\-Piece ()} -\/ The piece to extract.  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Output ()} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Output (int )} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Object )} -\/ Set an input of this algorithm.  
\item {\ttfamily obj.\-Set\-Input (int , vtk\-Data\-Object )} -\/ Set an input of this algorithm.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkpiecescalars}{}\section{vtk\-Piece\-Scalars}\label{vtkparallel_vtkpiecescalars}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Piece\-Scalars is meant to display which piece is being requested as scalar values. It is usefull for visualizing the partitioning for streaming or distributed pipelines.

To create an instance of class vtk\-Piece\-Scalars, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPieceScalars
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Piece\-Scalars has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Piece\-Scalars class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Piece\-Scalars = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Piece\-Scalars = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Scalar\-Mode\-To\-Cell\-Data ()} -\/ Option to centerate cell scalars of points scalars. Default is point scalars.  
\item {\ttfamily obj.\-Set\-Scalar\-Mode\-To\-Point\-Data ()} -\/ Option to centerate cell scalars of points scalars. Default is point scalars.  
\item {\ttfamily int = obj.\-Get\-Scalar\-Mode ()}  
\item {\ttfamily obj.\-Set\-Random\-Mode (int )}  
\item {\ttfamily int = obj.\-Get\-Random\-Mode ()}  
\item {\ttfamily obj.\-Random\-Mode\-On ()}  
\item {\ttfamily obj.\-Random\-Mode\-Off ()}  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkpimagewriter}{}\section{vtk\-P\-Image\-Writer}\label{vtkparallel_vtkpimagewriter}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-P\-Image\-Writer writes images to files with any data type. The data type of the file is the same scalar type as the input. The dimensionality determines whether the data will be written in one or multiple files. This class is used as the superclass of most image writing classes such as vtk\-B\-M\-P\-Writer etc. It supports streaming.

To create an instance of class vtk\-P\-Image\-Writer, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPImageWriter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-P\-Image\-Writer has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-P\-Image\-Writer class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-P\-Image\-Writer = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-P\-Image\-Writer = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Memory\-Limit (long )} -\/ Set / Get the memory limit in kilobytes. The writer will stream to attempt to keep the pipeline size within this limit  
\item {\ttfamily long = obj.\-Get\-Memory\-Limit ()} -\/ Set / Get the memory limit in kilobytes. The writer will stream to attempt to keep the pipeline size within this limit  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkpkdtree}{}\section{vtk\-P\-Kd\-Tree}\label{vtkparallel_vtkpkdtree}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Build, in parallel, a k-\/d tree decomposition of one or more vtk\-Data\-Sets distributed across processors. We assume each process has read in one portion of a large distributed data set. When done, each process has access to the k-\/d tree structure, can obtain information about which process contains data for each spatial region, and can depth sort the spatial regions.

This class can also assign spatial regions to processors, based on one of several region assignment schemes. By default a contiguous, convex region is assigned to each process. Several queries return information about how many and what cells I have that lie in a region assigned to another process.

To create an instance of class vtk\-P\-Kd\-Tree, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPKdTree
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-P\-Kd\-Tree has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-P\-Kd\-Tree class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-P\-Kd\-Tree = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-P\-Kd\-Tree = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Build\-Locator ()} -\/ Build the spatial decomposition. Call this explicitly after changing any parameters affecting the build of the tree. It must be called by all processes in the parallel application, or it will hang.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Total\-Number\-Of\-Cells ()} -\/ Create tables of counts of cells per process per region. These tables can be accessed with queries like \char`\"{}\-Has\-Data\char`\"{}, \char`\"{}\-Get\-Process\-Cell\-Count\-For\-Region\char`\"{}, and so on. You must have called Build\-Locator() beforehand. This method must be called by all processes or it will hang. Returns 1 on error, 0 when no error.  
\item {\ttfamily int = obj.\-Create\-Process\-Cell\-Count\-Data ()} -\/ Create tables of counts of cells per process per region. These tables can be accessed with queries like \char`\"{}\-Has\-Data\char`\"{}, \char`\"{}\-Get\-Process\-Cell\-Count\-For\-Region\char`\"{}, and so on. You must have called Build\-Locator() beforehand. This method must be called by all processes or it will hang. Returns 1 on error, 0 when no error.  
\item {\ttfamily int = obj.\-Create\-Global\-Data\-Array\-Bounds ()} -\/ A convenience function which compiles the global bounds of the data arrays across processes. These bounds can be accessed with \char`\"{}\-Get\-Cell\-Array\-Global\-Range\char`\"{} and \char`\"{}\-Get\-Point\-Array\-Global\-Range\char`\"{}. This method must be called by all processes or it will hang. Returns 1 on error, 0 when no error.  
\item {\ttfamily obj.\-Set\-Controller (vtk\-Multi\-Process\-Controller c)} -\/ Set/\-Get the communicator object  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Get\-Controller ()} -\/ Set/\-Get the communicator object  
\item {\ttfamily int = obj.\-Get\-Region\-Assignment ()} -\/ The P\-Kd\-Tree class can assign spatial regions to processors after building the k-\/d tree, using one of several partitioning criteria. These functions Set/\-Get whether this assignment is computed. The default is \char`\"{}\-Off\char`\"{}, no assignment is computed. If \char`\"{}\-On\char`\"{}, and no assignment scheme is specified, contiguous assignment will be computed. Specifying an assignment scheme (with Assign\-Regions$\ast$()) automatically turns on Region\-Assignment.  
\item {\ttfamily int = obj.\-Assign\-Regions (int map, int num\-Regions)} -\/ Assign spatial regions to processes via a user defined map. The user-\/supplied map is indexed by region I\-D, and provides a process I\-D for each region.  
\item {\ttfamily int = obj.\-Assign\-Regions\-Round\-Robin ()} -\/ Let the P\-Kd\-Tree class assign a process to each region in a round robin fashion. If the k-\/d tree has not yet been built, the regions will be assigned after Build\-Locator executes.  
\item {\ttfamily int = obj.\-Assign\-Regions\-Contiguous ()} -\/ Let the P\-Kd\-Tree class assign a process to each region by assigning contiguous sets of spatial regions to each process. The set of regions assigned to each process will always have a union that is a convex space (a box). If the k-\/d tree has not yet been built, the regions will be assigned after Build\-Locator executes.  
\item {\ttfamily int = obj.\-Get\-Region\-Assignment\-List (int proc\-Id, vtk\-Int\-Array list)} -\/ Writes the list of region I\-Ds assigned to the specified process. Regions I\-Ds start at 0 and increase by 1 from there. Returns the number of regions in the list.  
\item {\ttfamily obj.\-Get\-All\-Processes\-Bordering\-On\-Point (float x, float y, float z, vtk\-Int\-Array list)} -\/ The k-\/d tree spatial regions have been assigned to processes. Given a point on the boundary of one of the regions, this method creates a list of all processes whose region boundaries include that point. This may be required when looking for processes that have cells adjacent to the cells of a given process.  
\item {\ttfamily int = obj.\-Get\-Process\-Assigned\-To\-Region (int region\-Id)} -\/ Returns the I\-D of the process assigned to the region.  
\item {\ttfamily int = obj.\-Has\-Data (int process\-Id, int region\-Id)} -\/ Returns 1 if the process has data for the given region, 0 otherwise.  
\item {\ttfamily int = obj.\-Get\-Process\-Cell\-Count\-For\-Region (int process\-Id, int region\-Id)} -\/ Returns the number of cells the specified process has in the specified region.  
\item {\ttfamily int = obj.\-Get\-Total\-Processes\-In\-Region (int region\-Id)} -\/ Returns the total number of processes that have data falling within this spatial region.  
\item {\ttfamily int = obj.\-Get\-Process\-List\-For\-Region (int region\-Id, vtk\-Int\-Array processes)} -\/ Adds the list of processes having data for the given region to the supplied list, returns the number of processes added.  
\item {\ttfamily int = obj.\-Get\-Processes\-Cell\-Count\-For\-Region (int region\-Id, int count, int len)} -\/ Writes the number of cells each process has for the region to the supplied list of length len. Returns the number of cell counts written. The order of the cell counts corresponds to the order of process I\-Ds in the process list returned by Get\-Process\-List\-For\-Region.  
\item {\ttfamily int = obj.\-Get\-Total\-Regions\-For\-Process (int process\-Id)} -\/ Returns the total number of spatial regions that a given process has data for.  
\item {\ttfamily int = obj.\-Get\-Region\-List\-For\-Process (int process\-Id, vtk\-Int\-Array regions)} -\/ Adds the region I\-Ds for which this process has data to the supplied vtk\-Int\-Array. Retruns the number of regions.  
\item {\ttfamily int = obj.\-Get\-Regions\-Cell\-Count\-For\-Process (int Process\-Id, int count, int len)} -\/ Writes to the supplied integer array the number of cells this process has for each region. Returns the number of cell counts written. The order of the cell counts corresponds to the order of region I\-Ds in the region list returned by Get\-Region\-List\-For\-Process.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Cell\-Lists\-For\-Process\-Regions (int Process\-Id, int set, vtk\-Id\-List in\-Region\-Cells, vtk\-Id\-List on\-Boundary\-Cells)} -\/ After regions have been assigned to processes, I may want to know which cells I have that are in the regions assigned to a particular process.

This method takes a process I\-D and two vtk\-Id\-Lists. It writes to the first list the I\-Ds of the cells contained in the process' regions. (That is, their cell centroid is contained in the region.) To the second list it write the I\-Ds of the cells which intersect the process' regions but whose cell centroid lies elsewhere.

The total number of cell I\-Ds written to both lists is returned. Either list pointer passed in can be N\-U\-L\-L, and it will be ignored. If there are multiple data sets, you must specify which data set you wish cell I\-Ds for.

The caller should delete these two lists when done. This method uses the cell lists created in vtk\-Kd\-Tree\-::\-Create\-Cell\-Lists(). If the cell lists for the process' regions do not exist, this method will first build the cell lists for all regions by calling Create\-Cell\-Lists(). You must remember to Delete\-Cell\-Lists() when done with all calls to this method, as cell lists can require a great deal of memory.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Cell\-Lists\-For\-Process\-Regions (int Process\-Id, vtk\-Data\-Set set, vtk\-Id\-List in\-Region\-Cells, vtk\-Id\-List on\-Boundary\-Cells)} -\/ After regions have been assigned to processes, I may want to know which cells I have that are in the regions assigned to a particular process.

This method takes a process I\-D and two vtk\-Id\-Lists. It writes to the first list the I\-Ds of the cells contained in the process' regions. (That is, their cell centroid is contained in the region.) To the second list it write the I\-Ds of the cells which intersect the process' regions but whose cell centroid lies elsewhere.

The total number of cell I\-Ds written to both lists is returned. Either list pointer passed in can be N\-U\-L\-L, and it will be ignored. If there are multiple data sets, you must specify which data set you wish cell I\-Ds for.

The caller should delete these two lists when done. This method uses the cell lists created in vtk\-Kd\-Tree\-::\-Create\-Cell\-Lists(). If the cell lists for the process' regions do not exist, this method will first build the cell lists for all regions by calling Create\-Cell\-Lists(). You must remember to Delete\-Cell\-Lists() when done with all calls to this method, as cell lists can require a great deal of memory.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Cell\-Lists\-For\-Process\-Regions (int Process\-Id, vtk\-Id\-List in\-Region\-Cells, vtk\-Id\-List on\-Boundary\-Cells)} -\/ After regions have been assigned to processes, I may want to know which cells I have that are in the regions assigned to a particular process.

This method takes a process I\-D and two vtk\-Id\-Lists. It writes to the first list the I\-Ds of the cells contained in the process' regions. (That is, their cell centroid is contained in the region.) To the second list it write the I\-Ds of the cells which intersect the process' regions but whose cell centroid lies elsewhere.

The total number of cell I\-Ds written to both lists is returned. Either list pointer passed in can be N\-U\-L\-L, and it will be ignored. If there are multiple data sets, you must specify which data set you wish cell I\-Ds for.

The caller should delete these two lists when done. This method uses the cell lists created in vtk\-Kd\-Tree\-::\-Create\-Cell\-Lists(). If the cell lists for the process' regions do not exist, this method will first build the cell lists for all regions by calling Create\-Cell\-Lists(). You must remember to Delete\-Cell\-Lists() when done with all calls to this method, as cell lists can require a great deal of memory.  
\item {\ttfamily int = obj.\-Depth\-Order\-All\-Processes (double direction\-Of\-Projection, vtk\-Int\-Array ordered\-List)} -\/ D\-O N\-O\-T C\-A\-L\-L. Deprecated in V\-T\-K 5.\-2. Use View\-Order\-All\-Processes\-In\-Direction or View\-Order\-All\-Processes\-From\-Position.  
\item {\ttfamily int = obj.\-View\-Order\-All\-Processes\-In\-Direction (double direction\-Of\-Projection\mbox{[}3\mbox{]}, vtk\-Int\-Array ordered\-List)} -\/ Return a list of all processes in order from front to back given a vector direction of projection. Use this to do visibility sorts in parallel projection mode. `ordered\-List' will be resized to the number of processes. The return value is the number of processes. \begin{DoxyPrecond}{Precondition}
ordered\-List\-\_\-exists\-: ordered\-List!=0  
\end{DoxyPrecond}

\item {\ttfamily int = obj.\-View\-Order\-All\-Processes\-From\-Position (double camera\-Position\mbox{[}3\mbox{]}, vtk\-Int\-Array ordered\-List)} -\/ Return a list of all processes in order from front to back given a camera position. Use this to do visibility sorts in perspective projection mode. `ordered\-List' will be resized to the number of processes. The return value is the number of processes. \begin{DoxyPrecond}{Precondition}
ordered\-List\-\_\-exists\-: ordered\-List!=0  
\end{DoxyPrecond}

\item {\ttfamily int = obj.\-Get\-Cell\-Array\-Global\-Range (string name, float range\mbox{[}2\mbox{]})}  
\item {\ttfamily int = obj.\-Get\-Point\-Array\-Global\-Range (string name, float range\mbox{[}2\mbox{]})}  
\item {\ttfamily int = obj.\-Get\-Cell\-Array\-Global\-Range (string name, double range\mbox{[}2\mbox{]})}  
\item {\ttfamily int = obj.\-Get\-Point\-Array\-Global\-Range (string name, double range\mbox{[}2\mbox{]})}  
\item {\ttfamily int = obj.\-Get\-Cell\-Array\-Global\-Range (int array\-Index, double range\mbox{[}2\mbox{]})}  
\item {\ttfamily int = obj.\-Get\-Point\-Array\-Global\-Range (int array\-Index, double range\mbox{[}2\mbox{]})}  
\item {\ttfamily int = obj.\-Get\-Cell\-Array\-Global\-Range (int array\-Index, float range\mbox{[}2\mbox{]})}  
\item {\ttfamily int = obj.\-Get\-Point\-Array\-Global\-Range (int array\-Index, float range\mbox{[}2\mbox{]})}  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkplinearextrusionfilter}{}\section{vtk\-P\-Linear\-Extrusion\-Filter}\label{vtkparallel_vtkplinearextrusionfilter}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-P\-Linear\-Extrusion\-Filter is a parallel version of vtk\-Linear\-Extrusion\-Filter.

To create an instance of class vtk\-P\-Linear\-Extrusion\-Filter, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPLinearExtrusionFilter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-P\-Linear\-Extrusion\-Filter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-P\-Linear\-Extrusion\-Filter class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-P\-Linear\-Extrusion\-Filter = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-P\-Linear\-Extrusion\-Filter = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Piece\-Invariant (int )}  
\item {\ttfamily int = obj.\-Get\-Piece\-Invariant ()}  
\item {\ttfamily obj.\-Piece\-Invariant\-On ()}  
\item {\ttfamily obj.\-Piece\-Invariant\-Off ()}  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkpnrrdreader}{}\section{vtk\-P\-Nrrd\-Reader}\label{vtkparallel_vtkpnrrdreader}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-P\-Nrrd\-Reader is a subclass of vtk\-M\-P\-I\-Image\-Reader that will read Nrrd format header information of the image before reading the data. This means that the reader will automatically set information like file dimensions.

.S\-E\-C\-T\-I\-O\-N Bugs

There are several limitations on what type of nrrd files we can read. This reader only supports nrrd files in raw format. Other encodings like ascii and hex will result in errors. When reading in detached headers, this only supports reading one file that is detached.

To create an instance of class vtk\-P\-Nrrd\-Reader, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPNrrdReader
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-P\-Nrrd\-Reader has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-P\-Nrrd\-Reader class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-P\-Nrrd\-Reader = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-P\-Nrrd\-Reader = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Can\-Read\-File (string filename)}  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkpopenfoamreader}{}\section{vtk\-P\-Open\-F\-O\-A\-M\-Reader}\label{vtkparallel_vtkpopenfoamreader}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-P\-Open\-F\-O\-A\-M\-Reader creates a multiblock dataset. It reads parallel-\/decomposed mesh information and time dependent data. The poly\-Mesh folders contain mesh information. The time folders contain transient data for the cells. Each folder can contain any number of data files.

To create an instance of class vtk\-P\-Open\-F\-O\-A\-M\-Reader, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPOpenFOAMReader
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-P\-Open\-F\-O\-A\-M\-Reader has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-P\-Open\-F\-O\-A\-M\-Reader class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-P\-Open\-F\-O\-A\-M\-Reader = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-P\-Open\-F\-O\-A\-M\-Reader = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Case\-Type (int t)} -\/ Set and get case type. 0 = decomposed case, 1 = reconstructed case.  
\item {\ttfamily obj.\-Set\-Controller (vtk\-Multi\-Process\-Controller )} -\/ Set and get the controller.  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Get\-Controller ()} -\/ Set and get the controller.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkpopreader}{}\section{vtk\-P\-O\-P\-Reader}\label{vtkparallel_vtkpopreader}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-P\-O\-P\-Reader Just converts from images to a structured grid for now.

To create an instance of class vtk\-P\-O\-P\-Reader, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPOPReader
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-P\-O\-P\-Reader has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-P\-O\-P\-Reader class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-P\-O\-P\-Reader = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-P\-O\-P\-Reader = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj. Get\-Dimensions ()} -\/ This is the longitude and latitude dimensions of the structured grid.  
\item {\ttfamily string = obj.\-Get\-Grid\-File\-Name ()} -\/ This file contains the latitude and longitude of the grid. It must be double with no header.  
\item {\ttfamily string = obj.\-Get\-U\-Flow\-File\-Name ()} -\/ These files contains the u and v components of the flow.  
\item {\ttfamily string = obj.\-Get\-V\-Flow\-File\-Name ()} -\/ These files contains the u and v components of the flow.  
\item {\ttfamily obj.\-Set\-File\-Name (string )} -\/ This file contains information about all the files.  
\item {\ttfamily string = obj.\-Get\-File\-Name ()} -\/ This file contains information about all the files.  
\item {\ttfamily obj.\-Set\-Radius (double )} -\/ Radius of the earth.  
\item {\ttfamily double = obj.\-Get\-Radius ()} -\/ Radius of the earth.  
\item {\ttfamily obj.\-Set\-Clip\-Extent (int , int , int , int , int , int )} -\/ Because the data can be so large, here is an option to clip while reading.  
\item {\ttfamily obj.\-Set\-Clip\-Extent (int a\mbox{[}6\mbox{]})} -\/ Because the data can be so large, here is an option to clip while reading.  
\item {\ttfamily int = obj. Get\-Clip\-Extent ()} -\/ Because the data can be so large, here is an option to clip while reading.  
\item {\ttfamily obj.\-Set\-Number\-Of\-Ghost\-Levels (int )} -\/ Set the number of ghost levels to include in the data  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Ghost\-Levels ()} -\/ Set the number of ghost levels to include in the data  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkpoutlinecornerfilter}{}\section{vtk\-P\-Outline\-Corner\-Filter}\label{vtkparallel_vtkpoutlinecornerfilter}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-P\-Outline\-Corner\-Filter works like vtk\-Outline\-Corner\-Filter, but it looks for data partitions in other processes. It assumes the filter is operated in a data parallel pipeline.

To create an instance of class vtk\-P\-Outline\-Corner\-Filter, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPOutlineCornerFilter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-P\-Outline\-Corner\-Filter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-P\-Outline\-Corner\-Filter class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-P\-Outline\-Corner\-Filter = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-P\-Outline\-Corner\-Filter = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Corner\-Factor (double )} -\/ Set/\-Get the factor that controls the relative size of the corners to the length of the corresponding bounds  
\item {\ttfamily double = obj.\-Get\-Corner\-Factor\-Min\-Value ()} -\/ Set/\-Get the factor that controls the relative size of the corners to the length of the corresponding bounds  
\item {\ttfamily double = obj.\-Get\-Corner\-Factor\-Max\-Value ()} -\/ Set/\-Get the factor that controls the relative size of the corners to the length of the corresponding bounds  
\item {\ttfamily double = obj.\-Get\-Corner\-Factor ()} -\/ Set/\-Get the factor that controls the relative size of the corners to the length of the corresponding bounds  
\item {\ttfamily obj.\-Set\-Controller (vtk\-Multi\-Process\-Controller )} -\/ Set and get the controller.  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Get\-Controller ()} -\/ Set and get the controller.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkpoutlinefilter}{}\section{vtk\-P\-Outline\-Filter}\label{vtkparallel_vtkpoutlinefilter}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-P\-Outline\-Filter works like vtk\-Outline\-Filter, but it looks for data partitions in other processes. It assumes the filter is operated in a data parallel pipeline.

To create an instance of class vtk\-P\-Outline\-Filter, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPOutlineFilter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-P\-Outline\-Filter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-P\-Outline\-Filter class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-P\-Outline\-Filter = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-P\-Outline\-Filter = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Controller (vtk\-Multi\-Process\-Controller )} -\/ Set and get the controller.  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Get\-Controller ()} -\/ Set and get the controller.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkppolydatanormals}{}\section{vtk\-P\-Poly\-Data\-Normals}\label{vtkparallel_vtkppolydatanormals}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
To create an instance of class vtk\-P\-Poly\-Data\-Normals, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPPolyDataNormals
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-P\-Poly\-Data\-Normals has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-P\-Poly\-Data\-Normals class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-P\-Poly\-Data\-Normals = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-P\-Poly\-Data\-Normals = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Piece\-Invariant (int )} -\/ To get piece invariance, this filter has to request an extra ghost level. By default piece invariance is on.  
\item {\ttfamily int = obj.\-Get\-Piece\-Invariant ()} -\/ To get piece invariance, this filter has to request an extra ghost level. By default piece invariance is on.  
\item {\ttfamily obj.\-Piece\-Invariant\-On ()} -\/ To get piece invariance, this filter has to request an extra ghost level. By default piece invariance is on.  
\item {\ttfamily obj.\-Piece\-Invariant\-Off ()} -\/ To get piece invariance, this filter has to request an extra ghost level. By default piece invariance is on.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkpprobefilter}{}\section{vtk\-P\-Probe\-Filter}\label{vtkparallel_vtkpprobefilter}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
To create an instance of class vtk\-P\-Probe\-Filter, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPProbeFilter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-P\-Probe\-Filter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-P\-Probe\-Filter class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-P\-Probe\-Filter = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-P\-Probe\-Filter = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Controller (vtk\-Multi\-Process\-Controller )} -\/ Set and get the controller.  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Get\-Controller ()} -\/ Set and get the controller.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkpreflectionfilter}{}\section{vtk\-P\-Reflection\-Filter}\label{vtkparallel_vtkpreflectionfilter}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-P\-Reflection\-Filter is a parallel version of vtk\-Reflection\-Filter which takes into consideration the full dataset bounds for performing the reflection.

To create an instance of class vtk\-P\-Reflection\-Filter, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPReflectionFilter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-P\-Reflection\-Filter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-P\-Reflection\-Filter class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-P\-Reflection\-Filter = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-P\-Reflection\-Filter = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Controller (vtk\-Multi\-Process\-Controller )} -\/ Get/\-Set the parallel controller.  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Get\-Controller ()} -\/ Get/\-Set the parallel controller.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkprocess}{}\section{vtk\-Process}\label{vtkparallel_vtkprocess}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Process is an abstract class representing a process that can be launched by a vtk\-Multi\-Process\-Controller. Concrete classes just have to implement Execute() method and make sure it set the proper value in Return\-Value.

.S\-E\-C\-T\-I\-O\-N Example class My\-Process\-: public vtk\-Process ... vtk\-Multi\-Process\-Controller $\ast$c; My\-Process $\ast$p=new My\-Process\-::\-New(); p-\/$>$Set\-Args(argc,argv); // some parameters specific to the process p-\/$>$Set\-X(10.\-0); // ... c-\/$>$Set\-Single\-Process(p); c-\/$>$Single\-Method\-Execute(); int return\-Value=p-\/$>$Get\-Return\-Value();

To create an instance of class vtk\-Process, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkProcess
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Process has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Process class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Process = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Process = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Execute ()}  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Get\-Controller ()} -\/ Give access to the controller that launched the process. Initial value is N\-U\-L\-L.  
\item {\ttfamily obj.\-Set\-Controller (vtk\-Multi\-Process\-Controller a\-Controller)} -\/ This method should not be called directly but set by the controller itself.  
\item {\ttfamily int = obj.\-Get\-Return\-Value ()} -\/ Value set at the end of a call to Execute.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkprocessgroup}{}\section{vtk\-Process\-Group}\label{vtkparallel_vtkprocessgroup}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This class is used for creating groups of processes. A vtk\-Process\-Group is initialized by passing the controller or communicator on which the group is based off of. You can then use the group to subset and reorder the the processes. Eventually, you can pass the group object to the Create\-Sub\-Controller method of vtk\-Multi\-Process\-Controller to create a controller for the defined group of processes. You must use the same controller (or attached communicator) from which this group was initialized with.

To create an instance of class vtk\-Process\-Group, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkProcessGroup
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Process\-Group has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Process\-Group class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Process\-Group = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Process\-Group = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Initialize (vtk\-Multi\-Process\-Controller controller)} -\/ Initialize the group to the given controller or communicator. The group will be set to contain all of the processes in the controller/communicator in the same order.  
\item {\ttfamily obj.\-Initialize (vtk\-Communicator communicator)} -\/ Initialize the group to the given controller or communicator. The group will be set to contain all of the processes in the controller/communicator in the same order.  
\item {\ttfamily vtk\-Communicator = obj.\-Get\-Communicator ()} -\/ Get the communicator on which this group is based on.  
\item {\ttfamily obj.\-Set\-Communicator (vtk\-Communicator communicator)} -\/ Set the communicator. This has the same effect as Initialize except that the contents of the group will not be modified (although they may be truncated if the new communicator is smaller than the current group). Note that this can lead to an invalid group if there are values in the group that are not valid in the new communicator.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Process\-Ids ()} -\/ Returns the size of this group (the number of processes defined in it).  
\item {\ttfamily int = obj.\-Get\-Process\-Id (int pos)} -\/ Get the process id for the local process (as defined by the group's communicator). Returns -\/1 if the local process is not in the group.  
\item {\ttfamily int = obj.\-Get\-Local\-Process\-Id ()} -\/ Get the process id for the local process (as defined by the group's communicator). Returns -\/1 if the local process is not in the group.  
\item {\ttfamily int = obj.\-Find\-Process\-Id (int process\-Id)} -\/ Given a process id in the communicator, this method returns its location in the group or -\/1 if it is not in the group. For example, if this group contains \{6, 2, 8, 1\}, then Find\-Process\-Id(2) will return 1 and Find\-Process\-Id(3) will return -\/1.  
\item {\ttfamily int = obj.\-Add\-Process\-Id (int process\-Id)} -\/ Add a process id to the end of the group (if it is not already in the group). Returns the location where the id was stored.  
\item {\ttfamily int = obj.\-Remove\-Process\-Id (int process\-Id)} -\/ Remove the given process id from the group (assuming it is in the group). All ids to the \char`\"{}right\char`\"{} of the removed id are shifted over. Returns 1 if the process id was removed, 0 if the process id was not in the group in the first place.  
\item {\ttfamily obj.\-Remove\-All\-Process\-Ids ()} -\/ Removes all the processes ids from the group, leaving the group empty.  
\item {\ttfamily obj.\-Copy (vtk\-Process\-Group group)} -\/ Copies the given group's communicator and process ids.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkprocessidscalars}{}\section{vtk\-Process\-Id\-Scalars}\label{vtkparallel_vtkprocessidscalars}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Process\-Id\-Scalars is meant to display which processor owns which cells and points. It is useful for visualizing the partitioning for streaming or distributed pipelines.

To create an instance of class vtk\-Process\-Id\-Scalars, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkProcessIdScalars
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Process\-Id\-Scalars has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Process\-Id\-Scalars class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Process\-Id\-Scalars = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Process\-Id\-Scalars = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Scalar\-Mode\-To\-Cell\-Data ()} -\/ Option to centerate cell scalars of points scalars. Default is point scalars.  
\item {\ttfamily obj.\-Set\-Scalar\-Mode\-To\-Point\-Data ()} -\/ Option to centerate cell scalars of points scalars. Default is point scalars.  
\item {\ttfamily int = obj.\-Get\-Scalar\-Mode ()}  
\item {\ttfamily obj.\-Set\-Random\-Mode (int )}  
\item {\ttfamily int = obj.\-Get\-Random\-Mode ()}  
\item {\ttfamily obj.\-Random\-Mode\-On ()}  
\item {\ttfamily obj.\-Random\-Mode\-Off ()}  
\item {\ttfamily obj.\-Set\-Controller (vtk\-Multi\-Process\-Controller )} -\/ By defualt this filter uses the global controller, but this method can be used to set another instead.  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Get\-Controller ()} -\/ By defualt this filter uses the global controller, but this method can be used to set another instead.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkpslacreader}{}\section{vtk\-P\-S\-L\-A\-C\-Reader}\label{vtkparallel_vtkpslacreader}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Extends the vtk\-S\-L\-A\-C\-Reader to read in partitioned pieces. Due to the nature of the data layout, this reader only works in a data parallel mode where each process in a parallel job simultaneously attempts to read the piece corresponding to the local process id.

To create an instance of class vtk\-P\-S\-L\-A\-C\-Reader, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPSLACReader
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-P\-S\-L\-A\-C\-Reader has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-P\-S\-L\-A\-C\-Reader class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-P\-S\-L\-A\-C\-Reader = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-P\-S\-L\-A\-C\-Reader = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Get\-Controller ()} -\/ The controller used to communicate partition data. The number of pieces requested must agree with the number of processes, the piece requested must agree with the local process id, and all process must invoke Process\-Requests of this filter simultaneously.  
\item {\ttfamily obj.\-Set\-Controller (vtk\-Multi\-Process\-Controller )} -\/ The controller used to communicate partition data. The number of pieces requested must agree with the number of processes, the piece requested must agree with the local process id, and all process must invoke Process\-Requests of this filter simultaneously.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkpstreamtracer}{}\section{vtk\-P\-Stream\-Tracer}\label{vtkparallel_vtkpstreamtracer}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This class implements some necessary functionality used by distributed and parallel streamline generators. Note that all processes must have access to the W\-H\-O\-L\-E seed source, i.\-e. the source must be identical on all processes.

To create an instance of class vtk\-P\-Stream\-Tracer, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPStreamTracer
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-P\-Stream\-Tracer has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-P\-Stream\-Tracer class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-P\-Stream\-Tracer = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-P\-Stream\-Tracer = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Controller (vtk\-Multi\-Process\-Controller controller)} -\/ Set/\-Get the controller use in compositing (set to the global controller by default) If not using the default, this must be called before any other methods.  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Get\-Controller ()} -\/ Set/\-Get the controller use in compositing (set to the global controller by default) If not using the default, this must be called before any other methods.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkptabletostructuredgrid}{}\section{vtk\-P\-Table\-To\-Structured\-Grid}\label{vtkparallel_vtkptabletostructuredgrid}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-P\-Table\-To\-Structured\-Grid is vtk\-Table\-To\-Structured\-Grid specialization which handles distribution of the input table. For starters, this assumes that the input table is only available on the root node.

To create an instance of class vtk\-P\-Table\-To\-Structured\-Grid, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPTableToStructuredGrid
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-P\-Table\-To\-Structured\-Grid has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-P\-Table\-To\-Structured\-Grid class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-P\-Table\-To\-Structured\-Grid = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-P\-Table\-To\-Structured\-Grid = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Controller (vtk\-Multi\-Process\-Controller )} -\/ Get/\-Set the controller.  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Get\-Controller ()} -\/ Get/\-Set the controller.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkrectilineargridoutlinefilter}{}\section{vtk\-Rectilinear\-Grid\-Outline\-Filter}\label{vtkparallel_vtkrectilineargridoutlinefilter}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Rectilinear\-Grid\-Outline\-Filter works in parallel. There is no reason. to use this filter if you are not breaking the processing into pieces. With one piece you can simply use vtk\-Outline\-Filter. This filter ignores internal edges when the extent is not the whole extent.

To create an instance of class vtk\-Rectilinear\-Grid\-Outline\-Filter, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkRectilinearGridOutlineFilter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Rectilinear\-Grid\-Outline\-Filter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Rectilinear\-Grid\-Outline\-Filter class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Rectilinear\-Grid\-Outline\-Filter = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Rectilinear\-Grid\-Outline\-Filter = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\end{DoxyItemize}\hypertarget{vtkparallel_vtksocketcommunicator}{}\section{vtk\-Socket\-Communicator}\label{vtkparallel_vtksocketcommunicator}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This is a concrete implementation of vtk\-Communicator which supports interprocess communication using B\-S\-D style sockets. It supports byte swapping for the communication of machines with different endianness.

To create an instance of class vtk\-Socket\-Communicator, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkSocketCommunicator
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Socket\-Communicator has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Socket\-Communicator class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Socket\-Communicator = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Socket\-Communicator = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Wait\-For\-Connection (int port)} -\/ Wait for connection on a given port. These methods return 1 on success, 0 on error.  
\item {\ttfamily int = obj.\-Wait\-For\-Connection (vtk\-Server\-Socket socket, long msec)} -\/ Wait for connection on a given port. These methods return 1 on success, 0 on error.  
\item {\ttfamily obj.\-Close\-Connection ()} -\/ Close a connection.  
\item {\ttfamily int = obj.\-Connect\-To (string host\-Name, int port)} -\/ Open a connection to host.  
\item {\ttfamily int = obj.\-Get\-Swap\-Bytes\-In\-Received\-Data ()} -\/ Returns 1 if bytes must be swapped in received ints, floats, etc  
\item {\ttfamily int = obj.\-Get\-Is\-Connected ()} -\/ Is the communicator connected?.  
\item {\ttfamily obj.\-Set\-Number\-Of\-Processes (int num)} -\/ Set the number of processes you will be using.  
\item {\ttfamily obj.\-Barrier ()} -\/ This class foolishly breaks the conventions of the superclass, so this overload fixes the method.  
\item {\ttfamily obj.\-Set\-Perform\-Handshake (int )} -\/ Set or get the Perform\-Handshake ivar. If it is on, the communicator will try to perform a handshake when connected. It is on by default.  
\item {\ttfamily int = obj.\-Get\-Perform\-Handshake\-Min\-Value ()} -\/ Set or get the Perform\-Handshake ivar. If it is on, the communicator will try to perform a handshake when connected. It is on by default.  
\item {\ttfamily int = obj.\-Get\-Perform\-Handshake\-Max\-Value ()} -\/ Set or get the Perform\-Handshake ivar. If it is on, the communicator will try to perform a handshake when connected. It is on by default.  
\item {\ttfamily obj.\-Perform\-Handshake\-On ()} -\/ Set or get the Perform\-Handshake ivar. If it is on, the communicator will try to perform a handshake when connected. It is on by default.  
\item {\ttfamily obj.\-Perform\-Handshake\-Off ()} -\/ Set or get the Perform\-Handshake ivar. If it is on, the communicator will try to perform a handshake when connected. It is on by default.  
\item {\ttfamily int = obj.\-Get\-Perform\-Handshake ()} -\/ Set or get the Perform\-Handshake ivar. If it is on, the communicator will try to perform a handshake when connected. It is on by default.  
\item {\ttfamily int = obj.\-Log\-To\-File (string name)} -\/ Log messages to the given file. The file is truncated unless the second argument is non-\/zero (default is to truncate). If the file name is empty or N\-U\-L\-L, logging is disabled. Returns 0 if the file failed to open, and 1 otherwise.  
\item {\ttfamily int = obj.\-Log\-To\-File (string name, int append)} -\/ Log messages to the given file. The file is truncated unless the second argument is non-\/zero (default is to truncate). If the file name is empty or N\-U\-L\-L, logging is disabled. Returns 0 if the file failed to open, and 1 otherwise.  
\item {\ttfamily obj.\-Set\-Report\-Errors (int )} -\/ If Report\-Errors if false, all vtk\-Error\-Macros are suppressed.  
\item {\ttfamily int = obj.\-Get\-Report\-Errors ()} -\/ If Report\-Errors if false, all vtk\-Error\-Macros are suppressed.  
\item {\ttfamily vtk\-Client\-Socket = obj.\-Get\-Socket ()} -\/ Get/\-Set the actual socket used for communication.  
\item {\ttfamily obj.\-Set\-Socket (vtk\-Client\-Socket )} -\/ Get/\-Set the actual socket used for communication.  
\item {\ttfamily int = obj.\-Handshake ()} -\/ Performs handshake. This uses vtk\-Client\-Socket\-::\-Connecting\-Side to decide whether to perform Server\-Side\-Handshake or Client\-Side\-Handshake.  
\item {\ttfamily int = obj.\-Server\-Side\-Handshake ()} -\/ Performs Server\-Side handshake. One should preferably use Handshake() which calls Server\-Side\-Handshake or Client\-Side\-Handshake as required.  
\item {\ttfamily int = obj.\-Client\-Side\-Handshake ()} -\/ Performs Client\-Side handshake. One should preferably use Handshake() which calls Server\-Side\-Handshake or Client\-Side\-Handshake as required.  
\item {\ttfamily int = obj.\-Get\-Is\-Server ()} -\/ Returns true if this side of the socket is the server. The result is invalid if the socket is not connected.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtksocketcontroller}{}\section{vtk\-Socket\-Controller}\label{vtkparallel_vtksocketcontroller}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This is a concrete implementation of vtk\-Multi\-Process\-Controller. It supports one-\/to-\/one communication using sockets. Note that process 0 will always correspond to self and process 1 to the remote process. This class is best used with ports.

To create an instance of class vtk\-Socket\-Controller, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkSocketController
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Socket\-Controller has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Socket\-Controller class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Socket\-Controller = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Socket\-Controller = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Initialize ()} -\/ Does not apply to sockets. Does nothing.  
\item {\ttfamily obj.\-Finalize ()} -\/ Does not apply to sockets. Does nothing.  
\item {\ttfamily obj.\-Finalize (int )} -\/ Does not apply to sockets. Does nothing.  
\item {\ttfamily obj.\-Single\-Method\-Execute ()} -\/ Does not apply to sockets. Does nothing.  
\item {\ttfamily obj.\-Multiple\-Method\-Execute ()} -\/ Does not apply to sockets. Does nothing.  
\item {\ttfamily obj.\-Create\-Output\-Window ()} -\/ Does not apply to sockets. Does nothing.  
\item {\ttfamily int = obj.\-Wait\-For\-Connection (int port)} -\/ Wait for connection on a given port, forwarded to the communicator  
\item {\ttfamily obj.\-Close\-Connection ()} -\/ Close a connection, forwarded to the communicator  
\item {\ttfamily int = obj.\-Connect\-To (string host\-Name, int port)} -\/ Open a connection to a give machine, forwarded to the communicator  
\item {\ttfamily int = obj.\-Get\-Swap\-Bytes\-In\-Received\-Data ()}  
\item {\ttfamily obj.\-Set\-Communicator (vtk\-Socket\-Communicator comm)} -\/ Set the communicator used in normal and rmi communications.  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Create\-Compliant\-Controller ()} -\/ F\-O\-O\-L\-I\-S\-H M\-O\-R\-T\-A\-L\-S! Thou hast forsaken the sacred laws of ad-\/hoc polymorphism when thou broke a critical assumption of the superclass (namely, each process has thine own id). The time frame to fix thy error has passed. Too much code has come to rely on this abhorrent behavior. Instead, we offer this gift\-: a method for creating an equivalent communicator with correct process id semantics. The calling code is responsible for deleting this controller.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtksubcommunicator}{}\section{vtk\-Sub\-Communicator}\label{vtkparallel_vtksubcommunicator}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This class provides an implementation for communicating on process groups. In general, you should never use this class directly. Instead, use the vtk\-Multi\-Process\-Controller\-::\-Create\-Sub\-Controller method.

.S\-E\-C\-T\-I\-O\-N B\-U\-G\-S

Because all communication is delegated to the original communicator, any error will report process ids with respect to the original communicator, not this communicator that was actually used.

To create an instance of class vtk\-Sub\-Communicator, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkSubCommunicator
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Sub\-Communicator has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Sub\-Communicator class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Sub\-Communicator = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Sub\-Communicator = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Process\-Group = obj.\-Get\-Group ()} -\/ Set/get the group on which communication will happen.  
\item {\ttfamily obj.\-Set\-Group (vtk\-Process\-Group group)} -\/ Set/get the group on which communication will happen.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtksubgroup}{}\section{vtk\-Sub\-Group}\label{vtkparallel_vtksubgroup}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This class provides scalable broadcast, reduce, etc. using only a vtk\-Multi\-Process\-Controller. It does not require M\-P\-I. Users are vtk\-P\-Kd\-Tree and vtk\-Distributed\-Data\-Filter.

.S\-E\-C\-T\-I\-O\-N Note This class will be deprecated soon. Instead of using this class, use the collective and subgrouping operations now built into vtk\-Multi\-Process\-Controller. The only reason this class is not deprecated already is because vtk\-P\-Kd\-Tree relies heavily on this class in ways that are not easy to work around. Since vtk\-P\-Kd\-Tree is due for a major overhaul anyway, we are leaving things the way they are for now.

To create an instance of class vtk\-Sub\-Group, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkSubGroup
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Sub\-Group has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Sub\-Group class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Sub\-Group = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Sub\-Group = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Initialize (int p0, int p1, int me, int tag, vtk\-Communicator c)}  
\item {\ttfamily int = obj.\-Gather (int data, int to, int length, int root)}  
\item {\ttfamily int = obj.\-Gather (string data, string to, int length, int root)}  
\item {\ttfamily int = obj.\-Gather (float data, float to, int length, int root)}  
\item {\ttfamily int = obj.\-Broadcast (float data, int length, int root)}  
\item {\ttfamily int = obj.\-Broadcast (double data, int length, int root)}  
\item {\ttfamily int = obj.\-Broadcast (int data, int length, int root)}  
\item {\ttfamily int = obj.\-Broadcast (string data, int length, int root)}  
\item {\ttfamily int = obj.\-Reduce\-Sum (int data, int to, int length, int root)}  
\item {\ttfamily int = obj.\-Reduce\-Max (float data, float to, int length, int root)}  
\item {\ttfamily int = obj.\-Reduce\-Max (double data, double to, int length, int root)}  
\item {\ttfamily int = obj.\-Reduce\-Max (int data, int to, int length, int root)}  
\item {\ttfamily int = obj.\-Reduce\-Min (float data, float to, int length, int root)}  
\item {\ttfamily int = obj.\-Reduce\-Min (double data, double to, int length, int root)}  
\item {\ttfamily int = obj.\-Reduce\-Min (int data, int to, int length, int root)}  
\item {\ttfamily obj.\-set\-Gather\-Pattern (int root, int length)}  
\item {\ttfamily int = obj.\-get\-Local\-Rank (int process\-I\-D)}  
\item {\ttfamily int = obj.\-Barrier ()}  
\item {\ttfamily obj.\-Print\-Sub\-Group () const}  
\end{DoxyItemize}\hypertarget{vtkparallel_vtktemporalfractal}{}\section{vtk\-Temporal\-Fractal}\label{vtkparallel_vtktemporalfractal}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Temporal\-Fractal is a collection of uniform grids. All have the same dimensions. Each block has a different origin and spacing. It uses mandelbrot to create cell data. I scale the fractal array to look like a volme fraction. I may also add block id and level as extra cell arrays. This source produces a vtk\-Hierarchical\-Box\-Data\-Set when Generate\-Rectilinear\-Grids is off, otherwise produces a vtk\-Multi\-Block\-Data\-Set.

To create an instance of class vtk\-Temporal\-Fractal, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkTemporalFractal
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Temporal\-Fractal has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Temporal\-Fractal class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Temporal\-Fractal = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Temporal\-Fractal = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Fractal\-Value (float )} -\/ Essentially the iso surface value. The fractal array is scaled to map this value to 0.\-5 for use as a volume fraction.  
\item {\ttfamily float = obj.\-Get\-Fractal\-Value ()} -\/ Essentially the iso surface value. The fractal array is scaled to map this value to 0.\-5 for use as a volume fraction.  
\item {\ttfamily obj.\-Set\-Maximum\-Level (int )} -\/ Any blocks touching a predefined line will be subdivided to this level. Other blocks are subdivided so that neighboring blocks only differ by one level.  
\item {\ttfamily int = obj.\-Get\-Maximum\-Level ()} -\/ Any blocks touching a predefined line will be subdivided to this level. Other blocks are subdivided so that neighboring blocks only differ by one level.  
\item {\ttfamily obj.\-Set\-Dimensions (int )} -\/ X\-Y\-Z dimensions of cells.  
\item {\ttfamily int = obj.\-Get\-Dimensions ()} -\/ X\-Y\-Z dimensions of cells.  
\item {\ttfamily obj.\-Set\-Ghost\-Levels (int )} -\/ For testing ghost levels.  
\item {\ttfamily int = obj.\-Get\-Ghost\-Levels ()} -\/ For testing ghost levels.  
\item {\ttfamily obj.\-Ghost\-Levels\-On ()} -\/ For testing ghost levels.  
\item {\ttfamily obj.\-Ghost\-Levels\-Off ()} -\/ For testing ghost levels.  
\item {\ttfamily obj.\-Set\-Generate\-Rectilinear\-Grids (int )} -\/ Generate either rectilinear grids either uniform grids. Default is false.  
\item {\ttfamily int = obj.\-Get\-Generate\-Rectilinear\-Grids ()} -\/ Generate either rectilinear grids either uniform grids. Default is false.  
\item {\ttfamily obj.\-Generate\-Rectilinear\-Grids\-On ()} -\/ Generate either rectilinear grids either uniform grids. Default is false.  
\item {\ttfamily obj.\-Generate\-Rectilinear\-Grids\-Off ()} -\/ Generate either rectilinear grids either uniform grids. Default is false.  
\item {\ttfamily obj.\-Set\-Discrete\-Time\-Steps (int )} -\/ Limit this source to discrete integer time steps Default is off (continuous)  
\item {\ttfamily int = obj.\-Get\-Discrete\-Time\-Steps ()} -\/ Limit this source to discrete integer time steps Default is off (continuous)  
\item {\ttfamily obj.\-Discrete\-Time\-Steps\-On ()} -\/ Limit this source to discrete integer time steps Default is off (continuous)  
\item {\ttfamily obj.\-Discrete\-Time\-Steps\-Off ()} -\/ Limit this source to discrete integer time steps Default is off (continuous)  
\item {\ttfamily obj.\-Set\-Two\-Dimensional (int )} -\/ Make a 2\-D data set to test.  
\item {\ttfamily int = obj.\-Get\-Two\-Dimensional ()} -\/ Make a 2\-D data set to test.  
\item {\ttfamily obj.\-Two\-Dimensional\-On ()} -\/ Make a 2\-D data set to test.  
\item {\ttfamily obj.\-Two\-Dimensional\-Off ()} -\/ Make a 2\-D data set to test.  
\item {\ttfamily obj.\-Set\-Asymetric (int )} -\/ Test the case when the blocks do not have the same sizes. Adds 2 to the x extent of the far x blocks (level 1).  
\item {\ttfamily int = obj.\-Get\-Asymetric ()} -\/ Test the case when the blocks do not have the same sizes. Adds 2 to the x extent of the far x blocks (level 1).  
\item {\ttfamily obj.\-Set\-Adaptive\-Subdivision (int )} -\/ Make the division adaptive or not, defaults to Adaptive  
\item {\ttfamily int = obj.\-Get\-Adaptive\-Subdivision ()} -\/ Make the division adaptive or not, defaults to Adaptive  
\item {\ttfamily obj.\-Adaptive\-Subdivision\-On ()} -\/ Make the division adaptive or not, defaults to Adaptive  
\item {\ttfamily obj.\-Adaptive\-Subdivision\-Off ()} -\/ Make the division adaptive or not, defaults to Adaptive  
\end{DoxyItemize}\hypertarget{vtkparallel_vtktemporalinterpolatedvelocityfield}{}\section{vtk\-Temporal\-Interpolated\-Velocity\-Field}\label{vtkparallel_vtktemporalinterpolatedvelocityfield}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Temporal\-Interpolated\-Velocity\-Field is a general purpose helper for the temporal particle tracing code (vtk\-Temporal\-Stream\-Tracer)

It maintains two copies of vtk\-Caching\-Interpolated\-Velocity\-Field internally and uses them to obtain velocity values at time T0 and T1.

In fact the class does quite a bit more than this because when the geometry of the datasets is the same at T0 and T1, we can re-\/use cached cell Ids and weights used in the cell interpolation routines. Additionally, the same weights can be used when interpolating (point) scalar values and computing vorticity etc.

To create an instance of class vtk\-Temporal\-Interpolated\-Velocity\-Field, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkTemporalInterpolatedVelocityField
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Temporal\-Interpolated\-Velocity\-Field has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Temporal\-Interpolated\-Velocity\-Field class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Temporal\-Interpolated\-Velocity\-Field = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Temporal\-Interpolated\-Velocity\-Field = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Function\-Values (double x, double u)} -\/ Evaluate the velocity field, f, at (x, y, z, t). For now, t is ignored.  
\item {\ttfamily int = obj.\-Function\-Values\-At\-T (int T, double x, double u)} -\/ Evaluate the velocity field, f, at (x, y, z, t). For now, t is ignored.  
\item {\ttfamily obj.\-Select\-Vectors (string field\-Name)} -\/ In order to use this class, two sets of data must be supplied, corresponding to times T1 and T2. Data is added via this function.  
\item {\ttfamily obj.\-Set\-Data\-Set\-At\-Time (int I, int N, double T, vtk\-Data\-Set dataset, bool staticdataset)} -\/ In order to use this class, two sets of data must be supplied, corresponding to times T1 and T2. Data is added via this function.  
\item {\ttfamily obj.\-Clear\-Cache ()} -\/ Set the last cell id to -\/1 so that the next search does not start from the previous cell  
\item {\ttfamily int = obj.\-Test\-Point (double x)} -\/ A utility function which evaluates the point at T1, T2 to see if it is inside the data at both times or only one.  
\item {\ttfamily int = obj.\-Quick\-Test\-Point (double x)} -\/ A utility function which evaluates the point at T1, T2 to see if it is inside the data at both times or only one.  
\item {\ttfamily double = obj. Get\-Last\-Good\-Velocity ()} -\/ If an interpolation was successful, we can retrieve the last computed value from here. Initial value is (0.\-0,0.\-0,0.\-0)  
\item {\ttfamily double = obj.\-Get\-Current\-Weight ()} -\/ Get the most recent weight between 0-\/$>$1 from T1-\/$>$T2. Initial value is 0.  
\item {\ttfamily bool = obj.\-Interpolate\-Point (vtk\-Point\-Data out\-P\-D1, vtk\-Point\-Data out\-P\-D2, vtk\-Id\-Type out\-Index)}  
\item {\ttfamily bool = obj.\-Interpolate\-Point (int T, vtk\-Point\-Data out\-P\-D1, vtk\-Id\-Type out\-Index)}  
\item {\ttfamily obj.\-Show\-Cache\-Results ()}  
\item {\ttfamily bool = obj.\-Is\-Static (int dataset\-Index)}  
\item {\ttfamily obj.\-Advance\-One\-Time\-Step ()}  
\end{DoxyItemize}\hypertarget{vtkparallel_vtktemporalstreamtracer}{}\section{vtk\-Temporal\-Stream\-Tracer}\label{vtkparallel_vtktemporalstreamtracer}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Temporal\-Stream\-Tracer is a filter that integrates a vector field to generate

To create an instance of class vtk\-Temporal\-Stream\-Tracer, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkTemporalStreamTracer
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Temporal\-Stream\-Tracer has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Temporal\-Stream\-Tracer class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Temporal\-Stream\-Tracer = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Temporal\-Stream\-Tracer = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Time\-Step (int )} -\/ Set/\-Get the Time\-Step. This is the primary means of advancing the particles. The Time\-Step should be animated and this will drive the pipeline forcing timesteps to be fetched from upstream.  
\item {\ttfamily int = obj.\-Get\-Time\-Step ()} -\/ Set/\-Get the Time\-Step. This is the primary means of advancing the particles. The Time\-Step should be animated and this will drive the pipeline forcing timesteps to be fetched from upstream.  
\item {\ttfamily obj.\-Set\-Ignore\-Pipeline\-Time (int )} -\/ To get around problems with the Paraview Animation controls we can just animate the time step and ignore the T\-I\-M\-E\-\_\- requests  
\item {\ttfamily int = obj.\-Get\-Ignore\-Pipeline\-Time ()} -\/ To get around problems with the Paraview Animation controls we can just animate the time step and ignore the T\-I\-M\-E\-\_\- requests  
\item {\ttfamily obj.\-Ignore\-Pipeline\-Time\-On ()} -\/ To get around problems with the Paraview Animation controls we can just animate the time step and ignore the T\-I\-M\-E\-\_\- requests  
\item {\ttfamily obj.\-Ignore\-Pipeline\-Time\-Off ()} -\/ To get around problems with the Paraview Animation controls we can just animate the time step and ignore the T\-I\-M\-E\-\_\- requests  
\item {\ttfamily obj.\-Set\-Time\-Step\-Resolution (double )} -\/ If the data source does not have the correct time values present on each time step -\/ setting this value to non unity can be used to adjust the time step size from 1s pre step to 1x\-\_\-\-Time\-Step\-Resolution \-: Not functional in this version. Broke it  
\end{DoxyItemize}\hypertarget{vtkparallel_vtktransmitimagedatapiece}{}\section{vtk\-Transmit\-Image\-Data\-Piece}\label{vtkparallel_vtktransmitimagedatapiece}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This filter updates the appropriate piece by requesting the piece from process 0. Process 0 always updates all of the data. It is important that Execute get called on all processes, otherwise the filter will deadlock.

To create an instance of class vtk\-Transmit\-Image\-Data\-Piece, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkTransmitImageDataPiece
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Transmit\-Image\-Data\-Piece has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Transmit\-Image\-Data\-Piece class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Transmit\-Image\-Data\-Piece = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Transmit\-Image\-Data\-Piece = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Controller (vtk\-Multi\-Process\-Controller )} -\/ By defualt this filter uses the global controller, but this method can be used to set another instead.  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Get\-Controller ()} -\/ By defualt this filter uses the global controller, but this method can be used to set another instead.  
\item {\ttfamily obj.\-Set\-Create\-Ghost\-Cells (int )} -\/ Turn on/off creating ghost cells (on by default).  
\item {\ttfamily int = obj.\-Get\-Create\-Ghost\-Cells ()} -\/ Turn on/off creating ghost cells (on by default).  
\item {\ttfamily obj.\-Create\-Ghost\-Cells\-On ()} -\/ Turn on/off creating ghost cells (on by default).  
\item {\ttfamily obj.\-Create\-Ghost\-Cells\-Off ()} -\/ Turn on/off creating ghost cells (on by default).  
\end{DoxyItemize}\hypertarget{vtkparallel_vtktransmitpolydatapiece}{}\section{vtk\-Transmit\-Poly\-Data\-Piece}\label{vtkparallel_vtktransmitpolydatapiece}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This filter updates the appropriate piece by requesting the piece from process 0. Process 0 always updates all of the data. It is important that Execute get called on all processes, otherwise the filter will deadlock.

To create an instance of class vtk\-Transmit\-Poly\-Data\-Piece, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkTransmitPolyDataPiece
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Transmit\-Poly\-Data\-Piece has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Transmit\-Poly\-Data\-Piece class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Transmit\-Poly\-Data\-Piece = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Transmit\-Poly\-Data\-Piece = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Controller (vtk\-Multi\-Process\-Controller )} -\/ By defualt this filter uses the global controller, but this method can be used to set another instead.  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Get\-Controller ()} -\/ By defualt this filter uses the global controller, but this method can be used to set another instead.  
\item {\ttfamily obj.\-Set\-Create\-Ghost\-Cells (int )} -\/ Turn on/off creating ghost cells (on by default).  
\item {\ttfamily int = obj.\-Get\-Create\-Ghost\-Cells ()} -\/ Turn on/off creating ghost cells (on by default).  
\item {\ttfamily obj.\-Create\-Ghost\-Cells\-On ()} -\/ Turn on/off creating ghost cells (on by default).  
\item {\ttfamily obj.\-Create\-Ghost\-Cells\-Off ()} -\/ Turn on/off creating ghost cells (on by default).  
\end{DoxyItemize}\hypertarget{vtkparallel_vtktransmitrectilineargridpiece}{}\section{vtk\-Transmit\-Rectilinear\-Grid\-Piece}\label{vtkparallel_vtktransmitrectilineargridpiece}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This filter updates the appropriate piece by requesting the piece from process 0. Process 0 always updates all of the data. It is important that Execute get called on all processes, otherwise the filter will deadlock.

To create an instance of class vtk\-Transmit\-Rectilinear\-Grid\-Piece, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkTransmitRectilinearGridPiece
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Transmit\-Rectilinear\-Grid\-Piece has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Transmit\-Rectilinear\-Grid\-Piece class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Transmit\-Rectilinear\-Grid\-Piece = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Transmit\-Rectilinear\-Grid\-Piece = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Controller (vtk\-Multi\-Process\-Controller )} -\/ By defualt this filter uses the global controller, but this method can be used to set another instead.  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Get\-Controller ()} -\/ By defualt this filter uses the global controller, but this method can be used to set another instead.  
\item {\ttfamily obj.\-Set\-Create\-Ghost\-Cells (int )} -\/ Turn on/off creating ghost cells (on by default).  
\item {\ttfamily int = obj.\-Get\-Create\-Ghost\-Cells ()} -\/ Turn on/off creating ghost cells (on by default).  
\item {\ttfamily obj.\-Create\-Ghost\-Cells\-On ()} -\/ Turn on/off creating ghost cells (on by default).  
\item {\ttfamily obj.\-Create\-Ghost\-Cells\-Off ()} -\/ Turn on/off creating ghost cells (on by default).  
\end{DoxyItemize}\hypertarget{vtkparallel_vtktransmitstructuredgridpiece}{}\section{vtk\-Transmit\-Structured\-Grid\-Piece}\label{vtkparallel_vtktransmitstructuredgridpiece}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This filter updates the appropriate piece by requesting the piece from process 0. Process 0 always updates all of the data. It is important that Execute get called on all processes, otherwise the filter will deadlock.

To create an instance of class vtk\-Transmit\-Structured\-Grid\-Piece, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkTransmitStructuredGridPiece
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Transmit\-Structured\-Grid\-Piece has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Transmit\-Structured\-Grid\-Piece class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Transmit\-Structured\-Grid\-Piece = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Transmit\-Structured\-Grid\-Piece = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Controller (vtk\-Multi\-Process\-Controller )} -\/ By defualt this filter uses the global controller, but this method can be used to set another instead.  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Get\-Controller ()} -\/ By defualt this filter uses the global controller, but this method can be used to set another instead.  
\item {\ttfamily obj.\-Set\-Create\-Ghost\-Cells (int )} -\/ Turn on/off creating ghost cells (on by default).  
\item {\ttfamily int = obj.\-Get\-Create\-Ghost\-Cells ()} -\/ Turn on/off creating ghost cells (on by default).  
\item {\ttfamily obj.\-Create\-Ghost\-Cells\-On ()} -\/ Turn on/off creating ghost cells (on by default).  
\item {\ttfamily obj.\-Create\-Ghost\-Cells\-Off ()} -\/ Turn on/off creating ghost cells (on by default).  
\end{DoxyItemize}\hypertarget{vtkparallel_vtktransmitunstructuredgridpiece}{}\section{vtk\-Transmit\-Unstructured\-Grid\-Piece}\label{vtkparallel_vtktransmitunstructuredgridpiece}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This filter updates the appropriate piece by requesting the piece from process 0. Process 0 always updates all of the data. It is important that Execute get called on all processes, otherwise the filter will deadlock.

To create an instance of class vtk\-Transmit\-Unstructured\-Grid\-Piece, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkTransmitUnstructuredGridPiece
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Transmit\-Unstructured\-Grid\-Piece has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Transmit\-Unstructured\-Grid\-Piece class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Transmit\-Unstructured\-Grid\-Piece = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Transmit\-Unstructured\-Grid\-Piece = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Controller (vtk\-Multi\-Process\-Controller )} -\/ By defualt this filter uses the global controller, but this method can be used to set another instead.  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Get\-Controller ()} -\/ By defualt this filter uses the global controller, but this method can be used to set another instead.  
\item {\ttfamily obj.\-Set\-Create\-Ghost\-Cells (int )} -\/ Turn on/off creating ghost cells (on by default).  
\item {\ttfamily int = obj.\-Get\-Create\-Ghost\-Cells ()} -\/ Turn on/off creating ghost cells (on by default).  
\item {\ttfamily obj.\-Create\-Ghost\-Cells\-On ()} -\/ Turn on/off creating ghost cells (on by default).  
\item {\ttfamily obj.\-Create\-Ghost\-Cells\-Off ()} -\/ Turn on/off creating ghost cells (on by default).  
\end{DoxyItemize}\hypertarget{vtkparallel_vtktreecompositer}{}\section{vtk\-Tree\-Compositer}\label{vtkparallel_vtktreecompositer}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Tree\-Compositer operates in multiple processes. Each compositer has a render window. They use a vtk\-Multi\-Process\-Controller to communicate the color and depth buffer to process 0's render window. It will not handle transparency well.

To create an instance of class vtk\-Tree\-Compositer, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkTreeCompositer
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Tree\-Compositer has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Tree\-Compositer class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Tree\-Compositer = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Tree\-Compositer = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Composite\-Buffer (vtk\-Data\-Array p\-Buf, vtk\-Float\-Array z\-Buf, vtk\-Data\-Array p\-Tmp, vtk\-Float\-Array z\-Tmp)}  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkvpicreader}{}\section{vtk\-V\-P\-I\-C\-Reader}\label{vtkparallel_vtkvpicreader}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Data\-Reader is a helper superclass that reads the vtk data file header, dataset type, and attribute data (point and cell attributes such as scalars, vectors, normals, etc.) from a vtk data file. See text for the format of the various vtk file types.

To create an instance of class vtk\-V\-P\-I\-C\-Reader, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkVPICReader
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-V\-P\-I\-C\-Reader has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-V\-P\-I\-C\-Reader class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-V\-P\-I\-C\-Reader = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-V\-P\-I\-C\-Reader = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-File\-Name (string )} -\/ Specify file name of V\-P\-I\-C data file to read.  
\item {\ttfamily string = obj.\-Get\-File\-Name ()} -\/ Specify file name of V\-P\-I\-C data file to read.  
\item {\ttfamily obj.\-Set\-Stride (int , int , int )} -\/ Set the stride in each dimension  
\item {\ttfamily obj.\-Set\-Stride (int a\mbox{[}3\mbox{]})} -\/ Set the stride in each dimension  
\item {\ttfamily int = obj. Get\-Stride ()} -\/ Set the stride in each dimension  
\item {\ttfamily obj.\-Set\-X\-Extent (int , int )} -\/ Set the simulation file decomposition in each dimension  
\item {\ttfamily obj.\-Set\-X\-Extent (int a\mbox{[}2\mbox{]})} -\/ Set the simulation file decomposition in each dimension  
\item {\ttfamily obj.\-Set\-Y\-Extent (int , int )} -\/ Set the simulation file decomposition in each dimension  
\item {\ttfamily obj.\-Set\-Y\-Extent (int a\mbox{[}2\mbox{]})} -\/ Set the simulation file decomposition in each dimension  
\item {\ttfamily obj.\-Set\-Z\-Extent (int , int )} -\/ Set the simulation file decomposition in each dimension  
\item {\ttfamily obj.\-Set\-Z\-Extent (int a\mbox{[}2\mbox{]})} -\/ Set the simulation file decomposition in each dimension  
\item {\ttfamily int = obj. Get\-X\-Layout ()}  
\item {\ttfamily int = obj. Get\-Y\-Layout ()}  
\item {\ttfamily int = obj. Get\-Z\-Layout ()}  
\item {\ttfamily vtk\-Image\-Data = obj.\-Get\-Output ()} -\/ Get the reader's output  
\item {\ttfamily vtk\-Image\-Data = obj.\-Get\-Output (int index)} -\/ Get the reader's output  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Point\-Arrays ()} -\/ The following methods allow selective reading of solutions fields. By default, A\-L\-L data fields on the nodes are read, but this can be modified.  
\item {\ttfamily string = obj.\-Get\-Point\-Array\-Name (int index)} -\/ The following methods allow selective reading of solutions fields. By default, A\-L\-L data fields on the nodes are read, but this can be modified.  
\item {\ttfamily int = obj.\-Get\-Point\-Array\-Status (string name)} -\/ The following methods allow selective reading of solutions fields. By default, A\-L\-L data fields on the nodes are read, but this can be modified.  
\item {\ttfamily obj.\-Set\-Point\-Array\-Status (string name, int status)} -\/ The following methods allow selective reading of solutions fields. By default, A\-L\-L data fields on the nodes are read, but this can be modified.  
\item {\ttfamily obj.\-Disable\-All\-Point\-Arrays ()} -\/ The following methods allow selective reading of solutions fields. By default, A\-L\-L data fields on the nodes are read, but this can be modified.  
\item {\ttfamily obj.\-Enable\-All\-Point\-Arrays ()} -\/ The following methods allow selective reading of solutions fields. By default, A\-L\-L data fields on the nodes are read, but this can be modified.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkwindbladereader}{}\section{vtk\-Wind\-Blade\-Reader}\label{vtkparallel_vtkwindbladereader}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Wind\-Blade\-Reader is a source object that reads Wind\-Blade files which are block binary files with tags before and after each block giving the number of bytes within the block. The number of data variables dumped varies. The data is 3\-D rectilinear with irregular spacing on the Z dimension.

To create an instance of class vtk\-Wind\-Blade\-Reader, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkWindBladeReader
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Wind\-Blade\-Reader has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Wind\-Blade\-Reader class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Wind\-Blade\-Reader = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Wind\-Blade\-Reader = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Filename (string )}  
\item {\ttfamily string = obj.\-Get\-Filename ()}  
\item {\ttfamily obj.\-Set\-Whole\-Extent (int , int , int , int , int , int )}  
\item {\ttfamily obj.\-Set\-Whole\-Extent (int a\mbox{[}6\mbox{]})}  
\item {\ttfamily int = obj. Get\-Whole\-Extent ()}  
\item {\ttfamily obj.\-Set\-Sub\-Extent (int , int , int , int , int , int )}  
\item {\ttfamily obj.\-Set\-Sub\-Extent (int a\mbox{[}6\mbox{]})}  
\item {\ttfamily int = obj. Get\-Sub\-Extent ()}  
\item {\ttfamily vtk\-Structured\-Grid = obj.\-Get\-Field\-Output ()} -\/ Get the reader's output  
\item {\ttfamily vtk\-Unstructured\-Grid = obj.\-Get\-Blade\-Output ()} -\/ Get the reader's output  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Point\-Arrays ()} -\/ The following methods allow selective reading of solutions fields. By default, A\-L\-L data fields on the nodes are read, but this can be modified.  
\item {\ttfamily string = obj.\-Get\-Point\-Array\-Name (int index)} -\/ The following methods allow selective reading of solutions fields. By default, A\-L\-L data fields on the nodes are read, but this can be modified.  
\item {\ttfamily int = obj.\-Get\-Point\-Array\-Status (string name)}  
\item {\ttfamily obj.\-Set\-Point\-Array\-Status (string name, int status)}  
\item {\ttfamily obj.\-Disable\-All\-Point\-Arrays ()}  
\item {\ttfamily obj.\-Enable\-All\-Point\-Arrays ()}  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkxmlphierarchicalboxdatawriter}{}\section{vtk\-X\-M\-L\-P\-Hierarchical\-Box\-Data\-Writer}\label{vtkparallel_vtkxmlphierarchicalboxdatawriter}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-X\-M\-L\-P\-Composite\-Data\-Writer writes (in parallel or serially) the V\-T\-K X\-M\-L multi-\/group, multi-\/block hierarchical and hierarchical box files. X\-M\-L multi-\/group data files are meta-\/files that point to a list of serial V\-T\-K X\-M\-L files.

To create an instance of class vtk\-X\-M\-L\-P\-Hierarchical\-Box\-Data\-Writer, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkXMLPHierarchicalBoxDataWriter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-X\-M\-L\-P\-Hierarchical\-Box\-Data\-Writer has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-X\-M\-L\-P\-Hierarchical\-Box\-Data\-Writer class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-X\-M\-L\-P\-Hierarchical\-Box\-Data\-Writer = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-X\-M\-L\-P\-Hierarchical\-Box\-Data\-Writer = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Controller (vtk\-Multi\-Process\-Controller )} -\/ Controller used to communicate data type of blocks. By default, the global controller is used. If you want another controller to be used, set it with this. If no controller is set, only the local blocks will be written to the meta-\/file.  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Get\-Controller ()} -\/ Controller used to communicate data type of blocks. By default, the global controller is used. If you want another controller to be used, set it with this. If no controller is set, only the local blocks will be written to the meta-\/file.  
\item {\ttfamily obj.\-Set\-Write\-Meta\-File (int flag)} -\/ Set whether this instance will write the meta-\/file. Write\-Meta\-File is set to flag only on process 0 and all other processes have Write\-Meta\-File set to 0 by default.  
\end{DoxyItemize}\hypertarget{vtkparallel_vtkxmlpmultiblockdatawriter}{}\section{vtk\-X\-M\-L\-P\-Multi\-Block\-Data\-Writer}\label{vtkparallel_vtkxmlpmultiblockdatawriter}
Section\-: \hyperlink{sec_vtkparallel}{Visualization Toolkit Parallel Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-X\-M\-L\-P\-Composite\-Data\-Writer writes (in parallel or serially) the V\-T\-K X\-M\-L multi-\/group, multi-\/block hierarchical and hierarchical box files. X\-M\-L multi-\/group data files are meta-\/files that point to a list of serial V\-T\-K X\-M\-L files.

To create an instance of class vtk\-X\-M\-L\-P\-Multi\-Block\-Data\-Writer, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkXMLPMultiBlockDataWriter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-X\-M\-L\-P\-Multi\-Block\-Data\-Writer has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-X\-M\-L\-P\-Multi\-Block\-Data\-Writer class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-X\-M\-L\-P\-Multi\-Block\-Data\-Writer = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-X\-M\-L\-P\-Multi\-Block\-Data\-Writer = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Controller (vtk\-Multi\-Process\-Controller )} -\/ Controller used to communicate data type of blocks. By default, the global controller is used. If you want another controller to be used, set it with this. If no controller is set, only the local blocks will be written to the meta-\/file.  
\item {\ttfamily vtk\-Multi\-Process\-Controller = obj.\-Get\-Controller ()} -\/ Controller used to communicate data type of blocks. By default, the global controller is used. If you want another controller to be used, set it with this. If no controller is set, only the local blocks will be written to the meta-\/file.  
\item {\ttfamily obj.\-Set\-Write\-Meta\-File (int flag)} -\/ Set whether this instance will write the meta-\/file. Write\-Meta\-File is set to flag only on process 0 and all other processes have Write\-Meta\-File set to 0 by default.  
\end{DoxyItemize}
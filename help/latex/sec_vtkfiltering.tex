
\begin{DoxyItemize}
\item \hyperlink{vtkfiltering_vtkabstractcelllocator}{vtk\-Abstract\-Cell\-Locator}  
\item \hyperlink{vtkfiltering_vtkabstractinterpolatedvelocityfield}{vtk\-Abstract\-Interpolated\-Velocity\-Field}  
\item \hyperlink{vtkfiltering_vtkabstractmapper}{vtk\-Abstract\-Mapper}  
\item \hyperlink{vtkfiltering_vtkabstractpointlocator}{vtk\-Abstract\-Point\-Locator}  
\item \hyperlink{vtkfiltering_vtkactor2d}{vtk\-Actor2\-D}  
\item \hyperlink{vtkfiltering_vtkactor2dcollection}{vtk\-Actor2\-D\-Collection}  
\item \hyperlink{vtkfiltering_vtkadjacentvertexiterator}{vtk\-Adjacent\-Vertex\-Iterator}  
\item \hyperlink{vtkfiltering_vtkalgorithm}{vtk\-Algorithm}  
\item \hyperlink{vtkfiltering_vtkalgorithmoutput}{vtk\-Algorithm\-Output}  
\item \hyperlink{vtkfiltering_vtkannotation}{vtk\-Annotation}  
\item \hyperlink{vtkfiltering_vtkannotationlayers}{vtk\-Annotation\-Layers}  
\item \hyperlink{vtkfiltering_vtkannotationlayersalgorithm}{vtk\-Annotation\-Layers\-Algorithm}  
\item \hyperlink{vtkfiltering_vtkarraydata}{vtk\-Array\-Data}  
\item \hyperlink{vtkfiltering_vtkarraydataalgorithm}{vtk\-Array\-Data\-Algorithm}  
\item \hyperlink{vtkfiltering_vtkattributeserrormetric}{vtk\-Attributes\-Error\-Metric}  
\item \hyperlink{vtkfiltering_vtkbiquadraticquad}{vtk\-Bi\-Quadratic\-Quad}  
\item \hyperlink{vtkfiltering_vtkbiquadraticquadratichexahedron}{vtk\-Bi\-Quadratic\-Quadratic\-Hexahedron}  
\item \hyperlink{vtkfiltering_vtkbiquadraticquadraticwedge}{vtk\-Bi\-Quadratic\-Quadratic\-Wedge}  
\item \hyperlink{vtkfiltering_vtkbiquadratictriangle}{vtk\-Bi\-Quadratic\-Triangle}  
\item \hyperlink{vtkfiltering_vtkbspcuts}{vtk\-B\-S\-P\-Cuts}  
\item \hyperlink{vtkfiltering_vtkbspintersections}{vtk\-B\-S\-P\-Intersections}  
\item \hyperlink{vtkfiltering_vtkcachedstreamingdemanddrivenpipeline}{vtk\-Cached\-Streaming\-Demand\-Driven\-Pipeline}  
\item \hyperlink{vtkfiltering_vtkcardinalspline}{vtk\-Cardinal\-Spline}  
\item \hyperlink{vtkfiltering_vtkcasttoconcrete}{vtk\-Cast\-To\-Concrete}  
\item \hyperlink{vtkfiltering_vtkcell}{vtk\-Cell}  
\item \hyperlink{vtkfiltering_vtkcell3d}{vtk\-Cell3\-D}  
\item \hyperlink{vtkfiltering_vtkcellarray}{vtk\-Cell\-Array}  
\item \hyperlink{vtkfiltering_vtkcelldata}{vtk\-Cell\-Data}  
\item \hyperlink{vtkfiltering_vtkcelllinks}{vtk\-Cell\-Links}  
\item \hyperlink{vtkfiltering_vtkcelllocator}{vtk\-Cell\-Locator}  
\item \hyperlink{vtkfiltering_vtkcelllocatorinterpolatedvelocityfield}{vtk\-Cell\-Locator\-Interpolated\-Velocity\-Field}  
\item \hyperlink{vtkfiltering_vtkcelltypes}{vtk\-Cell\-Types}  
\item \hyperlink{vtkfiltering_vtkcolortransferfunction}{vtk\-Color\-Transfer\-Function}  
\item \hyperlink{vtkfiltering_vtkcompositedataiterator}{vtk\-Composite\-Data\-Iterator}  
\item \hyperlink{vtkfiltering_vtkcompositedatapipeline}{vtk\-Composite\-Data\-Pipeline}  
\item \hyperlink{vtkfiltering_vtkcompositedataset}{vtk\-Composite\-Data\-Set}  
\item \hyperlink{vtkfiltering_vtkcompositedatasetalgorithm}{vtk\-Composite\-Data\-Set\-Algorithm}  
\item \hyperlink{vtkfiltering_vtkcone}{vtk\-Cone}  
\item \hyperlink{vtkfiltering_vtkconvexpointset}{vtk\-Convex\-Point\-Set}  
\item \hyperlink{vtkfiltering_vtkcoordinate}{vtk\-Coordinate}  
\item \hyperlink{vtkfiltering_vtkcubicline}{vtk\-Cubic\-Line}  
\item \hyperlink{vtkfiltering_vtkcylinder}{vtk\-Cylinder}  
\item \hyperlink{vtkfiltering_vtkdataobject}{vtk\-Data\-Object}  
\item \hyperlink{vtkfiltering_vtkdataobjectalgorithm}{vtk\-Data\-Object\-Algorithm}  
\item \hyperlink{vtkfiltering_vtkdataobjectcollection}{vtk\-Data\-Object\-Collection}  
\item \hyperlink{vtkfiltering_vtkdataobjectsource}{vtk\-Data\-Object\-Source}  
\item \hyperlink{vtkfiltering_vtkdataobjecttypes}{vtk\-Data\-Object\-Types}  
\item \hyperlink{vtkfiltering_vtkdataset}{vtk\-Data\-Set}  
\item \hyperlink{vtkfiltering_vtkdatasetalgorithm}{vtk\-Data\-Set\-Algorithm}  
\item \hyperlink{vtkfiltering_vtkdatasetattributes}{vtk\-Data\-Set\-Attributes}  
\item \hyperlink{vtkfiltering_vtkdatasetcollection}{vtk\-Data\-Set\-Collection}  
\item \hyperlink{vtkfiltering_vtkdatasetsource}{vtk\-Data\-Set\-Source}  
\item \hyperlink{vtkfiltering_vtkdatasettodatasetfilter}{vtk\-Data\-Set\-To\-Data\-Set\-Filter}  
\item \hyperlink{vtkfiltering_vtkdatasettoimagefilter}{vtk\-Data\-Set\-To\-Image\-Filter}  
\item \hyperlink{vtkfiltering_vtkdatasettopolydatafilter}{vtk\-Data\-Set\-To\-Poly\-Data\-Filter}  
\item \hyperlink{vtkfiltering_vtkdatasettostructuredgridfilter}{vtk\-Data\-Set\-To\-Structured\-Grid\-Filter}  
\item \hyperlink{vtkfiltering_vtkdatasettostructuredpointsfilter}{vtk\-Data\-Set\-To\-Structured\-Points\-Filter}  
\item \hyperlink{vtkfiltering_vtkdatasettounstructuredgridfilter}{vtk\-Data\-Set\-To\-Unstructured\-Grid\-Filter}  
\item \hyperlink{vtkfiltering_vtkdemanddrivenpipeline}{vtk\-Demand\-Driven\-Pipeline}  
\item \hyperlink{vtkfiltering_vtkdirectedacyclicgraph}{vtk\-Directed\-Acyclic\-Graph}  
\item \hyperlink{vtkfiltering_vtkdirectedgraph}{vtk\-Directed\-Graph}  
\item \hyperlink{vtkfiltering_vtkdirectedgraphalgorithm}{vtk\-Directed\-Graph\-Algorithm}  
\item \hyperlink{vtkfiltering_vtkdiscretizablecolortransferfunction}{vtk\-Discretizable\-Color\-Transfer\-Function}  
\item \hyperlink{vtkfiltering_vtkdistributedgraphhelper}{vtk\-Distributed\-Graph\-Helper}  
\item \hyperlink{vtkfiltering_vtkedgelistiterator}{vtk\-Edge\-List\-Iterator}  
\item \hyperlink{vtkfiltering_vtkemptycell}{vtk\-Empty\-Cell}  
\item \hyperlink{vtkfiltering_vtkexecutive}{vtk\-Executive}  
\item \hyperlink{vtkfiltering_vtkexecutivecollection}{vtk\-Executive\-Collection}  
\item \hyperlink{vtkfiltering_vtkexplicitcell}{vtk\-Explicit\-Cell}  
\item \hyperlink{vtkfiltering_vtkfielddata}{vtk\-Field\-Data}  
\item \hyperlink{vtkfiltering_vtkgenericadaptorcell}{vtk\-Generic\-Adaptor\-Cell}  
\item \hyperlink{vtkfiltering_vtkgenericattribute}{vtk\-Generic\-Attribute}  
\item \hyperlink{vtkfiltering_vtkgenericattributecollection}{vtk\-Generic\-Attribute\-Collection}  
\item \hyperlink{vtkfiltering_vtkgenericcell}{vtk\-Generic\-Cell}  
\item \hyperlink{vtkfiltering_vtkgenericcelliterator}{vtk\-Generic\-Cell\-Iterator}  
\item \hyperlink{vtkfiltering_vtkgenericcelltessellator}{vtk\-Generic\-Cell\-Tessellator}  
\item \hyperlink{vtkfiltering_vtkgenericdataset}{vtk\-Generic\-Data\-Set}  
\item \hyperlink{vtkfiltering_vtkgenericdatasetalgorithm}{vtk\-Generic\-Data\-Set\-Algorithm}  
\item \hyperlink{vtkfiltering_vtkgenericedgetable}{vtk\-Generic\-Edge\-Table}  
\item \hyperlink{vtkfiltering_vtkgenericinterpolatedvelocityfield}{vtk\-Generic\-Interpolated\-Velocity\-Field}  
\item \hyperlink{vtkfiltering_vtkgenericpointiterator}{vtk\-Generic\-Point\-Iterator}  
\item \hyperlink{vtkfiltering_vtkgenericsubdivisionerrormetric}{vtk\-Generic\-Subdivision\-Error\-Metric}  
\item \hyperlink{vtkfiltering_vtkgeometricerrormetric}{vtk\-Geometric\-Error\-Metric}  
\item \hyperlink{vtkfiltering_vtkgraph}{vtk\-Graph}  
\item \hyperlink{vtkfiltering_vtkgraphalgorithm}{vtk\-Graph\-Algorithm}  
\item \hyperlink{vtkfiltering_vtkgraphedge}{vtk\-Graph\-Edge}  
\item \hyperlink{vtkfiltering_vtkgraphinternals}{vtk\-Graph\-Internals}  
\item \hyperlink{vtkfiltering_vtkhexagonalprism}{vtk\-Hexagonal\-Prism}  
\item \hyperlink{vtkfiltering_vtkhexahedron}{vtk\-Hexahedron}  
\item \hyperlink{vtkfiltering_vtkhierarchicalboxdataiterator}{vtk\-Hierarchical\-Box\-Data\-Iterator}  
\item \hyperlink{vtkfiltering_vtkhierarchicalboxdataset}{vtk\-Hierarchical\-Box\-Data\-Set}  
\item \hyperlink{vtkfiltering_vtkhierarchicalboxdatasetalgorithm}{vtk\-Hierarchical\-Box\-Data\-Set\-Algorithm}  
\item \hyperlink{vtkfiltering_vtkhyperoctree}{vtk\-Hyper\-Octree}  
\item \hyperlink{vtkfiltering_vtkhyperoctreealgorithm}{vtk\-Hyper\-Octree\-Algorithm}  
\item \hyperlink{vtkfiltering_vtkhyperoctreecursor}{vtk\-Hyper\-Octree\-Cursor}  
\item \hyperlink{vtkfiltering_vtkimagealgorithm}{vtk\-Image\-Algorithm}  
\item \hyperlink{vtkfiltering_vtkimagedata}{vtk\-Image\-Data}  
\item \hyperlink{vtkfiltering_vtkimageinplacefilter}{vtk\-Image\-In\-Place\-Filter}  
\item \hyperlink{vtkfiltering_vtkimagemultipleinputfilter}{vtk\-Image\-Multiple\-Input\-Filter}  
\item \hyperlink{vtkfiltering_vtkimagemultipleinputoutputfilter}{vtk\-Image\-Multiple\-Input\-Output\-Filter}  
\item \hyperlink{vtkfiltering_vtkimagesource}{vtk\-Image\-Source}  
\item \hyperlink{vtkfiltering_vtkimagetoimagefilter}{vtk\-Image\-To\-Image\-Filter}  
\item \hyperlink{vtkfiltering_vtkimagetostructuredpoints}{vtk\-Image\-To\-Structured\-Points}  
\item \hyperlink{vtkfiltering_vtkimagetwoinputfilter}{vtk\-Image\-Two\-Input\-Filter}  
\item \hyperlink{vtkfiltering_vtkimplicitboolean}{vtk\-Implicit\-Boolean}  
\item \hyperlink{vtkfiltering_vtkimplicitdataset}{vtk\-Implicit\-Data\-Set}  
\item \hyperlink{vtkfiltering_vtkimplicithalo}{vtk\-Implicit\-Halo}  
\item \hyperlink{vtkfiltering_vtkimplicitselectionloop}{vtk\-Implicit\-Selection\-Loop}  
\item \hyperlink{vtkfiltering_vtkimplicitsum}{vtk\-Implicit\-Sum}  
\item \hyperlink{vtkfiltering_vtkimplicitvolume}{vtk\-Implicit\-Volume}  
\item \hyperlink{vtkfiltering_vtkimplicitwindowfunction}{vtk\-Implicit\-Window\-Function}  
\item \hyperlink{vtkfiltering_vtkincrementaloctreenode}{vtk\-Incremental\-Octree\-Node}  
\item \hyperlink{vtkfiltering_vtkincrementaloctreepointlocator}{vtk\-Incremental\-Octree\-Point\-Locator}  
\item \hyperlink{vtkfiltering_vtkincrementalpointlocator}{vtk\-Incremental\-Point\-Locator}  
\item \hyperlink{vtkfiltering_vtkinedgeiterator}{vtk\-In\-Edge\-Iterator}  
\item \hyperlink{vtkfiltering_vtkinformationexecutiveportkey}{vtk\-Information\-Executive\-Port\-Key}  
\item \hyperlink{vtkfiltering_vtkinformationexecutiveportvectorkey}{vtk\-Information\-Executive\-Port\-Vector\-Key}  
\item \hyperlink{vtkfiltering_vtkinterpolatedvelocityfield}{vtk\-Interpolated\-Velocity\-Field}  
\item \hyperlink{vtkfiltering_vtkkdnode}{vtk\-Kd\-Node}  
\item \hyperlink{vtkfiltering_vtkkdtree}{vtk\-Kd\-Tree}  
\item \hyperlink{vtkfiltering_vtkkdtreepointlocator}{vtk\-Kd\-Tree\-Point\-Locator}  
\item \hyperlink{vtkfiltering_vtkkochanekspline}{vtk\-Kochanek\-Spline}  
\item \hyperlink{vtkfiltering_vtkline}{vtk\-Line}  
\item \hyperlink{vtkfiltering_vtklocator}{vtk\-Locator}  
\item \hyperlink{vtkfiltering_vtkmapper2d}{vtk\-Mapper2\-D}  
\item \hyperlink{vtkfiltering_vtkmergepoints}{vtk\-Merge\-Points}  
\item \hyperlink{vtkfiltering_vtkmodifiedbsptree}{vtk\-Modified\-B\-S\-P\-Tree}  
\item \hyperlink{vtkfiltering_vtkmultiblockdataset}{vtk\-Multi\-Block\-Data\-Set}  
\item \hyperlink{vtkfiltering_vtkmultiblockdatasetalgorithm}{vtk\-Multi\-Block\-Data\-Set\-Algorithm}  
\item \hyperlink{vtkfiltering_vtkmultipiecedataset}{vtk\-Multi\-Piece\-Data\-Set}  
\item \hyperlink{vtkfiltering_vtkmutabledirectedgraph}{vtk\-Mutable\-Directed\-Graph}  
\item \hyperlink{vtkfiltering_vtkmutableundirectedgraph}{vtk\-Mutable\-Undirected\-Graph}  
\item \hyperlink{vtkfiltering_vtknonlinearcell}{vtk\-Non\-Linear\-Cell}  
\item \hyperlink{vtkfiltering_vtknonmergingpointlocator}{vtk\-Non\-Merging\-Point\-Locator}  
\item \hyperlink{vtkfiltering_vtkoctreepointlocator}{vtk\-Octree\-Point\-Locator}  
\item \hyperlink{vtkfiltering_vtkoctreepointlocatornode}{vtk\-Octree\-Point\-Locator\-Node}  
\item \hyperlink{vtkfiltering_vtkorderedtriangulator}{vtk\-Ordered\-Triangulator}  
\item \hyperlink{vtkfiltering_vtkoutedgeiterator}{vtk\-Out\-Edge\-Iterator}  
\item \hyperlink{vtkfiltering_vtkparametricspline}{vtk\-Parametric\-Spline}  
\item \hyperlink{vtkfiltering_vtkpassinputtypealgorithm}{vtk\-Pass\-Input\-Type\-Algorithm}  
\item \hyperlink{vtkfiltering_vtkpentagonalprism}{vtk\-Pentagonal\-Prism}  
\item \hyperlink{vtkfiltering_vtkperlinnoise}{vtk\-Perlin\-Noise}  
\item \hyperlink{vtkfiltering_vtkpiecewisefunction}{vtk\-Piecewise\-Function}  
\item \hyperlink{vtkfiltering_vtkpiecewisefunctionalgorithm}{vtk\-Piecewise\-Function\-Algorithm}  
\item \hyperlink{vtkfiltering_vtkpiecewisefunctionshiftscale}{vtk\-Piecewise\-Function\-Shift\-Scale}  
\item \hyperlink{vtkfiltering_vtkpixel}{vtk\-Pixel}  
\item \hyperlink{vtkfiltering_vtkplanesintersection}{vtk\-Planes\-Intersection}  
\item \hyperlink{vtkfiltering_vtkpointdata}{vtk\-Point\-Data}  
\item \hyperlink{vtkfiltering_vtkpointlocator}{vtk\-Point\-Locator}  
\item \hyperlink{vtkfiltering_vtkpointset}{vtk\-Point\-Set}  
\item \hyperlink{vtkfiltering_vtkpointsetalgorithm}{vtk\-Point\-Set\-Algorithm}  
\item \hyperlink{vtkfiltering_vtkpointsetsource}{vtk\-Point\-Set\-Source}  
\item \hyperlink{vtkfiltering_vtkpointsettopointsetfilter}{vtk\-Point\-Set\-To\-Point\-Set\-Filter}  
\item \hyperlink{vtkfiltering_vtkpointsprojectedhull}{vtk\-Points\-Projected\-Hull}  
\item \hyperlink{vtkfiltering_vtkpolydata}{vtk\-Poly\-Data}  
\item \hyperlink{vtkfiltering_vtkpolydataalgorithm}{vtk\-Poly\-Data\-Algorithm}  
\item \hyperlink{vtkfiltering_vtkpolydatacollection}{vtk\-Poly\-Data\-Collection}  
\item \hyperlink{vtkfiltering_vtkpolydatasource}{vtk\-Poly\-Data\-Source}  
\item \hyperlink{vtkfiltering_vtkpolydatatopolydatafilter}{vtk\-Poly\-Data\-To\-Poly\-Data\-Filter}  
\item \hyperlink{vtkfiltering_vtkpolygon}{vtk\-Polygon}  
\item \hyperlink{vtkfiltering_vtkpolyline}{vtk\-Poly\-Line}  
\item \hyperlink{vtkfiltering_vtkpolyvertex}{vtk\-Poly\-Vertex}  
\item \hyperlink{vtkfiltering_vtkprocessobject}{vtk\-Process\-Object}  
\item \hyperlink{vtkfiltering_vtkpropassembly}{vtk\-Prop\-Assembly}  
\item \hyperlink{vtkfiltering_vtkpyramid}{vtk\-Pyramid}  
\item \hyperlink{vtkfiltering_vtkquad}{vtk\-Quad}  
\item \hyperlink{vtkfiltering_vtkquadraticedge}{vtk\-Quadratic\-Edge}  
\item \hyperlink{vtkfiltering_vtkquadratichexahedron}{vtk\-Quadratic\-Hexahedron}  
\item \hyperlink{vtkfiltering_vtkquadraticlinearquad}{vtk\-Quadratic\-Linear\-Quad}  
\item \hyperlink{vtkfiltering_vtkquadraticlinearwedge}{vtk\-Quadratic\-Linear\-Wedge}  
\item \hyperlink{vtkfiltering_vtkquadraticpyramid}{vtk\-Quadratic\-Pyramid}  
\item \hyperlink{vtkfiltering_vtkquadraticquad}{vtk\-Quadratic\-Quad}  
\item \hyperlink{vtkfiltering_vtkquadratictetra}{vtk\-Quadratic\-Tetra}  
\item \hyperlink{vtkfiltering_vtkquadratictriangle}{vtk\-Quadratic\-Triangle}  
\item \hyperlink{vtkfiltering_vtkquadraticwedge}{vtk\-Quadratic\-Wedge}  
\item \hyperlink{vtkfiltering_vtkrectilineargrid}{vtk\-Rectilinear\-Grid}  
\item \hyperlink{vtkfiltering_vtkrectilineargridalgorithm}{vtk\-Rectilinear\-Grid\-Algorithm}  
\item \hyperlink{vtkfiltering_vtkrectilineargridsource}{vtk\-Rectilinear\-Grid\-Source}  
\item \hyperlink{vtkfiltering_vtkrectilineargridtopolydatafilter}{vtk\-Rectilinear\-Grid\-To\-Poly\-Data\-Filter}  
\item \hyperlink{vtkfiltering_vtkscalartree}{vtk\-Scalar\-Tree}  
\item \hyperlink{vtkfiltering_vtkselection}{vtk\-Selection}  
\item \hyperlink{vtkfiltering_vtkselectionalgorithm}{vtk\-Selection\-Algorithm}  
\item \hyperlink{vtkfiltering_vtkselectionnode}{vtk\-Selection\-Node}  
\item \hyperlink{vtkfiltering_vtksimplecelltessellator}{vtk\-Simple\-Cell\-Tessellator}  
\item \hyperlink{vtkfiltering_vtksimpleimagetoimagefilter}{vtk\-Simple\-Image\-To\-Image\-Filter}  
\item \hyperlink{vtkfiltering_vtksimplescalartree}{vtk\-Simple\-Scalar\-Tree}  
\item \hyperlink{vtkfiltering_vtksmootherrormetric}{vtk\-Smooth\-Error\-Metric}  
\item \hyperlink{vtkfiltering_vtksource}{vtk\-Source}  
\item \hyperlink{vtkfiltering_vtksphere}{vtk\-Sphere}  
\item \hyperlink{vtkfiltering_vtkspline}{vtk\-Spline}  
\item \hyperlink{vtkfiltering_vtkstreamingdemanddrivenpipeline}{vtk\-Streaming\-Demand\-Driven\-Pipeline}  
\item \hyperlink{vtkfiltering_vtkstructuredgrid}{vtk\-Structured\-Grid}  
\item \hyperlink{vtkfiltering_vtkstructuredgridalgorithm}{vtk\-Structured\-Grid\-Algorithm}  
\item \hyperlink{vtkfiltering_vtkstructuredgridsource}{vtk\-Structured\-Grid\-Source}  
\item \hyperlink{vtkfiltering_vtkstructuredgridtopolydatafilter}{vtk\-Structured\-Grid\-To\-Poly\-Data\-Filter}  
\item \hyperlink{vtkfiltering_vtkstructuredgridtostructuredgridfilter}{vtk\-Structured\-Grid\-To\-Structured\-Grid\-Filter}  
\item \hyperlink{vtkfiltering_vtkstructuredpoints}{vtk\-Structured\-Points}  
\item \hyperlink{vtkfiltering_vtkstructuredpointscollection}{vtk\-Structured\-Points\-Collection}  
\item \hyperlink{vtkfiltering_vtkstructuredpointssource}{vtk\-Structured\-Points\-Source}  
\item \hyperlink{vtkfiltering_vtkstructuredpointstopolydatafilter}{vtk\-Structured\-Points\-To\-Poly\-Data\-Filter}  
\item \hyperlink{vtkfiltering_vtkstructuredpointstostructuredpointsfilter}{vtk\-Structured\-Points\-To\-Structured\-Points\-Filter}  
\item \hyperlink{vtkfiltering_vtkstructuredpointstounstructuredgridfilter}{vtk\-Structured\-Points\-To\-Unstructured\-Grid\-Filter}  
\item \hyperlink{vtkfiltering_vtksuperquadric}{vtk\-Superquadric}  
\item \hyperlink{vtkfiltering_vtktable}{vtk\-Table}  
\item \hyperlink{vtkfiltering_vtktablealgorithm}{vtk\-Table\-Algorithm}  
\item \hyperlink{vtkfiltering_vtktemporaldataset}{vtk\-Temporal\-Data\-Set}  
\item \hyperlink{vtkfiltering_vtktemporaldatasetalgorithm}{vtk\-Temporal\-Data\-Set\-Algorithm}  
\item \hyperlink{vtkfiltering_vtktetra}{vtk\-Tetra}  
\item \hyperlink{vtkfiltering_vtkthreadedimagealgorithm}{vtk\-Threaded\-Image\-Algorithm}  
\item \hyperlink{vtkfiltering_vtktree}{vtk\-Tree}  
\item \hyperlink{vtkfiltering_vtktreealgorithm}{vtk\-Tree\-Algorithm}  
\item \hyperlink{vtkfiltering_vtktreedfsiterator}{vtk\-Tree\-D\-F\-S\-Iterator}  
\item \hyperlink{vtkfiltering_vtktriangle}{vtk\-Triangle}  
\item \hyperlink{vtkfiltering_vtktrianglestrip}{vtk\-Triangle\-Strip}  
\item \hyperlink{vtkfiltering_vtktriquadratichexahedron}{vtk\-Tri\-Quadratic\-Hexahedron}  
\item \hyperlink{vtkfiltering_vtktrivialproducer}{vtk\-Trivial\-Producer}  
\item \hyperlink{vtkfiltering_vtkundirectedgraph}{vtk\-Undirected\-Graph}  
\item \hyperlink{vtkfiltering_vtkundirectedgraphalgorithm}{vtk\-Undirected\-Graph\-Algorithm}  
\item \hyperlink{vtkfiltering_vtkuniformgrid}{vtk\-Uniform\-Grid}  
\item \hyperlink{vtkfiltering_vtkunstructuredgrid}{vtk\-Unstructured\-Grid}  
\item \hyperlink{vtkfiltering_vtkunstructuredgridalgorithm}{vtk\-Unstructured\-Grid\-Algorithm}  
\item \hyperlink{vtkfiltering_vtkunstructuredgridsource}{vtk\-Unstructured\-Grid\-Source}  
\item \hyperlink{vtkfiltering_vtkunstructuredgridtopolydatafilter}{vtk\-Unstructured\-Grid\-To\-Poly\-Data\-Filter}  
\item \hyperlink{vtkfiltering_vtkunstructuredgridtounstructuredgridfilter}{vtk\-Unstructured\-Grid\-To\-Unstructured\-Grid\-Filter}  
\item \hyperlink{vtkfiltering_vtkvertex}{vtk\-Vertex}  
\item \hyperlink{vtkfiltering_vtkvertexlistiterator}{vtk\-Vertex\-List\-Iterator}  
\item \hyperlink{vtkfiltering_vtkviewdependenterrormetric}{vtk\-View\-Dependent\-Error\-Metric}  
\item \hyperlink{vtkfiltering_vtkviewport}{vtk\-Viewport}  
\item \hyperlink{vtkfiltering_vtkvoxel}{vtk\-Voxel}  
\item \hyperlink{vtkfiltering_vtkwedge}{vtk\-Wedge}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkabstractcelllocator}{}\section{vtk\-Abstract\-Cell\-Locator}\label{vtkfiltering_vtkabstractcelllocator}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Abstract\-Cell\-Locator is a spatial search object to quickly locate cells in 3\-D. vtk\-Abstract\-Cell\-Locator supplies a basic interface which concrete subclasses should implement.

.S\-E\-C\-T\-I\-O\-N Warning When deriving a class from vtk\-Abstract\-Cell\-Locator, one should include the 'hidden' member functions by the following construct in the derived class \begin{DoxyVerb} //BTX
  using vtkAbstractCellLocator::IntersectWithLine;
  using vtkAbstractCellLocator::FindClosestPoint;
  using vtkAbstractCellLocator::FindClosestPointWithinRadius;
 //ETX\end{DoxyVerb}


To create an instance of class vtk\-Abstract\-Cell\-Locator, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkAbstractCellLocator
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Abstract\-Cell\-Locator has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Abstract\-Cell\-Locator class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Abstract\-Cell\-Locator = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Abstract\-Cell\-Locator = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Number\-Of\-Cells\-Per\-Node (int )} -\/ Specify the preferred/maximum number of cells in each node/bucket. Default 32. Locators generally operate by subdividing space into smaller regions until the number of cells in each region (or node) reaches the desired level.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Cells\-Per\-Node\-Min\-Value ()} -\/ Specify the preferred/maximum number of cells in each node/bucket. Default 32. Locators generally operate by subdividing space into smaller regions until the number of cells in each region (or node) reaches the desired level.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Cells\-Per\-Node\-Max\-Value ()} -\/ Specify the preferred/maximum number of cells in each node/bucket. Default 32. Locators generally operate by subdividing space into smaller regions until the number of cells in each region (or node) reaches the desired level.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Cells\-Per\-Node ()} -\/ Specify the preferred/maximum number of cells in each node/bucket. Default 32. Locators generally operate by subdividing space into smaller regions until the number of cells in each region (or node) reaches the desired level.  
\item {\ttfamily obj.\-Set\-Cache\-Cell\-Bounds (int )} -\/ Boolean controls whether the bounds of each cell are computed only once and then saved. Should be 10 to 20\% faster if repeatedly calling any of the Intersect/\-Find routines and the extra memory won't cause disk caching (24 extra bytes per cell are required to save the bounds).  
\item {\ttfamily int = obj.\-Get\-Cache\-Cell\-Bounds ()} -\/ Boolean controls whether the bounds of each cell are computed only once and then saved. Should be 10 to 20\% faster if repeatedly calling any of the Intersect/\-Find routines and the extra memory won't cause disk caching (24 extra bytes per cell are required to save the bounds).  
\item {\ttfamily obj.\-Cache\-Cell\-Bounds\-On ()} -\/ Boolean controls whether the bounds of each cell are computed only once and then saved. Should be 10 to 20\% faster if repeatedly calling any of the Intersect/\-Find routines and the extra memory won't cause disk caching (24 extra bytes per cell are required to save the bounds).  
\item {\ttfamily obj.\-Cache\-Cell\-Bounds\-Off ()} -\/ Boolean controls whether the bounds of each cell are computed only once and then saved. Should be 10 to 20\% faster if repeatedly calling any of the Intersect/\-Find routines and the extra memory won't cause disk caching (24 extra bytes per cell are required to save the bounds).  
\item {\ttfamily obj.\-Set\-Retain\-Cell\-Lists (int )} -\/ Boolean controls whether to maintain list of cells in each node. not applicable to all implementations, but if the locator is being used as a geometry simplification technique, there is no need to keep them.  
\item {\ttfamily int = obj.\-Get\-Retain\-Cell\-Lists ()} -\/ Boolean controls whether to maintain list of cells in each node. not applicable to all implementations, but if the locator is being used as a geometry simplification technique, there is no need to keep them.  
\item {\ttfamily obj.\-Retain\-Cell\-Lists\-On ()} -\/ Boolean controls whether to maintain list of cells in each node. not applicable to all implementations, but if the locator is being used as a geometry simplification technique, there is no need to keep them.  
\item {\ttfamily obj.\-Retain\-Cell\-Lists\-Off ()} -\/ Boolean controls whether to maintain list of cells in each node. not applicable to all implementations, but if the locator is being used as a geometry simplification technique, there is no need to keep them.  
\item {\ttfamily obj.\-Set\-Lazy\-Evaluation (int )} -\/ Most Locators build their search structures during Build\-Locator but some may delay construction until it is actually needed. If Lazy\-Evaluation is supported, this turns on/off the feature. if not supported, it is ignored.  
\item {\ttfamily int = obj.\-Get\-Lazy\-Evaluation ()} -\/ Most Locators build their search structures during Build\-Locator but some may delay construction until it is actually needed. If Lazy\-Evaluation is supported, this turns on/off the feature. if not supported, it is ignored.  
\item {\ttfamily obj.\-Lazy\-Evaluation\-On ()} -\/ Most Locators build their search structures during Build\-Locator but some may delay construction until it is actually needed. If Lazy\-Evaluation is supported, this turns on/off the feature. if not supported, it is ignored.  
\item {\ttfamily obj.\-Lazy\-Evaluation\-Off ()} -\/ Most Locators build their search structures during Build\-Locator but some may delay construction until it is actually needed. If Lazy\-Evaluation is supported, this turns on/off the feature. if not supported, it is ignored.  
\item {\ttfamily obj.\-Set\-Use\-Existing\-Search\-Structure (int )} -\/ Some locators support querying a new dataset without rebuilding the search structure (typically this may occur when a dataset changes due to a time update, but is actually the same topology) Turning on this flag enables some locators to skip the rebuilding phase  
\item {\ttfamily int = obj.\-Get\-Use\-Existing\-Search\-Structure ()} -\/ Some locators support querying a new dataset without rebuilding the search structure (typically this may occur when a dataset changes due to a time update, but is actually the same topology) Turning on this flag enables some locators to skip the rebuilding phase  
\item {\ttfamily obj.\-Use\-Existing\-Search\-Structure\-On ()} -\/ Some locators support querying a new dataset without rebuilding the search structure (typically this may occur when a dataset changes due to a time update, but is actually the same topology) Turning on this flag enables some locators to skip the rebuilding phase  
\item {\ttfamily obj.\-Use\-Existing\-Search\-Structure\-Off ()} -\/ Some locators support querying a new dataset without rebuilding the search structure (typically this may occur when a dataset changes due to a time update, but is actually the same topology) Turning on this flag enables some locators to skip the rebuilding phase  
\item {\ttfamily int = obj.\-Intersect\-With\-Line (double p1\mbox{[}3\mbox{]}, double p2\mbox{[}3\mbox{]}, vtk\-Points points, vtk\-Id\-List cell\-Ids)} -\/ Take the passed line segment and intersect it with the data set. This method assumes that the data set is a vtk\-Poly\-Data that describes a closed surface, and the intersection points that are returned in 'points' alternate between entrance points and exit points. The return value of the function is 0 if no intersections were found, -\/1 if point 'a0' lies inside the closed surface, or +1 if point 'a0' lies outside the closed surface. Either 'points' or 'cell\-Ids' can be set to N\-U\-L\-L if you don't want to receive that information. This method is currently only implemented in vtk\-O\-B\-B\-Tree  
\item {\ttfamily obj.\-Find\-Cells\-Within\-Bounds (double bbox, vtk\-Id\-List cells)} -\/ Return a list of unique cell ids inside of a given bounding box. The user must provide the vtk\-Id\-List to populate. This method returns data only after the locator has been built.  
\item {\ttfamily obj.\-Find\-Cells\-Along\-Line (double p1\mbox{[}3\mbox{]}, double p2\mbox{[}3\mbox{]}, double tolerance, vtk\-Id\-List cells)} -\/ Given a finite line defined by the two points (p1,p2), return the list of unique cell ids in the buckets containing the line. It is possible that an empty cell list is returned. The user must provide the vtk\-Id\-List to populate. This method returns data only after the locator has been built.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Find\-Cell (double x\mbox{[}3\mbox{]})} -\/ Returns the Id of the cell containing the point, returns -\/1 if no cell found. This interface uses a tolerance of zero  
\item {\ttfamily vtk\-Id\-Type = obj.\-Find\-Cell (double x\mbox{[}3\mbox{]}, double tol2, vtk\-Generic\-Cell Gen\-Cell, double pcoords\mbox{[}3\mbox{]}, double weights)} -\/ Find the cell containing a given point. returns -\/1 if no cell found the cell parameters are copied into the supplied variables, a cell must be provided to store the information.  
\item {\ttfamily bool = obj.\-Inside\-Cell\-Bounds (double x\mbox{[}3\mbox{]}, vtk\-Id\-Type cell\-\_\-\-I\-D)} -\/ Quickly test if a point is inside the bounds of a particular cell. Some locators cache cell bounds and this function can make use of fast access to the data.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkabstractinterpolatedvelocityfield}{}\section{vtk\-Abstract\-Interpolated\-Velocity\-Field}\label{vtkfiltering_vtkabstractinterpolatedvelocityfield}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Abstract\-Interpolated\-Velocity\-Field acts as a continuous velocity field by performing cell interpolation on the underlying vtk\-Data\-Set. This is an abstract sub-\/class of vtk\-Function\-Set, Number\-Of\-Independent\-Variables = 4 (x,y,z,t) and Number\-Of\-Functions = 3 (u,v,w). With a brute-\/force scheme, every time an evaluation is performed, the target cell containing point (x,y,z) needs to be found by calling Find\-Cell(), via either vtk\-Data\-Set or vtk\-Abstract\-Celllocator's sub-\/classes (vtk\-Cell\-Locator \& vtk\-Modified\-B\-S\-P\-Tree). As it incurs a large cost, one (for vtk\-Cell\-Locator\-Interpolated\-Velocity\-Field via vtk\-Abstract\-Cell\-Locator) or two (for vtk\-Interpolated\-Velocity\-Field via vtk\-Data\-Set that involves vtk\-Point\-Locator in addressing vtk\-Point\-Set) levels of cell caching may be exploited to increase the performance.

For vtk\-Interpolated\-Velocity\-Field, level \#0 begins with intra-\/cell caching. Specifically if the previous cell is valid and the next point is still in it ( i.\-e., vtk\-Cell\-::\-Evaluate\-Position() returns 1, coupled with newly created parametric coordinates \& weights ), the function values can be interpolated and only vtk\-Cell\-::\-Evaluate\-Position() is invoked. If this fails, then level \#1 follows by inter-\/cell search for the target cell that contains the next point. By an inter-\/cell search, the previous cell provides an important clue or serves as an immediate neighbor to aid in locating the target cell via vtk\-Point\-Set\-:\-: Find\-Cell(). If this still fails, a global cell location / search is invoked via vtk\-Point\-Set\-::\-Find\-Cell(). Here regardless of either inter-\/cell or global search, vtk\-Point\-Locator is in fact employed (for datasets of type vtk\-Point\-Set only, note vtk\-Image\-Data and vtk\-Rectilinear\-Grid are able to provide rapid and robust cell location due to the simple mesh topology) as a crucial tool underlying the cell locator. However, the use of vtk\-Point\-Locator makes vtk\-Interpolated\-Velocity\-Field non-\/robust in cell location for vtk\-Point\-Set.

For vtk\-Cell\-Locator\-Interpolated\-Velocity\-Field, the only caching (level \#0) works by intra-\/cell trial. In case of failure, a global search for the target cell is invoked via vtk\-Abstract\-Cell\-Locator\-::\-Find\-Cell() and the actual work is done by either vtk\-Cell\-Locator or vtk\-Modified\-B\-S\-P\-Tree (for datasets of type vtk\-Point\-Set only, while vtk\-Image\-Data and vtk\-Rectilinear\-Grid themselves are able to provide fast robust cell location). Without the involvement of vtk\-Point\-Locator, robust cell location is achieved for vtk\-Point\-Set.

To create an instance of class vtk\-Abstract\-Interpolated\-Velocity\-Field, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkAbstractInterpolatedVelocityField
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Abstract\-Interpolated\-Velocity\-Field has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Abstract\-Interpolated\-Velocity\-Field class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Abstract\-Interpolated\-Velocity\-Field = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Abstract\-Interpolated\-Velocity\-Field = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Caching (bool )} -\/ Set/\-Get the caching flag. If this flag is turned O\-N, there are two levels of caching for derived concrete class vtk\-Interpolated\-Velocity\-Field and one level of caching for derived concrete class vtk\-Cell\-Locator\-Interpolated\-Velocity\-Field. Otherwise a global cell location is always invoked for evaluating the function values at any point.  
\item {\ttfamily bool = obj.\-Get\-Caching ()} -\/ Set/\-Get the caching flag. If this flag is turned O\-N, there are two levels of caching for derived concrete class vtk\-Interpolated\-Velocity\-Field and one level of caching for derived concrete class vtk\-Cell\-Locator\-Interpolated\-Velocity\-Field. Otherwise a global cell location is always invoked for evaluating the function values at any point.  
\item {\ttfamily int = obj.\-Get\-Cache\-Hit ()} -\/ Get the caching statistics. Cache\-Hit refers to the number of level \#0 cache hits while Cache\-Miss is the number of level \#0 cache misses.  
\item {\ttfamily int = obj.\-Get\-Cache\-Miss ()} -\/ Get the caching statistics. Cache\-Hit refers to the number of level \#0 cache hits while Cache\-Miss is the number of level \#0 cache misses.  
\item {\ttfamily int = obj.\-Get\-Last\-Data\-Set\-Index ()} -\/ Get the most recently visited dataset and it id. The dataset is used for a guess regarding where the next point will be, without searching through all datasets. When setting the last dataset, care is needed as no reference counting or checks are performed. This feature is intended for custom interpolators only that cache datasets independently.  
\item {\ttfamily vtk\-Data\-Set = obj.\-Get\-Last\-Data\-Set ()} -\/ Get the most recently visited dataset and it id. The dataset is used for a guess regarding where the next point will be, without searching through all datasets. When setting the last dataset, care is needed as no reference counting or checks are performed. This feature is intended for custom interpolators only that cache datasets independently.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Last\-Cell\-Id ()} -\/ Get/\-Set the id of the cell cached from last evaluation.  
\item {\ttfamily obj.\-Set\-Last\-Cell\-Id (vtk\-Id\-Type c)} -\/ Set the id of the most recently visited cell of a dataset.  
\item {\ttfamily obj.\-Set\-Last\-Cell\-Id (vtk\-Id\-Type c, int dataindex)} -\/ Set the id of the most recently visited cell of a dataset.  
\item {\ttfamily string = obj.\-Get\-Vectors\-Selection ()} -\/ Get/\-Set the name of a spcified vector array. By default it is N\-U\-L\-L, with the active vector array for use.  
\item {\ttfamily obj.\-Select\-Vectors (string field\-Name)} -\/ Set/\-Get the flag indicating vector post-\/normalization (following vector interpolation). Vector post-\/normalization is required to avoid the 'curve-\/overshooting' problem (caused by high velocity magnitude) that occurs when Cell-\/\-Length is used as the step size unit (particularly the Minimum step size unit). Furthermore, it is required by R\-K45 to achieve, as expected, high numerical accuracy (or high smoothness of flow lines) through adaptive step sizing. Note this operation is performed (when Normalize\-Vector T\-R\-U\-E) right after vector interpolation such that the differing amount of contribution of each node (of a cell) to the resulting direction of the interpolated vector, due to the possibly significantly-\/differing velocity magnitude values at the nodes (which is the case with large cells), can be reflected as is. Also note that this flag needs to be turned to F\-A\-L\-S\-E after vtk\-Initial\-Value\-Problem\-Solver\-:\-: Compute\-Next\-Step() as subsequent operations, e.\-g., vorticity computation, may need non-\/normalized vectors.  
\item {\ttfamily obj.\-Set\-Normalize\-Vector (bool )} -\/ Set/\-Get the flag indicating vector post-\/normalization (following vector interpolation). Vector post-\/normalization is required to avoid the 'curve-\/overshooting' problem (caused by high velocity magnitude) that occurs when Cell-\/\-Length is used as the step size unit (particularly the Minimum step size unit). Furthermore, it is required by R\-K45 to achieve, as expected, high numerical accuracy (or high smoothness of flow lines) through adaptive step sizing. Note this operation is performed (when Normalize\-Vector T\-R\-U\-E) right after vector interpolation such that the differing amount of contribution of each node (of a cell) to the resulting direction of the interpolated vector, due to the possibly significantly-\/differing velocity magnitude values at the nodes (which is the case with large cells), can be reflected as is. Also note that this flag needs to be turned to F\-A\-L\-S\-E after vtk\-Initial\-Value\-Problem\-Solver\-:\-: Compute\-Next\-Step() as subsequent operations, e.\-g., vorticity computation, may need non-\/normalized vectors.  
\item {\ttfamily bool = obj.\-Get\-Normalize\-Vector ()} -\/ Set/\-Get the flag indicating vector post-\/normalization (following vector interpolation). Vector post-\/normalization is required to avoid the 'curve-\/overshooting' problem (caused by high velocity magnitude) that occurs when Cell-\/\-Length is used as the step size unit (particularly the Minimum step size unit). Furthermore, it is required by R\-K45 to achieve, as expected, high numerical accuracy (or high smoothness of flow lines) through adaptive step sizing. Note this operation is performed (when Normalize\-Vector T\-R\-U\-E) right after vector interpolation such that the differing amount of contribution of each node (of a cell) to the resulting direction of the interpolated vector, due to the possibly significantly-\/differing velocity magnitude values at the nodes (which is the case with large cells), can be reflected as is. Also note that this flag needs to be turned to F\-A\-L\-S\-E after vtk\-Initial\-Value\-Problem\-Solver\-:\-: Compute\-Next\-Step() as subsequent operations, e.\-g., vorticity computation, may need non-\/normalized vectors.  
\item {\ttfamily obj.\-Copy\-Parameters (vtk\-Abstract\-Interpolated\-Velocity\-Field from)} -\/ Add a dataset for implicit velocity function evaluation. If more than one dataset is added, the evaluation point is searched in all until a match is found. T\-H\-I\-S F\-U\-N\-C\-T\-I\-O\-N D\-O\-E\-S N\-O\-T C\-H\-A\-N\-G\-E T\-H\-E R\-E\-F\-E\-R\-E\-N\-C\-E C\-O\-U\-N\-T O\-F dataset F\-O\-R T\-H\-R\-E\-A\-D S\-A\-F\-E\-T\-Y R\-E\-A\-S\-O\-N\-S.  
\item {\ttfamily obj.\-Add\-Data\-Set (vtk\-Data\-Set dataset)} -\/ Add a dataset for implicit velocity function evaluation. If more than one dataset is added, the evaluation point is searched in all until a match is found. T\-H\-I\-S F\-U\-N\-C\-T\-I\-O\-N D\-O\-E\-S N\-O\-T C\-H\-A\-N\-G\-E T\-H\-E R\-E\-F\-E\-R\-E\-N\-C\-E C\-O\-U\-N\-T O\-F dataset F\-O\-R T\-H\-R\-E\-A\-D S\-A\-F\-E\-T\-Y R\-E\-A\-S\-O\-N\-S.  
\item {\ttfamily int = obj.\-Function\-Values (double x, double f)} -\/ Evaluate the velocity field f at point (x, y, z).  
\item {\ttfamily obj.\-Clear\-Last\-Cell\-Id ()} -\/ Get the interpolation weights cached from last evaluation. Return 1 if the cached cell is valid and 0 otherwise.  
\item {\ttfamily int = obj.\-Get\-Last\-Weights (double w)} -\/ Get the interpolation weights cached from last evaluation. Return 1 if the cached cell is valid and 0 otherwise.  
\item {\ttfamily int = obj.\-Get\-Last\-Local\-Coordinates (double pcoords\mbox{[}3\mbox{]})} -\/ Get the interpolation weights cached from last evaluation. Return 1 if the cached cell is valid and 0 otherwise.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkabstractmapper}{}\section{vtk\-Abstract\-Mapper}\label{vtkfiltering_vtkabstractmapper}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Abstract\-Mapper is an abstract class to specify interface between data and graphics primitives or software rendering techniques. Subclasses of vtk\-Abstract\-Mapper can be used for rendering 2\-D data, geometry, or volumetric data.

To create an instance of class vtk\-Abstract\-Mapper, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkAbstractMapper
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Abstract\-Mapper has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Abstract\-Mapper class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Abstract\-Mapper = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Abstract\-Mapper = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily long = obj.\-Get\-M\-Time ()} -\/ Override Modifiedtime as we have added Clipping planes  
\item {\ttfamily obj.\-Release\-Graphics\-Resources (vtk\-Window )} -\/ Release any graphics resources that are being consumed by this mapper. The parameter window could be used to determine which graphic resources to release.  
\item {\ttfamily double = obj.\-Get\-Time\-To\-Draw ()} -\/ Get the time required to draw the geometry last time it was rendered  
\item {\ttfamily obj.\-Add\-Clipping\-Plane (vtk\-Plane plane)} -\/ Specify clipping planes to be applied when the data is mapped (at most 6 clipping planes can be specified).  
\item {\ttfamily obj.\-Remove\-Clipping\-Plane (vtk\-Plane plane)} -\/ Specify clipping planes to be applied when the data is mapped (at most 6 clipping planes can be specified).  
\item {\ttfamily obj.\-Remove\-All\-Clipping\-Planes ()} -\/ Specify clipping planes to be applied when the data is mapped (at most 6 clipping planes can be specified).  
\item {\ttfamily obj.\-Set\-Clipping\-Planes (vtk\-Plane\-Collection )} -\/ Get/\-Set the vtk\-Plane\-Collection which specifies the clipping planes.  
\item {\ttfamily vtk\-Plane\-Collection = obj.\-Get\-Clipping\-Planes ()} -\/ Get/\-Set the vtk\-Plane\-Collection which specifies the clipping planes.  
\item {\ttfamily obj.\-Set\-Clipping\-Planes (vtk\-Planes planes)} -\/ An alternative way to set clipping planes\-: use up to six planes found in the supplied instance of the implicit function vtk\-Planes.  
\item {\ttfamily obj.\-Shallow\-Copy (vtk\-Abstract\-Mapper m)} -\/ Make a shallow copy of this mapper.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkabstractpointlocator}{}\section{vtk\-Abstract\-Point\-Locator}\label{vtkfiltering_vtkabstractpointlocator}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Abstract\-Point\-Locator is an abstract spatial search object to quickly locate points in 3\-D. vtk\-Abstract\-Point\-Locator works by dividing a specified region of space into \char`\"{}rectangular\char`\"{} buckets, and then keeping a list of points that lie in each bucket. Typical operation involves giving a position in 3\-D and finding the closest point. The points are provided from the specified dataset input.

To create an instance of class vtk\-Abstract\-Point\-Locator, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkAbstractPointLocator
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Abstract\-Point\-Locator has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Abstract\-Point\-Locator class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Abstract\-Point\-Locator = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Abstract\-Point\-Locator = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Id\-Type = obj.\-Find\-Closest\-Point (double x\mbox{[}3\mbox{]})} -\/ Given a position x, return the id of the point closest to it. Alternative method requires separate x-\/y-\/z values. These methods are thread safe if Build\-Locator() is directly or indirectly called from a single thread first.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Find\-Closest\-Point (double x, double y, double z)} -\/ Given a position x, return the id of the point closest to it. Alternative method requires separate x-\/y-\/z values. These methods are thread safe if Build\-Locator() is directly or indirectly called from a single thread first.  
\item {\ttfamily obj.\-Find\-Closest\-N\-Points (int N, double x\mbox{[}3\mbox{]}, vtk\-Id\-List result)} -\/ Find the closest N points to a position. This returns the closest N points to a position. A faster method could be created that returned N close points to a position, but necessarily the exact N closest. The returned points are sorted from closest to farthest. These methods are thread safe if Build\-Locator() is directly or indirectly called from a single thread first.  
\item {\ttfamily obj.\-Find\-Closest\-N\-Points (int N, double x, double y, double z, vtk\-Id\-List result)} -\/ Find the closest N points to a position. This returns the closest N points to a position. A faster method could be created that returned N close points to a position, but necessarily the exact N closest. The returned points are sorted from closest to farthest. These methods are thread safe if Build\-Locator() is directly or indirectly called from a single thread first.  
\item {\ttfamily obj.\-Find\-Points\-Within\-Radius (double R, double x\mbox{[}3\mbox{]}, vtk\-Id\-List result)} -\/ Find all points within a specified radius R of position x. The result is not sorted in any specific manner. These methods are thread safe if Build\-Locator() is directly or indirectly called from a single thread first.  
\item {\ttfamily obj.\-Find\-Points\-Within\-Radius (double R, double x, double y, double z, vtk\-Id\-List result)} -\/ Find all points within a specified radius R of position x. The result is not sorted in any specific manner. These methods are thread safe if Build\-Locator() is directly or indirectly called from a single thread first.  
\item {\ttfamily obj.\-Get\-Bounds (double )} -\/ Provide an accessor to the bounds.  
\item {\ttfamily obj.\-Free\-Search\-Structure ()} -\/ See vtk\-Locator interface documentation. These methods are not thread safe.  
\item {\ttfamily obj.\-Build\-Locator ()} -\/ See vtk\-Locator interface documentation. These methods are not thread safe.  
\item {\ttfamily obj.\-Generate\-Representation (int level, vtk\-Poly\-Data pd)} -\/ See vtk\-Locator interface documentation. These methods are not thread safe.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkactor2d}{}\section{vtk\-Actor2\-D}\label{vtkfiltering_vtkactor2d}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Actor2\-D is similar to vtk\-Actor, but it is made to be used with two dimensional images and annotation. vtk\-Actor2\-D has a position but does not use a transformation matrix like vtk\-Actor (see the superclass vtk\-Prop for information on positioning vtk\-Actor2\-D). vtk\-Actor2\-D has a reference to a vtk\-Mapper2\-D object which does the rendering.

To create an instance of class vtk\-Actor2\-D, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkActor2D
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Actor2\-D has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Actor2\-D class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Actor2\-D = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Actor2\-D = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Render\-Overlay (vtk\-Viewport viewport)} -\/ Support the standard render methods.  
\item {\ttfamily int = obj.\-Render\-Opaque\-Geometry (vtk\-Viewport viewport)} -\/ Support the standard render methods.  
\item {\ttfamily int = obj.\-Render\-Translucent\-Polygonal\-Geometry (vtk\-Viewport viewport)} -\/ Support the standard render methods.  
\item {\ttfamily int = obj.\-Has\-Translucent\-Polygonal\-Geometry ()} -\/ Does this prop have some translucent polygonal geometry?  
\item {\ttfamily obj.\-Set\-Mapper (vtk\-Mapper2\-D mapper)} -\/ Set/\-Get the vtk\-Mapper2\-D which defines the data to be drawn.  
\item {\ttfamily vtk\-Mapper2\-D = obj.\-Get\-Mapper ()} -\/ Set/\-Get the vtk\-Mapper2\-D which defines the data to be drawn.  
\item {\ttfamily obj.\-Set\-Layer\-Number (int )} -\/ Set/\-Get the layer number in the overlay planes into which to render.  
\item {\ttfamily int = obj.\-Get\-Layer\-Number ()} -\/ Set/\-Get the layer number in the overlay planes into which to render.  
\item {\ttfamily vtk\-Property2\-D = obj.\-Get\-Property ()} -\/ Returns this actor's vtk\-Property2\-D. Creates a property if one doesn't already exist.  
\item {\ttfamily obj.\-Set\-Property (vtk\-Property2\-D )} -\/ Set this vtk\-Prop's vtk\-Property2\-D.  
\item {\ttfamily vtk\-Coordinate = obj.\-Get\-Position\-Coordinate ()} -\/ Get the Position\-Coordinate instance of vtk\-Coordinate. This is used for for complicated or relative positioning. The position variable controls the lower left corner of the Actor2\-D  
\item {\ttfamily obj.\-Set\-Position (double, double)} -\/ Get the Position\-Coordinate instance of vtk\-Coordinate. This is used for for complicated or relative positioning. The position variable controls the lower left corner of the Actor2\-D  
\item {\ttfamily obj.\-Set\-Position (double a\mbox{[}2\mbox{]})} -\/ Get the Position\-Coordinate instance of vtk\-Coordinate. This is used for for complicated or relative positioning. The position variable controls the lower left corner of the Actor2\-D  
\item {\ttfamily double = obj.\-Get\-Position ()} -\/ Get the Position\-Coordinate instance of vtk\-Coordinate. This is used for for complicated or relative positioning. The position variable controls the lower left corner of the Actor2\-D  
\item {\ttfamily obj.\-Set\-Display\-Position (int , int )} -\/ Set the Prop2\-D's position in display coordinates.  
\item {\ttfamily vtk\-Coordinate = obj.\-Get\-Position2\-Coordinate ()} -\/ Access the Position2 instance variable. This variable controls the upper right corner of the Actor2\-D. It is by default relative to Position and in normalized viewport coordinates. Some 2\-D actor subclasses ignore the position2 variable  
\item {\ttfamily obj.\-Set\-Position2 (double, double)} -\/ Access the Position2 instance variable. This variable controls the upper right corner of the Actor2\-D. It is by default relative to Position and in normalized viewport coordinates. Some 2\-D actor subclasses ignore the position2 variable  
\item {\ttfamily obj.\-Set\-Position2 (double a\mbox{[}2\mbox{]})} -\/ Access the Position2 instance variable. This variable controls the upper right corner of the Actor2\-D. It is by default relative to Position and in normalized viewport coordinates. Some 2\-D actor subclasses ignore the position2 variable  
\item {\ttfamily double = obj.\-Get\-Position2 ()} -\/ Access the Position2 instance variable. This variable controls the upper right corner of the Actor2\-D. It is by default relative to Position and in normalized viewport coordinates. Some 2\-D actor subclasses ignore the position2 variable  
\item {\ttfamily obj.\-Set\-Width (double w)} -\/ Set/\-Get the height and width of the Actor2\-D. The value is expressed as a fraction of the viewport. This really is just another way of setting the Position2 instance variable.  
\item {\ttfamily double = obj.\-Get\-Width ()} -\/ Set/\-Get the height and width of the Actor2\-D. The value is expressed as a fraction of the viewport. This really is just another way of setting the Position2 instance variable.  
\item {\ttfamily obj.\-Set\-Height (double h)} -\/ Set/\-Get the height and width of the Actor2\-D. The value is expressed as a fraction of the viewport. This really is just another way of setting the Position2 instance variable.  
\item {\ttfamily double = obj.\-Get\-Height ()} -\/ Set/\-Get the height and width of the Actor2\-D. The value is expressed as a fraction of the viewport. This really is just another way of setting the Position2 instance variable.  
\item {\ttfamily long = obj.\-Get\-M\-Time ()} -\/ Return this objects M\-Time.  
\item {\ttfamily obj.\-Get\-Actors2\-D (vtk\-Prop\-Collection pc)} -\/ For some exporters and other other operations we must be able to collect all the actors or volumes. These methods are used in that process.  
\item {\ttfamily obj.\-Shallow\-Copy (vtk\-Prop prop)} -\/ Shallow copy of this vtk\-Actor2\-D. Overloads the virtual vtk\-Prop method.  
\item {\ttfamily obj.\-Release\-Graphics\-Resources (vtk\-Window )} -\/ Release any graphics resources that are being consumed by this actor. The parameter window could be used to determine which graphic resources to release.  
\item {\ttfamily vtk\-Coordinate = obj.\-Get\-Actual\-Position\-Coordinate (void )} -\/ Return the actual vtk\-Coordinate reference that the mapper should use to position the actor. This is used internally by the mappers and should be overridden in specialized subclasses and otherwise ignored.  
\item {\ttfamily vtk\-Coordinate = obj.\-Get\-Actual\-Position2\-Coordinate (void )}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkactor2dcollection}{}\section{vtk\-Actor2\-D\-Collection}\label{vtkfiltering_vtkactor2dcollection}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Actor2\-D\-Collection is a subclass of vtk\-Collection. vtk\-Actor2\-D\-Collection maintains a collection of vtk\-Actor2\-D objects that is sorted by layer number, with lower layer numbers at the start of the list. This allows the vtk\-Actor2\-D objects to be rendered in the correct order.

To create an instance of class vtk\-Actor2\-D\-Collection, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkActor2DCollection
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Actor2\-D\-Collection has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Actor2\-D\-Collection class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Actor2\-D\-Collection = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Actor2\-D\-Collection = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Sort ()} -\/ Sorts the vtk\-Actor2\-D\-Collection by layer number. Smaller layer numbers are first. Layer numbers can be any integer value.  
\item {\ttfamily obj.\-Add\-Item (vtk\-Actor2\-D a)} -\/ Add an actor to the list. The new actor is inserted in the list according to it's layer number.  
\item {\ttfamily int = obj.\-Is\-Item\-Present (vtk\-Actor2\-D a)} -\/ Standard Collection methods  
\item {\ttfamily vtk\-Actor2\-D = obj.\-Get\-Next\-Actor2\-D ()} -\/ Standard Collection methods  
\item {\ttfamily vtk\-Actor2\-D = obj.\-Get\-Last\-Actor2\-D ()} -\/ Standard Collection methods  
\item {\ttfamily vtk\-Actor2\-D = obj.\-Get\-Next\-Item ()} -\/ Access routines that are provided for compatibility with previous version of V\-T\-K. Please use the Get\-Next\-Actor2\-D(), Get\-Last\-Actor2\-D() variants where possible.  
\item {\ttfamily vtk\-Actor2\-D = obj.\-Get\-Last\-Item ()} -\/ Access routines that are provided for compatibility with previous version of V\-T\-K. Please use the Get\-Next\-Actor2\-D(), Get\-Last\-Actor2\-D() variants where possible.  
\item {\ttfamily obj.\-Render\-Overlay (vtk\-Viewport viewport)} -\/ Sort and then render the collection of 2\-D actors.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkadjacentvertexiterator}{}\section{vtk\-Adjacent\-Vertex\-Iterator}\label{vtkfiltering_vtkadjacentvertexiterator}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Adjacent\-Vertex\-Iterator iterates through all vertices adjacent to a vertex, i.\-e. the vertices which may be reached by traversing an out edge of the source vertex. Use graph-\/$>$Get\-Adjacent\-Vertices(v, it) to initialize the iterator.

To create an instance of class vtk\-Adjacent\-Vertex\-Iterator, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkAdjacentVertexIterator
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Adjacent\-Vertex\-Iterator has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Adjacent\-Vertex\-Iterator class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Adjacent\-Vertex\-Iterator = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Adjacent\-Vertex\-Iterator = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Initialize (vtk\-Graph g, vtk\-Id\-Type v)} -\/ Initialize the iterator with a graph and vertex.  
\item {\ttfamily vtk\-Graph = obj.\-Get\-Graph ()} -\/ Get the graph and vertex associated with this iterator.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Vertex ()} -\/ Get the graph and vertex associated with this iterator.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Next ()} -\/ Whether this iterator has more edges.  
\item {\ttfamily bool = obj.\-Has\-Next ()}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkalgorithm}{}\section{vtk\-Algorithm}\label{vtkfiltering_vtkalgorithm}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Algorithm is the superclass for all sources, filters, and sinks in V\-T\-K. It defines a generalized interface for executing data processing algorithms. Pipeline connections are associated with input and output ports that are independent of the type of data passing through the connections.

Instances may be used independently or within pipelines with a variety of architectures and update mechanisms. Pipelines are controlled by instances of vtk\-Executive. Every vtk\-Algorithm instance has an associated vtk\-Executive when it is used in a pipeline. The executive is responsible for data flow.

To create an instance of class vtk\-Algorithm, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkAlgorithm
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Algorithm has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Algorithm class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Algorithm = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Algorithm = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Has\-Executive ()} -\/ Check whether this algorithm has an assigned executive. This will N\-O\-T create a default executive.  
\item {\ttfamily vtk\-Executive = obj.\-Get\-Executive ()} -\/ Get this algorithm's executive. If it has none, a default executive will be created.  
\item {\ttfamily obj.\-Set\-Executive (vtk\-Executive executive)} -\/ Set this algorithm's executive. This algorithm is removed from any executive to which it has previously been assigned and then assigned to the given executive.  
\item {\ttfamily int = obj.\-Modify\-Request (vtk\-Information request, int when)} -\/ This method gives the algorithm a chance to modify the contents of a request before or after (specified in the when argument) it is forwarded. The default implementation is empty. Returns 1 on success, 0 on failure. When can be either vtk\-Executive\-::\-Before\-Forward or vtk\-Executive\-::\-After\-Forward.  
\item {\ttfamily vtk\-Information = obj.\-Get\-Input\-Port\-Information (int port)} -\/ Get the information object associated with an input port. There is one input port per kind of input to the algorithm. Each input port tells executives what kind of data and downstream requests this algorithm can handle for that input.  
\item {\ttfamily vtk\-Information = obj.\-Get\-Output\-Port\-Information (int port)} -\/ Get the information object associated with an output port. There is one output port per output from the algorithm. Each output port tells executives what kind of upstream requests this algorithm can handle for that output.  
\item {\ttfamily vtk\-Information = obj.\-Get\-Information ()} -\/ Set/\-Get the information object associated with this algorithm.  
\item {\ttfamily obj.\-Set\-Information (vtk\-Information )} -\/ Set/\-Get the information object associated with this algorithm.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Input\-Ports ()} -\/ Get the number of input ports used by the algorithm.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Output\-Ports ()} -\/ Get the number of output ports provided by the algorithm.  
\item {\ttfamily obj.\-Register (vtk\-Object\-Base o)} -\/ Participate in garbage collection.  
\item {\ttfamily obj.\-Un\-Register (vtk\-Object\-Base o)} -\/ Participate in garbage collection.  
\item {\ttfamily obj.\-Set\-Abort\-Execute (int )} -\/ Set/\-Get the Abort\-Execute flag for the process object. Process objects may handle premature termination of execution in different ways.  
\item {\ttfamily int = obj.\-Get\-Abort\-Execute ()} -\/ Set/\-Get the Abort\-Execute flag for the process object. Process objects may handle premature termination of execution in different ways.  
\item {\ttfamily obj.\-Abort\-Execute\-On ()} -\/ Set/\-Get the Abort\-Execute flag for the process object. Process objects may handle premature termination of execution in different ways.  
\item {\ttfamily obj.\-Abort\-Execute\-Off ()} -\/ Set/\-Get the Abort\-Execute flag for the process object. Process objects may handle premature termination of execution in different ways.  
\item {\ttfamily obj.\-Set\-Progress (double )} -\/ Set/\-Get the execution progress of a process object.  
\item {\ttfamily double = obj.\-Get\-Progress\-Min\-Value ()} -\/ Set/\-Get the execution progress of a process object.  
\item {\ttfamily double = obj.\-Get\-Progress\-Max\-Value ()} -\/ Set/\-Get the execution progress of a process object.  
\item {\ttfamily double = obj.\-Get\-Progress ()} -\/ Set/\-Get the execution progress of a process object.  
\item {\ttfamily obj.\-Update\-Progress (double amount)} -\/ Update the progress of the process object. If a Progress\-Method exists, executes it. Then set the Progress ivar to amount. The parameter amount should range between (0,1).  
\item {\ttfamily obj.\-Set\-Progress\-Text (string ptext)} -\/ Set the current text message associated with the progress state. This may be used by a calling process/\-G\-U\-I. Note\-: Because Set\-Progress\-Text() is called from inside Request\-Data() it does not modify the algorithm object. Algorithms are not allowed to modify themselves from inside Request\-Data().  
\item {\ttfamily string = obj.\-Get\-Progress\-Text ()} -\/ Set the current text message associated with the progress state. This may be used by a calling process/\-G\-U\-I. Note\-: Because Set\-Progress\-Text() is called from inside Request\-Data() it does not modify the algorithm object. Algorithms are not allowed to modify themselves from inside Request\-Data().  
\item {\ttfamily long = obj.\-Get\-Error\-Code ()} -\/ The error code contains a possible error that occured while reading or writing the file.  
\item {\ttfamily obj.\-Set\-Input\-Array\-To\-Process (int idx, int port, int connection, int field\-Association, string name)} -\/ Set the input data arrays that this algorithm will process. Specifically the idx array that this algorithm will process (starting from 0) is the array on port, connection with the specified association and name or attribute type (such as S\-C\-A\-L\-A\-R\-S). The field\-Association refers to which field in the data object the array is stored. See vtk\-Data\-Object\-::\-Field\-Associations for detail.  
\item {\ttfamily obj.\-Set\-Input\-Array\-To\-Process (int idx, int port, int connection, int field\-Association, int field\-Attribute\-Type)} -\/ Set the input data arrays that this algorithm will process. Specifically the idx array that this algorithm will process (starting from 0) is the array on port, connection with the specified association and name or attribute type (such as S\-C\-A\-L\-A\-R\-S). The field\-Association refers to which field in the data object the array is stored. See vtk\-Data\-Object\-::\-Field\-Associations for detail.  
\item {\ttfamily obj.\-Set\-Input\-Array\-To\-Process (int idx, vtk\-Information info)} -\/ Set the input data arrays that this algorithm will process. Specifically the idx array that this algorithm will process (starting from 0) is the array on port, connection with the specified association and name or attribute type (such as S\-C\-A\-L\-A\-R\-S). The field\-Association refers to which field in the data object the array is stored. See vtk\-Data\-Object\-::\-Field\-Associations for detail.  
\item {\ttfamily obj.\-Set\-Input\-Array\-To\-Process (int idx, int port, int connection, string field\-Association, string attribute\-Typeor\-Name)} -\/ String based versions of Set\-Input\-Array\-To\-Process(). Because field\-Association and field\-Attribute\-Type are enums, they cannot be easily accessed from scripting language. These methods provides an easy and safe way of passing association and attribute type information. Field association is one of the following\-: \begin{DoxyVerb} vtkDataObject::FIELD_ASSOCIATION_POINTS
 vtkDataObject::FIELD_ASSOCIATION_CELLS
 vtkDataObject::FIELD_ASSOCIATION_NONE
 vtkDataObject::FIELD_ASSOCIATION_POINTS_THEN_CELLS\end{DoxyVerb}
 Attribute type is one of the following\-: \begin{DoxyVerb} vtkDataSetAttributes::SCALARS
 vtkDataSetAttributes::VECTORS
 vtkDataSetAttributes::NORMALS
 vtkDataSetAttributes::TCOORDS
 vtkDataSetAttributes::TENSORS\end{DoxyVerb}
 If the last argument is not an attribute type, it is assumed to be an array name.  
\item {\ttfamily vtk\-Information = obj.\-Get\-Input\-Array\-Information (int idx)} -\/ Get the info object for the specified input array to this algorithm  
\item {\ttfamily obj.\-Remove\-All\-Inputs ()} -\/ Remove all the input data.  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Output\-Data\-Object (int port)} -\/ Get the data object that will contain the algorithm output for the given port.  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Input\-Data\-Object (int port, int connection)} -\/ Get the data object that will contain the algorithm input for the given port and given connection.  
\item {\ttfamily obj.\-Set\-Input\-Connection (int port, vtk\-Algorithm\-Output input)} -\/ Set the connection for the given input port index. Each input port of a filter has a specific purpose. A port may have zero or more connections and the required number is specified by each filter. Setting the connection with this method removes all other connections from the port. To add more than one connection use Add\-Input\-Connection().

The input for the connection is the output port of another filter, which is obtained with Get\-Output\-Port(). Typical usage is

filter2-\/$>$Set\-Input\-Connection(0, filter1-\/$>$Get\-Output\-Port(0)).  
\item {\ttfamily obj.\-Set\-Input\-Connection (vtk\-Algorithm\-Output input)} -\/ Set the connection for the given input port index. Each input port of a filter has a specific purpose. A port may have zero or more connections and the required number is specified by each filter. Setting the connection with this method removes all other connections from the port. To add more than one connection use Add\-Input\-Connection().

The input for the connection is the output port of another filter, which is obtained with Get\-Output\-Port(). Typical usage is

filter2-\/$>$Set\-Input\-Connection(0, filter1-\/$>$Get\-Output\-Port(0)).  
\item {\ttfamily obj.\-Add\-Input\-Connection (int port, vtk\-Algorithm\-Output input)} -\/ Add a connection to the given input port index. See Set\-Input\-Connection() for details on input connections. This method is the complement to Remove\-Input\-Connection() in that it adds only the connection specified without affecting other connections. Typical usage is

filter2-\/$>$Add\-Input\-Connection(0, filter1-\/$>$Get\-Output\-Port(0)).  
\item {\ttfamily obj.\-Add\-Input\-Connection (vtk\-Algorithm\-Output input)} -\/ Add a connection to the given input port index. See Set\-Input\-Connection() for details on input connections. This method is the complement to Remove\-Input\-Connection() in that it adds only the connection specified without affecting other connections. Typical usage is

filter2-\/$>$Add\-Input\-Connection(0, filter1-\/$>$Get\-Output\-Port(0)).  
\item {\ttfamily obj.\-Remove\-Input\-Connection (int port, vtk\-Algorithm\-Output input)} -\/ Remove a connection from the given input port index. See Set\-Input\-Connection() for details on input connection. This method is the complement to Add\-Input\-Connection() in that it removes only the connection specified without affecting other connections. Typical usage is

filter2-\/$>$Remove\-Input\-Connection(0, filter1-\/$>$Get\-Output\-Port(0)).  
\item {\ttfamily vtk\-Algorithm\-Output = obj.\-Get\-Output\-Port (int index)} -\/ Get a proxy object corresponding to the given output port of this algorithm. The proxy object can be passed to another algorithm's Set\-Input\-Connection(), Add\-Input\-Connection(), and Remove\-Input\-Connection() methods to modify pipeline connectivity.  
\item {\ttfamily vtk\-Algorithm\-Output = obj.\-Get\-Output\-Port ()} -\/ Get the number of inputs currently connected to a port.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Input\-Connections (int port)} -\/ Get the number of inputs currently connected to a port.  
\item {\ttfamily int = obj.\-Get\-Total\-Number\-Of\-Input\-Connections ()} -\/ Get the total number of inputs for this algorithm  
\item {\ttfamily vtk\-Algorithm\-Output = obj.\-Get\-Input\-Connection (int port, int index)} -\/ Get the algorithm output port connected to an input port.  
\item {\ttfamily obj.\-Update ()} -\/ Bring this algorithm's outputs up-\/to-\/date.  
\item {\ttfamily obj.\-Update\-Information ()} -\/ Backward compatibility method to invoke Update\-Information on executive.  
\item {\ttfamily obj.\-Update\-Whole\-Extent ()} -\/ Bring this algorithm's outputs up-\/to-\/date.  
\item {\ttfamily obj.\-Set\-Release\-Data\-Flag (int )} -\/ Turn release data flag on or off for all output ports.  
\item {\ttfamily int = obj.\-Get\-Release\-Data\-Flag ()} -\/ Turn release data flag on or off for all output ports.  
\item {\ttfamily obj.\-Release\-Data\-Flag\-On ()} -\/ Turn release data flag on or off for all output ports.  
\item {\ttfamily obj.\-Release\-Data\-Flag\-Off ()} -\/ Turn release data flag on or off for all output ports.  
\item {\ttfamily int = obj.\-Update\-Extent\-Is\-Empty (vtk\-Data\-Object output)} -\/ This detects when the Update\-Extent will generate no data This condition is satisfied when the Update\-Extent has zero volume (0,-\/1,...) or the Update\-Number\-Of\-Pieces is 0. The source uses this call to determine whether to call Execute.  
\item {\ttfamily int = obj.\-Update\-Extent\-Is\-Empty (vtk\-Information pinfo, int extent\-Type)} -\/ This detects when the Update\-Extent will generate no data This condition is satisfied when the Update\-Extent has zero volume (0,-\/1,...) or the Update\-Number\-Of\-Pieces is 0. The source uses this call to determine whether to call Execute.  
\item {\ttfamily double = obj.\-Compute\-Priority ()} -\/ Returns the priority of the piece described by the current update extent. The priority is a number between 0.\-0 and 1.\-0 with 0 meaning skippable (R\-E\-Q\-U\-E\-S\-T\-\_\-\-D\-A\-T\-A not needed) and 1.\-0 meaning important.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkalgorithmoutput}{}\section{vtk\-Algorithm\-Output}\label{vtkfiltering_vtkalgorithmoutput}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Algorithm\-Output is a proxy object returned by the Get\-Output\-Port method of vtk\-Algorithm. It may be passed to the Set\-Input\-Connection, Add\-Input\-Connection, or Remove\-Input\-Connection methods of another vtk\-Algorithm to establish a connection between an output and input port. The connection is not stored in the proxy object\-: it is simply a convenience for creating or removing connections.

To create an instance of class vtk\-Algorithm\-Output, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkAlgorithmOutput
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Algorithm\-Output has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Algorithm\-Output class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Algorithm\-Output = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Algorithm\-Output = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Index (int index)}  
\item {\ttfamily int = obj.\-Get\-Index ()}  
\item {\ttfamily vtk\-Algorithm = obj.\-Get\-Producer ()}  
\item {\ttfamily obj.\-Set\-Producer (vtk\-Algorithm producer)}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkannotation}{}\section{vtk\-Annotation}\label{vtkfiltering_vtkannotation}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Annotation is a collection of annotation properties along with an associated selection indicating the portion of data the annotation refers to.

.S\-E\-C\-T\-I\-O\-N Thanks Timothy M. Shead (\href{mailto:tshead@sandia.gov}{\tt tshead@sandia.\-gov}) at Sandia National Laboratories contributed code to this class.

To create an instance of class vtk\-Annotation, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkAnnotation
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Annotation has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Annotation class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Annotation = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Annotation = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Selection = obj.\-Get\-Selection ()} -\/ The selection to which this set of annotations will apply.  
\item {\ttfamily obj.\-Set\-Selection (vtk\-Selection selection)} -\/ The selection to which this set of annotations will apply.  
\item {\ttfamily obj.\-Initialize ()} -\/ Initialize the annotation to an empty state.  
\item {\ttfamily obj.\-Shallow\-Copy (vtk\-Data\-Object other)} -\/ Make this annotation have the same properties and have the same selection of another annotation.  
\item {\ttfamily obj.\-Deep\-Copy (vtk\-Data\-Object other)} -\/ Make this annotation have the same properties and have a copy of the selection of another annotation.  
\item {\ttfamily long = obj.\-Get\-M\-Time ()} -\/ Get the modified time of this object.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkannotationlayers}{}\section{vtk\-Annotation\-Layers}\label{vtkfiltering_vtkannotationlayers}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Annotation\-Layers stores a vector of annotation layers. Each layer may contain any number of vtk\-Annotation objects. The ordering of the layers introduces a prioritization of annotations. Annotations in higher layers may obscure annotations in lower layers.

To create an instance of class vtk\-Annotation\-Layers, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkAnnotationLayers
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Annotation\-Layers has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Annotation\-Layers class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Annotation\-Layers = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Annotation\-Layers = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Current\-Annotation (vtk\-Annotation ann)} -\/ The current annotation associated with this annotation link.  
\item {\ttfamily vtk\-Annotation = obj.\-Get\-Current\-Annotation ()} -\/ The current annotation associated with this annotation link.  
\item {\ttfamily obj.\-Set\-Current\-Selection (vtk\-Selection sel)} -\/ The current selection associated with this annotation link. This is simply the selection contained in the current annotation.  
\item {\ttfamily vtk\-Selection = obj.\-Get\-Current\-Selection ()} -\/ The current selection associated with this annotation link. This is simply the selection contained in the current annotation.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Annotations ()} -\/ The number of annotations in a specific layer.  
\item {\ttfamily vtk\-Annotation = obj.\-Get\-Annotation (int idx)} -\/ Retrieve an annotation from a layer.  
\item {\ttfamily obj.\-Add\-Annotation (vtk\-Annotation ann)} -\/ Add an annotation to a layer.  
\item {\ttfamily obj.\-Remove\-Annotation (vtk\-Annotation ann)} -\/ Remove an annotation from a layer.  
\item {\ttfamily obj.\-Initialize ()} -\/ Initialize the data structure to an empty state.  
\item {\ttfamily obj.\-Shallow\-Copy (vtk\-Data\-Object other)} -\/ Copy data from another data object into this one which references the same member annotations.  
\item {\ttfamily obj.\-Deep\-Copy (vtk\-Data\-Object other)} -\/ Copy data from another data object into this one, performing a deep copy of member annotations.  
\item {\ttfamily long = obj.\-Get\-M\-Time ()} -\/ The modified time for this object.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkannotationlayersalgorithm}{}\section{vtk\-Annotation\-Layers\-Algorithm}\label{vtkfiltering_vtkannotationlayersalgorithm}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Annotation\-Layers\-Algorithm is a convenience class to make writing algorithms easier. It is also designed to help transition old algorithms to the new pipeline architecture. There are some assumptions and defaults made by this class you should be aware of. This class defaults such that your filter will have one input port and one output port. If that is not the case simply change it with Set\-Number\-Of\-Input\-Ports etc. See this class constructor for the default. This class also provides a Fill\-Input\-Port\-Info method that by default says that all inputs will be vtk\-Annotation\-Layers. If that isn't the case then please override this method in your subclass. This class breaks out the downstream requests into separate functions such as Execute\-Data and Execute\-Information. For new algorithms you should implement Request\-Data( request, input\-Vec, output\-Vec) but for older filters there is a default implementation that calls the old Execute\-Data(output) signature. For even older filters that don't implement Execute\-Data the default implementation calls the even older Execute() signature.

To create an instance of class vtk\-Annotation\-Layers\-Algorithm, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkAnnotationLayersAlgorithm
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Annotation\-Layers\-Algorithm has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Annotation\-Layers\-Algorithm class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Annotation\-Layers\-Algorithm = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Annotation\-Layers\-Algorithm = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Annotation\-Layers = obj.\-Get\-Output ()} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Annotation\-Layers = obj.\-Get\-Output (int index)} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Object obj)} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Set\-Input (int index, vtk\-Data\-Object obj)} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkarraydata}{}\section{vtk\-Array\-Data}\label{vtkfiltering_vtkarraydata}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Because vtk\-Array cannot be stored as attributes of data objects (yet), a \char`\"{}carrier\char`\"{} object is needed to pass vtk\-Array through the pipeline. vtk\-Array\-Data acts as a container of zero-\/to-\/many vtk\-Array instances, which can be retrieved via a zero-\/based index. Note that a collection of arrays stored in vtk\-Array\-Data may-\/or-\/may-\/not have related types, dimensions, or extents.

To create an instance of class vtk\-Array\-Data, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkArrayData
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Array\-Data has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Array\-Data class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Array\-Data = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Array\-Data = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Add\-Array (vtk\-Array )} -\/ Adds a vtk\-Array to the collection  
\item {\ttfamily obj.\-Clear\-Arrays ()} -\/ Clears the contents of the collection  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Arrays ()} -\/ Returns the number of vtk\-Array instances in the collection  
\item {\ttfamily vtk\-Array = obj.\-Get\-Array (vtk\-Id\-Type index)} -\/ Returns the n-\/th vtk\-Array in the collection  
\item {\ttfamily vtk\-Array = obj.\-Get\-Array\-By\-Name (string name)} -\/ Returns the array having called name from the collection  
\item {\ttfamily int = obj.\-Get\-Data\-Object\-Type ()}  
\item {\ttfamily obj.\-Shallow\-Copy (vtk\-Data\-Object other)}  
\item {\ttfamily obj.\-Deep\-Copy (vtk\-Data\-Object other)}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkarraydataalgorithm}{}\section{vtk\-Array\-Data\-Algorithm}\label{vtkfiltering_vtkarraydataalgorithm}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Array\-Data\-Algorithm is a convenience class to make writing algorithms easier. It is also designed to help transition old algorithms to the new pipeline architecture. There are some assumptions and defaults made by this class you should be aware of. This class defaults such that your filter will have one input port and one output port. If that is not the case simply change it with Set\-Number\-Of\-Input\-Ports etc. See this class constructor for the default. This class also provides a Fill\-Input\-Port\-Info method that by default says that all inputs will be vtk\-Array\-Data. If that isn't the case then please override this method in your subclass. This class breaks out the downstream requests into separate functions such as Execute\-Data and Execute\-Information. For new algorithms you should implement Request\-Data( request, input\-Vec, output\-Vec) but for older filters there is a default implementation that calls the old Execute\-Data(output) signature. For even older filters that don't implement Execute\-Data the default implementation calls the even older Execute() signature.

To create an instance of class vtk\-Array\-Data\-Algorithm, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkArrayDataAlgorithm
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Array\-Data\-Algorithm has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Array\-Data\-Algorithm class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Array\-Data\-Algorithm = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Array\-Data\-Algorithm = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Array\-Data = obj.\-Get\-Output ()} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Array\-Data = obj.\-Get\-Output (int index)} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Object obj)} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Set\-Input (int index, vtk\-Data\-Object obj)} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkattributeserrormetric}{}\section{vtk\-Attributes\-Error\-Metric}\label{vtkfiltering_vtkattributeserrormetric}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
It is a concrete error metric, based on an attribute criterium\-: the variation of the active attribute/component value from a linear ramp

To create an instance of class vtk\-Attributes\-Error\-Metric, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkAttributesErrorMetric
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Attributes\-Error\-Metric has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Attributes\-Error\-Metric class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()} -\/ Standard V\-T\-K type and error macros.  
\item {\ttfamily int = obj.\-Is\-A (string name)} -\/ Standard V\-T\-K type and error macros.  
\item {\ttfamily vtk\-Attributes\-Error\-Metric = obj.\-New\-Instance ()} -\/ Standard V\-T\-K type and error macros.  
\item {\ttfamily vtk\-Attributes\-Error\-Metric = obj.\-Safe\-Down\-Cast (vtk\-Object o)} -\/ Standard V\-T\-K type and error macros.  
\item {\ttfamily double = obj.\-Get\-Absolute\-Attribute\-Tolerance ()} -\/ Absolute tolerance of the active scalar (attribute+component). Subdivision is required if the square distance between the real attribute at the mid point on the edge and the interpolated attribute is greater than Absolute\-Attribute\-Tolerance. This is the attribute accuracy. 0.\-01 will give better result than 0.\-1.  
\item {\ttfamily obj.\-Set\-Absolute\-Attribute\-Tolerance (double value)} -\/ Set the absolute attribute accuracy to `value'. See Get\-Absolute\-Attribute\-Tolerance() for details. It is particularly useful when some concrete implementation of vtk\-Generic\-Attribute does not support Get\-Range() request, called internally in Set\-Attribute\-Tolerance(). It may happen when the implementation support higher order attributes but cannot compute the range. \begin{DoxyPrecond}{Precondition}
valid\-\_\-range\-\_\-value\-: value$>$0  
\end{DoxyPrecond}

\item {\ttfamily double = obj.\-Get\-Attribute\-Tolerance ()} -\/ Relative tolerance of the active scalar (attribute+component). Subdivision is required if the square distance between the real attribute at the mid point on the edge and the interpolated attribute is greater than Attribute\-Tolerance. This is the attribute accuracy. 0.\-01 will give better result than 0.\-1.  
\item {\ttfamily obj.\-Set\-Attribute\-Tolerance (double value)} -\/ Set the relative attribute accuracy to `value'. See Get\-Attribute\-Tolerance() for details. \begin{DoxyPrecond}{Precondition}
valid\-\_\-range\-\_\-value\-: value$>$0 \&\& value$<$1  
\end{DoxyPrecond}

\item {\ttfamily int = obj.\-Requires\-Edge\-Subdivision (double left\-Point, double mid\-Point, double right\-Point, double alpha)} -\/ Does the edge need to be subdivided according to the distance between the value of the active attribute/component at the midpoint and the mean value between the endpoints? The edge is defined by its `left\-Point' and its `right\-Point'. `left\-Point', `mid\-Point' and `right\-Point' have to be initialized before calling Requires\-Edge\-Subdivision(). Their format is global coordinates, parametric coordinates and point centered attributes\-: xyx rst abc de... `alpha' is the normalized abscissa of the midpoint along the edge. (close to 0 means close to the left point, close to 1 means close to the right point) \begin{DoxyPrecond}{Precondition}
left\-Point\-\_\-exists\-: left\-Point!=0 

mid\-Point\-\_\-exists\-: mid\-Point!=0 

right\-Point\-\_\-exists\-: right\-Point!=0 

clamped\-\_\-alpha\-: alpha$>$0 \&\& alpha$<$1 

valid\-\_\-size\-: sizeof(left\-Point)=sizeof(mid\-Point)=sizeof(right\-Point) =Get\-Attribute\-Collection()-\/$>$Get\-Number\-Of\-Point\-Centered\-Components()+6  
\end{DoxyPrecond}

\item {\ttfamily double = obj.\-Get\-Error (double left\-Point, double mid\-Point, double right\-Point, double alpha)} -\/ Return the error at the mid-\/point. The type of error depends on the state of the concrete error metric. For instance, it can return an absolute or relative error metric. See Requires\-Edge\-Subdivision() for a description of the arguments. \begin{DoxyPrecond}{Precondition}
left\-Point\-\_\-exists\-: left\-Point!=0 

mid\-Point\-\_\-exists\-: mid\-Point!=0 

right\-Point\-\_\-exists\-: right\-Point!=0 

clamped\-\_\-alpha\-: alpha$>$0 \&\& alpha$<$1 

valid\-\_\-size\-: sizeof(left\-Point)=sizeof(mid\-Point)=sizeof(right\-Point) =Get\-Attribute\-Collection()-\/$>$Get\-Number\-Of\-Point\-Centered\-Components()+6 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$=0  
\end{DoxyPostcond}

\end{DoxyItemize}\hypertarget{vtkfiltering_vtkbiquadraticquad}{}\section{vtk\-Bi\-Quadratic\-Quad}\label{vtkfiltering_vtkbiquadraticquad}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Quadratic\-Quad is a concrete implementation of vtk\-Non\-Linear\-Cell to represent a two-\/dimensional, 9-\/node isoparametric parabolic quadrilateral element with a Centerpoint. The interpolation is the standard finite element, quadratic isoparametric shape function. The cell includes a mid-\/edge node for each of the four edges of the cell and a center node at the surface. The ordering of the eight points defining the cell are point ids (0-\/3,4-\/8) where ids 0-\/3 define the four corner vertices of the quad; ids 4-\/7 define the midedge nodes (0,1), (1,2), (2,3), (3,0) and 8 define the face center node.

To create an instance of class vtk\-Bi\-Quadratic\-Quad, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkBiQuadraticQuad
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Bi\-Quadratic\-Quad has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Bi\-Quadratic\-Quad class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Bi\-Quadratic\-Quad = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Bi\-Quadratic\-Quad = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int )} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int )}  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)}  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)}  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)}  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)}  
\item {\ttfamily obj.\-Clip (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd, int inside\-Out)} -\/ Clip this biquadratic quad using scalar value provided. Like contouring, except that it cuts the twi quads to produce linear triangles.  
\item {\ttfamily int = obj.\-Get\-Parametric\-Center (double pcoords\mbox{[}3\mbox{]})} -\/ Return the center of the pyramid in parametric coordinates.  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double weights\mbox{[}9\mbox{]})} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs\mbox{[}18\mbox{]})}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkbiquadraticquadratichexahedron}{}\section{vtk\-Bi\-Quadratic\-Quadratic\-Hexahedron}\label{vtkfiltering_vtkbiquadraticquadratichexahedron}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Bi\-Quadratic\-Quadratic\-Hexahedron is a concrete implementation of vtk\-Non\-Linear\-Cell to represent a three-\/dimensional, 24-\/node isoparametric biquadratic hexahedron. The interpolation is the standard finite element, biquadratic-\/quadratic isoparametric shape function. The cell includes mid-\/edge and center-\/face nodes. The ordering of the 24 points defining the cell is point ids (0-\/7,8-\/19, 20-\/23) where point ids 0-\/7 are the eight corner vertices of the cube; followed by twelve midedge nodes (8-\/19), nodes 20-\/23 are the center-\/face nodes. Note that these midedge nodes correspond lie on the edges defined by (0,1), (1,2), (2,3), (3,0), (4,5), (5,6), (6,7), (7,4), (0,4), (1,5), (2,6), (3,7). The center face nodes lieing in quad 22-\/(0,1,5,4), 21-\/(1,2,6,5), 23-\/(2,3,7,6) and 22-\/(3,0,4,7)

\begin{DoxyVerb} top 
  7--14--6
  |      |
 15      13
  |      |
  4--12--5

  middle
 19--23--18
  |      |
 20      21
  |      |
 16--22--17

 bottom
  3--10--2
  |      |
 11      9 
  |      |
  0-- 8--1\end{DoxyVerb}


To create an instance of class vtk\-Bi\-Quadratic\-Quadratic\-Hexahedron, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkBiQuadraticQuadraticHexahedron
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Bi\-Quadratic\-Quadratic\-Hexahedron has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Bi\-Quadratic\-Quadratic\-Hexahedron class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Bi\-Quadratic\-Quadratic\-Hexahedron = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Bi\-Quadratic\-Quadratic\-Hexahedron = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int )} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int )} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)}  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)}  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)}  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)}  
\item {\ttfamily obj.\-Clip (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array tetras, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd, int inside\-Out)} -\/ Clip this biquadratic hexahedron using scalar value provided. Like contouring, except that it cuts the hex to produce linear tetrahedron.  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double weights\mbox{[}24\mbox{]})} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs\mbox{[}72\mbox{]})} -\/ Return the ids of the vertices defining edge/face ({\ttfamily edge\-Id}/`face\-Id'). Ids are related to the cell, not to the dataset.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkbiquadraticquadraticwedge}{}\section{vtk\-Bi\-Quadratic\-Quadratic\-Wedge}\label{vtkfiltering_vtkbiquadraticquadraticwedge}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Bi\-Quadratic\-Quadratic\-Wedge is a concrete implementation of vtk\-Non\-Linear\-Cell to represent a three-\/dimensional, 18-\/node isoparametric biquadratic wedge. The interpolation is the standard finite element, biquadratic-\/quadratic isoparametric shape function plus the linear functions. The cell includes a mid-\/edge node. The ordering of the 18 points defining the cell is point ids (0-\/5,6-\/15, 16-\/18) where point ids 0-\/5 are the six corner vertices of the wedge; followed by nine midedge nodes (6-\/15) and 3 center-\/face nodes. Note that these midedge nodes correspond lie on the edges defined by (0,1), (1,2), (2,0), (3,4), (4,5), (5,3), (0,3), (1,4), (2,5), and the center-\/face nodes are lieing in quads 16-\/(0,1,4,3), 17-\/(1,2,5,4) and (2,0,3,5).

To create an instance of class vtk\-Bi\-Quadratic\-Quadratic\-Wedge, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkBiQuadraticQuadraticWedge
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Bi\-Quadratic\-Quadratic\-Wedge has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Bi\-Quadratic\-Quadratic\-Wedge class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Bi\-Quadratic\-Quadratic\-Wedge = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Bi\-Quadratic\-Quadratic\-Wedge = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int edge\-Id)} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int face\-Id)} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)}  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)}  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)}  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)}  
\item {\ttfamily obj.\-Clip (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array tetras, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd, int inside\-Out)} -\/ Clip this quadratic Wedge using scalar value provided. Like contouring, except that it cuts the hex to produce linear tetrahedron.  
\item {\ttfamily int = obj.\-Get\-Parametric\-Center (double pcoords\mbox{[}3\mbox{]})} -\/ Return the center of the quadratic wedge in parametric coordinates.  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double weights\mbox{[}15\mbox{]})} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs\mbox{[}45\mbox{]})} -\/ Return the ids of the vertices defining edge/face ({\ttfamily edge\-Id}/`face\-Id'). Ids are related to the cell, not to the dataset.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkbiquadratictriangle}{}\section{vtk\-Bi\-Quadratic\-Triangle}\label{vtkfiltering_vtkbiquadratictriangle}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Bi\-Quadratic\-Triangle is a concrete implementation of vtk\-Non\-Linear\-Cell to represent a two-\/dimensional, 7-\/node, isoparametric parabolic triangle. The interpolation is the standard finite element, bi-\/quadratic isoparametric shape function. The cell includes three mid-\/edge nodes besides the three triangle vertices and a center node. The ordering of the three points defining the cell is point ids (0-\/2,3-\/6) where id \#3 is the midedge node between points (0,1); id \#4 is the midedge node between points (1,2); and id \#5 is the midedge node between points (2,0). id \#6 is the center node of the cell.

To create an instance of class vtk\-Bi\-Quadratic\-Triangle, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkBiQuadraticTriangle
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Bi\-Quadratic\-Triangle has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Bi\-Quadratic\-Triangle class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Bi\-Quadratic\-Triangle = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Bi\-Quadratic\-Triangle = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int edge\-Id)} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int )}  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)}  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)}  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)}  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)}  
\item {\ttfamily obj.\-Clip (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd, int inside\-Out)} -\/ Clip this quadratic triangle using scalar value provided. Like contouring, except that it cuts the triangle to produce linear triangles.  
\item {\ttfamily int = obj.\-Get\-Parametric\-Center (double pcoords\mbox{[}3\mbox{]})} -\/ Return the center of the quadratic triangle in parametric coordinates.  
\item {\ttfamily double = obj.\-Get\-Parametric\-Distance (double pcoords\mbox{[}3\mbox{]})} -\/ Return the distance of the parametric coordinate provided to the cell. If inside the cell, a distance of zero is returned.  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double weights\mbox{[}7\mbox{]})} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs\mbox{[}14\mbox{]})}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkbspcuts}{}\section{vtk\-B\-S\-P\-Cuts}\label{vtkfiltering_vtkbspcuts}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This class converts between the vtk\-Kd\-Tree representation of a tree of vtk\-Kd\-Nodes (used by vtk\-Distributed\-Data\-Filter) and a compact array representation that might be provided by a graph partitioning library like Zoltan. Such a representation could be used in message passing.

To create an instance of class vtk\-B\-S\-P\-Cuts, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkBSPCuts
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-B\-S\-P\-Cuts has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-B\-S\-P\-Cuts class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-B\-S\-P\-Cuts = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-B\-S\-P\-Cuts = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Create\-Cuts (double bounds, int ncuts, int dim, double coord, int lower, int upper, double lower\-Data\-Coord, double upper\-Data\-Coord, int npoints)}  
\item {\ttfamily obj.\-Create\-Cuts (vtk\-Kd\-Node kd)}  
\item {\ttfamily vtk\-Kd\-Node = obj.\-Get\-Kd\-Node\-Tree ()}  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Cuts ()}  
\item {\ttfamily int = obj.\-Get\-Arrays (int len, int dim, double coord, int lower, int upper, double lower\-Data\-Coord, double upper\-Data\-Coord, int npoints)}  
\item {\ttfamily int = obj.\-Equals (vtk\-B\-S\-P\-Cuts other, double tolerance)} -\/ Compare these cuts with those of the other tree. Returns true if the two trees are the same.  
\item {\ttfamily obj.\-Print\-Tree ()}  
\item {\ttfamily obj.\-Print\-Arrays ()}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkbspintersections}{}\section{vtk\-B\-S\-P\-Intersections}\label{vtkfiltering_vtkbspintersections}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Given an axis aligned binary spatial partitioning described by a vtk\-B\-S\-P\-Cuts object, perform intersection queries on various geometric entities with regions of the spatial partitioning.

To create an instance of class vtk\-B\-S\-P\-Intersections, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkBSPIntersections
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-B\-S\-P\-Intersections has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-B\-S\-P\-Intersections class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-B\-S\-P\-Intersections = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-B\-S\-P\-Intersections = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Cuts (vtk\-B\-S\-P\-Cuts cuts)}  
\item {\ttfamily vtk\-B\-S\-P\-Cuts = obj.\-Get\-Cuts ()}  
\item {\ttfamily int = obj.\-Get\-Bounds (double bounds)}  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Regions ()}  
\item {\ttfamily int = obj.\-Get\-Region\-Bounds (int region\-I\-D, double bounds\mbox{[}6\mbox{]})}  
\item {\ttfamily int = obj.\-Get\-Region\-Data\-Bounds (int region\-I\-D, double bounds\mbox{[}6\mbox{]})}  
\item {\ttfamily int = obj.\-Intersects\-Box (int region\-Id, double x)} -\/ Determine whether a region of the spatial decomposition intersects an axis aligned box.  
\item {\ttfamily int = obj.\-Intersects\-Box (int region\-Id, double xmin, double xmax, double ymin, double ymax, double zmin, double zmax)} -\/ Determine whether a region of the spatial decomposition intersects an axis aligned box.  
\item {\ttfamily int = obj.\-Intersects\-Box (int ids, int len, double x)} -\/ Compute a list of the Ids of all regions that intersect the specified axis aligned box. Returns\-: the number of ids in the list.  
\item {\ttfamily int = obj.\-Intersects\-Box (int ids, int len, double x0, double x1, double y0, double y1, double z0, double z1)} -\/ Compute a list of the Ids of all regions that intersect the specified axis aligned box. Returns\-: the number of ids in the list.  
\item {\ttfamily int = obj.\-Intersects\-Sphere2 (int region\-Id, double x, double y, double z, double r\-Squared)} -\/ Determine whether a region of the spatial decomposition intersects a sphere, given the center of the sphere and the square of it's radius.  
\item {\ttfamily int = obj.\-Intersects\-Sphere2 (int ids, int len, double x, double y, double z, double r\-Squared)} -\/ Compute a list of the Ids of all regions that intersect the specified sphere. The sphere is given by it's center and the square of it's radius. Returns\-: the number of ids in the list.  
\item {\ttfamily int = obj.\-Intersects\-Cell (int region\-Id, vtk\-Cell cell, int cell\-Region)} -\/ Determine whether a region of the spatial decomposition intersects the given cell. If you already know the region that the cell centroid lies in, provide that as the last argument to make the computation quicker.  
\item {\ttfamily int = obj.\-Intersects\-Cell (int ids, int len, vtk\-Cell cell, int cell\-Region)} -\/ Compute a list of the Ids of all regions that intersect the given cell. If you alrady know the region that the cell centroid lies in, provide that as the last argument to make the computation quicker. Returns the number of regions the cell intersects.  
\item {\ttfamily int = obj.\-Get\-Compute\-Intersections\-Using\-Data\-Bounds ()}  
\item {\ttfamily obj.\-Set\-Compute\-Intersections\-Using\-Data\-Bounds (int c)}  
\item {\ttfamily obj.\-Compute\-Intersections\-Using\-Data\-Bounds\-On ()}  
\item {\ttfamily obj.\-Compute\-Intersections\-Using\-Data\-Bounds\-Off ()}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkcachedstreamingdemanddrivenpipeline}{}\section{vtk\-Cached\-Streaming\-Demand\-Driven\-Pipeline}\label{vtkfiltering_vtkcachedstreamingdemanddrivenpipeline}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Cached\-Streaming\-Demand\-Driven\-Pipeline

To create an instance of class vtk\-Cached\-Streaming\-Demand\-Driven\-Pipeline, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkCachedStreamingDemandDrivenPipeline
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Cached\-Streaming\-Demand\-Driven\-Pipeline has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Cached\-Streaming\-Demand\-Driven\-Pipeline class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Cached\-Streaming\-Demand\-Driven\-Pipeline = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Cached\-Streaming\-Demand\-Driven\-Pipeline = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Update ()} -\/ Bring the algorithm's outputs up-\/to-\/date.  
\item {\ttfamily int = obj.\-Update (int port)} -\/ Bring the algorithm's outputs up-\/to-\/date.  
\item {\ttfamily obj.\-Set\-Cache\-Size (int size)} -\/ This is the maximum number of images that can be retained in memory. it defaults to 10.  
\item {\ttfamily int = obj.\-Get\-Cache\-Size ()} -\/ This is the maximum number of images that can be retained in memory. it defaults to 10.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkcardinalspline}{}\section{vtk\-Cardinal\-Spline}\label{vtkfiltering_vtkcardinalspline}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Cardinal\-Spline is a concrete implementation of vtk\-Spline using a Cardinal basis.

To create an instance of class vtk\-Cardinal\-Spline, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkCardinalSpline
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Cardinal\-Spline has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Cardinal\-Spline class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Cardinal\-Spline = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Cardinal\-Spline = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Compute ()}  
\item {\ttfamily double = obj.\-Evaluate (double t)} -\/ Evaluate a 1\-D cardinal spline.  
\item {\ttfamily obj.\-Deep\-Copy (vtk\-Spline s)} -\/ Deep copy of cardinal spline data.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkcasttoconcrete}{}\section{vtk\-Cast\-To\-Concrete}\label{vtkfiltering_vtkcasttoconcrete}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Cast\-To\-Concrete is a filter that works around type-\/checking limitations in the filter classes. Some filters generate abstract types on output, and cannot be connected to the input of filters requiring a concrete input type. For example, vtk\-Elevation\-Filter generates vtk\-Data\-Set for output, and cannot be connected to vtk\-Decimate, because vtk\-Decimate requires vtk\-Poly\-Data as input. This is true even though (in this example) the input to vtk\-Elevation\-Filter is of type vtk\-Poly\-Data, and you know the output of vtk\-Elevation\-Filter is the same type as its input.

vtk\-Cast\-To\-Concrete performs run-\/time checking to insure that output type is of the right type. An error message will result if you try to cast an input type improperly. Otherwise, the filter performs the appropriate cast and returns the data.

To create an instance of class vtk\-Cast\-To\-Concrete, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkCastToConcrete
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Cast\-To\-Concrete has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Cast\-To\-Concrete class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Cast\-To\-Concrete = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Cast\-To\-Concrete = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkcell}{}\section{vtk\-Cell}\label{vtkfiltering_vtkcell}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Cell is an abstract class that specifies the interfaces for data cells. Data cells are simple topological elements like points, lines, polygons, and tetrahedra of which visualization datasets are composed. In some cases visualization datasets may explicitly represent cells (e.\-g., vtk\-Poly\-Data, vtk\-Unstructured\-Grid), and in some cases, the datasets are implicitly composed of cells (e.\-g., vtk\-Structured\-Points).

To create an instance of class vtk\-Cell, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkCell
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Cell has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Cell class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Cell = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Cell = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Shallow\-Copy (vtk\-Cell c)} -\/ Copy this cell by reference counting the internal data structures. This is safe if you want a \char`\"{}read-\/only\char`\"{} copy. If you modify the cell you might wish to use Deep\-Copy().  
\item {\ttfamily obj.\-Deep\-Copy (vtk\-Cell c)} -\/ Copy this cell by completely copying internal data structures. This is slower but safer than Shallow\-Copy().  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ Return the type of cell.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ Return the topological dimensional of the cell (0,1,2, or 3).  
\item {\ttfamily int = obj.\-Is\-Linear ()} -\/ Some cells require initialization prior to access. For example, they may have to triangulate themselves or set up internal data structures.  
\item {\ttfamily int = obj.\-Requires\-Initialization ()} -\/ Some cells require initialization prior to access. For example, they may have to triangulate themselves or set up internal data structures.  
\item {\ttfamily obj.\-Initialize ()} -\/ Explicit cells require additional representational information beyond the usual cell type and connectivity list information. Most cells in V\-T\-K are implicit cells.  
\item {\ttfamily int = obj.\-Is\-Explicit\-Cell ()} -\/ Get the point coordinates for the cell.  
\item {\ttfamily vtk\-Points = obj.\-Get\-Points ()} -\/ Return the number of points in the cell.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Points ()} -\/ Return the number of edges in the cell.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ Return the number of edges in the cell.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ Return the number of faces in the cell.  
\item {\ttfamily vtk\-Id\-List = obj.\-Get\-Point\-Ids ()} -\/ For cell point i, return the actual point id.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Point\-Id (int pt\-Id)} -\/ Return the edge cell from the edge\-Id of the cell.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int edge\-Id)} -\/ Return the edge cell from the edge\-Id of the cell.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int face\-Id)} -\/ Return the face cell from the face\-Id of the cell.  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)} -\/ Given parametric coordinates of a point, return the closest cell boundary, and whether the point is inside or outside of the cell. The cell boundary is defined by a list of points (pts) that specify a face (3\-D cell), edge (2\-D cell), or vertex (1\-D cell). If the return value of the method is != 0, then the point is inside the cell.  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)} -\/ Generate contouring primitives. The scalar list cell\-Scalars are scalar values at each cell point. The point locator is essentially a points list that merges points as they are inserted (i.\-e., prevents duplicates). Contouring primitives can be vertices, lines, or polygons. It is possible to interpolate point data along the edge by providing input and output point data -\/ if out\-Pd is N\-U\-L\-L, then no interpolation is performed. Also, if the output cell data is non-\/\-N\-U\-L\-L, the cell data from the contoured cell is passed to the generated contouring primitives. (Note\-: the Copy\-Allocate() method must be invoked on both the output cell and point data. The cell\-Id refers to the cell from which the cell data is copied.)  
\item {\ttfamily obj.\-Clip (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array connectivity, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd, int inside\-Out)} -\/ Cut (or clip) the cell based on the input cell\-Scalars and the specified value. The output of the clip operation will be one or more cells of the same topological dimension as the original cell. The flag inside\-Out controls what part of the cell is considered inside -\/ normally cell points whose scalar value is greater than \char`\"{}value\char`\"{} are considered inside. If inside\-Out is on, this is reversed. Also, if the output cell data is non-\/\-N\-U\-L\-L, the cell data from the clipped cell is passed to the generated contouring primitives. (Note\-: the Copy\-Allocate() method must be invoked on both the output cell and point data. The cell\-Id refers to the cell from which the cell data is copied.)  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)} -\/ Generate simplices of proper dimension. If cell is 3\-D, tetrahedron are generated; if 2\-D triangles; if 1\-D lines; if 0\-D points. The form of the output is a sequence of points, each n+1 points (where n is topological cell dimension) defining a simplex. The index is a parameter that controls which triangulation to use (if more than one is possible). If numerical degeneracy encountered, 0 is returned, otherwise 1 is returned. This method does not insert new points\-: all the points that define the simplices are the points that define the cell.  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)} -\/ Compute derivatives given cell sub\-Id and parametric coordinates. The values array is a series of data value(s) at the cell points. There is a one-\/to-\/one correspondence between cell point and data value(s). Dim is the number of data values per cell point. Derivs are derivatives in the x-\/y-\/z coordinate directions for each data value. Thus, if computing derivatives for a scalar function in a hexahedron, dim=1, 8 values are supplied, and 3 deriv values are returned (i.\-e., derivatives in x-\/y-\/z directions). On the other hand, if computing derivatives of velocity (vx,vy,vz) dim=3, 24 values are supplied ((vx,vy,vz)1, (vx,vy,vz)2, ....()8), and 9 deriv values are returned ((d(vx)/dx),(d(vx)/dy),(d(vx)/dz), (d(vy)/dx),(d(vy)/dy), (d(vy)/dz), (d(vz)/dx),(d(vz)/dy),(d(vz)/dz)).  
\item {\ttfamily obj.\-Get\-Bounds (double bounds\mbox{[}6\mbox{]})} -\/ Compute cell bounding box (xmin,xmax,ymin,ymax,zmin,zmax). Copy result into user provided array.  
\item {\ttfamily double = obj.\-Get\-Bounds ()} -\/ Compute cell bounding box (xmin,xmax,ymin,ymax,zmin,zmax). Return pointer to array of six double values.  
\item {\ttfamily double = obj.\-Get\-Length2 ()} -\/ Compute Length squared of cell (i.\-e., bounding box diagonal squared).  
\item {\ttfamily int = obj.\-Get\-Parametric\-Center (double pcoords\mbox{[}3\mbox{]})} -\/ Return center of the cell in parametric coordinates. Note that the parametric center is not always located at (0.\-5,0.\-5,0.\-5). The return value is the sub\-Id that the center is in (if a composite cell). If you want the center in x-\/y-\/z space, invoke the Evaluate\-Location() method.  
\item {\ttfamily double = obj.\-Get\-Parametric\-Distance (double pcoords\mbox{[}3\mbox{]})} -\/ Return the distance of the parametric coordinate provided to the cell. If inside the cell, a distance of zero is returned. This is used during picking to get the correct cell picked. (The tolerance will occasionally allow cells to be picked who are not really intersected \char`\"{}inside\char`\"{} the cell.)  
\item {\ttfamily int = obj.\-Is\-Primary\-Cell ()} -\/ Return a contiguous array of parametric coordinates of the points defining this cell. In other words, (px,py,pz, px,py,pz, etc..) The coordinates are ordered consistent with the definition of the point ordering for the cell. This method returns a non-\/\-N\-U\-L\-L pointer when the cell is a primary type (i.\-e., Is\-Primary\-Cell() is true). Note that 3\-D parametric coordinates are returned no matter what the topological dimension of the cell.  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double weights\mbox{[}3\mbox{]})} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives) No-\/ops at this level. Typically overridden in subclasses.  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs\mbox{[}3\mbox{]})}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkcell3d}{}\section{vtk\-Cell3\-D}\label{vtkfiltering_vtkcell3d}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Cell3\-D is an abstract class that extends the interfaces for 3\-D data cells, and implements methods needed to satisfy the vtk\-Cell A\-P\-I. The 3\-D cells include hexehedra, tetrahedra, wedge, pyramid, and voxel.

To create an instance of class vtk\-Cell3\-D, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkCell3D
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Cell3\-D has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Cell3\-D class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Cell3\-D = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Cell3\-D = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)}  
\item {\ttfamily obj.\-Clip (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array connectivity, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd, int inside\-Out)} -\/ Cut (or clip) the cell based on the input cell\-Scalars and the specified value. The output of the clip operation will be one or more cells of the same topological dimension as the original cell. The flag inside\-Out controls what part of the cell is considered inside -\/ normally cell points whose scalar value is greater than \char`\"{}value\char`\"{} are considered inside. If inside\-Out is on, this is reversed. Also, if the output cell data is non-\/\-N\-U\-L\-L, the cell data from the clipped cell is passed to the generated contouring primitives. (Note\-: the Copy\-Allocate() method must be invoked on both the output cell and point data. The cell\-Id refers to the cell from which the cell data is copied.) (Satisfies vtk\-Cell A\-P\-I.)  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ Set the tolerance for merging clip intersection points that are near the vertices of cells. This tolerance is used to prevent the generation of degenerate tetrahedra during clipping.  
\item {\ttfamily obj.\-Set\-Merge\-Tolerance (double )} -\/ Set the tolerance for merging clip intersection points that are near the vertices of cells. This tolerance is used to prevent the generation of degenerate tetrahedra during clipping.  
\item {\ttfamily double = obj.\-Get\-Merge\-Tolerance\-Min\-Value ()} -\/ Set the tolerance for merging clip intersection points that are near the vertices of cells. This tolerance is used to prevent the generation of degenerate tetrahedra during clipping.  
\item {\ttfamily double = obj.\-Get\-Merge\-Tolerance\-Max\-Value ()} -\/ Set the tolerance for merging clip intersection points that are near the vertices of cells. This tolerance is used to prevent the generation of degenerate tetrahedra during clipping.  
\item {\ttfamily double = obj.\-Get\-Merge\-Tolerance ()} -\/ Set the tolerance for merging clip intersection points that are near the vertices of cells. This tolerance is used to prevent the generation of degenerate tetrahedra during clipping.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkcellarray}{}\section{vtk\-Cell\-Array}\label{vtkfiltering_vtkcellarray}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Cell\-Array is a supporting object that explicitly represents cell connectivity. The cell array structure is a raw integer list of the form\-: (n,id1,id2,...,idn, n,id1,id2,...,idn, ...) where n is the number of points in the cell, and id is a zero-\/offset index into an associated point list.

Advantages of this data structure are its compactness, simplicity, and easy interface to external data. However, it is totally inadequate for random access. This functionality (when necessary) is accomplished by using the vtk\-Cell\-Types and vtk\-Cell\-Links objects to extend the definition of the data structure.

To create an instance of class vtk\-Cell\-Array, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkCellArray
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Cell\-Array has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Cell\-Array class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Cell\-Array = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Cell\-Array = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Allocate (vtk\-Id\-Type sz, int ext)} -\/ Free any memory and reset to an empty state.  
\item {\ttfamily obj.\-Initialize ()} -\/ Free any memory and reset to an empty state.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Cells ()} -\/ Get the number of cells in the array.  
\item {\ttfamily obj.\-Set\-Number\-Of\-Cells (vtk\-Id\-Type )} -\/ Set the number of cells in the array. D\-O N\-O\-T do any kind of allocation, advanced use only.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Estimate\-Size (vtk\-Id\-Type num\-Cells, int max\-Pts\-Per\-Cell)} -\/ A cell traversal methods that is more efficient than vtk\-Data\-Set traversal methods. Init\-Traversal() initializes the traversal of the list of cells.  
\item {\ttfamily obj.\-Init\-Traversal ()} -\/ A cell traversal methods that is more efficient than vtk\-Data\-Set traversal methods. Init\-Traversal() initializes the traversal of the list of cells.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Size ()} -\/ Get the total number of entries (i.\-e., data values) in the connectivity array. This may be much less than the allocated size (i.\-e., return value from Get\-Size().)  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Connectivity\-Entries ()} -\/ Internal method used to retrieve a cell given an offset into the internal array.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Insert\-Next\-Cell (vtk\-Cell cell)} -\/ Insert a cell object. Return the cell id of the cell.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Insert\-Next\-Cell (vtk\-Id\-List pts)} -\/ Create a cell by specifying a list of point ids. Return the cell id of the cell.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Insert\-Next\-Cell (int npts)} -\/ Create cells by specifying count, and then adding points one at a time using method Insert\-Cell\-Point(). If you don't know the count initially, use the method Update\-Cell\-Count() to complete the cell. Return the cell id of the cell.  
\item {\ttfamily obj.\-Insert\-Cell\-Point (vtk\-Id\-Type id)} -\/ Used in conjunction with Insert\-Next\-Cell(int npts) to add another point to the list of cells.  
\item {\ttfamily obj.\-Update\-Cell\-Count (int npts)} -\/ Used in conjunction with Insert\-Next\-Cell(int npts) and Insert\-Cell\-Point() to update the number of points defining the cell.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Insert\-Location (int npts)} -\/ Computes the current insertion location within the internal array. Used in conjunction with Get\-Cell(int loc,...).  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Traversal\-Location ()} -\/ Get/\-Set the current traversal location.  
\item {\ttfamily obj.\-Set\-Traversal\-Location (vtk\-Id\-Type loc)} -\/ Computes the current traversal location within the internal array. Used in conjunction with Get\-Cell(int loc,...).  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Traversal\-Location (vtk\-Id\-Type npts)} -\/ Special method inverts ordering of current cell. Must be called carefully or the cell topology may be corrupted.  
\item {\ttfamily obj.\-Reverse\-Cell (vtk\-Id\-Type loc)} -\/ Special method inverts ordering of current cell. Must be called carefully or the cell topology may be corrupted.  
\item {\ttfamily int = obj.\-Get\-Max\-Cell\-Size ()} -\/ Returns the size of the largest cell. The size is the number of points defining the cell.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Pointer ()} -\/ Get pointer to data array for purpose of direct writes of data. Size is the total storage consumed by the cell array. ncells is the number of cells represented in the array.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Write\-Pointer (vtk\-Id\-Type ncells, vtk\-Id\-Type size)} -\/ Get pointer to data array for purpose of direct writes of data. Size is the total storage consumed by the cell array. ncells is the number of cells represented in the array.  
\item {\ttfamily obj.\-Set\-Cells (vtk\-Id\-Type ncells, vtk\-Id\-Type\-Array cells)} -\/ Define multiple cells by providing a connectivity list. The list is in the form (npts,p0,p1,...p(npts-\/1), repeated for each cell). Be careful using this method because it discards the old cells, and anything referring these cells becomes invalid (for example, if Build\-Cells() has been called see vtk\-Poly\-Data). The traversal location is reset to the beginning of the list; the insertion location is set to the end of the list.  
\item {\ttfamily obj.\-Deep\-Copy (vtk\-Cell\-Array ca)} -\/ Perform a deep copy (no reference counting) of the given cell array.  
\item {\ttfamily vtk\-Id\-Type\-Array = obj.\-Get\-Data ()} -\/ Reuse list. Reset to initial condition.  
\item {\ttfamily obj.\-Reset ()} -\/ Reuse list. Reset to initial condition.  
\item {\ttfamily obj.\-Squeeze ()} -\/ Return the memory in kilobytes consumed by this cell array. Used to support streaming and reading/writing data. The value returned is guaranteed to be greater than or equal to the memory required to actually represent the data represented by this object. The information returned is valid only after the pipeline has been updated.  
\item {\ttfamily long = obj.\-Get\-Actual\-Memory\-Size ()} -\/ Return the memory in kilobytes consumed by this cell array. Used to support streaming and reading/writing data. The value returned is guaranteed to be greater than or equal to the memory required to actually represent the data represented by this object. The information returned is valid only after the pipeline has been updated.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkcelldata}{}\section{vtk\-Cell\-Data}\label{vtkfiltering_vtkcelldata}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Cell\-Data is a class that is used to represent and manipulate cell attribute data (e.\-g., scalars, vectors, normals, texture coordinates, etc.) Special methods are provided to work with filter objects, such as passing data through filter, copying data from one cell to another, and interpolating data given cell interpolation weights.

To create an instance of class vtk\-Cell\-Data, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkCellData
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Cell\-Data has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Cell\-Data class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Cell\-Data = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Cell\-Data = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkcelllinks}{}\section{vtk\-Cell\-Links}\label{vtkfiltering_vtkcelllinks}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Cell\-Links is a supplemental object to vtk\-Cell\-Array and vtk\-Cell\-Types, enabling access from points to the cells using the points. vtk\-Cell\-Links is a list of Links, each link represents a dynamic list of cell id's using the point. The information provided by this object can be used to determine neighbors and construct other local topological information.

To create an instance of class vtk\-Cell\-Links, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkCellLinks
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Cell\-Links has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Cell\-Links class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Cell\-Links = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Cell\-Links = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Allocate (vtk\-Id\-Type num\-Links, vtk\-Id\-Type ext)} -\/ Allocate the specified number of links (i.\-e., number of points) that will be built.  
\item {\ttfamily short = obj.\-Get\-Ncells (vtk\-Id\-Type pt\-Id)} -\/ Get the number of cells using the point specified by pt\-Id.  
\item {\ttfamily obj.\-Build\-Links (vtk\-Data\-Set data)} -\/ Build the link list array.  
\item {\ttfamily obj.\-Build\-Links (vtk\-Data\-Set data, vtk\-Cell\-Array Connectivity)} -\/ Build the link list array.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Cells (vtk\-Id\-Type pt\-Id)} -\/ Return a list of cell ids using the point.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Insert\-Next\-Point (int num\-Links)} -\/ Insert a new point into the cell-\/links data structure. The size parameter is the initial size of the list.  
\item {\ttfamily obj.\-Insert\-Next\-Cell\-Reference (vtk\-Id\-Type pt\-Id, vtk\-Id\-Type cell\-Id)} -\/ Insert a cell id into the list of cells (at the end) using the cell id provided. (Make sure to extend the link list (if necessary) using the method Resize\-Cell\-List().)  
\item {\ttfamily obj.\-Delete\-Point (vtk\-Id\-Type pt\-Id)} -\/ Delete point (and storage) by destroying links to using cells.  
\item {\ttfamily obj.\-Remove\-Cell\-Reference (vtk\-Id\-Type cell\-Id, vtk\-Id\-Type pt\-Id)} -\/ Delete the reference to the cell (cell\-Id) from the point (pt\-Id). This removes the reference to the cell\-Id from the cell list, but does not resize the list (recover memory with Resize\-Cell\-List(), if necessary).  
\item {\ttfamily obj.\-Add\-Cell\-Reference (vtk\-Id\-Type cell\-Id, vtk\-Id\-Type pt\-Id)} -\/ Add the reference to the cell (cell\-Id) from the point (pt\-Id). This adds a reference to the cell\-Id from the cell list, but does not resize the list (extend memory with Resize\-Cell\-List(), if necessary).  
\item {\ttfamily obj.\-Resize\-Cell\-List (vtk\-Id\-Type pt\-Id, int size)} -\/ Change the length of a point's link list (i.\-e., list of cells using a point) by the size specified.  
\item {\ttfamily obj.\-Squeeze ()} -\/ Reclaim any unused memory.  
\item {\ttfamily obj.\-Reset ()} -\/ Reset to a state of no entries without freeing the memory.  
\item {\ttfamily long = obj.\-Get\-Actual\-Memory\-Size ()} -\/ Return the memory in kilobytes consumed by this cell links array. Used to support streaming and reading/writing data. The value returned is guaranteed to be greater than or equal to the memory required to actually represent the data represented by this object. The information returned is valid only after the pipeline has been updated.  
\item {\ttfamily obj.\-Deep\-Copy (vtk\-Cell\-Links src)} -\/ Standard Deep\-Copy method. Since this object contains no reference to other objects, there is no Shallow\-Copy.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkcelllocator}{}\section{vtk\-Cell\-Locator}\label{vtkfiltering_vtkcelllocator}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Cell\-Locator is a spatial search object to quickly locate cells in 3\-D. vtk\-Cell\-Locator uses a uniform-\/level octree subdivision, where each octant (an octant is also referred to as a bucket) carries an indication of whether it is empty or not, and each leaf octant carries a list of the cells inside of it. (An octant is not empty if it has one or more cells inside of it.) Typical operations are intersection with a line to return candidate cells, or intersection with another vtk\-Cell\-Locator to return candidate cells.

To create an instance of class vtk\-Cell\-Locator, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkCellLocator
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Cell\-Locator has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Cell\-Locator class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Cell\-Locator = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Cell\-Locator = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Number\-Of\-Cells\-Per\-Bucket (int N)} -\/ Specify the average number of cells in each octant.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Cells\-Per\-Bucket ()} -\/ reimplemented from vtk\-Abstract\-Cell\-Locator to support bad compilers  
\item {\ttfamily int = obj.\-Intersect\-With\-Line (double a0\mbox{[}3\mbox{]}, double a1\mbox{[}3\mbox{]}, vtk\-Points points, vtk\-Id\-List cell\-Ids)} -\/ Return intersection point (if any) A\-N\-D the cell which was intersected by the finite line. The cell is returned as a cell id and as a generic cell. For other Intersect\-With\-Line signatures, see vtk\-Abstract\-Cell\-Locator  
\item {\ttfamily vtk\-Id\-List = obj.\-Get\-Cells (int bucket)} -\/ Get the cells in a particular bucket.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Buckets (void )} -\/ Return number of buckets available. Insure that the locator has been built before attempting to access buckets (octants).  
\item {\ttfamily vtk\-Id\-Type = obj.\-Find\-Cell (double x\mbox{[}3\mbox{]})} -\/ Find the cell containing a given point. returns -\/1 if no cell found the cell parameters are copied into the supplied variables, a cell must be provided to store the information.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Find\-Cell (double x\mbox{[}3\mbox{]}, double tol2, vtk\-Generic\-Cell Gen\-Cell, double pcoords\mbox{[}3\mbox{]}, double weights)} -\/ Find the cell containing a given point. returns -\/1 if no cell found the cell parameters are copied into the supplied variables, a cell must be provided to store the information.  
\item {\ttfamily obj.\-Find\-Cells\-Within\-Bounds (double bbox, vtk\-Id\-List cells)} -\/ Return a list of unique cell ids inside of a given bounding box. The user must provide the vtk\-Id\-List to populate. This method returns data only after the locator has been built.  
\item {\ttfamily obj.\-Find\-Cells\-Along\-Line (double p1\mbox{[}3\mbox{]}, double p2\mbox{[}3\mbox{]}, double tolerance, vtk\-Id\-List cells)} -\/ Given a finite line defined by the two points (p1,p2), return the list of unique cell ids in the buckets containing the line. It is possible that an empty cell list is returned. The user must provide the vtk\-Id\-List to populate. This method returns data only after the locator has been built.  
\item {\ttfamily obj.\-Free\-Search\-Structure ()} -\/ Satisfy vtk\-Locator abstract interface.  
\item {\ttfamily obj.\-Build\-Locator ()} -\/ Satisfy vtk\-Locator abstract interface.  
\item {\ttfamily obj.\-Build\-Locator\-If\-Needed ()} -\/ Satisfy vtk\-Locator abstract interface.  
\item {\ttfamily obj.\-Force\-Build\-Locator ()} -\/ Satisfy vtk\-Locator abstract interface.  
\item {\ttfamily obj.\-Build\-Locator\-Internal ()} -\/ Satisfy vtk\-Locator abstract interface.  
\item {\ttfamily obj.\-Generate\-Representation (int level, vtk\-Poly\-Data pd)} -\/ Satisfy vtk\-Locator abstract interface.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkcelllocatorinterpolatedvelocityfield}{}\section{vtk\-Cell\-Locator\-Interpolated\-Velocity\-Field}\label{vtkfiltering_vtkcelllocatorinterpolatedvelocityfield}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Cell\-Locator\-Interpolated\-Velocity\-Field acts as a continuous velocity field via cell interpolation on a vtk\-Data\-Set, Number\-Of\-Independent\-Variables = 4 (x,y,z,t) and Number\-Of\-Functions = 3 (u,v,w). As a concrete sub-\/class of vtk\-Abstract\-Interpolated\-Velocity\-Field, it adopts vtk\-Abstract\-Cell\-Locator's sub-\/classes, e.\-g., vtk\-Cell\-Locator and vtk\-Modified\-B\-S\-P\-Tree, without the use of vtk\-Point\-Locator ( employed by vtk\-Data\-Set/vtk\-Point\-Set\-::\-Find\-Cell() in vtk\-Interpolated\-Velocity\-Field ). vtk\-Cell\-Locator\-Interpolated\-Velocity\-Field adopts one level of cell caching. Specifically, if the next point is still within the previous cell, cell location is then simply skipped and vtk\-Cell\-:\-: Evaluate\-Position() is called to obtain the new parametric coordinates and weights that are used to interpolate the velocity function values across the vertices of this cell. Otherwise a global cell (the target containing the next point) location is instead directly invoked, without exploiting the clue that vtk\-Interpolated\-Velocity\-Field makes use of from the previous cell (an immediate neighbor). Although ignoring the neighbor cell may incur a relatively high computational cost, vtk\-Cell\-Locator\-Interpolated\-Velocity\-Field is more robust in locating the target cell than its sibling class vtk\-Interpolated\-Velocity\-Field.

To create an instance of class vtk\-Cell\-Locator\-Interpolated\-Velocity\-Field, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkCellLocatorInterpolatedVelocityField
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Cell\-Locator\-Interpolated\-Velocity\-Field has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Cell\-Locator\-Interpolated\-Velocity\-Field class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Cell\-Locator\-Interpolated\-Velocity\-Field = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Cell\-Locator\-Interpolated\-Velocity\-Field = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Abstract\-Cell\-Locator = obj.\-Get\-Last\-Cell\-Locator ()} -\/ Get the cell locator attached to the most recently visited dataset.  
\item {\ttfamily vtk\-Abstract\-Cell\-Locator = obj.\-Get\-Cell\-Locator\-Prototype ()} -\/ Get the prototype of the cell locator that is used for interpolating the velocity field during integration.  
\item {\ttfamily obj.\-Set\-Cell\-Locator\-Prototype (vtk\-Abstract\-Cell\-Locator prototype)} -\/ Set a prototype of the cell locator that is used for interpolating the velocity field during integration.  
\item {\ttfamily obj.\-Copy\-Parameters (vtk\-Abstract\-Interpolated\-Velocity\-Field from)} -\/ Import parameters. Sub-\/classes can add more after chaining.  
\item {\ttfamily obj.\-Add\-Data\-Set (vtk\-Data\-Set dataset)} -\/ Add a dataset coupled with a cell locator (of type vtk\-Abstract\-Cell\-Locator) for vector function evaluation. Note the use of a vtk\-Abstract\-Cell\-Locator enables robust cell location. If more than one dataset is added, the evaluation point is searched in all until a match is found. T\-H\-I\-S F\-U\-N\-C\-T\-I\-O\-N D\-O\-E\-S N\-O\-T C\-H\-A\-N\-G\-E T\-H\-E R\-E\-F\-E\-R\-E\-N\-C\-E C\-O\-U\-N\-T O\-F dataset F\-O\-R T\-H\-R\-E\-A\-D S\-A\-F\-E\-T\-Y R\-E\-A\-S\-O\-N\-S.  
\item {\ttfamily int = obj.\-Function\-Values (double x, double f)} -\/ Evaluate the velocity field f at point (x, y, z).  
\item {\ttfamily obj.\-Set\-Last\-Cell\-Id (vtk\-Id\-Type c, int dataindex)} -\/ Set the cell id cached by the last evaluation within a specified dataset.  
\item {\ttfamily obj.\-Set\-Last\-Cell\-Id (vtk\-Id\-Type c)}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkcelltypes}{}\section{vtk\-Cell\-Types}\label{vtkfiltering_vtkcelltypes}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This class is a supplemental object to vtk\-Cell\-Array to allow random access into cells as well as representing cell type information. The \char`\"{}location\char`\"{} field is the location in the vtk\-Cell\-Array list in terms of an integer offset. An integer offset was used instead of a pointer for easy storage and inter-\/process communication. The type information is defined in the file vtk\-Cell\-Type.\-h.

To create an instance of class vtk\-Cell\-Types, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkCellTypes
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Cell\-Types has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Cell\-Types class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Cell\-Types = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Cell\-Types = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Allocate (int sz, int ext)} -\/ Allocate memory for this array. Delete old storage only if necessary.  
\item {\ttfamily obj.\-Insert\-Cell (int id, char type, int loc)} -\/ Add a cell at specified id.  
\item {\ttfamily int = obj.\-Insert\-Next\-Cell (char type, int loc)} -\/ Add a cell to the object in the next available slot.  
\item {\ttfamily obj.\-Set\-Cell\-Types (int ncells, vtk\-Unsigned\-Char\-Array cell\-Types, vtk\-Int\-Array cell\-Locations)} -\/ Specify a group of cell types.  
\item {\ttfamily int = obj.\-Get\-Cell\-Location (int cell\-Id)} -\/ Return the location of the cell in the associated vtk\-Cell\-Array.  
\item {\ttfamily obj.\-Delete\-Cell (vtk\-Id\-Type cell\-Id)} -\/ Delete cell by setting to N\-U\-L\-L cell type.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Types ()} -\/ Return the number of types in the list.  
\item {\ttfamily int = obj.\-Is\-Type (char type)} -\/ Return 1 if type specified is contained in list; 0 otherwise.  
\item {\ttfamily int = obj.\-Insert\-Next\-Type (char type)} -\/ Add the type specified to the end of the list. Range checking is performed.  
\item {\ttfamily char = obj.\-Get\-Cell\-Type (int cell\-Id)} -\/ Return the type of cell.  
\item {\ttfamily obj.\-Squeeze ()} -\/ Reclaim any extra memory.  
\item {\ttfamily obj.\-Reset ()} -\/ Initialize object without releasing memory.  
\item {\ttfamily long = obj.\-Get\-Actual\-Memory\-Size ()} -\/ Return the memory in kilobytes consumed by this cell type array. Used to support streaming and reading/writing data. The value returned is guaranteed to be greater than or equal to the memory required to actually represent the data represented by this object. The information returned is valid only after the pipeline has been updated.  
\item {\ttfamily obj.\-Deep\-Copy (vtk\-Cell\-Types src)} -\/ Standard Deep\-Copy method. Since this object contains no reference to other objects, there is no Shallow\-Copy.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkcolortransferfunction}{}\section{vtk\-Color\-Transfer\-Function}\label{vtkfiltering_vtkcolortransferfunction}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Color\-Transfer\-Function is a color mapping in R\-G\-B or H\-S\-V space that uses piecewise hermite functions to allow interpolation that can be piecewise constant, piecewise linear, or somewhere in-\/between (a modified piecewise hermite function that squishes the function according to a sharpness parameter). The function also allows for the specification of the midpoint (the place where the function reaches the average of the two bounding nodes) as a normalize distance between nodes. See the description of class vtk\-Piecewise\-Function for an explanation of midpoint and sharpness.

To create an instance of class vtk\-Color\-Transfer\-Function, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkColorTransferFunction
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Color\-Transfer\-Function has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Color\-Transfer\-Function class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Color\-Transfer\-Function = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Color\-Transfer\-Function = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Deep\-Copy (vtk\-Color\-Transfer\-Function f)}  
\item {\ttfamily obj.\-Shallow\-Copy (vtk\-Color\-Transfer\-Function f)}  
\item {\ttfamily int = obj.\-Get\-Size ()} -\/ How many points are there defining this function?  
\item {\ttfamily int = obj.\-Add\-R\-G\-B\-Point (double x, double r, double g, double b)} -\/ Add/\-Remove a point to/from the function defined in R\-G\-B or H\-S\-V Return the index of the point (0 based), or -\/1 on error. See the description of class vtk\-Piecewise\-Function for an explanation of midpoint and sharpness.  
\item {\ttfamily int = obj.\-Add\-R\-G\-B\-Point (double x, double r, double g, double b, double midpoint, double sharpness)} -\/ Add/\-Remove a point to/from the function defined in R\-G\-B or H\-S\-V Return the index of the point (0 based), or -\/1 on error. See the description of class vtk\-Piecewise\-Function for an explanation of midpoint and sharpness.  
\item {\ttfamily int = obj.\-Add\-H\-S\-V\-Point (double x, double h, double s, double v)} -\/ Add/\-Remove a point to/from the function defined in R\-G\-B or H\-S\-V Return the index of the point (0 based), or -\/1 on error. See the description of class vtk\-Piecewise\-Function for an explanation of midpoint and sharpness.  
\item {\ttfamily int = obj.\-Add\-H\-S\-V\-Point (double x, double h, double s, double v, double midpoint, double sharpness)} -\/ Add/\-Remove a point to/from the function defined in R\-G\-B or H\-S\-V Return the index of the point (0 based), or -\/1 on error. See the description of class vtk\-Piecewise\-Function for an explanation of midpoint and sharpness.  
\item {\ttfamily int = obj.\-Remove\-Point (double x)} -\/ Add/\-Remove a point to/from the function defined in R\-G\-B or H\-S\-V Return the index of the point (0 based), or -\/1 on error. See the description of class vtk\-Piecewise\-Function for an explanation of midpoint and sharpness.  
\item {\ttfamily obj.\-Add\-R\-G\-B\-Segment (double x1, double r1, double g1, double b1, double x2, double r2, double g2, double b2)} -\/ Add two points to the function and remove all the points between them  
\item {\ttfamily obj.\-Add\-H\-S\-V\-Segment (double x1, double h1, double s1, double v1, double x2, double h2, double s2, double v2)} -\/ Add two points to the function and remove all the points between them  
\item {\ttfamily obj.\-Remove\-All\-Points ()} -\/ Remove all points  
\item {\ttfamily double = obj.\-Get\-Color (double x)} -\/ Returns an R\-G\-B color for the specified scalar value  
\item {\ttfamily obj.\-Get\-Color (double x, double rgb\mbox{[}3\mbox{]})} -\/ Returns an R\-G\-B color for the specified scalar value  
\item {\ttfamily double = obj.\-Get\-Red\-Value (double x)} -\/ Get the color components individually.  
\item {\ttfamily double = obj.\-Get\-Green\-Value (double x)} -\/ Get the color components individually.  
\item {\ttfamily double = obj.\-Get\-Blue\-Value (double x)} -\/ Get the color components individually.  
\item {\ttfamily int = obj.\-Get\-Node\-Value (int index, double val\mbox{[}6\mbox{]})} -\/ For the node specified by index, set/get the location (X), R, G, and B values, midpoint, and sharpness values at the node.  
\item {\ttfamily int = obj.\-Set\-Node\-Value (int index, double val\mbox{[}6\mbox{]})} -\/ For the node specified by index, set/get the location (X), R, G, and B values, midpoint, and sharpness values at the node.  
\item {\ttfamily double = obj. Get\-Range ()} -\/ Returns min and max position of all function points.  
\item {\ttfamily int = obj.\-Adjust\-Range (double range\mbox{[}2\mbox{]})} -\/ Remove all points out of the new range, and make sure there is a point at each end of that range. Return 1 on success, 0 otherwise.  
\item {\ttfamily obj.\-Get\-Table (double x1, double x2, int n, double table)} -\/ Fills in a table of n function values between x1 and x2  
\item {\ttfamily obj.\-Get\-Table (double x1, double x2, int n, float table)} -\/ Fills in a table of n function values between x1 and x2  
\item {\ttfamily obj.\-Build\-Function\-From\-Table (double x1, double x2, int size, double table)} -\/ Construct a color transfer function from a table. Function range is is set to \mbox{[}x1, x2\mbox{]}, each function size is set to size, and function points are regularly spaced between x1 and x2. Parameter \char`\"{}table\char`\"{} is assumed to be a block of memory of size \mbox{[}3$\ast$size\mbox{]}  
\item {\ttfamily obj.\-Set\-Clamping (int )} -\/ Sets and gets the clamping value for this transfer function.  
\item {\ttfamily int = obj.\-Get\-Clamping\-Min\-Value ()} -\/ Sets and gets the clamping value for this transfer function.  
\item {\ttfamily int = obj.\-Get\-Clamping\-Max\-Value ()} -\/ Sets and gets the clamping value for this transfer function.  
\item {\ttfamily int = obj.\-Get\-Clamping ()} -\/ Sets and gets the clamping value for this transfer function.  
\item {\ttfamily obj.\-Clamping\-On ()} -\/ Sets and gets the clamping value for this transfer function.  
\item {\ttfamily obj.\-Clamping\-Off ()} -\/ Sets and gets the clamping value for this transfer function.  
\item {\ttfamily obj.\-Set\-Color\-Space (int )} -\/ Set/\-Get the color space used for interpolation\-: R\-G\-B, H\-S\-V, C\-I\-E\-L\-A\-B, or Diverging. In H\-S\-V mode, if H\-S\-V\-Wrap is on, it will take the shortest path in Hue (going back through 0 if that is the shortest way around the hue circle) whereas if H\-S\-V\-Wrap is off it will not go through 0 (in order the match the current functionality of vtk\-Lookup\-Table). Diverging is a special mode where colors will pass through white when interpolating between two saturated colors.  
\item {\ttfamily int = obj.\-Get\-Color\-Space\-Min\-Value ()} -\/ Set/\-Get the color space used for interpolation\-: R\-G\-B, H\-S\-V, C\-I\-E\-L\-A\-B, or Diverging. In H\-S\-V mode, if H\-S\-V\-Wrap is on, it will take the shortest path in Hue (going back through 0 if that is the shortest way around the hue circle) whereas if H\-S\-V\-Wrap is off it will not go through 0 (in order the match the current functionality of vtk\-Lookup\-Table). Diverging is a special mode where colors will pass through white when interpolating between two saturated colors.  
\item {\ttfamily int = obj.\-Get\-Color\-Space\-Max\-Value ()} -\/ Set/\-Get the color space used for interpolation\-: R\-G\-B, H\-S\-V, C\-I\-E\-L\-A\-B, or Diverging. In H\-S\-V mode, if H\-S\-V\-Wrap is on, it will take the shortest path in Hue (going back through 0 if that is the shortest way around the hue circle) whereas if H\-S\-V\-Wrap is off it will not go through 0 (in order the match the current functionality of vtk\-Lookup\-Table). Diverging is a special mode where colors will pass through white when interpolating between two saturated colors.  
\item {\ttfamily obj.\-Set\-Color\-Space\-To\-R\-G\-B ()} -\/ Set/\-Get the color space used for interpolation\-: R\-G\-B, H\-S\-V, C\-I\-E\-L\-A\-B, or Diverging. In H\-S\-V mode, if H\-S\-V\-Wrap is on, it will take the shortest path in Hue (going back through 0 if that is the shortest way around the hue circle) whereas if H\-S\-V\-Wrap is off it will not go through 0 (in order the match the current functionality of vtk\-Lookup\-Table). Diverging is a special mode where colors will pass through white when interpolating between two saturated colors.  
\item {\ttfamily obj.\-Set\-Color\-Space\-To\-H\-S\-V ()} -\/ Set/\-Get the color space used for interpolation\-: R\-G\-B, H\-S\-V, C\-I\-E\-L\-A\-B, or Diverging. In H\-S\-V mode, if H\-S\-V\-Wrap is on, it will take the shortest path in Hue (going back through 0 if that is the shortest way around the hue circle) whereas if H\-S\-V\-Wrap is off it will not go through 0 (in order the match the current functionality of vtk\-Lookup\-Table). Diverging is a special mode where colors will pass through white when interpolating between two saturated colors.  
\item {\ttfamily obj.\-Set\-Color\-Space\-To\-Lab ()} -\/ Set/\-Get the color space used for interpolation\-: R\-G\-B, H\-S\-V, C\-I\-E\-L\-A\-B, or Diverging. In H\-S\-V mode, if H\-S\-V\-Wrap is on, it will take the shortest path in Hue (going back through 0 if that is the shortest way around the hue circle) whereas if H\-S\-V\-Wrap is off it will not go through 0 (in order the match the current functionality of vtk\-Lookup\-Table). Diverging is a special mode where colors will pass through white when interpolating between two saturated colors.  
\item {\ttfamily obj.\-Set\-Color\-Space\-To\-Diverging ()} -\/ Set/\-Get the color space used for interpolation\-: R\-G\-B, H\-S\-V, C\-I\-E\-L\-A\-B, or Diverging. In H\-S\-V mode, if H\-S\-V\-Wrap is on, it will take the shortest path in Hue (going back through 0 if that is the shortest way around the hue circle) whereas if H\-S\-V\-Wrap is off it will not go through 0 (in order the match the current functionality of vtk\-Lookup\-Table). Diverging is a special mode where colors will pass through white when interpolating between two saturated colors.  
\item {\ttfamily int = obj.\-Get\-Color\-Space ()} -\/ Set/\-Get the color space used for interpolation\-: R\-G\-B, H\-S\-V, C\-I\-E\-L\-A\-B, or Diverging. In H\-S\-V mode, if H\-S\-V\-Wrap is on, it will take the shortest path in Hue (going back through 0 if that is the shortest way around the hue circle) whereas if H\-S\-V\-Wrap is off it will not go through 0 (in order the match the current functionality of vtk\-Lookup\-Table). Diverging is a special mode where colors will pass through white when interpolating between two saturated colors.  
\item {\ttfamily obj.\-Set\-H\-S\-V\-Wrap (int )} -\/ Set/\-Get the color space used for interpolation\-: R\-G\-B, H\-S\-V, C\-I\-E\-L\-A\-B, or Diverging. In H\-S\-V mode, if H\-S\-V\-Wrap is on, it will take the shortest path in Hue (going back through 0 if that is the shortest way around the hue circle) whereas if H\-S\-V\-Wrap is off it will not go through 0 (in order the match the current functionality of vtk\-Lookup\-Table). Diverging is a special mode where colors will pass through white when interpolating between two saturated colors.  
\item {\ttfamily int = obj.\-Get\-H\-S\-V\-Wrap ()} -\/ Set/\-Get the color space used for interpolation\-: R\-G\-B, H\-S\-V, C\-I\-E\-L\-A\-B, or Diverging. In H\-S\-V mode, if H\-S\-V\-Wrap is on, it will take the shortest path in Hue (going back through 0 if that is the shortest way around the hue circle) whereas if H\-S\-V\-Wrap is off it will not go through 0 (in order the match the current functionality of vtk\-Lookup\-Table). Diverging is a special mode where colors will pass through white when interpolating between two saturated colors.  
\item {\ttfamily obj.\-H\-S\-V\-Wrap\-On ()} -\/ Set/\-Get the color space used for interpolation\-: R\-G\-B, H\-S\-V, C\-I\-E\-L\-A\-B, or Diverging. In H\-S\-V mode, if H\-S\-V\-Wrap is on, it will take the shortest path in Hue (going back through 0 if that is the shortest way around the hue circle) whereas if H\-S\-V\-Wrap is off it will not go through 0 (in order the match the current functionality of vtk\-Lookup\-Table). Diverging is a special mode where colors will pass through white when interpolating between two saturated colors.  
\item {\ttfamily obj.\-H\-S\-V\-Wrap\-Off ()} -\/ Set/\-Get the color space used for interpolation\-: R\-G\-B, H\-S\-V, C\-I\-E\-L\-A\-B, or Diverging. In H\-S\-V mode, if H\-S\-V\-Wrap is on, it will take the shortest path in Hue (going back through 0 if that is the shortest way around the hue circle) whereas if H\-S\-V\-Wrap is off it will not go through 0 (in order the match the current functionality of vtk\-Lookup\-Table). Diverging is a special mode where colors will pass through white when interpolating between two saturated colors.  
\item {\ttfamily obj.\-Set\-Scale (int )} -\/ Set the type of scale to use, linear or logarithmic. The default is linear. If the scale is logarithmic, and the range contains zero, the color mapping will be linear.  
\item {\ttfamily obj.\-Set\-Scale\-To\-Linear ()} -\/ Set the type of scale to use, linear or logarithmic. The default is linear. If the scale is logarithmic, and the range contains zero, the color mapping will be linear.  
\item {\ttfamily obj.\-Set\-Scale\-To\-Log10 ()} -\/ Set the type of scale to use, linear or logarithmic. The default is linear. If the scale is logarithmic, and the range contains zero, the color mapping will be linear.  
\item {\ttfamily int = obj.\-Get\-Scale ()} -\/ Set the type of scale to use, linear or logarithmic. The default is linear. If the scale is logarithmic, and the range contains zero, the color mapping will be linear.  
\item {\ttfamily obj.\-Fill\-From\-Data\-Pointer (int , double )} -\/ Returns a list of all nodes Fills from a pointer to data stored in a similar list of nodes.  
\item {\ttfamily obj.\-Set\-Allow\-Duplicate\-Scalars (int )} -\/ Toggle whether to allow duplicate scalar values in the color transfer function (off by default).  
\item {\ttfamily int = obj.\-Get\-Allow\-Duplicate\-Scalars ()} -\/ Toggle whether to allow duplicate scalar values in the color transfer function (off by default).  
\item {\ttfamily obj.\-Allow\-Duplicate\-Scalars\-On ()} -\/ Toggle whether to allow duplicate scalar values in the color transfer function (off by default).  
\item {\ttfamily obj.\-Allow\-Duplicate\-Scalars\-Off ()} -\/ Toggle whether to allow duplicate scalar values in the color transfer function (off by default).  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkcompositedataiterator}{}\section{vtk\-Composite\-Data\-Iterator}\label{vtkfiltering_vtkcompositedataiterator}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Composite\-Data\-Iterator provides an interface for accessing datasets in a collection (vtk\-Composite\-Data\-Iterator).

To create an instance of class vtk\-Composite\-Data\-Iterator, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkCompositeDataIterator
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Composite\-Data\-Iterator has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Composite\-Data\-Iterator class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Composite\-Data\-Iterator = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Composite\-Data\-Iterator = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Data\-Set (vtk\-Composite\-Data\-Set ds)} -\/ Set the composite dataset this iterator is iterating over. Must be set before traversal begins.  
\item {\ttfamily vtk\-Composite\-Data\-Set = obj.\-Get\-Data\-Set ()} -\/ Set the composite dataset this iterator is iterating over. Must be set before traversal begins.  
\item {\ttfamily obj.\-Init\-Traversal ()} -\/ Begin iterating over the composite dataset structure.  
\item {\ttfamily obj.\-Init\-Reverse\-Traversal ()} -\/ Begin iterating over the composite dataset structure in reverse order.  
\item {\ttfamily obj.\-Go\-To\-First\-Item ()} -\/ Move the iterator to the beginning of the collection.  
\item {\ttfamily obj.\-Go\-To\-Next\-Item ()} -\/ Move the iterator to the next item in the collection.  
\item {\ttfamily int = obj.\-Is\-Done\-With\-Traversal ()} -\/ Test whether the iterator is finished with the traversal. Returns 1 for yes, and 0 for no. It is safe to call any of the Get\-Current...() methods only when Is\-Done\-With\-Traversal() returns 0.  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Current\-Data\-Object ()} -\/ Returns the current item. Valid only when Is\-Done\-With\-Traversal() returns 0.  
\item {\ttfamily vtk\-Information = obj.\-Get\-Current\-Meta\-Data ()} -\/ Returns the meta-\/data associated with the current item. This will allocate a new vtk\-Information object is none is already present. Use Has\-Current\-Meta\-Data to avoid unnecessary creation of vtk\-Information objects.  
\item {\ttfamily int = obj.\-Has\-Current\-Meta\-Data ()} -\/ Returns if the a meta-\/data information object is present for the current item. Return 1 on success, 0 otherwise.  
\item {\ttfamily obj.\-Set\-Visit\-Only\-Leaves (int )} -\/ If Visit\-Only\-Leaves is true, the iterator will only visit nodes (sub-\/datasets) that are not composite. If it encounters a composite data set, it will automatically traverse that composite dataset until it finds non-\/composite datasets. With this options, it is possible to visit all non-\/composite datasets in tree of composite datasets (composite of composite of composite for example \-:-\/) ) If Visit\-Only\-Leaves is false, Get\-Current\-Data\-Object() may return vtk\-Composite\-Data\-Set. By default, Visit\-Only\-Leaves is 1.  
\item {\ttfamily int = obj.\-Get\-Visit\-Only\-Leaves ()} -\/ If Visit\-Only\-Leaves is true, the iterator will only visit nodes (sub-\/datasets) that are not composite. If it encounters a composite data set, it will automatically traverse that composite dataset until it finds non-\/composite datasets. With this options, it is possible to visit all non-\/composite datasets in tree of composite datasets (composite of composite of composite for example \-:-\/) ) If Visit\-Only\-Leaves is false, Get\-Current\-Data\-Object() may return vtk\-Composite\-Data\-Set. By default, Visit\-Only\-Leaves is 1.  
\item {\ttfamily obj.\-Visit\-Only\-Leaves\-On ()} -\/ If Visit\-Only\-Leaves is true, the iterator will only visit nodes (sub-\/datasets) that are not composite. If it encounters a composite data set, it will automatically traverse that composite dataset until it finds non-\/composite datasets. With this options, it is possible to visit all non-\/composite datasets in tree of composite datasets (composite of composite of composite for example \-:-\/) ) If Visit\-Only\-Leaves is false, Get\-Current\-Data\-Object() may return vtk\-Composite\-Data\-Set. By default, Visit\-Only\-Leaves is 1.  
\item {\ttfamily obj.\-Visit\-Only\-Leaves\-Off ()} -\/ If Visit\-Only\-Leaves is true, the iterator will only visit nodes (sub-\/datasets) that are not composite. If it encounters a composite data set, it will automatically traverse that composite dataset until it finds non-\/composite datasets. With this options, it is possible to visit all non-\/composite datasets in tree of composite datasets (composite of composite of composite for example \-:-\/) ) If Visit\-Only\-Leaves is false, Get\-Current\-Data\-Object() may return vtk\-Composite\-Data\-Set. By default, Visit\-Only\-Leaves is 1.  
\item {\ttfamily obj.\-Set\-Traverse\-Sub\-Tree (int )} -\/ If Traverse\-Sub\-Tree is set to true, the iterator will visit the entire tree structure, otherwise it only visits the first level children. Set to 1 by default.  
\item {\ttfamily int = obj.\-Get\-Traverse\-Sub\-Tree ()} -\/ If Traverse\-Sub\-Tree is set to true, the iterator will visit the entire tree structure, otherwise it only visits the first level children. Set to 1 by default.  
\item {\ttfamily obj.\-Traverse\-Sub\-Tree\-On ()} -\/ If Traverse\-Sub\-Tree is set to true, the iterator will visit the entire tree structure, otherwise it only visits the first level children. Set to 1 by default.  
\item {\ttfamily obj.\-Traverse\-Sub\-Tree\-Off ()} -\/ If Traverse\-Sub\-Tree is set to true, the iterator will visit the entire tree structure, otherwise it only visits the first level children. Set to 1 by default.  
\item {\ttfamily obj.\-Set\-Skip\-Empty\-Nodes (int )} -\/ If Skip\-Empty\-Nodes is true, then N\-U\-L\-L datasets will be skipped. Default is true.  
\item {\ttfamily int = obj.\-Get\-Skip\-Empty\-Nodes ()} -\/ If Skip\-Empty\-Nodes is true, then N\-U\-L\-L datasets will be skipped. Default is true.  
\item {\ttfamily obj.\-Skip\-Empty\-Nodes\-On ()} -\/ If Skip\-Empty\-Nodes is true, then N\-U\-L\-L datasets will be skipped. Default is true.  
\item {\ttfamily obj.\-Skip\-Empty\-Nodes\-Off ()} -\/ If Skip\-Empty\-Nodes is true, then N\-U\-L\-L datasets will be skipped. Default is true.  
\item {\ttfamily int = obj.\-Get\-Current\-Flat\-Index ()} -\/ Flat index is an index obtained by traversing the tree in preorder. This can be used to uniquely identify nodes in the tree. Not valid if Is\-Done\-With\-Traversal() returns true.  
\item {\ttfamily int = obj.\-Get\-Reverse ()} -\/ Returns if the iteration is in reverse order.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkcompositedatapipeline}{}\section{vtk\-Composite\-Data\-Pipeline}\label{vtkfiltering_vtkcompositedatapipeline}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Composite\-Data\-Pipeline is an executive that supports the processing of composite dataset. It supports algorithms that are aware of composite dataset as well as those that are not. Type checking is performed at run time. Algorithms that are not composite dataset-\/aware have to support all dataset types contained in the composite dataset. The pipeline execution can be summarized as follows\-:

R\-E\-Q\-U\-E\-S\-T\-\_\-\-I\-N\-F\-O\-R\-M\-A\-T\-I\-O\-N\-: The producers have to provide information about the contents of the composite dataset in this pass. Sources that can produce more than one piece (note that a piece is different than a block; each piece consistes of 0 or more blocks) should set M\-A\-X\-I\-M\-U\-M\-\_\-\-N\-U\-M\-B\-E\-R\-\_\-\-O\-F\-\_\-\-P\-I\-E\-C\-E\-S to -\/1.

R\-E\-Q\-U\-E\-S\-T\-\_\-\-U\-P\-D\-A\-T\-E\-\_\-\-E\-X\-T\-E\-N\-T\-: This pass is identical to the one implemented in vtk\-Streaming\-Demand\-Driven\-Pipeline

R\-E\-Q\-U\-E\-S\-T\-\_\-\-D\-A\-T\-A\-: This is where the algorithms execute. If the vtk\-Composite\-Data\-Pipeline is assigned to a simple filter, it will invoke the vtk\-Streaming\-Demand\-Driven\-Pipeline passes in a loop, passing a different block each time and will collect the results in a composite dataset. .S\-E\-C\-T\-I\-O\-N See also vtk\-Composite\-Data\-Set

To create an instance of class vtk\-Composite\-Data\-Pipeline, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkCompositeDataPipeline
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Composite\-Data\-Pipeline has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Composite\-Data\-Pipeline class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Composite\-Data\-Pipeline = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Composite\-Data\-Pipeline = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Composite\-Output\-Data (int port)} -\/ Returns the data object stored with the D\-A\-T\-A\-\_\-\-O\-B\-J\-E\-C\-T() in the output port  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkcompositedataset}{}\section{vtk\-Composite\-Data\-Set}\label{vtkfiltering_vtkcompositedataset}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Composite\-Data\-Set is an abstract class that represents a collection of datasets (including other composite datasets). It provides an interface to access the datasets through iterators. vtk\-Composite\-Data\-Set provides methods that are used by subclasses to store the datasets. vtk\-Composite\-Data\-Set provides the datastructure for a full tree representation. Subclasses provide the semantics for it and control how this tree is built.

To create an instance of class vtk\-Composite\-Data\-Set, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkCompositeDataSet
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Composite\-Data\-Set has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Composite\-Data\-Set class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Composite\-Data\-Set = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Composite\-Data\-Set = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Composite\-Data\-Iterator = obj.\-New\-Iterator ()} -\/ Return a new iterator (the iterator has to be deleted by user).  
\item {\ttfamily int = obj.\-Get\-Data\-Object\-Type ()} -\/ Get the port currently producing this object.  
\item {\ttfamily vtk\-Algorithm\-Output = obj.\-Get\-Producer\-Port ()} -\/ Get the port currently producing this object.  
\item {\ttfamily obj.\-Copy\-Structure (vtk\-Composite\-Data\-Set input)} -\/ Copies the tree structure from the input. All pointers to non-\/composite data objects are intialized to N\-U\-L\-L. This also shallow copies the meta data associated with all the nodes.  
\item {\ttfamily obj.\-Set\-Data\-Set (vtk\-Composite\-Data\-Iterator iter, vtk\-Data\-Object data\-Obj)} -\/ Sets the data set at the location pointed by the iterator. The iterator does not need to be iterating over this dataset itself. It can be any composite datasite with similar structure (achieved by using Copy\-Structure).  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Data\-Set (vtk\-Composite\-Data\-Iterator iter)} -\/ Returns the dataset located at the positiong pointed by the iterator. The iterator does not need to be iterating over this dataset itself. It can be an iterator for composite dataset with similar structure (achieved by using Copy\-Structure).  
\item {\ttfamily vtk\-Information = obj.\-Get\-Meta\-Data (vtk\-Composite\-Data\-Iterator iter)} -\/ Returns the meta-\/data associated with the position pointed by the iterator. This will create a new vtk\-Information object if none already exists. Use Has\-Meta\-Data to avoid creating the vtk\-Information object unnecessarily. The iterator does not need to be iterating over this dataset itself. It can be an iterator for composite dataset with similar structure (achieved by using Copy\-Structure).  
\item {\ttfamily int = obj.\-Has\-Meta\-Data (vtk\-Composite\-Data\-Iterator iter)} -\/ Returns if any meta-\/data associated with the position pointed by the iterator. The iterator does not need to be iterating over this dataset itself. It can be an iterator for composite dataset with similar structure (achieved by using Copy\-Structure).  
\item {\ttfamily obj.\-Initialize ()} -\/ Restore data object to initial state,  
\item {\ttfamily obj.\-Shallow\-Copy (vtk\-Data\-Object src)} -\/ Shallow and Deep copy.  
\item {\ttfamily obj.\-Deep\-Copy (vtk\-Data\-Object src)} -\/ Shallow and Deep copy.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Points ()} -\/ Returns the total number of points of all blocks. This will iterate over all blocks and call Get\-Number\-Of\-Points() so it might be expansive.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkcompositedatasetalgorithm}{}\section{vtk\-Composite\-Data\-Set\-Algorithm}\label{vtkfiltering_vtkcompositedatasetalgorithm}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Algorithms that take any type of data object (including composite dataset) and produce a vtk\-Composite\-Data\-Set in the output can subclass from this class.

To create an instance of class vtk\-Composite\-Data\-Set\-Algorithm, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkCompositeDataSetAlgorithm
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Composite\-Data\-Set\-Algorithm has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Composite\-Data\-Set\-Algorithm class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Composite\-Data\-Set\-Algorithm = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Composite\-Data\-Set\-Algorithm = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Composite\-Data\-Set = obj.\-Get\-Output ()} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Composite\-Data\-Set = obj.\-Get\-Output (int )} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Object )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Set\-Input (int , vtk\-Data\-Object )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkcone}{}\section{vtk\-Cone}\label{vtkfiltering_vtkcone}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Cone computes the implicit function and function gradient for a cone. vtk\-Cone is a concrete implementation of vtk\-Implicit\-Function. The cone vertex is located at the origin with axis of rotation coincident with x-\/axis. (Use the superclass' vtk\-Implicit\-Function transformation matrix if necessary to reposition.) The angle specifies the angle between the axis of rotation and the side of the cone.

To create an instance of class vtk\-Cone, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkCone
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Cone has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Cone class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Cone = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Cone = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily double = obj.\-Evaluate\-Function (double x\mbox{[}3\mbox{]})}  
\item {\ttfamily double = obj.\-Evaluate\-Function (double x, double y, double z)}  
\item {\ttfamily obj.\-Evaluate\-Gradient (double x\mbox{[}3\mbox{]}, double g\mbox{[}3\mbox{]})}  
\item {\ttfamily obj.\-Set\-Angle (double )} -\/ Set/\-Get the cone angle (expressed in degrees).  
\item {\ttfamily double = obj.\-Get\-Angle\-Min\-Value ()} -\/ Set/\-Get the cone angle (expressed in degrees).  
\item {\ttfamily double = obj.\-Get\-Angle\-Max\-Value ()} -\/ Set/\-Get the cone angle (expressed in degrees).  
\item {\ttfamily double = obj.\-Get\-Angle ()} -\/ Set/\-Get the cone angle (expressed in degrees).  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkconvexpointset}{}\section{vtk\-Convex\-Point\-Set}\label{vtkfiltering_vtkconvexpointset}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Convex\-Point\-Set is a concrete implementation that represents a 3\-D cell defined by a convex set of points. An example of such a cell is an octant (from an octree). vtk\-Convex\-Point\-Set uses the ordered triangulations approach (vtk\-Ordered\-Triangulator) to create triangulations guaranteed to be compatible across shared faces. This allows a general approach to processing complex, convex cell types.

To create an instance of class vtk\-Convex\-Point\-Set, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkConvexPointSet
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Convex\-Point\-Set has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Convex\-Point\-Set class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Convex\-Point\-Set = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Convex\-Point\-Set = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Has\-Fixed\-Topology ()} -\/ See vtk\-Cell3\-D A\-P\-I for description of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ This cell requires that it be initialized prior to access.  
\item {\ttfamily int = obj.\-Requires\-Initialization ()} -\/ This cell requires that it be initialized prior to access.  
\item {\ttfamily obj.\-Initialize ()} -\/ This cell requires that it be initialized prior to access.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ A convex point set has no explicit cell edge or faces; however implicitly (after triangulation) it does. Currently the method Get\-Number\-Of\-Edges() always returns 0 while the Get\-Number\-Of\-Faces() returns the number of boundary triangles of the triangulation of the convex point set. The method Get\-Number\-Of\-Faces() triggers a triangulation of the convex point set; repeated calls to Get\-Face() then return the boundary faces. (Note\-: Get\-Number\-Of\-Edges() currently returns 0 because it is a rarely used method and hard to implement. It can be changed in the future.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int )} -\/ A convex point set has no explicit cell edge or faces; however implicitly (after triangulation) it does. Currently the method Get\-Number\-Of\-Edges() always returns 0 while the Get\-Number\-Of\-Faces() returns the number of boundary triangles of the triangulation of the convex point set. The method Get\-Number\-Of\-Faces() triggers a triangulation of the convex point set; repeated calls to Get\-Face() then return the boundary faces. (Note\-: Get\-Number\-Of\-Edges() currently returns 0 because it is a rarely used method and hard to implement. It can be changed in the future.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ A convex point set has no explicit cell edge or faces; however implicitly (after triangulation) it does. Currently the method Get\-Number\-Of\-Edges() always returns 0 while the Get\-Number\-Of\-Faces() returns the number of boundary triangles of the triangulation of the convex point set. The method Get\-Number\-Of\-Faces() triggers a triangulation of the convex point set; repeated calls to Get\-Face() then return the boundary faces. (Note\-: Get\-Number\-Of\-Edges() currently returns 0 because it is a rarely used method and hard to implement. It can be changed in the future.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int face\-Id)} -\/ A convex point set has no explicit cell edge or faces; however implicitly (after triangulation) it does. Currently the method Get\-Number\-Of\-Edges() always returns 0 while the Get\-Number\-Of\-Faces() returns the number of boundary triangles of the triangulation of the convex point set. The method Get\-Number\-Of\-Faces() triggers a triangulation of the convex point set; repeated calls to Get\-Face() then return the boundary faces. (Note\-: Get\-Number\-Of\-Edges() currently returns 0 because it is a rarely used method and hard to implement. It can be changed in the future.  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)} -\/ Satisfy the vtk\-Cell A\-P\-I. This method contours by triangulating the cell and then contouring the resulting tetrahedra.  
\item {\ttfamily obj.\-Clip (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array connectivity, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd, int inside\-Out)} -\/ Satisfy the vtk\-Cell A\-P\-I. This method contours by triangulating the cell and then adding clip-\/edge intersection points into the triangulation; extracting the clipped region.  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)} -\/ Triangulate using methods of vtk\-Ordered\-Triangulator.  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)} -\/ Computes derivatives by triangulating and from sub\-Id and pcoords, evaluating derivatives on the resulting tetrahedron.  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)} -\/ Returns the set of points forming a face of the triangulation of these points that are on the boundary of the cell that are closest parametrically to the point specified.  
\item {\ttfamily int = obj.\-Get\-Parametric\-Center (double pcoords\mbox{[}3\mbox{]})} -\/ Return the center of the cell in parametric coordinates.  
\item {\ttfamily int = obj.\-Is\-Primary\-Cell ()} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double sf)} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs)} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkcoordinate}{}\section{vtk\-Coordinate}\label{vtkfiltering_vtkcoordinate}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Coordinate represents position in a variety of coordinate systems, and converts position to other coordinate systems. It also supports relative positioning, so you can create a cascade of vtk\-Coordinate objects (no loops please!) that refer to each other. The typical usage of this object is to set the coordinate system in which to represent a position (e.\-g., Set\-Coordinate\-System\-To\-Normalized\-Display()), set the value of the coordinate (e.\-g., Set\-Value()), and then invoke the appropriate method to convert to another coordinate system (e.\-g., Get\-Computed\-World\-Value()).

The coordinate systems in vtk are as follows\-: 
\begin{DoxyPre}
  DISPLAY -             x-y pixel values in window
  NORMALIZED DISPLAY -  x-y (0,1) normalized values
  VIEWPORT -            x-y pixel values in viewport
  NORMALIZED VIEWPORT - x-y (0,1) normalized value in viewport
  VIEW -                x-y-z (-1,1) values in camera coordinates. (z is depth)
  WORLD -               x-y-z global coordinate values
  USERDEFINED -         x-y-z in User defined space
\end{DoxyPre}


If you cascade vtk\-Coordinate objects, you refer to another vtk\-Coordinate object which in turn can refer to others, and so on. This allows you to create composite groups of things like vtk\-Actor2\-D that are positioned relative to one another. Note that in cascaded sequences, each vtk\-Coordinate object may be specified in different coordinate systems!

To create an instance of class vtk\-Coordinate, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkCoordinate
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Coordinate has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Coordinate class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Coordinate = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Coordinate = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Coordinate\-System (int )} -\/ Set/get the coordinate system which this coordinate is defined in. The options are Display, Normalized Display, Viewport, Normalized Viewport, View, and World.  
\item {\ttfamily int = obj.\-Get\-Coordinate\-System ()} -\/ Set/get the coordinate system which this coordinate is defined in. The options are Display, Normalized Display, Viewport, Normalized Viewport, View, and World.  
\item {\ttfamily obj.\-Set\-Coordinate\-System\-To\-Display ()} -\/ Set/get the coordinate system which this coordinate is defined in. The options are Display, Normalized Display, Viewport, Normalized Viewport, View, and World.  
\item {\ttfamily obj.\-Set\-Coordinate\-System\-To\-Normalized\-Display ()} -\/ Set/get the coordinate system which this coordinate is defined in. The options are Display, Normalized Display, Viewport, Normalized Viewport, View, and World.  
\item {\ttfamily obj.\-Set\-Coordinate\-System\-To\-Viewport ()} -\/ Set/get the coordinate system which this coordinate is defined in. The options are Display, Normalized Display, Viewport, Normalized Viewport, View, and World.  
\item {\ttfamily obj.\-Set\-Coordinate\-System\-To\-Normalized\-Viewport ()} -\/ Set/get the coordinate system which this coordinate is defined in. The options are Display, Normalized Display, Viewport, Normalized Viewport, View, and World.  
\item {\ttfamily obj.\-Set\-Coordinate\-System\-To\-View ()} -\/ Set/get the coordinate system which this coordinate is defined in. The options are Display, Normalized Display, Viewport, Normalized Viewport, View, and World.  
\item {\ttfamily obj.\-Set\-Coordinate\-System\-To\-World ()}  
\item {\ttfamily string = obj.\-Get\-Coordinate\-System\-As\-String ()}  
\item {\ttfamily obj.\-Set\-Value (double , double , double )} -\/ Set/get the value of this coordinate. This can be thought of as the position of this coordinate in its coordinate system.  
\item {\ttfamily obj.\-Set\-Value (double a\mbox{[}3\mbox{]})} -\/ Set/get the value of this coordinate. This can be thought of as the position of this coordinate in its coordinate system.  
\item {\ttfamily double = obj. Get\-Value ()} -\/ Set/get the value of this coordinate. This can be thought of as the position of this coordinate in its coordinate system.  
\item {\ttfamily obj.\-Set\-Value (double a, double b)} -\/ If this coordinate is relative to another coordinate, then specify that coordinate as the Reference\-Coordinate. If this is N\-U\-L\-L the coordinate is assumed to be absolute.  
\item {\ttfamily obj.\-Set\-Reference\-Coordinate (vtk\-Coordinate )} -\/ If this coordinate is relative to another coordinate, then specify that coordinate as the Reference\-Coordinate. If this is N\-U\-L\-L the coordinate is assumed to be absolute.  
\item {\ttfamily vtk\-Coordinate = obj.\-Get\-Reference\-Coordinate ()} -\/ If this coordinate is relative to another coordinate, then specify that coordinate as the Reference\-Coordinate. If this is N\-U\-L\-L the coordinate is assumed to be absolute.  
\item {\ttfamily obj.\-Set\-Viewport (vtk\-Viewport viewport)} -\/ If you want this coordinate to be relative to a specific vtk\-Viewport (vtk\-Renderer) then you can specify that here. N\-O\-T\-E\-: this is a raw pointer, not a weak pointer not a reference counted object to avoid reference cycle loop between rendering classes and filter classes.  
\item {\ttfamily vtk\-Viewport = obj.\-Get\-Viewport ()} -\/ If you want this coordinate to be relative to a specific vtk\-Viewport (vtk\-Renderer) then you can specify that here. N\-O\-T\-E\-: this is a raw pointer, not a weak pointer not a reference counted object to avoid reference cycle loop between rendering classes and filter classes.  
\item {\ttfamily double = obj.\-Get\-Computed\-World\-Value (vtk\-Viewport )} -\/ Return the computed value in a specified coordinate system.  
\item {\ttfamily int = obj.\-Get\-Computed\-Viewport\-Value (vtk\-Viewport )} -\/ Return the computed value in a specified coordinate system.  
\item {\ttfamily int = obj.\-Get\-Computed\-Display\-Value (vtk\-Viewport )} -\/ Return the computed value in a specified coordinate system.  
\item {\ttfamily int = obj.\-Get\-Computed\-Local\-Display\-Value (vtk\-Viewport )} -\/ Return the computed value in a specified coordinate system.  
\item {\ttfamily double = obj.\-Get\-Computed\-Double\-Viewport\-Value (vtk\-Viewport )}  
\item {\ttfamily double = obj.\-Get\-Computed\-Double\-Display\-Value (vtk\-Viewport )}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkcubicline}{}\section{vtk\-Cubic\-Line}\label{vtkfiltering_vtkcubicline}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Cubic\-Line is a concrete implementation of vtk\-Non\-Linear\-Cell to represent a 1\-D Cubic line. The Cubic Line is the 4 nodes isoparametric parabolic line . The interpolation is the standard finite element, cubic isoparametric shape function. The cell includes two mid-\/edge nodes. The ordering of the four points defining the cell is point ids (0,1,2,3) where id \#2 and \#3 are the mid-\/edge nodes. Please note that the parametric coordinates lie between -\/1 and 1 in accordance with most standard documentations. .S\-E\-C\-T\-I\-O\-N Thanks $<$verbatim$>$ This file has been developed by Oxalya -\/ www.\-oxalya.\-com Copyright (c) E\-D\-F -\/ www.\-edf.\-fr $<$/verbatim$>$

To create an instance of class vtk\-Cubic\-Line, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkCubicLine
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Cubic\-Line has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Cubic\-Line class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Cubic\-Line = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Cubic\-Line = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int )} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int )} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily double = obj.\-Get\-Parametric\-Distance (double pcoords\mbox{[}3\mbox{]})} -\/ Return the distance of the parametric coordinate provided to the cell. If inside the cell, a distance of zero is returned.  
\item {\ttfamily obj.\-Clip (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array lines, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd, int inside\-Out)} -\/ Clip this line using scalar value provided. Like contouring, except that it cuts the line to produce other lines.  
\item {\ttfamily int = obj.\-Get\-Parametric\-Center (double pcoords\mbox{[}3\mbox{]})} -\/ Return the center of the triangle in parametric coordinates.  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double weights\mbox{[}4\mbox{]})} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs\mbox{[}4\mbox{]})}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkcylinder}{}\section{vtk\-Cylinder}\label{vtkfiltering_vtkcylinder}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Cylinder computes the implicit function and function gradient for a cylinder. vtk\-Cylinder is a concrete implementation of vtk\-Implicit\-Function. Cylinder is centered at Center and axes of rotation is along the y-\/axis. (Use the superclass' vtk\-Implicit\-Function transformation matrix if necessary to reposition.)

To create an instance of class vtk\-Cylinder, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkCylinder
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Cylinder has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Cylinder class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Cylinder = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Cylinder = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily double = obj.\-Evaluate\-Function (double x\mbox{[}3\mbox{]})}  
\item {\ttfamily double = obj.\-Evaluate\-Function (double x, double y, double z)}  
\item {\ttfamily obj.\-Evaluate\-Gradient (double x\mbox{[}3\mbox{]}, double g\mbox{[}3\mbox{]})}  
\item {\ttfamily obj.\-Set\-Radius (double )} -\/ Set/\-Get cylinder radius.  
\item {\ttfamily double = obj.\-Get\-Radius ()} -\/ Set/\-Get cylinder radius.  
\item {\ttfamily obj.\-Set\-Center (double , double , double )} -\/ Set/\-Get cylinder center  
\item {\ttfamily obj.\-Set\-Center (double a\mbox{[}3\mbox{]})} -\/ Set/\-Get cylinder center  
\item {\ttfamily double = obj. Get\-Center ()} -\/ Set/\-Get cylinder center  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkdataobject}{}\section{vtk\-Data\-Object}\label{vtkfiltering_vtkdataobject}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Data\-Object is an general representation of visualization data. It serves to encapsulate instance variables and methods for visualization network execution, as well as representing data consisting of a field (i.\-e., just an unstructured pile of data). This is to be compared with a vtk\-Data\-Set, which is data with geometric and/or topological structure.

vtk\-Data\-Objects are used to represent arbitrary repositories of data via the vtk\-Field\-Data instance variable. These data must be eventually mapped into a concrete subclass of vtk\-Data\-Set before they can actually be displayed.

To create an instance of class vtk\-Data\-Object, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkDataObject
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Data\-Object has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Data\-Object class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Data\-Object = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Data\-Object = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Source = obj.\-Get\-Source ()} -\/ Set/\-Get the source object creating this data object.  
\item {\ttfamily obj.\-Set\-Source (vtk\-Source s)} -\/ Set/\-Get the source object creating this data object.  
\item {\ttfamily vtk\-Information = obj.\-Get\-Information ()} -\/ Set/\-Get the information object associated with this data object.  
\item {\ttfamily obj.\-Set\-Information (vtk\-Information )} -\/ Set/\-Get the information object associated with this data object.  
\item {\ttfamily vtk\-Information = obj.\-Get\-Pipeline\-Information ()} -\/ Get/\-Set the pipeline information object that owns this data object.  
\item {\ttfamily obj.\-Set\-Pipeline\-Information (vtk\-Information )} -\/ Get/\-Set the pipeline information object that owns this data object.  
\item {\ttfamily vtk\-Algorithm\-Output = obj.\-Get\-Producer\-Port ()} -\/ Get the port currently producing this object.  
\item {\ttfamily long = obj.\-Get\-M\-Time ()} -\/ Data objects are composite objects and need to check each part for M\-Time. The information object also needs to be considered.  
\item {\ttfamily obj.\-Initialize ()} -\/ Restore data object to initial state,  
\item {\ttfamily obj.\-Release\-Data ()} -\/ Release data back to system to conserve memory resource. Used during visualization network execution. Releasing this data does not make down-\/stream data invalid, so it does not modify the M\-Time of this data object.  
\item {\ttfamily int = obj.\-Should\-I\-Release\-Data ()} -\/ Return flag indicating whether data should be released after use by a filter.  
\item {\ttfamily int = obj.\-Get\-Data\-Released ()} -\/ Get the flag indicating the data has been released.  
\item {\ttfamily obj.\-Set\-Release\-Data\-Flag (int )} -\/ Turn on/off flag to control whether this object's data is released after being used by a filter.  
\item {\ttfamily int = obj.\-Get\-Release\-Data\-Flag ()} -\/ Turn on/off flag to control whether this object's data is released after being used by a filter.  
\item {\ttfamily obj.\-Release\-Data\-Flag\-On ()} -\/ Turn on/off flag to control whether this object's data is released after being used by a filter.  
\item {\ttfamily obj.\-Release\-Data\-Flag\-Off ()} -\/ Turn on/off flag to control whether this object's data is released after being used by a filter.  
\item {\ttfamily obj.\-Global\-Release\-Data\-Flag\-On ()} -\/ Turn on/off flag to control whether every object releases its data after being used by a filter.  
\item {\ttfamily obj.\-Global\-Release\-Data\-Flag\-Off ()} -\/ Turn on/off flag to control whether every object releases its data after being used by a filter.  
\item {\ttfamily obj.\-Set\-Field\-Data (vtk\-Field\-Data )} -\/ Assign or retrieve a general field data to this data object.  
\item {\ttfamily vtk\-Field\-Data = obj.\-Get\-Field\-Data ()} -\/ Assign or retrieve a general field data to this data object.  
\item {\ttfamily obj.\-Register (vtk\-Object\-Base o)}  
\item {\ttfamily obj.\-Un\-Register (vtk\-Object\-Base o)}  
\item {\ttfamily obj.\-Update ()} -\/ Provides opportunity for the data object to insure internal consistency before access. Also causes owning source/filter (if any) to update itself. The Update() method is composed of Update\-Information(), Propagate\-Update\-Extent(), Trigger\-Asynchronous\-Update(), and Update\-Data().  
\item {\ttfamily obj.\-Update\-Information ()} -\/ W\-A\-R\-N\-I\-N\-G\-: I\-N\-T\-E\-R\-N\-A\-L M\-E\-T\-H\-O\-D -\/ N\-O\-T F\-O\-R G\-E\-N\-E\-R\-A\-L U\-S\-E. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S P\-A\-R\-T O\-F T\-H\-E P\-I\-P\-E\-L\-I\-N\-E U\-P\-D\-A\-T\-E F\-U\-N\-C\-T\-I\-O\-N\-A\-L\-I\-T\-Y. Update all the \char`\"{}easy to update\char`\"{} information about the object such as the extent which will be used to control the update. This propagates all the way up then back down the pipeline. As a by-\/product the Pipeline\-M\-Time is updated.  
\item {\ttfamily obj.\-Propagate\-Update\-Extent ()} -\/ W\-A\-R\-N\-I\-N\-G\-: I\-N\-T\-E\-R\-N\-A\-L M\-E\-T\-H\-O\-D -\/ N\-O\-T F\-O\-R G\-E\-N\-E\-R\-A\-L U\-S\-E. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S P\-A\-R\-T O\-F T\-H\-E P\-I\-P\-E\-L\-I\-N\-E U\-P\-D\-A\-T\-E F\-U\-N\-C\-T\-I\-O\-N\-A\-L\-I\-T\-Y. The update extent for this object is propagated up the pipeline. This propagation may early terminate based on the Pipeline\-M\-Time.  
\item {\ttfamily obj.\-Trigger\-Asynchronous\-Update ()} -\/ W\-A\-R\-N\-I\-N\-G\-: I\-N\-T\-E\-R\-N\-A\-L M\-E\-T\-H\-O\-D -\/ N\-O\-T F\-O\-R G\-E\-N\-E\-R\-A\-L U\-S\-E. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S P\-A\-R\-T O\-F T\-H\-E P\-I\-P\-E\-L\-I\-N\-E U\-P\-D\-A\-T\-E F\-U\-N\-C\-T\-I\-O\-N\-A\-L\-I\-T\-Y. Propagate back up the pipeline for ports and trigger the update on the other side of the port to allow for asynchronous parallel processing in the pipeline. This propagation may early terminate based on the Pipeline\-M\-Time.  
\item {\ttfamily obj.\-Update\-Data ()} -\/ W\-A\-R\-N\-I\-N\-G\-: I\-N\-T\-E\-R\-N\-A\-L M\-E\-T\-H\-O\-D -\/ N\-O\-T F\-O\-R G\-E\-N\-E\-R\-A\-L U\-S\-E. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S P\-A\-R\-T O\-F T\-H\-E P\-I\-P\-E\-L\-I\-N\-E U\-P\-D\-A\-T\-E F\-U\-N\-C\-T\-I\-O\-N\-A\-L\-I\-T\-Y. Propagate the update back up the pipeline, and perform the actual work of updating on the way down. When the propagate arrives at a port, block and wait for the asynchronous update to finish on the other side. This propagation may early terminate based on the Pipeline\-M\-Time.  
\item {\ttfamily long = obj.\-Get\-Estimated\-Memory\-Size ()} -\/ Get the estimated size of this data object itself. Should be called after Update\-Information() and Propagate\-Update\-Extent() have both been called. Should be overridden in a subclass -\/ otherwise the default is to assume that this data object requires no memory. The size is returned in kilobytes.  
\item {\ttfamily obj.\-Set\-Update\-Extent (int piece, int num\-Pieces, int ghost\-Level)} -\/ A generic way of specifying an update extent. Subclasses must decide what a piece is. When the Number\-Of\-Pieces is zero, then no data is requested, and the source will not execute.  
\item {\ttfamily obj.\-Set\-Update\-Extent (int piece, int num\-Pieces)} -\/ Set the update extent for data objects that use 3\-D extents. Using this method on data objects that set extents as pieces (such as vtk\-Poly\-Data or vtk\-Unstructured\-Grid) has no real effect. Don't use the set macro to set the update extent since we don't want this object to be modified just due to a change in update extent. When the volume of the extent is zero (0, -\/1,..), then no data is requested, and the source will not execute.  
\item {\ttfamily obj.\-Set\-Update\-Extent (int x0, int x1, int y0, int y1, int z0, int z1)} -\/ Set the update extent for data objects that use 3\-D extents. Using this method on data objects that set extents as pieces (such as vtk\-Poly\-Data or vtk\-Unstructured\-Grid) has no real effect. Don't use the set macro to set the update extent since we don't want this object to be modified just due to a change in update extent. When the volume of the extent is zero (0, -\/1,..), then no data is requested, and the source will not execute.  
\item {\ttfamily obj.\-Set\-Update\-Extent (int extent\mbox{[}6\mbox{]})} -\/ Set the update extent for data objects that use 3\-D extents. Using this method on data objects that set extents as pieces (such as vtk\-Poly\-Data or vtk\-Unstructured\-Grid) has no real effect. Don't use the set macro to set the update extent since we don't want this object to be modified just due to a change in update extent. When the volume of the extent is zero (0, -\/1,..), then no data is requested, and the source will not execute.  
\item {\ttfamily int = obj.\-Get\-Update\-Extent ()} -\/ Set the update extent for data objects that use 3\-D extents. Using this method on data objects that set extents as pieces (such as vtk\-Poly\-Data or vtk\-Unstructured\-Grid) has no real effect. Don't use the set macro to set the update extent since we don't want this object to be modified just due to a change in update extent. When the volume of the extent is zero (0, -\/1,..), then no data is requested, and the source will not execute.  
\item {\ttfamily obj.\-Get\-Update\-Extent (int extent\mbox{[}6\mbox{]})} -\/ Set the update extent for data objects that use 3\-D extents. Using this method on data objects that set extents as pieces (such as vtk\-Poly\-Data or vtk\-Unstructured\-Grid) has no real effect. Don't use the set macro to set the update extent since we don't want this object to be modified just due to a change in update extent. When the volume of the extent is zero (0, -\/1,..), then no data is requested, and the source will not execute.  
\item {\ttfamily int = obj.\-Get\-Data\-Object\-Type ()} -\/ Used by Threaded ports to determine if they should initiate an asynchronous update (still in development).  
\item {\ttfamily long = obj.\-Get\-Update\-Time ()} -\/ Used by Threaded ports to determine if they should initiate an asynchronous update (still in development).  
\item {\ttfamily obj.\-Set\-Update\-Extent\-To\-Whole\-Extent ()} -\/ If the whole input extent is required to generate the requested output extent, this method can be called to set the input update extent to the whole input extent. This method assumes that the whole extent is known (that Update\-Information has been called)  
\item {\ttfamily long = obj.\-Get\-Pipeline\-M\-Time ()} -\/ Get the cumulative modified time of everything upstream. Does not include the M\-Time of this object.  
\item {\ttfamily long = obj.\-Get\-Actual\-Memory\-Size ()} -\/ Return the actual size of the data in kilobytes. This number is valid only after the pipeline has updated. The memory size returned is guaranteed to be greater than or equal to the memory required to represent the data (e.\-g., extra space in arrays, etc. are not included in the return value).  
\item {\ttfamily obj.\-Copy\-Information (vtk\-Data\-Object data)} -\/ Copy the generic information (Whole\-Extent ...)  
\item {\ttfamily obj.\-Copy\-Type\-Specific\-Information (vtk\-Data\-Object data)} -\/ By default, there is no type specific information  
\item {\ttfamily obj.\-Set\-Update\-Piece (int piece)} -\/ Set / Get the update piece and the update number of pieces. Similar to update extent in 3\-D.  
\item {\ttfamily obj.\-Set\-Update\-Number\-Of\-Pieces (int num)} -\/ Set / Get the update piece and the update number of pieces. Similar to update extent in 3\-D.  
\item {\ttfamily int = obj.\-Get\-Update\-Piece ()} -\/ Set / Get the update piece and the update number of pieces. Similar to update extent in 3\-D.  
\item {\ttfamily int = obj.\-Get\-Update\-Number\-Of\-Pieces ()} -\/ Set / Get the update piece and the update number of pieces. Similar to update extent in 3\-D.  
\item {\ttfamily obj.\-Set\-Update\-Ghost\-Level (int level)} -\/ Set / Get the update ghost level and the update number of ghost levels. Similar to update extent in 3\-D.  
\item {\ttfamily int = obj.\-Get\-Update\-Ghost\-Level ()} -\/ Set / Get the update ghost level and the update number of ghost levels. Similar to update extent in 3\-D.  
\item {\ttfamily obj.\-Set\-Request\-Exact\-Extent (int flag)} -\/ This request flag indicates whether the requester can handle more data than requested. Right now it is used in vtk\-Image\-Data. Image filters can return more data than requested. The the consumer cannot handle this (i.\-e. Data\-Set\-To\-Data\-Set\-Fitler) the image will crop itself. This functionality used to be in Image\-To\-Structured\-Points.  
\item {\ttfamily int = obj.\-Get\-Request\-Exact\-Extent ()} -\/ This request flag indicates whether the requester can handle more data than requested. Right now it is used in vtk\-Image\-Data. Image filters can return more data than requested. The the consumer cannot handle this (i.\-e. Data\-Set\-To\-Data\-Set\-Fitler) the image will crop itself. This functionality used to be in Image\-To\-Structured\-Points.  
\item {\ttfamily obj.\-Request\-Exact\-Extent\-On ()} -\/ This request flag indicates whether the requester can handle more data than requested. Right now it is used in vtk\-Image\-Data. Image filters can return more data than requested. The the consumer cannot handle this (i.\-e. Data\-Set\-To\-Data\-Set\-Fitler) the image will crop itself. This functionality used to be in Image\-To\-Structured\-Points.  
\item {\ttfamily obj.\-Request\-Exact\-Extent\-Off ()} -\/ This request flag indicates whether the requester can handle more data than requested. Right now it is used in vtk\-Image\-Data. Image filters can return more data than requested. The the consumer cannot handle this (i.\-e. Data\-Set\-To\-Data\-Set\-Fitler) the image will crop itself. This functionality used to be in Image\-To\-Structured\-Points.  
\item {\ttfamily obj.\-Set\-Whole\-Extent (int x0, int x1, int y0, int y1, int z0, int z1)} -\/ Set/\-Get the whole extent of this data object. The whole extent is meta data for structured data sets. It gets set by the source during the update information call.  
\item {\ttfamily obj.\-Set\-Whole\-Extent (int extent\mbox{[}6\mbox{]})} -\/ Set/\-Get the whole extent of this data object. The whole extent is meta data for structured data sets. It gets set by the source during the update information call.  
\item {\ttfamily int = obj.\-Get\-Whole\-Extent ()} -\/ Set/\-Get the whole extent of this data object. The whole extent is meta data for structured data sets. It gets set by the source during the update information call.  
\item {\ttfamily obj.\-Get\-Whole\-Extent (int extent\mbox{[}6\mbox{]})} -\/ Set/\-Get the whole extent of this data object. The whole extent is meta data for structured data sets. It gets set by the source during the update information call.  
\item {\ttfamily obj.\-Set\-Whole\-Bounding\-Box (double x0, double x1, double y0, double y1, double z0, double z1)} -\/ Set/\-Get the whole bounding box of this data object. The whole whole bounding box is meta data for data sets It gets set by the source during the update information call.  
\item {\ttfamily obj.\-Set\-Whole\-Bounding\-Box (double bb\mbox{[}6\mbox{]})} -\/ Set/\-Get the whole bounding box of this data object. The whole whole bounding box is meta data for data sets It gets set by the source during the update information call.  
\item {\ttfamily double = obj.\-Get\-Whole\-Bounding\-Box ()} -\/ Set/\-Get the whole bounding box of this data object. The whole whole bounding box is meta data for data sets It gets set by the source during the update information call.  
\item {\ttfamily obj.\-Get\-Whole\-Bounding\-Box (double extent\mbox{[}6\mbox{]})} -\/ Set/\-Get the whole bounding box of this data object. The whole whole bounding box is meta data for data sets It gets set by the source during the update information call.  
\item {\ttfamily obj.\-Set\-Maximum\-Number\-Of\-Pieces (int )} -\/ Set/\-Get the maximum number of pieces that can be requested. The maximum number of pieces is meta data for unstructured data sets. It gets set by the source during the update information call. A value of -\/1 indicates that there is no maximum. A value of  
\item {\ttfamily int = obj.\-Get\-Maximum\-Number\-Of\-Pieces ()} -\/ Set/\-Get the maximum number of pieces that can be requested. The maximum number of pieces is meta data for unstructured data sets. It gets set by the source during the update information call. A value of -\/1 indicates that there is no maximum. A value of  
\item {\ttfamily obj.\-Copy\-Information\-To\-Pipeline (vtk\-Information request, vtk\-Information input, vtk\-Information output, int force\-Copy)} -\/ Copy information about this data object to the output information from its own Information for the given request. If the second argument is not N\-U\-L\-L then it is the pipeline information object for the input to this data object's producer. If force\-Copy is true, information is copied even if it exists in the output.  
\item {\ttfamily obj.\-Copy\-Information\-To\-Pipeline (vtk\-Information request, vtk\-Information input)} -\/ Copy information about this data object from the Pipeline\-Information to its own Information for the given request.  
\item {\ttfamily obj.\-Copy\-Information\-From\-Pipeline (vtk\-Information request)} -\/ Copy information about this data object from the Pipeline\-Information to its own Information for the given request.  
\item {\ttfamily obj.\-Data\-Has\-Been\-Generated ()} -\/ This method is called by the source when it executes to generate data. It is sort of the opposite of Release\-Data. It sets the Data\-Released flag to 0, and sets a new Update\-Time.  
\item {\ttfamily obj.\-Prepare\-For\-New\-Data ()} -\/ make the output data ready for new data to be inserted. For most objects we just call Initialize. But for vtk\-Image\-Data we leave the old data in case the memory can be reused.  
\item {\ttfamily obj.\-Shallow\-Copy (vtk\-Data\-Object src)} -\/ Shallow and Deep copy. These copy the data, but not any of the pipeline connections.  
\item {\ttfamily obj.\-Deep\-Copy (vtk\-Data\-Object src)} -\/ Shallow and Deep copy. These copy the data, but not any of the pipeline connections.  
\item {\ttfamily obj.\-Set\-Extent\-Translator (vtk\-Extent\-Translator translator)} -\/ An object that will translate pieces into structured extents.  
\item {\ttfamily vtk\-Extent\-Translator = obj.\-Get\-Extent\-Translator ()} -\/ An object that will translate pieces into structured extents.  
\item {\ttfamily int = obj.\-Get\-Extent\-Type ()} -\/ The Extent\-Type will be left as V\-T\-K\-\_\-\-P\-I\-E\-C\-E\-S\-\_\-\-E\-X\-T\-E\-N\-T for data objects such as vtk\-Poly\-Data and vtk\-Unstructured\-Grid. The Extent\-Type will be changed to V\-T\-K\-\_\-3\-D\-\_\-\-E\-X\-T\-E\-N\-T for data objects with 3\-D structure such as vtk\-Image\-Data (and its subclass vtk\-Structured\-Points), vtk\-Rectilinear\-Grid, and vtk\-Structured\-Grid. The default is the have an extent in pieces, with only one piece (no streaming possible).  
\item {\ttfamily obj.\-Crop ()} -\/ This method crops the data object (if necesary) so that the extent matches the update extent.  
\item {\ttfamily vtk\-Data\-Set\-Attributes = obj.\-Get\-Attributes (int type)} -\/ Returns the attributes of the data object of the specified attribute type. The type may be\-: 
\begin{DoxyItemize}
\item P\-O\-I\-N\-T -\/ Defined in vtk\-Data\-Set subclasses. 
\item C\-E\-L\-L -\/ Defined in vtk\-Data\-Set subclasses. 
\item V\-E\-R\-T\-E\-X -\/ Defined in vtk\-Graph subclasses. 
\item E\-D\-G\-E -\/ Defined in vtk\-Graph subclasses. 
\item R\-O\-W -\/ Defined in vtk\-Table. 
\end{DoxyItemize}The other attribute type, F\-I\-E\-L\-D, will return N\-U\-L\-L since field data is stored as a vtk\-Field\-Data instance, not a vtk\-Data\-Set\-Attributes instance. To retrieve field data, use Get\-Attributes\-As\-Field\-Data.  
\item {\ttfamily vtk\-Field\-Data = obj.\-Get\-Attributes\-As\-Field\-Data (int type)} -\/ Returns the attributes of the data object as a vtk\-Field\-Data. This returns non-\/null values in all the same cases as Get\-Attributes, in addition to the case of F\-I\-E\-L\-D, which will return the field data for any vtk\-Data\-Object subclass.  
\item {\ttfamily int = obj.\-Get\-Attribute\-Type\-For\-Array (vtk\-Abstract\-Array arr)} -\/ Retrieves the attribute type that an array came from. This is useful for obtaining which attribute type a input array to an algorithm came from (retrieved from Get\-Input\-Abstract\-Array\-To\-Processs).  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Elements (int type)} -\/ Get the number of elements for a specific attribute type (P\-O\-I\-N\-T, C\-E\-L\-L, etc.).  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkdataobjectalgorithm}{}\section{vtk\-Data\-Object\-Algorithm}\label{vtkfiltering_vtkdataobjectalgorithm}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
To create an instance of class vtk\-Data\-Object\-Algorithm, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkDataObjectAlgorithm
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Data\-Object\-Algorithm has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Data\-Object\-Algorithm class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Data\-Object\-Algorithm = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Data\-Object\-Algorithm = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Output ()} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Output (int )} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily obj.\-Set\-Output (vtk\-Data\-Object d)} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Input ()}  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Input (int port)}  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Object )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Set\-Input (int , vtk\-Data\-Object )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Add\-Input (vtk\-Data\-Object )} -\/ Add an input of this algorithm. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Add\-Input\-Connection(). See Set\-Input() for details.  
\item {\ttfamily obj.\-Add\-Input (int , vtk\-Data\-Object )} -\/ Add an input of this algorithm. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Add\-Input\-Connection(). See Set\-Input() for details.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkdataobjectcollection}{}\section{vtk\-Data\-Object\-Collection}\label{vtkfiltering_vtkdataobjectcollection}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Data\-Object\-Collection is an object that creates and manipulates lists of data objects. See also vtk\-Collection and subclasses.

To create an instance of class vtk\-Data\-Object\-Collection, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkDataObjectCollection
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Data\-Object\-Collection has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Data\-Object\-Collection class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Data\-Object\-Collection = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Data\-Object\-Collection = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Add\-Item (vtk\-Data\-Object ds)} -\/ Get the next data object in the list.  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Next\-Item ()} -\/ Get the ith data object in the list.  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Item (int i)}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkdataobjectsource}{}\section{vtk\-Data\-Object\-Source}\label{vtkfiltering_vtkdataobjectsource}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Data\-Object\-Source is an abstract object that specifies behavior and interface of field source objects. Field source objects are source objects that create vtk\-Field\-Data (field data) on output.

Concrete subclasses of vtk\-Data\-Object\-Source must define Update() and Execute() methods. The public method Update() invokes network execution and will bring the network up-\/to-\/date. The protected Execute() method actually does the work of data creation/generation. The difference between the two methods is that Update() implements input consistency checks and modified time comparisons and then invokes the Execute() which is an implementation of a particular algorithm.

vtk\-Data\-Object\-Source provides a mechanism for invoking the methods Start\-Method() and End\-Method() before and after object execution (via Execute()). These are convenience methods you can use for any purpose (e.\-g., debugging info, highlighting/notifying user interface, etc.) These methods accept a single void$\ast$ pointer that can be used to send data to the methods. It is also possible to specify a function to delete the argument via Start\-Method\-Arg\-Delete and End\-Method\-Arg\-Delete.

Another method, Progress\-Method() can be specified. Some filters invoke this method periodically during their execution. The use is similar to that of Start\-Method() and End\-Method().

An important feature of subclasses of vtk\-Data\-Object\-Source is that it is possible to control the memory-\/management model (i.\-e., retain output versus delete output data). If enabled the Release\-Data\-Flag enables the deletion of the output data once the downstream process object finishes processing the data (please see text).

To create an instance of class vtk\-Data\-Object\-Source, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkDataObjectSource
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Data\-Object\-Source has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Data\-Object\-Source class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Data\-Object\-Source = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Data\-Object\-Source = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Output ()} -\/ Get the output field of this source.  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Output (int idx)}  
\item {\ttfamily obj.\-Set\-Output (vtk\-Data\-Object )}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkdataobjecttypes}{}\section{vtk\-Data\-Object\-Types}\label{vtkfiltering_vtkdataobjecttypes}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Data\-Object\-Types is a helper class that supports conversion between integer types defined in vtk\-Type.\-h and string names as well as creation of data objects from either integer or string types. This class has to be updated every time a new data type is added to V\-T\-K.

To create an instance of class vtk\-Data\-Object\-Types, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkDataObjectTypes
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Data\-Object\-Types has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Data\-Object\-Types class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Data\-Object\-Types = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Data\-Object\-Types = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkdataset}{}\section{vtk\-Data\-Set}\label{vtkfiltering_vtkdataset}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Data\-Set is an abstract class that specifies an interface for dataset objects. vtk\-Data\-Set also provides methods to provide informations about the data, such as center, bounding box, and representative length.

In vtk a dataset consists of a structure (geometry and topology) and attribute data. The structure is defined implicitly or explicitly as a collection of cells. The geometry of the structure is contained in point coordinates plus the cell interpolation functions. The topology of the dataset structure is defined by cell types and how the cells share their defining points.

Attribute data in vtk is either point data (data at points) or cell data (data at cells). Typically filters operate on point data, but some may operate on cell data, both cell and point data, either one, or none.

To create an instance of class vtk\-Data\-Set, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkDataSet
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Data\-Set has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Data\-Set class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Data\-Set = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Data\-Set = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Copy\-Structure (vtk\-Data\-Set ds)} -\/ Copy the geometric and topological structure of an object. Note that the invoking object and the object pointed to by the parameter ds must be of the same type. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S N\-O\-T T\-H\-R\-E\-A\-D S\-A\-F\-E.  
\item {\ttfamily obj.\-Copy\-Attributes (vtk\-Data\-Set ds)} -\/ Copy the attributes associated with the specified dataset to this instance of vtk\-Data\-Set. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S N\-O\-T T\-H\-R\-E\-A\-D S\-A\-F\-E.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Points ()} -\/ Determine the number of points composing the dataset. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Cells ()} -\/ Determine the number of cells composing the dataset. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E  
\item {\ttfamily double = obj.\-Get\-Point (vtk\-Id\-Type pt\-Id)} -\/ Get point coordinates with pt\-Id such that\-: 0 $<$= pt\-Id $<$ Number\-Of\-Points. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S N\-O\-T T\-H\-R\-E\-A\-D S\-A\-F\-E.  
\item {\ttfamily obj.\-Get\-Point (vtk\-Id\-Type id, double x\mbox{[}3\mbox{]})} -\/ Copy point coordinates into user provided array x\mbox{[}3\mbox{]} for specified point id. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E I\-F F\-I\-R\-S\-T C\-A\-L\-L\-E\-D F\-R\-O\-M A S\-I\-N\-G\-L\-E T\-H\-R\-E\-A\-D A\-N\-D T\-H\-E D\-A\-T\-A\-S\-E\-T I\-S N\-O\-T M\-O\-D\-I\-F\-I\-E\-D  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Cell (vtk\-Id\-Type cell\-Id)} -\/ Get cell with cell\-Id such that\-: 0 $<$= cell\-Id $<$ Number\-Of\-Cells. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S N\-O\-T T\-H\-R\-E\-A\-D S\-A\-F\-E.  
\item {\ttfamily obj.\-Get\-Cell (vtk\-Id\-Type cell\-Id, vtk\-Generic\-Cell cell)} -\/ Get cell with cell\-Id such that\-: 0 $<$= cell\-Id $<$ Number\-Of\-Cells. This is a thread-\/safe alternative to the previous Get\-Cell() method. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E I\-F F\-I\-R\-S\-T C\-A\-L\-L\-E\-D F\-R\-O\-M A S\-I\-N\-G\-L\-E T\-H\-R\-E\-A\-D A\-N\-D T\-H\-E D\-A\-T\-A\-S\-E\-T I\-S N\-O\-T M\-O\-D\-I\-F\-I\-E\-D  
\item {\ttfamily obj.\-Get\-Cell\-Bounds (vtk\-Id\-Type cell\-Id, double bounds\mbox{[}6\mbox{]})} -\/ Get the bounds of the cell with cell\-Id such that\-: 0 $<$= cell\-Id $<$ Number\-Of\-Cells. A subclass may be able to determine the bounds of cell without using an expensive Get\-Cell() method. A default implementation is provided that actually uses a Get\-Cell() call. This is to ensure the method is available to all datasets. Subclasses should override this method to provide an efficient implementation. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E I\-F F\-I\-R\-S\-T C\-A\-L\-L\-E\-D F\-R\-O\-M A S\-I\-N\-G\-L\-E T\-H\-R\-E\-A\-D A\-N\-D T\-H\-E D\-A\-T\-A\-S\-E\-T I\-S N\-O\-T M\-O\-D\-I\-F\-I\-E\-D  
\item {\ttfamily int = obj.\-Get\-Cell\-Type (vtk\-Id\-Type cell\-Id)} -\/ Get type of cell with cell\-Id such that\-: 0 $<$= cell\-Id $<$ Number\-Of\-Cells. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E I\-F F\-I\-R\-S\-T C\-A\-L\-L\-E\-D F\-R\-O\-M A S\-I\-N\-G\-L\-E T\-H\-R\-E\-A\-D A\-N\-D T\-H\-E D\-A\-T\-A\-S\-E\-T I\-S N\-O\-T M\-O\-D\-I\-F\-I\-E\-D  
\item {\ttfamily obj.\-Get\-Cell\-Types (vtk\-Cell\-Types types)} -\/ Get a list of types of cells in a dataset. The list consists of an array of types (not necessarily in any order), with a single entry per type. For example a dataset 5 triangles, 3 lines, and 100 hexahedra would result a list of three entries, corresponding to the types V\-T\-K\-\_\-\-T\-R\-I\-A\-N\-G\-L\-E, V\-T\-K\-\_\-\-L\-I\-N\-E, and V\-T\-K\-\_\-\-H\-E\-X\-A\-H\-E\-D\-R\-O\-N. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E I\-F F\-I\-R\-S\-T C\-A\-L\-L\-E\-D F\-R\-O\-M A S\-I\-N\-G\-L\-E T\-H\-R\-E\-A\-D A\-N\-D T\-H\-E D\-A\-T\-A\-S\-E\-T I\-S N\-O\-T M\-O\-D\-I\-F\-I\-E\-D  
\item {\ttfamily obj.\-Get\-Cell\-Points (vtk\-Id\-Type cell\-Id, vtk\-Id\-List pt\-Ids)} -\/ Topological inquiry to get points defining cell. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E I\-F F\-I\-R\-S\-T C\-A\-L\-L\-E\-D F\-R\-O\-M A S\-I\-N\-G\-L\-E T\-H\-R\-E\-A\-D A\-N\-D T\-H\-E D\-A\-T\-A\-S\-E\-T I\-S N\-O\-T M\-O\-D\-I\-F\-I\-E\-D  
\item {\ttfamily obj.\-Get\-Point\-Cells (vtk\-Id\-Type pt\-Id, vtk\-Id\-List cell\-Ids)} -\/ Topological inquiry to get cells using point. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E I\-F F\-I\-R\-S\-T C\-A\-L\-L\-E\-D F\-R\-O\-M A S\-I\-N\-G\-L\-E T\-H\-R\-E\-A\-D A\-N\-D T\-H\-E D\-A\-T\-A\-S\-E\-T I\-S N\-O\-T M\-O\-D\-I\-F\-I\-E\-D  
\item {\ttfamily obj.\-Get\-Cell\-Neighbors (vtk\-Id\-Type cell\-Id, vtk\-Id\-List pt\-Ids, vtk\-Id\-List cell\-Ids)} -\/ Topological inquiry to get all cells using list of points exclusive of cell specified (e.\-g., cell\-Id). Note that the list consists of only cells that use A\-L\-L the points provided. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E I\-F F\-I\-R\-S\-T C\-A\-L\-L\-E\-D F\-R\-O\-M A S\-I\-N\-G\-L\-E T\-H\-R\-E\-A\-D A\-N\-D T\-H\-E D\-A\-T\-A\-S\-E\-T I\-S N\-O\-T M\-O\-D\-I\-F\-I\-E\-D  
\item {\ttfamily vtk\-Id\-Type = obj.\-Find\-Point (double x, double y, double z)} -\/ Locate the closest point to the global coordinate x. Return the point id. If point id $<$ 0; then no point found. (This may arise when point is outside of dataset.) T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E I\-F F\-I\-R\-S\-T C\-A\-L\-L\-E\-D F\-R\-O\-M A S\-I\-N\-G\-L\-E T\-H\-R\-E\-A\-D A\-N\-D T\-H\-E D\-A\-T\-A\-S\-E\-T I\-S N\-O\-T M\-O\-D\-I\-F\-I\-E\-D  
\item {\ttfamily vtk\-Id\-Type = obj.\-Find\-Point (double x\mbox{[}3\mbox{]})} -\/ Locate the closest point to the global coordinate x. Return the point id. If point id $<$ 0; then no point found. (This may arise when point is outside of dataset.) T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E I\-F F\-I\-R\-S\-T C\-A\-L\-L\-E\-D F\-R\-O\-M A S\-I\-N\-G\-L\-E T\-H\-R\-E\-A\-D A\-N\-D T\-H\-E D\-A\-T\-A\-S\-E\-T I\-S N\-O\-T M\-O\-D\-I\-F\-I\-E\-D  
\item {\ttfamily long = obj.\-Get\-M\-Time ()} -\/ Datasets are composite objects and need to check each part for M\-Time T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E  
\item {\ttfamily vtk\-Cell\-Data = obj.\-Get\-Cell\-Data ()} -\/ Return a pointer to this dataset's cell data. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E  
\item {\ttfamily vtk\-Point\-Data = obj.\-Get\-Point\-Data ()} -\/ Return a pointer to this dataset's point data. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E  
\item {\ttfamily obj.\-Squeeze ()} -\/ Reclaim any extra memory used to store data. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S N\-O\-T T\-H\-R\-E\-A\-D S\-A\-F\-E.  
\item {\ttfamily obj.\-Compute\-Bounds ()} -\/ Compute the data bounding box from data points. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S N\-O\-T T\-H\-R\-E\-A\-D S\-A\-F\-E.  
\item {\ttfamily double = obj.\-Get\-Bounds ()} -\/ Return a pointer to the geometry bounding box in the form (xmin,xmax, ymin,ymax, zmin,zmax). T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S N\-O\-T T\-H\-R\-E\-A\-D S\-A\-F\-E.  
\item {\ttfamily obj.\-Get\-Bounds (double bounds\mbox{[}6\mbox{]})} -\/ Return a pointer to the geometry bounding box in the form (xmin,xmax, ymin,ymax, zmin,zmax). T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E I\-F F\-I\-R\-S\-T C\-A\-L\-L\-E\-D F\-R\-O\-M A S\-I\-N\-G\-L\-E T\-H\-R\-E\-A\-D A\-N\-D T\-H\-E D\-A\-T\-A\-S\-E\-T I\-S N\-O\-T M\-O\-D\-I\-F\-I\-E\-D  
\item {\ttfamily double = obj.\-Get\-Center ()} -\/ Get the center of the bounding box. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S N\-O\-T T\-H\-R\-E\-A\-D S\-A\-F\-E.  
\item {\ttfamily obj.\-Get\-Center (double center\mbox{[}3\mbox{]})} -\/ Get the center of the bounding box. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E I\-F F\-I\-R\-S\-T C\-A\-L\-L\-E\-D F\-R\-O\-M A S\-I\-N\-G\-L\-E T\-H\-R\-E\-A\-D A\-N\-D T\-H\-E D\-A\-T\-A\-S\-E\-T I\-S N\-O\-T M\-O\-D\-I\-F\-I\-E\-D  
\item {\ttfamily double = obj.\-Get\-Length ()} -\/ Return the length of the diagonal of the bounding box. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E I\-F F\-I\-R\-S\-T C\-A\-L\-L\-E\-D F\-R\-O\-M A S\-I\-N\-G\-L\-E T\-H\-R\-E\-A\-D A\-N\-D T\-H\-E D\-A\-T\-A\-S\-E\-T I\-S N\-O\-T M\-O\-D\-I\-F\-I\-E\-D  
\item {\ttfamily obj.\-Initialize ()} -\/ Restore data object to initial state, T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S N\-O\-T T\-H\-R\-E\-A\-D S\-A\-F\-E.  
\item {\ttfamily obj.\-Get\-Scalar\-Range (double range\mbox{[}2\mbox{]})} -\/ Convenience method to get the range of the scalar data (if there is any scalar data). Returns the (min/max) range of combined point and cell data. If there are no point or cell scalars the method will return (0,1). Note\-: Update needs to be called to create the scalars. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E I\-F F\-I\-R\-S\-T C\-A\-L\-L\-E\-D F\-R\-O\-M A S\-I\-N\-G\-L\-E T\-H\-R\-E\-A\-D A\-N\-D T\-H\-E D\-A\-T\-A\-S\-E\-T I\-S N\-O\-T M\-O\-D\-I\-F\-I\-E\-D  
\item {\ttfamily double = obj.\-Get\-Scalar\-Range ()} -\/ Convenience method to get the range of the scalar data (if there is any scalar data). T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S N\-O\-T T\-H\-R\-E\-A\-D S\-A\-F\-E.  
\item {\ttfamily int = obj.\-Get\-Max\-Cell\-Size ()} -\/ Convenience method returns largest cell size in dataset. This is generally used to allocate memory for supporting data structures. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E  
\item {\ttfamily long = obj.\-Get\-Actual\-Memory\-Size ()} -\/ Return the actual size of the data in kilobytes. This number is valid only after the pipeline has updated. The memory size returned is guaranteed to be greater than or equal to the memory required to represent the data (e.\-g., extra space in arrays, etc. are not included in the return value). T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E.  
\item {\ttfamily int = obj.\-Get\-Data\-Object\-Type ()} -\/ Shallow and Deep copy.  
\item {\ttfamily obj.\-Shallow\-Copy (vtk\-Data\-Object src)} -\/ Shallow and Deep copy.  
\item {\ttfamily obj.\-Deep\-Copy (vtk\-Data\-Object src)} -\/ Shallow and Deep copy.  
\item {\ttfamily int = obj.\-Check\-Attributes ()} -\/ This method checks to see if the cell and point attributes match the geometry. Many filters will crash if the number of tupples in an array is less than the number of points/cells. This method returns 1 if there is a mismatch, and 0 if everything is ok. It prints an error if an array is too short, and a warning if an array is too long.  
\item {\ttfamily obj.\-Generate\-Ghost\-Level\-Array ()} -\/ Normally called by pipeline executives or algoritgms only. This method computes the ghost arrays for a given dataset.  
\item {\ttfamily vtk\-Field\-Data = obj.\-Get\-Attributes\-As\-Field\-Data (int type)} -\/ Returns the attributes of the data object as a vtk\-Field\-Data. This returns non-\/null values in all the same cases as Get\-Attributes, in addition to the case of F\-I\-E\-L\-D, which will return the field data for any vtk\-Data\-Object subclass.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Elements (int type)} -\/ Get the number of elements for a specific attribute type (P\-O\-I\-N\-T, C\-E\-L\-L, etc.).  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkdatasetalgorithm}{}\section{vtk\-Data\-Set\-Algorithm}\label{vtkfiltering_vtkdatasetalgorithm}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Data\-Set\-Algorithm is a convenience class to make writing algorithms easier. It is also designed to help transition old algorithms to the new pipeline architecture. Ther are some assumptions and defaults made by this class you should be aware of. This class defaults such that your filter will have one input port and one output port. If that is not the case simply change it with Set\-Number\-Of\-Input\-Ports etc. See this classes contstructor for the default. This class also provides a Fill\-Input\-Port\-Info method that by default says that all inputs will be Data\-Set. If that isn't the case then please override this method in your subclass. This class breaks out the downstream requests into seperate functions such as Request\-Data\-Object Request\-Data and Request\-Information. The default implementation of Request\-Data\-Object will create an output data of the same type as the input.

To create an instance of class vtk\-Data\-Set\-Algorithm, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkDataSetAlgorithm
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Data\-Set\-Algorithm has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Data\-Set\-Algorithm class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Data\-Set\-Algorithm = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Data\-Set\-Algorithm = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Data\-Set = obj.\-Get\-Output ()} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Data\-Set = obj.\-Get\-Output (int )} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Input ()} -\/ Get the input data object. This method is not recommended for use, but lots of old style filters use it.  
\item {\ttfamily vtk\-Poly\-Data = obj.\-Get\-Poly\-Data\-Output ()} -\/ Get the output as vtk\-Poly\-Data.  
\item {\ttfamily vtk\-Structured\-Points = obj.\-Get\-Structured\-Points\-Output ()} -\/ Get the output as vtk\-Structured\-Points.  
\item {\ttfamily vtk\-Image\-Data = obj.\-Get\-Image\-Data\-Output ()} -\/ Get the output as vtk\-Structured\-Points.  
\item {\ttfamily vtk\-Structured\-Grid = obj.\-Get\-Structured\-Grid\-Output ()} -\/ Get the output as vtk\-Structured\-Grid.  
\item {\ttfamily vtk\-Unstructured\-Grid = obj.\-Get\-Unstructured\-Grid\-Output ()} -\/ Get the output as vtk\-Unstructured\-Grid.  
\item {\ttfamily vtk\-Rectilinear\-Grid = obj.\-Get\-Rectilinear\-Grid\-Output ()} -\/ Get the output as vtk\-Rectilinear\-Grid.  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Object )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Set\-Input (int , vtk\-Data\-Object )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Set )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Set\-Input (int , vtk\-Data\-Set )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Add\-Input (vtk\-Data\-Object )} -\/ Add an input of this algorithm. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Add\-Input\-Connection(). See Set\-Input() for details.  
\item {\ttfamily obj.\-Add\-Input (vtk\-Data\-Set )} -\/ Add an input of this algorithm. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Add\-Input\-Connection(). See Set\-Input() for details.  
\item {\ttfamily obj.\-Add\-Input (int , vtk\-Data\-Set )} -\/ Add an input of this algorithm. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Add\-Input\-Connection(). See Set\-Input() for details.  
\item {\ttfamily obj.\-Add\-Input (int , vtk\-Data\-Object )} -\/ Add an input of this algorithm. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Add\-Input\-Connection(). See Set\-Input() for details.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkdatasetattributes}{}\section{vtk\-Data\-Set\-Attributes}\label{vtkfiltering_vtkdatasetattributes}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Data\-Set\-Attributes is a class that is used to represent and manipulate attribute data (e.\-g., scalars, vectors, normals, texture coordinates, tensors, global ids, pedigree ids, and field data).

This adds to vtk\-Field\-Data the ability to pick one of the arrays from the field as the currently active array for each attribute type. In other words, you pick one array to be called \char`\"{}\-T\-H\-E\char`\"{} Scalars, and then filters down the pipeline will treat that array specially. For example vtk\-Contour\-Filter will contour \char`\"{}\-T\-H\-E\char`\"{} Scalar array unless a different array is asked for.

Additionally vtk\-Data\-Set\-Attributes provides methods that filters call to pass data through, copy data into, and interpolate from Fields. Pass\-Data passes entire arrays from the source to the destination. Copy passes through some subset of the tuples from the source to the destination. Interpolate interpolates from the chosen tuple(s) in the source data, using the provided weights, to produce new tuples in the destination. Each attribute type has pass, copy and interpolate \char`\"{}copy\char`\"{} flags that can be set in the destination to choose which attribute arrays will be transfered from the source to the destination.

Finally this class provides a mechanism to determine which attributes a group of sources have in common, and to copy tuples from a source into the destination, for only those attributes that are held by all.

To create an instance of class vtk\-Data\-Set\-Attributes, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkDataSetAttributes
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Data\-Set\-Attributes has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Data\-Set\-Attributes class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Data\-Set\-Attributes = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Data\-Set\-Attributes = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Initialize ()} -\/ Initialize all of the object's data to N\-U\-L\-L Also, clear the copy flags.  
\item {\ttfamily obj.\-Update ()} -\/ Deep copy of data (i.\-e., create new data arrays and copy from input data). Ignores the copy flags but preserves them in the output.  
\item {\ttfamily obj.\-Deep\-Copy (vtk\-Field\-Data pd)} -\/ Deep copy of data (i.\-e., create new data arrays and copy from input data). Ignores the copy flags but preserves them in the output.  
\item {\ttfamily obj.\-Shallow\-Copy (vtk\-Field\-Data pd)} -\/ Shallow copy of data (i.\-e., use reference counting). Ignores the copy flags but preserves them in the output.  
\item {\ttfamily int = obj.\-Set\-Scalars (vtk\-Data\-Array da)} -\/ Set/\-Get the scalar data.  
\item {\ttfamily int = obj.\-Set\-Active\-Scalars (string name)} -\/ Set/\-Get the scalar data.  
\item {\ttfamily vtk\-Data\-Array = obj.\-Get\-Scalars ()} -\/ Set/\-Get the scalar data.  
\item {\ttfamily int = obj.\-Set\-Vectors (vtk\-Data\-Array da)} -\/ Set/\-Get the vector data.  
\item {\ttfamily int = obj.\-Set\-Active\-Vectors (string name)} -\/ Set/\-Get the vector data.  
\item {\ttfamily vtk\-Data\-Array = obj.\-Get\-Vectors ()} -\/ Set/\-Get the vector data.  
\item {\ttfamily int = obj.\-Set\-Normals (vtk\-Data\-Array da)} -\/ Set/get the normal data.  
\item {\ttfamily int = obj.\-Set\-Active\-Normals (string name)} -\/ Set/get the normal data.  
\item {\ttfamily vtk\-Data\-Array = obj.\-Get\-Normals ()} -\/ Set/get the normal data.  
\item {\ttfamily int = obj.\-Set\-T\-Coords (vtk\-Data\-Array da)} -\/ Set/\-Get the texture coordinate data.  
\item {\ttfamily int = obj.\-Set\-Active\-T\-Coords (string name)} -\/ Set/\-Get the texture coordinate data.  
\item {\ttfamily vtk\-Data\-Array = obj.\-Get\-T\-Coords ()} -\/ Set/\-Get the texture coordinate data.  
\item {\ttfamily int = obj.\-Set\-Tensors (vtk\-Data\-Array da)} -\/ Set/\-Get the tensor data.  
\item {\ttfamily int = obj.\-Set\-Active\-Tensors (string name)} -\/ Set/\-Get the tensor data.  
\item {\ttfamily vtk\-Data\-Array = obj.\-Get\-Tensors ()} -\/ Set/\-Get the tensor data.  
\item {\ttfamily int = obj.\-Set\-Global\-Ids (vtk\-Data\-Array da)} -\/ Set/\-Get the global id data.  
\item {\ttfamily int = obj.\-Set\-Active\-Global\-Ids (string name)} -\/ Set/\-Get the global id data.  
\item {\ttfamily vtk\-Data\-Array = obj.\-Get\-Global\-Ids ()} -\/ Set/\-Get the global id data.  
\item {\ttfamily int = obj.\-Set\-Pedigree\-Ids (vtk\-Abstract\-Array da)} -\/ Set/\-Get the pedigree id data.  
\item {\ttfamily int = obj.\-Set\-Active\-Pedigree\-Ids (string name)} -\/ Set/\-Get the pedigree id data.  
\item {\ttfamily vtk\-Abstract\-Array = obj.\-Get\-Pedigree\-Ids ()} -\/ Set/\-Get the pedigree id data.  
\item {\ttfamily vtk\-Data\-Array = obj.\-Get\-Scalars (string name)} -\/ This will first look for an array with the correct name. If one exists, it is returned. Otherwise, the name argument is ignored, and the active attribute is returned.  
\item {\ttfamily vtk\-Data\-Array = obj.\-Get\-Vectors (string name)} -\/ This will first look for an array with the correct name. If one exists, it is returned. Otherwise, the name argument is ignored, and the active attribute is returned.  
\item {\ttfamily vtk\-Data\-Array = obj.\-Get\-Normals (string name)} -\/ This will first look for an array with the correct name. If one exists, it is returned. Otherwise, the name argument is ignored, and the active attribute is returned.  
\item {\ttfamily vtk\-Data\-Array = obj.\-Get\-T\-Coords (string name)} -\/ This will first look for an array with the correct name. If one exists, it is returned. Otherwise, the name argument is ignored, and the active attribute is returned.  
\item {\ttfamily vtk\-Data\-Array = obj.\-Get\-Tensors (string name)} -\/ This will first look for an array with the correct name. If one exists, it is returned. Otherwise, the name argument is ignored, and the active attribute is returned.  
\item {\ttfamily vtk\-Data\-Array = obj.\-Get\-Global\-Ids (string name)} -\/ This will first look for an array with the correct name. If one exists, it is returned. Otherwise, the name argument is ignored, and the active attribute is returned.  
\item {\ttfamily vtk\-Abstract\-Array = obj.\-Get\-Pedigree\-Ids (string name)} -\/ This will first look for an array with the correct name. If one exists, it is returned. Otherwise, the name argument is ignored, and the active attribute is returned.  
\item {\ttfamily int = obj.\-Set\-Active\-Attribute (string name, int attribute\-Type)} -\/ Make the array with the given name the active attribute. Attribute types are\-: vtk\-Data\-Set\-Attributes\-::\-S\-C\-A\-L\-A\-R\-S = 0 vtk\-Data\-Set\-Attributes\-::\-V\-E\-C\-T\-O\-R\-S = 1 vtk\-Data\-Set\-Attributes\-::\-N\-O\-R\-M\-A\-L\-S = 2 vtk\-Data\-Set\-Attributes\-::\-T\-C\-O\-O\-R\-D\-S = 3 vtk\-Data\-Set\-Attributes\-::\-T\-E\-N\-S\-O\-R\-S = 4 vtk\-Data\-Set\-Attributes\-::\-G\-L\-O\-B\-A\-L\-I\-D\-S = 5 vtk\-Data\-Set\-Attributes\-::\-P\-E\-D\-I\-G\-R\-E\-E\-I\-D\-S = 6 Returns the index of the array if succesful, -\/1 if the array is not in the list of arrays.  
\item {\ttfamily int = obj.\-Set\-Active\-Attribute (int index, int attribute\-Type)} -\/ Make the array with the given index the active attribute.  
\item {\ttfamily obj.\-Get\-Attribute\-Indices (int index\-Array)} -\/ Get the field data array indices corresponding to scalars, vectors, tensors, etc.  
\item {\ttfamily int = obj.\-Is\-Array\-An\-Attribute (int idx)} -\/ Determine whether a data array of index idx is considered a data set attribute (i.\-e., scalar, vector, tensor, etc). Return less-\/than zero if it is, otherwise an index 0$<$=idx$<$N\-U\-M\-\_\-\-A\-T\-T\-R\-I\-B\-U\-T\-E\-S to indicate which attribute.  
\item {\ttfamily vtk\-Data\-Array = obj.\-Get\-Attribute (int attribute\-Type)} -\/ Return an attribute given the attribute type (see vtk\-Data\-Set\-Attributes\-::\-Attribute\-Types). Some attributes (such as P\-E\-D\-I\-G\-R\-E\-E\-I\-D\-S) may not be vtk\-Data\-Array subclass, so in that case use Get\-Abstract\-Attribute().  
\item {\ttfamily vtk\-Abstract\-Array = obj.\-Get\-Abstract\-Attribute (int attribute\-Type)} -\/ Return an attribute given the attribute type (see vtk\-Data\-Set\-Attributes\-::\-Attribute\-Types). This is the same as Get\-Attribute(), except that the returned array is a vtk\-Abstract\-Array instead of vtk\-Data\-Array. Some attributes (such as P\-E\-D\-I\-G\-R\-E\-E\-I\-D\-S) may not be vtk\-Data\-Array subclass.  
\item {\ttfamily obj.\-Remove\-Array (string name)} -\/ Remove an array (with the given name) from the list of arrays.  
\item {\ttfamily obj.\-Set\-Copy\-Attribute (int index, int value, int ctype\-A\-L\-L\-C\-O\-P\-Y)} -\/ Specify whether to copy the data attribute referred to by index. ctype selects from the Attribute\-Copy\-Operations. If ctype is set to A\-L\-L\-C\-O\-P\-Y, then C\-O\-P\-Y\-T\-U\-P\-L\-E, I\-N\-T\-E\-R\-P\-O\-L\-A\-T\-E, and P\-A\-S\-S\-D\-A\-T\-A are set to value. If value is 0, copying is disallowed. otherwise it is allowed.  
\item {\ttfamily obj.\-Set\-Copy\-Scalars (int i, int ctype\-A\-L\-L\-C\-O\-P\-Y)} -\/ Turn on/off the copying of scalar data. ctype is one of the Attribute\-Copy\-Operations, and controls copy, interpolate and passdata behavior. For set, ctype=A\-L\-L\-C\-O\-P\-Y means set all three flags to the same value. For get, ctype=A\-L\-L\-C\-O\-P\-Y returns true only if all three flags are true.

During copying, interpolation and passdata, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy/interpolate/pass flag for an attribute is set (on or off), it is applied. This overrides rules 2 and 3.
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 3.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily int = obj.\-Get\-Copy\-Scalars (int ctype\-A\-L\-L\-C\-O\-P\-Y)} -\/ Turn on/off the copying of scalar data. ctype is one of the Attribute\-Copy\-Operations, and controls copy, interpolate and passdata behavior. For set, ctype=A\-L\-L\-C\-O\-P\-Y means set all three flags to the same value. For get, ctype=A\-L\-L\-C\-O\-P\-Y returns true only if all three flags are true.

During copying, interpolation and passdata, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy/interpolate/pass flag for an attribute is set (on or off), it is applied. This overrides rules 2 and 3.
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 3.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily obj.\-Copy\-Scalars\-On ()} -\/ Turn on/off the copying of scalar data. ctype is one of the Attribute\-Copy\-Operations, and controls copy, interpolate and passdata behavior. For set, ctype=A\-L\-L\-C\-O\-P\-Y means set all three flags to the same value. For get, ctype=A\-L\-L\-C\-O\-P\-Y returns true only if all three flags are true.

During copying, interpolation and passdata, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy/interpolate/pass flag for an attribute is set (on or off), it is applied. This overrides rules 2 and 3.
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 3.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily obj.\-Copy\-Scalars\-Off ()} -\/ Turn on/off the copying of scalar data. ctype is one of the Attribute\-Copy\-Operations, and controls copy, interpolate and passdata behavior. For set, ctype=A\-L\-L\-C\-O\-P\-Y means set all three flags to the same value. For get, ctype=A\-L\-L\-C\-O\-P\-Y returns true only if all three flags are true.

During copying, interpolation and passdata, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy/interpolate/pass flag for an attribute is set (on or off), it is applied. This overrides rules 2 and 3.
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 3.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily obj.\-Set\-Copy\-Vectors (int i, int ctype\-A\-L\-L\-C\-O\-P\-Y)} -\/ Turn on/off the copying of vector data. ctype is one of the Attribute\-Copy\-Operations, and controls copy, interpolate and passdata behavior. For set, ctype=A\-L\-L\-C\-O\-P\-Y means set all three flags to the same value. For get, ctype=A\-L\-L\-C\-O\-P\-Y returns true only if all three flags are true.

During copying, interpolation and passdata, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy/interpolate/pass flag for an attribute is set (on or off), it is applied. This overrides rules 2 and 3.
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 3.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily int = obj.\-Get\-Copy\-Vectors (int ctype\-A\-L\-L\-C\-O\-P\-Y)} -\/ Turn on/off the copying of vector data. ctype is one of the Attribute\-Copy\-Operations, and controls copy, interpolate and passdata behavior. For set, ctype=A\-L\-L\-C\-O\-P\-Y means set all three flags to the same value. For get, ctype=A\-L\-L\-C\-O\-P\-Y returns true only if all three flags are true.

During copying, interpolation and passdata, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy/interpolate/pass flag for an attribute is set (on or off), it is applied. This overrides rules 2 and 3.
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 3.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily obj.\-Copy\-Vectors\-On ()} -\/ Turn on/off the copying of vector data. ctype is one of the Attribute\-Copy\-Operations, and controls copy, interpolate and passdata behavior. For set, ctype=A\-L\-L\-C\-O\-P\-Y means set all three flags to the same value. For get, ctype=A\-L\-L\-C\-O\-P\-Y returns true only if all three flags are true.

During copying, interpolation and passdata, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy/interpolate/pass flag for an attribute is set (on or off), it is applied. This overrides rules 2 and 3.
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 3.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily obj.\-Copy\-Vectors\-Off ()} -\/ Turn on/off the copying of vector data. ctype is one of the Attribute\-Copy\-Operations, and controls copy, interpolate and passdata behavior. For set, ctype=A\-L\-L\-C\-O\-P\-Y means set all three flags to the same value. For get, ctype=A\-L\-L\-C\-O\-P\-Y returns true only if all three flags are true.

During copying, interpolation and passdata, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy/interpolate/pass flag for an attribute is set (on or off), it is applied. This overrides rules 2 and 3.
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 3.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily obj.\-Set\-Copy\-Normals (int i, int ctype\-A\-L\-L\-C\-O\-P\-Y)} -\/ Turn on/off the copying of normals data. ctype is one of the Attribute\-Copy\-Operations, and controls copy, interpolate and passdata behavior. For set, ctype=A\-L\-L\-C\-O\-P\-Y means set all three flags to the same value. For get, ctype=A\-L\-L\-C\-O\-P\-Y returns true only if all three flags are true.

During copying, interpolation and passdata, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy/interpolate/pass flag for an attribute is set (on or off), it is applied. This overrides rules 2 and 3.
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 3.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily int = obj.\-Get\-Copy\-Normals (int ctype\-A\-L\-L\-C\-O\-P\-Y)} -\/ Turn on/off the copying of normals data. ctype is one of the Attribute\-Copy\-Operations, and controls copy, interpolate and passdata behavior. For set, ctype=A\-L\-L\-C\-O\-P\-Y means set all three flags to the same value. For get, ctype=A\-L\-L\-C\-O\-P\-Y returns true only if all three flags are true.

During copying, interpolation and passdata, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy/interpolate/pass flag for an attribute is set (on or off), it is applied. This overrides rules 2 and 3.
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 3.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily obj.\-Copy\-Normals\-On ()} -\/ Turn on/off the copying of normals data. ctype is one of the Attribute\-Copy\-Operations, and controls copy, interpolate and passdata behavior. For set, ctype=A\-L\-L\-C\-O\-P\-Y means set all three flags to the same value. For get, ctype=A\-L\-L\-C\-O\-P\-Y returns true only if all three flags are true.

During copying, interpolation and passdata, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy/interpolate/pass flag for an attribute is set (on or off), it is applied. This overrides rules 2 and 3.
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 3.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily obj.\-Copy\-Normals\-Off ()} -\/ Turn on/off the copying of normals data. ctype is one of the Attribute\-Copy\-Operations, and controls copy, interpolate and passdata behavior. For set, ctype=A\-L\-L\-C\-O\-P\-Y means set all three flags to the same value. For get, ctype=A\-L\-L\-C\-O\-P\-Y returns true only if all three flags are true.

During copying, interpolation and passdata, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy/interpolate/pass flag for an attribute is set (on or off), it is applied. This overrides rules 2 and 3.
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 3.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily obj.\-Set\-Copy\-T\-Coords (int i, int ctype\-A\-L\-L\-C\-O\-P\-Y)} -\/ Turn on/off the copying of texture coordinates data. ctype is one of the Attribute\-Copy\-Operations, and controls copy, interpolate and passdata behavior. For set, ctype=A\-L\-L\-C\-O\-P\-Y means set all three flags to the same value. For get, ctype=A\-L\-L\-C\-O\-P\-Y returns true only if all three flags are true.

During copying, interpolation and passdata, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy/interpolate/pass flag for an attribute is set (on or off), it is applied. This overrides rules 2 and 3.
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 3.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily int = obj.\-Get\-Copy\-T\-Coords (int ctype\-A\-L\-L\-C\-O\-P\-Y)} -\/ Turn on/off the copying of texture coordinates data. ctype is one of the Attribute\-Copy\-Operations, and controls copy, interpolate and passdata behavior. For set, ctype=A\-L\-L\-C\-O\-P\-Y means set all three flags to the same value. For get, ctype=A\-L\-L\-C\-O\-P\-Y returns true only if all three flags are true.

During copying, interpolation and passdata, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy/interpolate/pass flag for an attribute is set (on or off), it is applied. This overrides rules 2 and 3.
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 3.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily obj.\-Copy\-T\-Coords\-On ()} -\/ Turn on/off the copying of texture coordinates data. ctype is one of the Attribute\-Copy\-Operations, and controls copy, interpolate and passdata behavior. For set, ctype=A\-L\-L\-C\-O\-P\-Y means set all three flags to the same value. For get, ctype=A\-L\-L\-C\-O\-P\-Y returns true only if all three flags are true.

During copying, interpolation and passdata, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy/interpolate/pass flag for an attribute is set (on or off), it is applied. This overrides rules 2 and 3.
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 3.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily obj.\-Copy\-T\-Coords\-Off ()} -\/ Turn on/off the copying of texture coordinates data. ctype is one of the Attribute\-Copy\-Operations, and controls copy, interpolate and passdata behavior. For set, ctype=A\-L\-L\-C\-O\-P\-Y means set all three flags to the same value. For get, ctype=A\-L\-L\-C\-O\-P\-Y returns true only if all three flags are true.

During copying, interpolation and passdata, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy/interpolate/pass flag for an attribute is set (on or off), it is applied. This overrides rules 2 and 3.
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 3.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily obj.\-Set\-Copy\-Tensors (int i, int ctype\-A\-L\-L\-C\-O\-P\-Y)} -\/ Turn on/off the copying of tensor data. ctype is one of the Attribute\-Copy\-Operations, and controls copy, interpolate and passdata behavior. For set, ctype=A\-L\-L\-C\-O\-P\-Y means set all three flags to the same value. For get, ctype=A\-L\-L\-C\-O\-P\-Y returns true only if all three flags are true.

During copying, interpolation and passdata, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy/interpolate/pass flag for an attribute is set (on or off), it is applied. This overrides rules 2 and 3.
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 3.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily int = obj.\-Get\-Copy\-Tensors (int ctype\-A\-L\-L\-C\-O\-P\-Y)} -\/ Turn on/off the copying of tensor data. ctype is one of the Attribute\-Copy\-Operations, and controls copy, interpolate and passdata behavior. For set, ctype=A\-L\-L\-C\-O\-P\-Y means set all three flags to the same value. For get, ctype=A\-L\-L\-C\-O\-P\-Y returns true only if all three flags are true.

During copying, interpolation and passdata, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy/interpolate/pass flag for an attribute is set (on or off), it is applied. This overrides rules 2 and 3.
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 3.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily obj.\-Copy\-Tensors\-On ()} -\/ Turn on/off the copying of tensor data. ctype is one of the Attribute\-Copy\-Operations, and controls copy, interpolate and passdata behavior. For set, ctype=A\-L\-L\-C\-O\-P\-Y means set all three flags to the same value. For get, ctype=A\-L\-L\-C\-O\-P\-Y returns true only if all three flags are true.

During copying, interpolation and passdata, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy/interpolate/pass flag for an attribute is set (on or off), it is applied. This overrides rules 2 and 3.
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 3.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily obj.\-Copy\-Tensors\-Off ()} -\/ Turn on/off the copying of tensor data. ctype is one of the Attribute\-Copy\-Operations, and controls copy, interpolate and passdata behavior. For set, ctype=A\-L\-L\-C\-O\-P\-Y means set all three flags to the same value. For get, ctype=A\-L\-L\-C\-O\-P\-Y returns true only if all three flags are true.

During copying, interpolation and passdata, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy/interpolate/pass flag for an attribute is set (on or off), it is applied. This overrides rules 2 and 3.
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 3.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily obj.\-Set\-Copy\-Global\-Ids (int i, int ctype\-A\-L\-L\-C\-O\-P\-Y)} -\/ Turn on/off the copying of global id data. ctype is one of the Attribute\-Copy\-Operations, and controls copy, interpolate and passdata behavior. For set, ctype=A\-L\-L\-C\-O\-P\-Y means set all three flags to the same value. For get, ctype=A\-L\-L\-C\-O\-P\-Y returns true only if all three flags are true.

During copying, interpolation and passdata, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy/interpolate/pass for an attribute is set (on or off), it is applied. This overrides rules 2 and 3.
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 3.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily int = obj.\-Get\-Copy\-Global\-Ids (int ctype\-A\-L\-L\-C\-O\-P\-Y)} -\/ Turn on/off the copying of global id data. ctype is one of the Attribute\-Copy\-Operations, and controls copy, interpolate and passdata behavior. For set, ctype=A\-L\-L\-C\-O\-P\-Y means set all three flags to the same value. For get, ctype=A\-L\-L\-C\-O\-P\-Y returns true only if all three flags are true.

During copying, interpolation and passdata, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy/interpolate/pass for an attribute is set (on or off), it is applied. This overrides rules 2 and 3.
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 3.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily obj.\-Copy\-Global\-Ids\-On ()} -\/ Turn on/off the copying of global id data. ctype is one of the Attribute\-Copy\-Operations, and controls copy, interpolate and passdata behavior. For set, ctype=A\-L\-L\-C\-O\-P\-Y means set all three flags to the same value. For get, ctype=A\-L\-L\-C\-O\-P\-Y returns true only if all three flags are true.

During copying, interpolation and passdata, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy/interpolate/pass for an attribute is set (on or off), it is applied. This overrides rules 2 and 3.
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 3.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily obj.\-Copy\-Global\-Ids\-Off ()} -\/ Turn on/off the copying of global id data. ctype is one of the Attribute\-Copy\-Operations, and controls copy, interpolate and passdata behavior. For set, ctype=A\-L\-L\-C\-O\-P\-Y means set all three flags to the same value. For get, ctype=A\-L\-L\-C\-O\-P\-Y returns true only if all three flags are true.

During copying, interpolation and passdata, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy/interpolate/pass for an attribute is set (on or off), it is applied. This overrides rules 2 and 3.
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 3.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily obj.\-Set\-Copy\-Pedigree\-Ids (int i, int ctype\-A\-L\-L\-C\-O\-P\-Y)} -\/ Turn on/off the copying of pedigree id data. ctype is one of the Attribute\-Copy\-Operations, and controls copy, interpolate and passdata behavior. For set, ctype=A\-L\-L\-C\-O\-P\-Y means set all three flags to the same value. For get, ctype=A\-L\-L\-C\-O\-P\-Y returns true only if all three flags are true.

During copying, interpolation and passdata, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy/interpolate/pass for an attribute is set (on or off), it is applied. This overrides rules 2 and 3.
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 3.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily int = obj.\-Get\-Copy\-Pedigree\-Ids (int ctype\-A\-L\-L\-C\-O\-P\-Y)} -\/ Turn on/off the copying of pedigree id data. ctype is one of the Attribute\-Copy\-Operations, and controls copy, interpolate and passdata behavior. For set, ctype=A\-L\-L\-C\-O\-P\-Y means set all three flags to the same value. For get, ctype=A\-L\-L\-C\-O\-P\-Y returns true only if all three flags are true.

During copying, interpolation and passdata, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy/interpolate/pass for an attribute is set (on or off), it is applied. This overrides rules 2 and 3.
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 3.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily obj.\-Copy\-Pedigree\-Ids\-On ()} -\/ Turn on/off the copying of pedigree id data. ctype is one of the Attribute\-Copy\-Operations, and controls copy, interpolate and passdata behavior. For set, ctype=A\-L\-L\-C\-O\-P\-Y means set all three flags to the same value. For get, ctype=A\-L\-L\-C\-O\-P\-Y returns true only if all three flags are true.

During copying, interpolation and passdata, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy/interpolate/pass for an attribute is set (on or off), it is applied. This overrides rules 2 and 3.
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 3.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily obj.\-Copy\-Pedigree\-Ids\-Off ()} -\/ Turn on/off the copying of pedigree id data. ctype is one of the Attribute\-Copy\-Operations, and controls copy, interpolate and passdata behavior. For set, ctype=A\-L\-L\-C\-O\-P\-Y means set all three flags to the same value. For get, ctype=A\-L\-L\-C\-O\-P\-Y returns true only if all three flags are true.

During copying, interpolation and passdata, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy/interpolate/pass for an attribute is set (on or off), it is applied. This overrides rules 2 and 3.
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 3.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily obj.\-Copy\-All\-On (int ctype\-A\-L\-L\-C\-O\-P\-Y)} -\/ Turn on copying of all data. ctype is one of the Attribute\-Copy\-Operations, and controls copy, interpolate and passdata behavior. For set, ctype=A\-L\-L\-C\-O\-P\-Y means set all three flags to the same value. For get, ctype=A\-L\-L\-C\-O\-P\-Y returns true only if all three flags are true.

During copying, interpolation and passdata, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy/interpolate/pass flag for an attribute is set (on or off), it is applied. This overrides rules 2 and 3.
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 3.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily obj.\-Copy\-All\-Off (int ctype\-A\-L\-L\-C\-O\-P\-Y)} -\/ Turn off copying of all data. ctype is one of the Attribute\-Copy\-Operations, and controls copy, interpolate and passdata behavior. For set, ctype=A\-L\-L\-C\-O\-P\-Y means set all three flags to the same value. For get, ctype=A\-L\-L\-C\-O\-P\-Y returns true only if all three flags are true.

During copying, interpolation and passdata, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy/interpolate/pass flag for an attribute is set (on or off), it is applied. This overrides rules 2 and 3.
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 3.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily obj.\-Pass\-Data (vtk\-Field\-Data fd)} -\/ Pass entire arrays of input data through to output. Obey the \char`\"{}copy\char`\"{} flags. When passing a field, the following copying rules are followed\-: 1) Check if a field is an attribute, if yes and if there is a P\-A\-S\-S\-D\-A\-T\-A copy flag for that attribute (on or off), obey the flag for that attribute, ignore (2) and (3), 2) if there is a copy field for that field (on or off), obey the flag, ignore (3) 3) obey Copy\-All\-On/\-Off  
\item {\ttfamily obj.\-Copy\-Allocate (vtk\-Data\-Set\-Attributes pd, vtk\-Id\-Type sze, vtk\-Id\-Type ext)} -\/ Allocates point data for point-\/by-\/point (or cell-\/by-\/cell) copy operation. If sze=0, then use the input Data\-Set\-Attributes to create (i.\-e., find initial size of) new objects; otherwise use the sze variable. Note that pd H\-A\-S to be the vtk\-Data\-Set\-Attributes object which will later be used with Copy\-Data. If this is not the case, consider using the alternative forms of Copy\-Allocate and Copy\-Data. ext is no longer used. If shallow\-Copy\-Arrays is true, input arrays are copied to the output instead of new ones being allocated.  
\item {\ttfamily obj.\-Copy\-Allocate (vtk\-Data\-Set\-Attributes pd, vtk\-Id\-Type sze, vtk\-Id\-Type ext, int shallow\-Copy\-Arrays)} -\/ Allocates point data for point-\/by-\/point (or cell-\/by-\/cell) copy operation. If sze=0, then use the input Data\-Set\-Attributes to create (i.\-e., find initial size of) new objects; otherwise use the sze variable. Note that pd H\-A\-S to be the vtk\-Data\-Set\-Attributes object which will later be used with Copy\-Data. If this is not the case, consider using the alternative forms of Copy\-Allocate and Copy\-Data. ext is no longer used. If shallow\-Copy\-Arrays is true, input arrays are copied to the output instead of new ones being allocated.  
\item {\ttfamily obj.\-Copy\-Structured\-Data (vtk\-Data\-Set\-Attributes in\-Dsa, int in\-Ext, int out\-Ext)} -\/ This method is used to copy data arrays in images. You should call \char`\"{}\-Copy\-Allocate\char`\"{} before calling this method.  
\item {\ttfamily obj.\-Copy\-Data (vtk\-Data\-Set\-Attributes from\-Pd, vtk\-Id\-Type from\-Id, vtk\-Id\-Type to\-Id)} -\/ Copy the attribute data from one id to another. Make sure Copy\-Allocate() has been invoked before using this method. When copying a field, the following copying rules are followed\-: 1) Check if a field is an attribute, if yes and if there is a C\-O\-P\-Y\-T\-U\-P\-L\-E copy flag for that attribute (on or off), obey the flag for that attribute, ignore (2) and (3), 2) if there is a copy field for that field (on or off), obey the flag, ignore (3) 3) obey Copy\-All\-On/\-Off  
\item {\ttfamily obj.\-Copy\-Tuple (vtk\-Abstract\-Array from\-Data, vtk\-Abstract\-Array to\-Data, vtk\-Id\-Type from\-Id, vtk\-Id\-Type to\-Id)} -\/ Copy a tuple of data from one data array to another. This method assumes that the from\-Data and to\-Data objects are of the same type, and have the same number of components. This is true if you invoke Copy\-Allocate() or Interpolate\-Allocate().  
\item {\ttfamily obj.\-Interpolate\-Allocate (vtk\-Data\-Set\-Attributes pd, vtk\-Id\-Type sze, vtk\-Id\-Type ext)} -\/ Initialize point interpolation method. Note that pd H\-A\-S to be the vtk\-Data\-Set\-Attributes object which will later be used with Interpolate\-Point or Interpolate\-Edge. ext is no longer used. If shallow\-Copy\-Arrays is true, input arrays are copied to the output instead of new ones being allocated.  
\item {\ttfamily obj.\-Interpolate\-Allocate (vtk\-Data\-Set\-Attributes pd, vtk\-Id\-Type sze, vtk\-Id\-Type ext, int shallow\-Copy\-Arrays)} -\/ Initialize point interpolation method. Note that pd H\-A\-S to be the vtk\-Data\-Set\-Attributes object which will later be used with Interpolate\-Point or Interpolate\-Edge. ext is no longer used. If shallow\-Copy\-Arrays is true, input arrays are copied to the output instead of new ones being allocated.  
\item {\ttfamily obj.\-Interpolate\-Point (vtk\-Data\-Set\-Attributes from\-Pd, vtk\-Id\-Type to\-Id, vtk\-Id\-List ids, double weights)} -\/ Interpolate data set attributes from other data set attributes given cell or point ids and associated interpolation weights. If the I\-N\-T\-E\-R\-P\-O\-L\-A\-T\-I\-O\-N copy flag is set to 0 for an array, interpolation is prevented. If the flag is set to 1, weighted interpolation occurs. If the flag is set to 2, nearest neighbor interpolation is used.  
\item {\ttfamily obj.\-Interpolate\-Edge (vtk\-Data\-Set\-Attributes from\-Pd, vtk\-Id\-Type to\-Id, vtk\-Id\-Type p1, vtk\-Id\-Type p2, double t)} -\/ Interpolate data from the two points p1,p2 (forming an edge) and an interpolation factor, t, along the edge. The weight ranges from (0,1), with t=0 located at p1. Make sure that the method Interpolate\-Allocate() has been invoked before using this method. If the I\-N\-T\-E\-R\-P\-O\-L\-A\-T\-I\-O\-N copy flag is set to 0 for an array, interpolation is prevented. If the flag is set to 1, weighted interpolation occurs. If the flag is set to 2, nearest neighbor interpolation is used.  
\item {\ttfamily obj.\-Interpolate\-Time (vtk\-Data\-Set\-Attributes from1, vtk\-Data\-Set\-Attributes from2, vtk\-Id\-Type id, double t)} -\/ Interpolate data from the same id (point or cell) at different points in time (parameter t). Two input data set attributes objects are input. The parameter t lies between (0$<$=t$<$=1). I\-M\-P\-O\-R\-T\-A\-N\-T\-: it is assumed that the number of attributes and number of components is the same for both from1 and from2, and the type of data for from1 and from2 are the same. Make sure that the method Interpolate\-Allocate() has been invoked before using this method. If the I\-N\-T\-E\-R\-P\-O\-L\-A\-T\-I\-O\-N copy flag is set to 0 for an array, interpolation is prevented. If the flag is set to 1, weighted interpolation occurs. If the flag is set to 2, nearest neighbor interpolation is used.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkdatasetcollection}{}\section{vtk\-Data\-Set\-Collection}\label{vtkfiltering_vtkdatasetcollection}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Data\-Set\-Collection is an object that creates and manipulates lists of datasets. See also vtk\-Collection and subclasses.

To create an instance of class vtk\-Data\-Set\-Collection, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkDataSetCollection
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Data\-Set\-Collection has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Data\-Set\-Collection class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Data\-Set\-Collection = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Data\-Set\-Collection = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Add\-Item (vtk\-Data\-Set ds)} -\/ Get the next dataset in the list.  
\item {\ttfamily vtk\-Data\-Set = obj.\-Get\-Next\-Item ()} -\/ Get the next dataset in the list.  
\item {\ttfamily vtk\-Data\-Set = obj.\-Get\-Next\-Data\-Set ()} -\/ Get the next dataset in the list.  
\item {\ttfamily vtk\-Data\-Set = obj.\-Get\-Item (int i)} -\/ Get the ith dataset in the list.  
\item {\ttfamily vtk\-Data\-Set = obj.\-Get\-Data\-Set (int i)} -\/ Get the ith dataset in the list.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkdatasetsource}{}\section{vtk\-Data\-Set\-Source}\label{vtkfiltering_vtkdatasetsource}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Data\-Set\-Source is an abstract class whose subclasses generate datasets.

To create an instance of class vtk\-Data\-Set\-Source, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkDataSetSource
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Data\-Set\-Source has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Data\-Set\-Source class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Data\-Set\-Source = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Data\-Set\-Source = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Data\-Set = obj.\-Get\-Output ()} -\/ Get the output of this source.  
\item {\ttfamily vtk\-Data\-Set = obj.\-Get\-Output (int idx)} -\/ Get the output of this source.  
\item {\ttfamily obj.\-Set\-Output (vtk\-Data\-Set )}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkdatasettodatasetfilter}{}\section{vtk\-Data\-Set\-To\-Data\-Set\-Filter}\label{vtkfiltering_vtkdatasettodatasetfilter}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Data\-Set\-To\-Data\-Set\-Filter is an abstract filter class. Subclasses of vtk\-Data\-Set\-To\-Data\-Set\-Filter take a dataset as input and create a dataset as output. The form of the input geometry is not changed in these filters, only the point attributes (e.\-g. scalars, vectors, etc.).

This is an abstract filter type. What that means is that the output of the filter is an abstract type (i.\-e., vtk\-Data\-Set), no matter what the input of the filter is. This can cause problems connecting together filters due to the change in dataset type. (For example, in a series of filters processing vtk\-Poly\-Data, when a vtk\-Data\-Set\-To\-Data\-Set\-Filter or subclass is introduced into the pipeline, if the filter downstream of it takes vtk\-Poly\-Data as input, the pipeline connection cannot be made.) To get around this problem, use one of the convenience methods to return a concrete type (e.\-g., vtk\-Get\-Poly\-Data\-Output(), Get\-Structured\-Points\-Output(), etc.).

To create an instance of class vtk\-Data\-Set\-To\-Data\-Set\-Filter, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkDataSetToDataSetFilter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Data\-Set\-To\-Data\-Set\-Filter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Data\-Set\-To\-Data\-Set\-Filter class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Data\-Set\-To\-Data\-Set\-Filter = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Data\-Set\-To\-Data\-Set\-Filter = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Set input)} -\/ Specify the input data or filter.  
\item {\ttfamily vtk\-Data\-Set = obj.\-Get\-Output ()} -\/ Get the output of this filter. If output is N\-U\-L\-L then input hasn't been set which is necessary for abstract objects.  
\item {\ttfamily vtk\-Data\-Set = obj.\-Get\-Output (int idx)} -\/ Get the output of this filter. If output is N\-U\-L\-L then input hasn't been set which is necessary for abstract objects.  
\item {\ttfamily vtk\-Poly\-Data = obj.\-Get\-Poly\-Data\-Output ()} -\/ Get the output as vtk\-Poly\-Data.  
\item {\ttfamily vtk\-Structured\-Points = obj.\-Get\-Structured\-Points\-Output ()} -\/ Get the output as vtk\-Structured\-Points.  
\item {\ttfamily vtk\-Structured\-Grid = obj.\-Get\-Structured\-Grid\-Output ()} -\/ Get the output as vtk\-Structured\-Grid.  
\item {\ttfamily vtk\-Unstructured\-Grid = obj.\-Get\-Unstructured\-Grid\-Output ()} -\/ Get the output as vtk\-Unstructured\-Grid.  
\item {\ttfamily vtk\-Rectilinear\-Grid = obj.\-Get\-Rectilinear\-Grid\-Output ()} -\/ Get the output as vtk\-Rectilinear\-Grid.  
\item {\ttfamily vtk\-Data\-Set = obj.\-Get\-Input ()} -\/ Get the input data or filter.  
\item {\ttfamily obj.\-Compute\-Input\-Update\-Extents (vtk\-Data\-Object output)} -\/ By default copy the output update extent to the input  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkdatasettoimagefilter}{}\section{vtk\-Data\-Set\-To\-Image\-Filter}\label{vtkfiltering_vtkdatasettoimagefilter}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Data\-Set\-To\-Image\-Filter is an abstract filter class whose subclasses take as input any dataset and generate image data on output.

To create an instance of class vtk\-Data\-Set\-To\-Image\-Filter, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkDataSetToImageFilter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Data\-Set\-To\-Image\-Filter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Data\-Set\-To\-Image\-Filter class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Data\-Set\-To\-Image\-Filter = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Data\-Set\-To\-Image\-Filter = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Set input)} -\/ Set / get the input data or filter.  
\item {\ttfamily vtk\-Data\-Set = obj.\-Get\-Input ()} -\/ Set / get the input data or filter.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkdatasettopolydatafilter}{}\section{vtk\-Data\-Set\-To\-Poly\-Data\-Filter}\label{vtkfiltering_vtkdatasettopolydatafilter}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Data\-Set\-To\-Poly\-Data\-Filter is an abstract filter class whose subclasses take as input any dataset and generate polygonal data on output.

To create an instance of class vtk\-Data\-Set\-To\-Poly\-Data\-Filter, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkDataSetToPolyDataFilter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Data\-Set\-To\-Poly\-Data\-Filter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Data\-Set\-To\-Poly\-Data\-Filter class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Data\-Set\-To\-Poly\-Data\-Filter = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Data\-Set\-To\-Poly\-Data\-Filter = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Set input)} -\/ Set / get the input data or filter.  
\item {\ttfamily vtk\-Data\-Set = obj.\-Get\-Input ()} -\/ Set / get the input data or filter.  
\item {\ttfamily obj.\-Compute\-Input\-Update\-Extents (vtk\-Data\-Object output)} -\/ Do not let images return more than requested.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkdatasettostructuredgridfilter}{}\section{vtk\-Data\-Set\-To\-Structured\-Grid\-Filter}\label{vtkfiltering_vtkdatasettostructuredgridfilter}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Data\-Set\-To\-Structured\-Grid\-Filter is an abstract filter class whose subclasses take as input any dataset and generate a structured grid on output.

To create an instance of class vtk\-Data\-Set\-To\-Structured\-Grid\-Filter, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkDataSetToStructuredGridFilter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Data\-Set\-To\-Structured\-Grid\-Filter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Data\-Set\-To\-Structured\-Grid\-Filter class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Data\-Set\-To\-Structured\-Grid\-Filter = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Data\-Set\-To\-Structured\-Grid\-Filter = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Set input)} -\/ Set / get the input data or filter.  
\item {\ttfamily vtk\-Data\-Set = obj.\-Get\-Input ()} -\/ Set / get the input data or filter.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkdatasettostructuredpointsfilter}{}\section{vtk\-Data\-Set\-To\-Structured\-Points\-Filter}\label{vtkfiltering_vtkdatasettostructuredpointsfilter}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Data\-Set\-To\-Structured\-Points\-Filter is an abstract filter class whose subclasses take as input any dataset and generate structured points data on output.

To create an instance of class vtk\-Data\-Set\-To\-Structured\-Points\-Filter, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkDataSetToStructuredPointsFilter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Data\-Set\-To\-Structured\-Points\-Filter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Data\-Set\-To\-Structured\-Points\-Filter class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Data\-Set\-To\-Structured\-Points\-Filter = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Data\-Set\-To\-Structured\-Points\-Filter = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Set input)} -\/ Set / get the input data or filter.  
\item {\ttfamily vtk\-Data\-Set = obj.\-Get\-Input ()} -\/ Set / get the input data or filter.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkdatasettounstructuredgridfilter}{}\section{vtk\-Data\-Set\-To\-Unstructured\-Grid\-Filter}\label{vtkfiltering_vtkdatasettounstructuredgridfilter}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Data\-Set\-To\-Unstructured\-Grid\-Filter is an abstract filter class whose subclasses take as input any dataset and generate an unstructured grid on output.

To create an instance of class vtk\-Data\-Set\-To\-Unstructured\-Grid\-Filter, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkDataSetToUnstructuredGridFilter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Data\-Set\-To\-Unstructured\-Grid\-Filter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Data\-Set\-To\-Unstructured\-Grid\-Filter class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Data\-Set\-To\-Unstructured\-Grid\-Filter = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Data\-Set\-To\-Unstructured\-Grid\-Filter = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Set input)} -\/ Set / get the input data or filter.  
\item {\ttfamily vtk\-Data\-Set = obj.\-Get\-Input ()} -\/ Set / get the input data or filter.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkdemanddrivenpipeline}{}\section{vtk\-Demand\-Driven\-Pipeline}\label{vtkfiltering_vtkdemanddrivenpipeline}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Demand\-Driven\-Pipeline is an executive that will execute an algorithm only when its outputs are out-\/of-\/date with respect to its inputs.

To create an instance of class vtk\-Demand\-Driven\-Pipeline, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkDemandDrivenPipeline
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Demand\-Driven\-Pipeline has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Demand\-Driven\-Pipeline class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Demand\-Driven\-Pipeline = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Demand\-Driven\-Pipeline = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Update ()} -\/ Bring the algorithm's outputs up-\/to-\/date. Returns 1 for success and 0 for failure.  
\item {\ttfamily int = obj.\-Update (int port)} -\/ Bring the algorithm's outputs up-\/to-\/date. Returns 1 for success and 0 for failure.  
\item {\ttfamily long = obj.\-Get\-Pipeline\-M\-Time ()} -\/ Get the Pipeline\-M\-Time for this exective.  
\item {\ttfamily int = obj.\-Set\-Release\-Data\-Flag (int port, int n)} -\/ Set whether the given output port releases data when it is consumed. Returns 1 if the the value changes and 0 otherwise.  
\item {\ttfamily int = obj.\-Get\-Release\-Data\-Flag (int port)} -\/ Get whether the given output port releases data when it is consumed.  
\item {\ttfamily int = obj.\-Update\-Pipeline\-M\-Time ()} -\/ Bring the Pipeline\-M\-Time up to date.  
\item {\ttfamily int = obj.\-Update\-Data\-Object ()} -\/ Bring the output data object's existence up to date. This does not actually produce data, but does create the data object that will store data produced during the Update\-Data step.  
\item {\ttfamily int = obj.\-Update\-Information ()} -\/ Bring the output information up to date.  
\item {\ttfamily int = obj.\-Update\-Data (int output\-Port)} -\/ Bring the output data up to date. This should be called only when information is up to date. Use the Update method if it is not known that the information is up to date.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkdirectedacyclicgraph}{}\section{vtk\-Directed\-Acyclic\-Graph}\label{vtkfiltering_vtkdirectedacyclicgraph}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Directed\-Acyclic\-Graph is a connected directed graph with no cycles. A tree is a type of directed graph, so works with all graph algorithms.

vtk\-Directed\-Acyclic\-Graph is a read-\/only data structure. To construct a tree, create an instance of vtk\-Mutable\-Directed\-Graph. Add vertices and edges with Add\-Vertex() and Add\-Edge(). You may alternately start by adding a single vertex as the root then call graph-\/$>$Add\-Child(parent) which adds a new vertex and connects the parent to the child. The tree M\-U\-S\-T have all edges in the proper direction, from parent to child. After building the tree, call tree-\/$>$Checked\-Shallow\-Copy(graph) to copy the structure into a vtk\-Directed\-Acyclic\-Graph. This method will return false if the graph is an invalid tree.

vtk\-Directed\-Acyclic\-Graph provides some convenience methods for obtaining the parent and children of a vertex, for finding the root, and determining if a vertex is a leaf (a vertex with no children).

To create an instance of class vtk\-Directed\-Acyclic\-Graph, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkDirectedAcyclicGraph
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Directed\-Acyclic\-Graph has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Directed\-Acyclic\-Graph class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Directed\-Acyclic\-Graph = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Directed\-Acyclic\-Graph = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Data\-Object\-Type ()}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkdirectedgraph}{}\section{vtk\-Directed\-Graph}\label{vtkfiltering_vtkdirectedgraph}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Directed\-Graph is a collection of vertices along with a collection of directed edges (edges that have a source and target). Shallow\-Copy() and Deep\-Copy() (and Checked\-Shallow\-Copy(), Checked\-Deep\-Copy()) accept instances of vtk\-Tree and vtk\-Mutable\-Directed\-Graph.

vtk\-Directed\-Graph is read-\/only. To create an undirected graph, use an instance of vtk\-Mutable\-Directed\-Graph, then you may set the structure to a vtk\-Directed\-Graph using Shallow\-Copy().

To create an instance of class vtk\-Directed\-Graph, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkDirectedGraph
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Directed\-Graph has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Directed\-Graph class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Directed\-Graph = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Directed\-Graph = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Data\-Object\-Type ()}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkdirectedgraphalgorithm}{}\section{vtk\-Directed\-Graph\-Algorithm}\label{vtkfiltering_vtkdirectedgraphalgorithm}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Directed\-Graph\-Algorithm is a convenience class to make writing algorithms easier. It is also designed to help transition old algorithms to the new pipeline edgehitecture. There are some assumptions and defaults made by this class you should be aware of. This class defaults such that your filter will have one input port and one output port. If that is not the case simply change it with Set\-Number\-Of\-Input\-Ports etc. See this class constructor for the default. This class also provides a Fill\-Input\-Port\-Info method that by default says that all inputs will be Graph. If that isn't the case then please override this method in your subclass. This class breaks out the downstream requests into separate functions such as Execute\-Data and Execute\-Information. For new algorithms you should implement Request\-Data( request, input\-Vec, output\-Vec) but for older filters there is a default implementation that calls the old Execute\-Data(output) signature. For even older filters that don't implement Execute\-Data the default implementation calls the even older Execute() signature.

.S\-E\-C\-T\-I\-O\-N Thanks Thanks to Patricia Crossno, Ken Moreland, Andrew Wilson and Brian Wylie from Sandia National Laboratories for their help in developing this class.

To create an instance of class vtk\-Directed\-Graph\-Algorithm, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkDirectedGraphAlgorithm
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Directed\-Graph\-Algorithm has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Directed\-Graph\-Algorithm class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Directed\-Graph\-Algorithm = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Directed\-Graph\-Algorithm = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Directed\-Graph = obj.\-Get\-Output ()} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Directed\-Graph = obj.\-Get\-Output (int index)} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Object obj)} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Set\-Input (int index, vtk\-Data\-Object obj)} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkdiscretizablecolortransferfunction}{}\section{vtk\-Discretizable\-Color\-Transfer\-Function}\label{vtkfiltering_vtkdiscretizablecolortransferfunction}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This is a cross between a vtk\-Color\-Transfer\-Function and a vtk\-Lookup\-Table selectively combiniting the functionality of both. N\-O\-T\-E\-: One must call Build() after making any changes to the points in the Color\-Transfer\-Function to ensure that the discrete and non-\/discrete version match up.

To create an instance of class vtk\-Discretizable\-Color\-Transfer\-Function, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkDiscretizableColorTransferFunction
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Discretizable\-Color\-Transfer\-Function has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Discretizable\-Color\-Transfer\-Function class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Discretizable\-Color\-Transfer\-Function = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Discretizable\-Color\-Transfer\-Function = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Build ()} -\/ Generate discretized lookup table, if applicable. This method must be called after changes to the Color\-Transfer\-Function otherwise the discretized version will be inconsitent with the non-\/discretized one.  
\item {\ttfamily obj.\-Set\-Discretize (int )} -\/ Set if the values are to mapped after discretization. The number of discrete values is set by using Set\-Number\-Of\-Values(). Not set by default, i.\-e. color value is determined by interpolating at the scalar value.  
\item {\ttfamily int = obj.\-Get\-Discretize ()} -\/ Set if the values are to mapped after discretization. The number of discrete values is set by using Set\-Number\-Of\-Values(). Not set by default, i.\-e. color value is determined by interpolating at the scalar value.  
\item {\ttfamily obj.\-Discretize\-On ()} -\/ Set if the values are to mapped after discretization. The number of discrete values is set by using Set\-Number\-Of\-Values(). Not set by default, i.\-e. color value is determined by interpolating at the scalar value.  
\item {\ttfamily obj.\-Discretize\-Off ()} -\/ Set if the values are to mapped after discretization. The number of discrete values is set by using Set\-Number\-Of\-Values(). Not set by default, i.\-e. color value is determined by interpolating at the scalar value.  
\item {\ttfamily obj.\-Set\-Use\-Log\-Scale (int use\-Log\-Scale)} -\/ Get/\-Set if log scale must be used while mapping scalars to colors. The default is 0.  
\item {\ttfamily int = obj.\-Get\-Use\-Log\-Scale ()} -\/ Get/\-Set if log scale must be used while mapping scalars to colors. The default is 0.  
\item {\ttfamily obj.\-Set\-Number\-Of\-Values (vtk\-Id\-Type number)} -\/ Set the number of values i.\-e. colors to be generated in the discrete lookup table. This has no effect if Discretize is off. The default is 256.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Values ()} -\/ Set the number of values i.\-e. colors to be generated in the discrete lookup table. This has no effect if Discretize is off. The default is 256.  
\item {\ttfamily obj.\-Get\-Color (double v, double rgb\mbox{[}3\mbox{]})} -\/ Map one value through the lookup table and return the color as an R\-G\-B array of doubles between 0 and 1.  
\item {\ttfamily vtk\-Unsigned\-Char\-Array = obj.\-Map\-Scalars (vtk\-Data\-Array scalars, int color\-Mode, int component)} -\/ An internal method maps a data array into a 4-\/component, unsigned char R\-G\-B\-A array. The color mode determines the behavior of mapping. If V\-T\-K\-\_\-\-C\-O\-L\-O\-R\-\_\-\-M\-O\-D\-E\-\_\-\-D\-E\-F\-A\-U\-L\-T is set, then unsigned char data arrays are treated as colors (and converted to R\-G\-B\-A if necessary); otherwise, the data is mapped through this instance of Scalars\-To\-Colors. The offset is used for data arrays with more than one component; it indicates which component to use to do the blending. When the component argument is -\/1, then the this object uses its own selected technique to change a vector into a scalar to map.  
\item {\ttfamily obj.\-Set\-Alpha (double alpha)} -\/ Specify an additional opacity (alpha) value to blend with. Values != 1 modify the resulting color consistent with the requested form of the output. This is typically used by an actor in order to blend its opacity. Overridden to pass the alpha to the internal vtk\-Lookup\-Table.  
\item {\ttfamily int = obj.\-Using\-Log\-Scale ()}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkdistributedgraphhelper}{}\section{vtk\-Distributed\-Graph\-Helper}\label{vtkfiltering_vtkdistributedgraphhelper}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
A distributed graph helper can be attached to an empty vtk\-Graph object to turn the vtk\-Graph into a distributed graph, whose vertices and edges are distributed across several different processors. vtk\-Distributed\-Graph\-Helper is an abstract class. Use a subclass of vtk\-Distributed\-Graph\-Helper, such as vtk\-P\-B\-G\-L\-Distributed\-Graph\-Helper, to build distributed graphs.

The distributed graph helper provides facilities used by vtk\-Graph to communicate with other processors that store other parts of the same distributed graph. The only user-\/level functionality provided by vtk\-Distributed\-Graph\-Helper involves this communication among processors and the ability to map between \char`\"{}distributed\char`\"{} vertex and edge I\-Ds and their component parts (processor and local index). For example, the Synchronize() method provides a barrier that allows all processors to catch up to the same point in the code before any processor can leave that Synchronize() call. For example, one would call Synchronize() after adding many edges to a distributed graph, so that all processors can handle the addition of inter-\/processor edges and continue, after the Synchronize() call, with a consistent view of the distributed graph. For more information about manipulating (distributed) graphs, see the vtk\-Graph documentation.

To create an instance of class vtk\-Distributed\-Graph\-Helper, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkDistributedGraphHelper
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Distributed\-Graph\-Helper has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Distributed\-Graph\-Helper class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Distributed\-Graph\-Helper = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Distributed\-Graph\-Helper = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Vertex\-Owner (vtk\-Id\-Type v) const} -\/ Returns owner of vertex v, by extracting top ceil(log2 P) bits of v.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Vertex\-Index (vtk\-Id\-Type v) const} -\/ Returns local index of vertex v, by masking off top ceil(log2 P) bits of v.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Edge\-Owner (vtk\-Id\-Type e\-\_\-id) const} -\/ Returns owner of edge with I\-D e\-\_\-id, by extracting top ceil(log2 P) bits of e\-\_\-id.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Edge\-Index (vtk\-Id\-Type e\-\_\-id) const} -\/ Returns local index of edge with I\-D e\-\_\-id, by masking off top ceil(log2 P) bits of e\-\_\-id.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Make\-Distributed\-Id (int owner, vtk\-Id\-Type local)} -\/ Builds a distributed I\-D consisting of the given owner and the local I\-D.  
\item {\ttfamily obj.\-Synchronize ()} -\/ Synchronizes all of the processors involved in this distributed graph, so that all processors have a consistent view of the distributed graph for the computation that follows. This routine should be invoked after adding new edges into the distributed graph, so that other processors will see those edges (or their corresponding back-\/edges).  
\item {\ttfamily vtk\-Distributed\-Graph\-Helper = obj.\-Clone ()} -\/ Clones the distributed graph helper, returning another distributed graph helper of the same kind that can be used in another vtk\-Graph.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkedgelistiterator}{}\section{vtk\-Edge\-List\-Iterator}\label{vtkfiltering_vtkedgelistiterator}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Edge\-List\-Iterator iterates through all the edges in a graph, by traversing the adjacency list for each vertex. You may instantiate this class directly and call Set\-Graph() to traverse a certain graph. You may also call the graph's Get\-Edges() method to set up the iterator for a certain graph.

Note that this class does N\-O\-T guarantee that the edges will be processed in order of their ids (i.\-e. it will not necessarily return edge 0, then edge 1, etc.).

To create an instance of class vtk\-Edge\-List\-Iterator, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkEdgeListIterator
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Edge\-List\-Iterator has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Edge\-List\-Iterator class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Edge\-List\-Iterator = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Edge\-List\-Iterator = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Graph = obj.\-Get\-Graph ()}  
\item {\ttfamily obj.\-Set\-Graph (vtk\-Graph graph)}  
\item {\ttfamily vtk\-Graph\-Edge = obj.\-Next\-Graph\-Edge ()} -\/ Just like Next(), but returns heavy-\/weight vtk\-Graph\-Edge object instead of the vtk\-Edge\-Type struct, for use with wrappers. The graph edge is owned by this iterator, and changes after each call to Next\-Graph\-Edge().  
\item {\ttfamily bool = obj.\-Has\-Next ()} -\/ Whether this iterator has more edges.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkemptycell}{}\section{vtk\-Empty\-Cell}\label{vtkfiltering_vtkemptycell}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Empty\-Cell is a concrete implementation of vtk\-Cell. It is used during processing to represented a deleted element.

To create an instance of class vtk\-Empty\-Cell, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkEmptyCell
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Empty\-Cell has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Empty\-Cell class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Empty\-Cell = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Empty\-Cell = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int )} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int )} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts1, vtk\-Cell\-Array lines, vtk\-Cell\-Array verts2, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Clip (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array pts, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd, int inside\-Out)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)}  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)}  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double weights)} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs)} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkexecutive}{}\section{vtk\-Executive}\label{vtkfiltering_vtkexecutive}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Executive is the superclass for all pipeline executives in V\-T\-K. A V\-T\-K executive is responsible for controlling one instance of vtk\-Algorithm. A pipeline consists of one or more executives that control data flow. Every reader, source, writer, or data processing algorithm in the pipeline is implemented in an instance of vtk\-Algorithm.

To create an instance of class vtk\-Executive, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkExecutive
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Executive has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Executive class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Executive = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Executive = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Algorithm = obj.\-Get\-Algorithm ()} -\/ Get the algorithm to which this executive has been assigned.  
\item {\ttfamily int = obj.\-Update ()} -\/ Bring the algorithm's outputs up-\/to-\/date. Returns 1 for success and 0 for failure.  
\item {\ttfamily int = obj.\-Update (int port)} -\/ Bring the algorithm's outputs up-\/to-\/date. Returns 1 for success and 0 for failure.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Input\-Ports ()} -\/ Get the number of input/output ports for the algorithm associated with this executive. Returns 0 if no algorithm is set.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Output\-Ports ()} -\/ Get the number of input/output ports for the algorithm associated with this executive. Returns 0 if no algorithm is set.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Input\-Connections (int port)} -\/ Get the number of input connections on the given port.  
\item {\ttfamily vtk\-Information = obj.\-Get\-Output\-Information (int port)} -\/ Get the pipeline information object for the given output port.  
\item {\ttfamily vtk\-Information\-Vector = obj.\-Get\-Output\-Information ()} -\/ Get the pipeline information object for all output ports.  
\item {\ttfamily vtk\-Information = obj.\-Get\-Input\-Information (int port, int connection)} -\/ Get the pipeline information for the given input connection.  
\item {\ttfamily vtk\-Information\-Vector = obj.\-Get\-Input\-Information (int port)} -\/ Get the pipeline information vectors for the given input port.  
\item {\ttfamily vtk\-Executive = obj.\-Get\-Input\-Executive (int port, int connection)} -\/ Get the executive managing the given input connection.  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Output\-Data (int port)} -\/ Get/\-Set the data object for an output port of the algorithm.  
\item {\ttfamily obj.\-Set\-Output\-Data (int port, vtk\-Data\-Object , vtk\-Information info)} -\/ Get/\-Set the data object for an output port of the algorithm.  
\item {\ttfamily obj.\-Set\-Output\-Data (int port, vtk\-Data\-Object )} -\/ Get/\-Set the data object for an output port of the algorithm.  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Input\-Data (int port, int connection)} -\/ Get the data object for an input port of the algorithm.  
\item {\ttfamily vtk\-Algorithm\-Output = obj.\-Get\-Producer\-Port (vtk\-Data\-Object )} -\/ Get the output port that produces the given data object.  
\item {\ttfamily obj.\-Set\-Shared\-Output\-Information (vtk\-Information\-Vector out\-Info\-Vec)} -\/ Set a pointer to an outside instance of input or output information vectors. No references are held to the given vectors, and setting this does not change the executive object modification time. This is a preliminary interface to use in implementing filters with internal pipelines, and may change without notice when a future interface is created.  
\item {\ttfamily obj.\-Register (vtk\-Object\-Base o)} -\/ Participate in garbage collection.  
\item {\ttfamily obj.\-Un\-Register (vtk\-Object\-Base o)} -\/ Participate in garbage collection.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkexecutivecollection}{}\section{vtk\-Executive\-Collection}\label{vtkfiltering_vtkexecutivecollection}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Executive\-Collection is an object that creates and manipulates lists of objects that are (inherited from) vtk\-Executives.

To create an instance of class vtk\-Executive\-Collection, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkExecutiveCollection
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Executive\-Collection has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Executive\-Collection class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Executive\-Collection = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Executive\-Collection = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Add\-Item (vtk\-Executive exec)} -\/ Get the next executive in the list.  
\item {\ttfamily vtk\-Executive = obj.\-Get\-Next\-Item ()}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkexplicitcell}{}\section{vtk\-Explicit\-Cell}\label{vtkfiltering_vtkexplicitcell}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Explicit\-Cell is an abstract superclass for cells that cannot be represented implicitly. An implicit representation requires only a cell type and connectivity list (e.\-g., triangle). Explicit cells require information beyond this; e.\-g., a N\-U\-R\-B\-S surface or cells that require explicit face/edge descriptions. Most cells in V\-T\-K are implicitly represented.

To create an instance of class vtk\-Explicit\-Cell, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkExplicitCell
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Explicit\-Cell has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Explicit\-Cell class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Explicit\-Cell = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Explicit\-Cell = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Is\-Explicit\-Cell ()} -\/ Set/\-Get the cell id. This is necessary for explicit cells because they often need to keep extra information (typically contained in the cell data of a point set). This information might be things like knot points/weights, boundaries, etc.  
\item {\ttfamily obj.\-Set\-Cell\-Id (vtk\-Id\-Type )} -\/ Set/\-Get the cell id. This is necessary for explicit cells because they often need to keep extra information (typically contained in the cell data of a point set). This information might be things like knot points/weights, boundaries, etc.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Cell\-Id ()} -\/ Set/\-Get the cell id. This is necessary for explicit cells because they often need to keep extra information (typically contained in the cell data of a point set). This information might be things like knot points/weights, boundaries, etc.  
\item {\ttfamily obj.\-Set\-Data\-Set (vtk\-Data\-Set )} -\/ Set/\-Get the mesh that owns this cell. This is necessary for explicit cells because they often need to keep extra information (typically contained in the cell data of a point set). This information might be things like knot points/weights, boundaries, etc.  
\item {\ttfamily vtk\-Data\-Set = obj.\-Get\-Data\-Set ()} -\/ Set/\-Get the mesh that owns this cell. This is necessary for explicit cells because they often need to keep extra information (typically contained in the cell data of a point set). This information might be things like knot points/weights, boundaries, etc.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkfielddata}{}\section{vtk\-Field\-Data}\label{vtkfiltering_vtkfielddata}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Field\-Data represents and manipulates fields of data. The model of a field is a m x n matrix of data values, where m is the number of tuples, and n is the number of components. (A tuple is a row of n components in the matrix.) The field is assumed to be composed of a set of one or more data arrays, where the data in the arrays are of different types (e.\-g., int, double, char, etc.), and there may be variable numbers of components in each array. Note that each data array is assumed to be \char`\"{}m\char`\"{} in length (i.\-e., number of tuples), which typically corresponds to the number of points or cells in a dataset. Also, each data array must have a character-\/string name. (This is used to manipulate data.)

There are two ways of manipulating and interfacing to fields. You can do it generically by manipulating components/tuples via a double-\/type data exchange, or you can do it by grabbing the arrays and manipulating them directly. The former is simpler but performs type conversion, which is bad if your data has non-\/castable types like (void) pointers, or you lose information as a result of the cast. The, more efficient method means managing each array in the field. Using this method you can create faster, more efficient algorithms that do not lose information.

To create an instance of class vtk\-Field\-Data, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkFieldData
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Field\-Data has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Field\-Data class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Field\-Data = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Field\-Data = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Initialize ()} -\/ Release all data but do not delete object. Also, clear the copy flags.  
\item {\ttfamily int = obj.\-Allocate (vtk\-Id\-Type sz, vtk\-Id\-Type ext)} -\/ Allocate data for each array. Note that ext is no longer used.  
\item {\ttfamily obj.\-Copy\-Structure (vtk\-Field\-Data )} -\/ Copy data array structure from a given field. The same arrays will exist with the same types, but will contain nothing in the copy.  
\item {\ttfamily obj.\-Allocate\-Arrays (int num)} -\/ Allocate\-Of\-Arrays actually sets the number of vtk\-Abstract\-Array pointers in the vtk\-Field\-Data object, not the number of used pointers (arrays). Adding more arrays will cause the object to dynamically adjust the number of pointers if it needs to extend. Although Allocate\-Arrays can be used if the number of arrays which will be added is known, it can be omitted with a small computation cost.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Arrays ()} -\/ Add an array to the array list. If an array with the same name already exists -\/ then the added array will replace it.  
\item {\ttfamily int = obj.\-Add\-Array (vtk\-Abstract\-Array array)} -\/ Add an array to the array list. If an array with the same name already exists -\/ then the added array will replace it.  
\item {\ttfamily obj.\-Remove\-Array (string name)} -\/ Return the ith array in the field. A N\-U\-L\-L is returned if the index i is out of range. A N\-U\-L\-L is returned if the array at the given index is not a vtk\-Data\-Array.  
\item {\ttfamily vtk\-Data\-Array = obj.\-Get\-Array (int i)} -\/ Return the ith array in the field. A N\-U\-L\-L is returned if the index i is out of range. A N\-U\-L\-L is returned if the array at the given index is not a vtk\-Data\-Array.  
\item {\ttfamily vtk\-Data\-Array = obj.\-Get\-Array (string array\-Name)} -\/ Returns the ith array in the field. Unlike Get\-Array(), this method returns a vtk\-Abstract\-Array. A N\-U\-L\-L is returned only if the index i is out of range.  
\item {\ttfamily vtk\-Abstract\-Array = obj.\-Get\-Abstract\-Array (int i)} -\/ Returns the ith array in the field. Unlike Get\-Array(), this method returns a vtk\-Abstract\-Array. A N\-U\-L\-L is returned only if the index i is out of range.  
\item {\ttfamily vtk\-Abstract\-Array = obj.\-Get\-Abstract\-Array (string array\-Name)} -\/ Return 1 if an array with the given name could be found. 0 otherwise.  
\item {\ttfamily int = obj.\-Has\-Array (string name)} -\/ Get the name of ith array. Note that this is equivalent to\-: Get\-Abstract\-Array(i)-\/$>$Get\-Name() if ith array pointer is not N\-U\-L\-L  
\item {\ttfamily string = obj.\-Get\-Array\-Name (int i)} -\/ Pass entire arrays of input data through to output. Obey the \char`\"{}copy\char`\"{} flags.  
\item {\ttfamily obj.\-Pass\-Data (vtk\-Field\-Data fd)} -\/ Pass entire arrays of input data through to output. Obey the \char`\"{}copy\char`\"{} flags.  
\item {\ttfamily obj.\-Copy\-Field\-On (string name)} -\/ Turn on/off the copying of the field specified by name. During the copying/passing, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 2.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily obj.\-Copy\-Field\-Off (string name)} -\/ Turn on copying of all data. During the copying/passing, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 2.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily obj.\-Copy\-All\-On (int unused)} -\/ Turn on copying of all data. During the copying/passing, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 2.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily obj.\-Copy\-All\-Off (int unused)} -\/ Turn off copying of all data. During the copying/passing, the following rules are followed for each array\-:
\begin{DoxyEnumerate}
\item If the copy flag for an array is set (on or off), it is applied This overrides rule 2.
\item If Copy\-All\-On is set, copy the array. If Copy\-All\-Off is set, do not copy the array  
\end{DoxyEnumerate}
\item {\ttfamily obj.\-Deep\-Copy (vtk\-Field\-Data da)} -\/ Copy a field by creating new data arrays (i.\-e., duplicate storage).  
\item {\ttfamily obj.\-Shallow\-Copy (vtk\-Field\-Data da)} -\/ Copy a field by reference counting the data arrays.  
\item {\ttfamily obj.\-Squeeze ()} -\/ Squeezes each data array in the field (Squeeze() reclaims unused memory.)  
\item {\ttfamily obj.\-Reset ()} -\/ Resets each data array in the field (Reset() does not release memory but it makes the arrays look like they are empty.)  
\item {\ttfamily long = obj.\-Get\-Actual\-Memory\-Size ()} -\/ Return the memory in kilobytes consumed by this field data. Used to support streaming and reading/writing data. The value returned is guaranteed to be greater than or equal to the memory required to actually represent the data represented by this object.  
\item {\ttfamily long = obj.\-Get\-M\-Time ()} -\/ Check object's components for modified times.  
\item {\ttfamily obj.\-Get\-Field (vtk\-Id\-List pt\-Id, vtk\-Field\-Data f)} -\/ Get a field from a list of ids. Supplied field f should have same types and number of data arrays as this one (i.\-e., like Copy\-Structure() creates). This method should not be used if the instance is from a subclass of vtk\-Field\-Data (vtk\-Point\-Data or vtk\-Cell\-Data). This is because in those cases, the attribute data is stored with the other fields and will cause the method to behave in an unexpected way.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Components ()} -\/ Get the number of components in the field. This is determined by adding up the components in each non-\/\-N\-U\-L\-L array. This method should not be used if the instance is from a subclass of vtk\-Field\-Data (vtk\-Point\-Data or vtk\-Cell\-Data). This is because in those cases, the attribute data is stored with the other fields and will cause the method to behave in an unexpected way.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Tuples ()} -\/ Get the number of tuples in the field. Note\-: some fields have arrays with different numbers of tuples; this method returns the number of tuples in the first array. Mixed-\/length arrays may have to be treated specially. This method should not be used if the instance is from a subclass of vtk\-Field\-Data (vtk\-Point\-Data or vtk\-Cell\-Data). This is because in those cases, the attribute data is stored with the other fields and will cause the method to behave in an unexpected way.  
\item {\ttfamily obj.\-Set\-Number\-Of\-Tuples (vtk\-Id\-Type number)} -\/ Set the number of tuples for each data array in the field. This method should not be used if the instance is from a subclass of vtk\-Field\-Data (vtk\-Point\-Data or vtk\-Cell\-Data). This is because in those cases, the attribute data is stored with the other fields and will cause the method to behave in an unexpected way.  
\item {\ttfamily obj.\-Set\-Tuple (vtk\-Id\-Type i, vtk\-Id\-Type j, vtk\-Field\-Data source)} -\/ Set the jth tuple in source field data at the ith location. Set operations mean that no range checking is performed, so they're faster.  
\item {\ttfamily obj.\-Insert\-Tuple (vtk\-Id\-Type i, vtk\-Id\-Type j, vtk\-Field\-Data source)} -\/ Insert the jth tuple in source field data at the ith location. Range checking is performed and memory allocates as necessary.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Insert\-Next\-Tuple (vtk\-Id\-Type j, vtk\-Field\-Data source)} -\/ Insert the jth tuple in source field data at the end of the tuple matrix. Range checking is performed and memory is allocated as necessary.  
\item {\ttfamily obj.\-Get\-Tuple (vtk\-Id\-Type i, double tuple)} -\/ Copy the ith tuple value into a user provided tuple array. Make sure that you've allocated enough space for the copy.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkgenericadaptorcell}{}\section{vtk\-Generic\-Adaptor\-Cell}\label{vtkfiltering_vtkgenericadaptorcell}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
In V\-T\-K, spatial-\/temporal data is defined in terms of a dataset which is composed of cells. The cells are topological entities over which an interpolation field is applied. Cells are defined in terms of a topology (e.\-g., vertices, lines, triangles, polygons, tetrahedra, etc.), points that instantiate the geometry of the cells, and interpolation fields (in the general case one interpolation field is for geometry, the other is for attribute data associated with the cell).

Currently most algorithms in V\-T\-K use vtk\-Cell and vtk\-Data\-Set, which make assumptions about the nature of datasets, cells, and attributes. In particular, this abstraction assumes that cell interpolation functions are linear, or products of linear functions. Further, V\-T\-K implements most of the interpolation functions. This implementation starts breaking down as the complexity of the interpolation (or basis) functions increases.

vtk\-Generic\-Adaptor\-Cell addresses these issues by providing more general abstraction for cells. It also adopts modern C++ practices including using iterators. The vtk\-Generic\-Adaptor\-Cell is designed to fit within the adaptor framework; meaning that it is meant to adapt V\-T\-K to external simulation systems (see the Generic\-Filtering/\-R\-E\-A\-D\-M\-E.\-html).

Please note that most cells are defined in terms of other cells (the boundary cells). They are also defined in terms of points, which are not the same as vertices (vertices are a 0-\/\-D cell; points represent a position in space).

Another important concept is the notion of D\-O\-F\-Nodes. These concept supports cell types with complex interpolation functions. For example, higher-\/order p-\/method finite elements may have different functions on each of their topological features (edges, faces, region). The coefficients of these polynomial functions are associated with D\-O\-F\-Nodes. (There is a single D\-O\-F\-Node for each topological feature.) Note that from this perspective, points are used to establish the topological form of the cell; mid-\/side nodes and such are considered D\-O\-F\-Nodes.

To create an instance of class vtk\-Generic\-Adaptor\-Cell, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkGenericAdaptorCell
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Generic\-Adaptor\-Cell has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Generic\-Adaptor\-Cell class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Generic\-Adaptor\-Cell = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Generic\-Adaptor\-Cell = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Id ()} -\/ Unique identification number of the cell over the whole data set. This unique key may not be contiguous.  
\item {\ttfamily int = obj.\-Is\-In\-Data\-Set ()} -\/ Does `this' a cell of a dataset? (otherwise, it is a boundary cell)  
\item {\ttfamily int = obj.\-Get\-Type ()} -\/ Return the type of the current cell. \begin{DoxyPostcond}{Postcondition}
(result==V\-T\-K\-\_\-\-H\-I\-G\-H\-E\-R\-\_\-\-O\-R\-D\-E\-R\-\_\-\-E\-D\-G\-E)$|$$|$ (result==V\-T\-K\-\_\-\-H\-I\-G\-H\-E\-R\-\_\-\-O\-R\-D\-E\-R\-\_\-\-T\-R\-I\-A\-N\-G\-L\-E)$|$$|$ (result==V\-T\-K\-\_\-\-H\-I\-G\-H\-E\-R\-\_\-\-O\-R\-D\-E\-R\-\_\-\-T\-E\-T\-R\-A\-H\-E\-D\-R\-O\-N)  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Get\-Dimension ()} -\/ Return the topological dimension of the current cell. \begin{DoxyPostcond}{Postcondition}
valid\-\_\-result\-: result$>$=0 \&\& result$<$=3  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Get\-Geometry\-Order ()} -\/ Return the interpolation order of the geometry. \begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$=0  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Is\-Geometry\-Linear ()} -\/ Does the cell have a non-\/linear interpolation for the geometry? \begin{DoxyPostcond}{Postcondition}
definition\-: result==(Get\-Geometry\-Order()==1)  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Get\-Attribute\-Order (vtk\-Generic\-Attribute a)} -\/ Return the interpolation order of attribute `a' on the cell (may differ by cell). \begin{DoxyPrecond}{Precondition}
a\-\_\-exists\-: a!=0 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$=0  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Get\-Highest\-Order\-Attribute (vtk\-Generic\-Attribute\-Collection ac)} -\/ Return the index of the first point centered attribute with the highest order in `ac'. \begin{DoxyPrecond}{Precondition}
ac\-\_\-exists\-: ac!=0 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
valid\-\_\-result\-: result$>$=-\/1 \&\& result$<$ac-\/$>$Get\-Number\-Of\-Attributes()  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Is\-Attribute\-Linear (vtk\-Generic\-Attribute a)} -\/ Does the attribute `a' have a non-\/linear interpolation? \begin{DoxyPrecond}{Precondition}
a\-\_\-exists\-: a!=0 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
definition\-: result==(Get\-Attribute\-Order()==1)  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Is\-Primary ()} -\/ Is the cell primary (i.\-e. not composite) ?  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Points ()} -\/ Return the number of corner points that compose the cell. \begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$=0  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Get\-Number\-Of\-Boundaries (int dim)} -\/ Return the number of boundaries of dimension `dim' (or all dimensions greater than 0 and less than Get\-Dimension() if -\/1) of the cell. When {\itshape dim} is -\/1, the number of vertices is not included in the count because vertices are a special case\-: a vertex will have at most a single field value associated with it; D\-O\-F nodes may have an arbitrary number of field values associated with them. \begin{DoxyPrecond}{Precondition}
valid\-\_\-dim\-\_\-range\-: (dim==-\/1) $|$$|$ ((dim$>$=0)\&\&(dim$<$Get\-Dimension())) 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$=0  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Get\-Number\-Of\-D\-O\-F\-Nodes ()} -\/ Accumulated number of D\-O\-F nodes of the current cell. A D\-O\-F node is a component of cell with a given topological dimension. e.\-g.\-: a triangle has 4 D\-O\-F\-: 1 face and 3 edges. An hexahedron has 19 D\-O\-F\-: 1 region, 6 faces, and 12 edges.

The number of vertices is not included in the count because vertices are a special case\-: a vertex will have at most a single field value associated with it; D\-O\-F nodes may have an arbitrary number of field values associated with them. \begin{DoxyPostcond}{Postcondition}
valid\-\_\-result\-: result==Get\-Number\-Of\-Boundaries(-\/1)+1  
\end{DoxyPostcond}

\item {\ttfamily obj.\-Get\-Point\-Iterator (vtk\-Generic\-Point\-Iterator it)} -\/ Return the points of cell into `it'. \begin{DoxyPrecond}{Precondition}
it\-\_\-exists\-: it!=0  
\end{DoxyPrecond}

\item {\ttfamily vtk\-Generic\-Cell\-Iterator = obj.\-New\-Cell\-Iterator ()} -\/ Create an empty cell iterator. The user is responsible for deleting it. \begin{DoxyPostcond}{Postcondition}
result\-\_\-exists\-: result!=0  
\end{DoxyPostcond}

\item {\ttfamily obj.\-Get\-Boundary\-Iterator (vtk\-Generic\-Cell\-Iterator boundaries, int dim)} -\/ Return the `boundaries' cells of dimension `dim' (or all dimensions less than Get\-Dimension() if -\/1) that are part of the boundary of the cell. \begin{DoxyPrecond}{Precondition}
valid\-\_\-dim\-\_\-range\-: (dim==-\/1) $|$$|$ ((dim$>$=0)\&\&(dim$<$Get\-Dimension())) 

boundaries\-\_\-exist\-: boundaries!=0  
\end{DoxyPrecond}

\item {\ttfamily int = obj.\-Count\-Neighbors (vtk\-Generic\-Adaptor\-Cell boundary)} -\/ Number of cells (dimension$>$boundary-\/$>$Get\-Dimension()) of the dataset that share the boundary `boundary' of `this'. `this' I\-S N\-O\-T I\-N\-C\-L\-U\-D\-E\-D. \begin{DoxyPrecond}{Precondition}
boundary\-\_\-exists\-: boundary!=0 

real\-\_\-boundary\-: !boundary-\/$>$Is\-In\-Data\-Set() 

cell\-\_\-of\-\_\-the\-\_\-dataset\-: Is\-In\-Data\-Set() 

boundary\-: Has\-Boundary(boundary) 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$=0  
\end{DoxyPostcond}

\item {\ttfamily obj.\-Count\-Edge\-Neighbors (int sharing)} -\/ Number of cells (dimension$>$boundary-\/$>$Get\-Dimension()) of the dataset that share the boundary `boundary' of `this'. `this' I\-S N\-O\-T I\-N\-C\-L\-U\-D\-E\-D. \begin{DoxyPrecond}{Precondition}
boundary\-\_\-exists\-: boundary!=0 

real\-\_\-boundary\-: !boundary-\/$>$Is\-In\-Data\-Set() 

cell\-\_\-of\-\_\-the\-\_\-dataset\-: Is\-In\-Data\-Set() 

boundary\-: Has\-Boundary(boundary) 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$=0  
\end{DoxyPostcond}

\item {\ttfamily obj.\-Get\-Neighbors (vtk\-Generic\-Adaptor\-Cell boundary, vtk\-Generic\-Cell\-Iterator neighbors)} -\/ Put into `neighbors' the cells (dimension$>$boundary-\/$>$Get\-Dimension()) of the dataset that share the boundary `boundary' with this cell. `this' I\-S N\-O\-T I\-N\-C\-L\-U\-D\-E\-D. \begin{DoxyPrecond}{Precondition}
boundary\-\_\-exists\-: boundary!=0 

real\-\_\-boundary\-: !boundary-\/$>$Is\-In\-Data\-Set() 

cell\-\_\-of\-\_\-the\-\_\-dataset\-: Is\-In\-Data\-Set() 

boundary\-: Has\-Boundary(boundary) 

neighbors\-\_\-exist\-: neighbors!=0  
\end{DoxyPrecond}

\item {\ttfamily obj.\-Evaluate\-Location (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double x\mbox{[}3\mbox{]})} -\/ Determine the global coordinates `x' from sub-\/cell `sub\-Id' and parametric coordinates `pcoords' in the cell. \begin{DoxyPrecond}{Precondition}
positive\-\_\-sub\-Id\-: sub\-Id$>$=0 

clamped\-\_\-pcoords\-: (0$<$=pcoords\mbox{[}0\mbox{]})\&\&(pcoords\mbox{[}0\mbox{]}$<$=1)\&\&(0$<$=pcoords\mbox{[}1\mbox{]}) \&\&(pcoords\mbox{[}1\mbox{]}$<$=1)\&\&(0$<$=pcoords\mbox{[}2\mbox{]})\&\&(pcoords\mbox{[}2\mbox{]}$<$=1)  
\end{DoxyPrecond}

\item {\ttfamily obj.\-Interpolate\-Tuple (vtk\-Generic\-Attribute a, double pcoords\mbox{[}3\mbox{]}, double val)} -\/ Interpolate the attribute `a' at local position `pcoords' of the cell into `val'. \begin{DoxyPrecond}{Precondition}
a\-\_\-exists\-: a!=0 

a\-\_\-is\-\_\-point\-\_\-centered\-: a-\/$>$Get\-Centering()==vtk\-Point\-Centered 

clamped\-\_\-point\-: pcoords\mbox{[}0\mbox{]}$>$=0 \&\& pcoords\mbox{[}0\mbox{]}$<$=1 \&\& pcoords\mbox{[}1\mbox{]}$>$=0 \&\& pcoords\mbox{[}1\mbox{]}$<$=1 \&\& pcoords\mbox{[}2\mbox{]}$>$=0 \&\& pcoords\mbox{[}2\mbox{]}$<$=1 

val\-\_\-exists\-: val!=0 

valid\-\_\-size\-: sizeof(val)==a-\/$>$Get\-Number\-Of\-Components()  
\end{DoxyPrecond}

\item {\ttfamily obj.\-Interpolate\-Tuple (vtk\-Generic\-Attribute\-Collection c, double pcoords\mbox{[}3\mbox{]}, double val)} -\/ Interpolate the whole collection of attributes `c' at local position `pcoords' of the cell into `val'. Only point centered attributes are taken into account. \begin{DoxyPrecond}{Precondition}
c\-\_\-exists\-: c!=0 

clamped\-\_\-point\-: pcoords\mbox{[}0\mbox{]}$>$=0 \&\& pcoords\mbox{[}0\mbox{]}$<$=1 \&\& pcoords\mbox{[}1\mbox{]}$>$=0 \&\& pcoords\mbox{[}1\mbox{]}$<$=1 \&\& pcoords\mbox{[}2\mbox{]}$>$=0 \&\& pcoords\mbox{[}2\mbox{]}$<$=1 

val\-\_\-exists\-: val!=0 

valid\-\_\-size\-: sizeof(val)==c-\/$>$Get\-Number\-Of\-Point\-Centered\-Components()  
\end{DoxyPrecond}

\item {\ttfamily obj.\-Contour (vtk\-Contour\-Values values, vtk\-Implicit\-Function f, vtk\-Generic\-Attribute\-Collection attributes, vtk\-Generic\-Cell\-Tessellator tess, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data out\-Cd, vtk\-Point\-Data internal\-Pd, vtk\-Point\-Data secondary\-Pd, vtk\-Cell\-Data secondary\-Cd)} -\/ Generate a contour (contouring primitives) for each `values' or with respect to an implicit function `f'. Contouring is performed on the scalar attribute (`attributes-\/$>$Get\-Active\-Attribute()' `attributes-\/$>$Get\-Active\-Component()'). Contouring interpolates the `attributes-\/$>$Get\-Number\-Ofattributes\-To\-Interpolate()' attributes `attributes-\/$>$Get\-Attributes\-To\-Interpolate()'. The `locator', `verts', `lines', `polys', `out\-Pd' and `out\-Cd' are cumulative data arrays over cell iterations\-: they store the result of each call to Contour()\-:
\begin{DoxyItemize}
\item `locator' is a points list that merges points as they are inserted (i.\-e., prevents duplicates).
\item `verts' is an array of generated vertices
\item `lines' is an array of generated lines
\item `polys' is an array of generated polygons
\item `out\-Pd' is an array of interpolated point data along the edge (if not-\/\-N\-U\-L\-L)
\item `out\-Cd' is an array of copied cell data of the current cell (if not-\/\-N\-U\-L\-L) `internal\-Pd', `secondary\-Pd' and `secondary\-Cd' are initialized by the filter that call it from `attributes'.
\item `internal\-Pd' stores the result of the tessellation pass\-: the higher-\/order cell is tessellated into linear sub-\/cells.
\item `secondary\-Pd' and `secondary\-Cd' are used internally as inputs to the Contour() method on linear sub-\/cells. Note\-: the Copy\-Allocate() method must be invoked on both `out\-Pd' and `out\-Cd', from `secondary\-Pd' and `secondary\-Cd'.
\end{DoxyItemize}

N\-O\-T\-E\-: `vtk\-Generic\-Attribute\-Collection $\ast$attributes' will be replaced by a `vtk\-Information'.

\begin{DoxyPrecond}{Precondition}
values\-\_\-exist\-: (values!=0 \&\& f==0) $|$$|$ (values==0 \&\& f!=0) 

attributes\-\_\-exist\-: attributes!=0 

tessellator\-\_\-exists\-: tess!=0 

locator\-\_\-exists\-: locator!=0 

verts\-\_\-exist\-: verts!=0 

lines\-\_\-exist\-: lines!=0 

polys\-\_\-exist\-: polys!=0 

internal\-Pd\-\_\-exists\-: internal\-Pd!=0 

secondary\-Pd\-\_\-exists\-: secondary\-Pd!=0 

secondary\-Cd\-\_\-exists\-: secondary\-Cd!=0  
\end{DoxyPrecond}

\item {\ttfamily obj.\-Clip (double value, vtk\-Implicit\-Function f, vtk\-Generic\-Attribute\-Collection attributes, vtk\-Generic\-Cell\-Tessellator tess, int inside\-Out, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array connectivity, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data out\-Cd, vtk\-Point\-Data internal\-Pd, vtk\-Point\-Data secondary\-Pd, vtk\-Cell\-Data secondary\-Cd)} -\/ Cut (or clip) the current cell with respect to the contour defined by the `value' or the implicit function `f' of the scalar attribute (`attributes-\/$>$Get\-Active\-Attribute()',`attributes-\/$>$Get\-Active\-Component()'). If `f' exists, `value' is not used. The output is the part of the current cell which is inside the contour. The output is a set of zero, one or more cells of the same topological dimension as the current cell. Normally, cell points whose scalar value is greater than \char`\"{}value\char`\"{} are considered inside. If `inside\-Out' is on, this is reversed. Clipping interpolates the `attributes-\/$>$Get\-Number\-Ofattributes\-To\-Interpolate()' attributes `attributes-\/$>$Get\-Attributes\-To\-Interpolate()'. `locator', `connectivity', `out\-Pd' and `out\-Cd' are cumulative data arrays over cell iterations\-: they store the result of each call to Clip()\-:
\begin{DoxyItemize}
\item `locator' is a points list that merges points as they are inserted (i.\-e., prevents duplicates).
\item `connectivity' is an array of generated cells
\item `out\-Pd' is an array of interpolated point data along the edge (if not-\/\-N\-U\-L\-L)
\item `out\-Cd' is an array of copied cell data of the current cell (if not-\/\-N\-U\-L\-L) `internal\-Pd', `secondary\-Pd' and `secondary\-Cd' are initialized by the filter that call it from `attributes'.
\item `internal\-Pd' stores the result of the tessellation pass\-: the higher-\/order cell is tessellated into linear sub-\/cells.
\item `secondary\-Pd' and `secondary\-Cd' are used internally as inputs to the Clip() method on linear sub-\/cells. Note\-: the Copy\-Allocate() method must be invoked on both `out\-Pd' and `out\-Cd', from `secondary\-Pd' and `secondary\-Cd'.
\end{DoxyItemize}

N\-O\-T\-E\-: `vtk\-Generic\-Attribute\-Collection $\ast$attributes' will be replaced by a `vtk\-Information'.

\begin{DoxyPrecond}{Precondition}
attributes\-\_\-exist\-: attributes!=0 

tessellator\-\_\-exists\-: tess!=0 

locator\-\_\-exists\-: locator!=0 

connectivity\-\_\-exists\-: connectivity!=0 

internal\-Pd\-\_\-exists\-: internal\-Pd!=0 

secondary\-Pd\-\_\-exists\-: secondary\-Pd!=0 

secondary\-Cd\-\_\-exists\-: secondary\-Cd!=0  
\end{DoxyPrecond}

\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Generic\-Attribute attribute, double derivs)} -\/ Compute derivatives `derivs' of the attribute `attribute' (from its values at the corner points of the cell) given sub-\/cell `sub\-Id' (0 means primary cell) and parametric coordinates `pcoords'. Derivatives are in the x-\/y-\/z coordinate directions for each data value. \begin{DoxyPrecond}{Precondition}
positive\-\_\-sub\-Id\-: sub\-Id$>$=0 

clamped\-\_\-pcoords\-: (0$<$=pcoords\mbox{[}0\mbox{]})\&\&(pcoords\mbox{[}0\mbox{]}$<$=1)\&\&(0$<$=pcoords\mbox{[}1\mbox{]}) \&\&(pcoords\mbox{[}1\mbox{]}$<$=1)\&\&(0$<$=pcoords\mbox{[}2\mbox{]})\%\%(pcoords\mbox{[}2\mbox{]}$<$=1) 

attribute\-\_\-exists\-: attribute!=0 

derivs\-\_\-exists\-: derivs!=0 

valid\-\_\-size\-: sizeof(derivs)$>$=attribute-\/$>$Get\-Number\-Of\-Components()$\ast$3  
\end{DoxyPrecond}

\item {\ttfamily obj.\-Get\-Bounds (double bounds\mbox{[}6\mbox{]})} -\/ Compute the bounding box of the current cell in `bounds' in global coordinates. T\-H\-R\-E\-A\-D S\-A\-F\-E  
\item {\ttfamily double = obj.\-Get\-Length2 ()} -\/ Return the bounding box diagonal squared of the current cell. \begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$=0  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Get\-Parametric\-Center (double pcoords\mbox{[}3\mbox{]})} -\/ Get the center of the current cell (in parametric coordinates) and place it in `pcoords'. If the current cell is a composite, the return value is the sub-\/cell id that the center is in. \begin{DoxyPostcond}{Postcondition}
valid\-\_\-result\-: (result$>$=0) \&\& (Is\-Primary() implies result==0)  
\end{DoxyPostcond}

\item {\ttfamily double = obj.\-Get\-Parametric\-Distance (double pcoords\mbox{[}3\mbox{]})} -\/ Return the distance of the parametric coordinate `pcoords' to the current cell. If inside the cell, a distance of zero is returned. This is used during picking to get the correct cell picked. (The tolerance will occasionally allow cells to be picked who are not really intersected \char`\"{}inside\char`\"{} the cell.) \begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$=0  
\end{DoxyPostcond}

\item {\ttfamily obj.\-Tessellate (vtk\-Generic\-Attribute\-Collection attributes, vtk\-Generic\-Cell\-Tessellator tess, vtk\-Points points, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array cell\-Array, vtk\-Point\-Data internal\-Pd, vtk\-Point\-Data pd, vtk\-Cell\-Data cd, vtk\-Unsigned\-Char\-Array types)} -\/ Tessellate the cell if it is not linear or if at least one attribute of `attributes' is not linear. The output are linear cells of the same dimension than the cell. If the cell is linear and all attributes are linear, the output is just a copy of the current cell. `points', `cell\-Array', `pd' and `cd' are cumulative output data arrays over cell iterations\-: they store the result of each call to Tessellate(). `internal\-Pd' is initialized by the calling filter and stores the result of the tessellation. If it is not null, `types' is filled with the types of the linear cells. `types' is null when it is called from vtk\-Generic\-Geometry\-Filter and not null when it is called from vtk\-Generic\-Dataset\-Tessellator. \begin{DoxyPrecond}{Precondition}
attributes\-\_\-exist\-: attributes!=0 

tessellator\-\_\-exists\-: tess!=0 

points\-\_\-exist\-: points!=0 

cell\-Array\-\_\-exists\-: cell\-Array!=0 

internal\-Pd\-\_\-exists\-: internal\-Pd!=0 

pd\-\_\-exist\-: pd!=0 

cd\-\_\-exists\-: cd!=0  
\end{DoxyPrecond}

\item {\ttfamily int = obj.\-Is\-Face\-On\-Boundary (vtk\-Id\-Type face\-Id)} -\/ Is the face `face\-Id' of the current cell on the exterior boundary of the dataset? \begin{DoxyPrecond}{Precondition}
3d\-: Get\-Dimension()==3  
\end{DoxyPrecond}

\item {\ttfamily int = obj.\-Is\-On\-Boundary ()} -\/ Is the cell on the exterior boundary of the dataset? \begin{DoxyPrecond}{Precondition}
2d\-: Get\-Dimension()==2  
\end{DoxyPrecond}

\item {\ttfamily obj.\-Triangulate\-Face (vtk\-Generic\-Attribute\-Collection attributes, vtk\-Generic\-Cell\-Tessellator tess, int index, vtk\-Points points, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array cell\-Array, vtk\-Point\-Data internal\-Pd, vtk\-Point\-Data pd, vtk\-Cell\-Data cd)} -\/ Tessellate face `index' of the cell. See Tessellate() for further explanations. \begin{DoxyPrecond}{Precondition}
cell\-\_\-is\-\_\-3d\-: Get\-Dimension()==3 

attributes\-\_\-exist\-: attributes!=0 

tessellator\-\_\-exists\-: tess!=0 

valid\-\_\-face\-: index$>$=0 

points\-\_\-exist\-: points!=0 

cell\-Array\-\_\-exists\-: cell\-Array!=0 

internal\-Pd\-\_\-exists\-: internal\-Pd!=0 

pd\-\_\-exist\-: pd!=0 

cd\-\_\-exists\-: cd!=0  
\end{DoxyPrecond}

\item {\ttfamily int = obj.\-Get\-Number\-Of\-Vertices\-On\-Face (int face\-Id)} -\/ Return the number of vertices defining face `face\-Id'. \begin{DoxyPrecond}{Precondition}
is\-\_\-3d\-: this-\/$>$Get\-Dimension()==3 

valid\-\_\-face\-Id\-\_\-range\-: face\-Id$>$=0 \&\& face\-Id$<$this-\/$>$Get\-Number\-Of\-Boundaries(2) 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: \&\& result$>$0  
\end{DoxyPostcond}

\end{DoxyItemize}\hypertarget{vtkfiltering_vtkgenericattribute}{}\section{vtk\-Generic\-Attribute}\label{vtkfiltering_vtkgenericattribute}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Generic\-Attribute is an abstract class that defines an A\-P\-I for attribute data. Attribute data is data associated with the topology or geometry of a dataset (i.\-e., points, cells, etc.). vtk\-Generic\-Attribute is part of the adaptor framework (see Generic\-Filtering/\-R\-E\-A\-D\-M\-E.\-html).

vtk\-Generic\-Attribute provides a more general interface to attribute data than its counterpart vtk\-Data\-Array (which assumes a linear, contiguous array). It adopts an iterator interface, and allows attributes to be associated with points, edges, faces, or edges.

To create an instance of class vtk\-Generic\-Attribute, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkGenericAttribute
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Generic\-Attribute has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Generic\-Attribute class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Generic\-Attribute = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Generic\-Attribute = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily string = obj.\-Get\-Name ()} -\/ Name of the attribute. (e.\-g. \char`\"{}velocity\char`\"{}) \begin{DoxyPostcond}{Postcondition}
result\-\_\-may\-\_\-not\-\_\-exist\-: result!=0 $|$$|$ result==0  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Get\-Number\-Of\-Components ()} -\/ Dimension of the attribute. (1 for scalar, 3 for velocity) \begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$=0 

Get\-Type()==V\-T\-K\-\_\-\-S\-C\-A\-L\-A\-R\-S implies result==1 

(Get\-Type()==V\-T\-K\-\_\-\-V\-E\-C\-T\-O\-R\-S$|$$|$(Get\-Type()==V\-T\-K\-\_\-\-N\-O\-R\-M\-A\-L\-S)$|$$|$(Get\-Type()==V\-T\-K\-\_\-\-T\-C\-O\-O\-R\-D\-S) implies result==3 

Get\-Type()==V\-T\-K\-\_\-\-T\-E\-N\-S\-O\-R\-S implies result==6  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Get\-Centering ()} -\/ Is the attribute centered either on points, cells or boundaries? \begin{DoxyPostcond}{Postcondition}
valid\-\_\-result\-: (result==vtk\-Point\-Centered)$|$$|$(result==vtk\-Cell\-Centered)  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Get\-Type ()} -\/ Type of the attribute\-: scalar, vector, normal, texture coordinate, tensor \begin{DoxyPostcond}{Postcondition}
valid\-\_\-result\-: (result==vtk\-Data\-Set\-Attributes\-::\-S\-C\-A\-L\-A\-R\-S) $|$$|$(result==vtk\-Data\-Set\-Attributes\-::\-V\-E\-C\-T\-O\-R\-S) $|$$|$(result==vtk\-Data\-Set\-Attributes\-::\-N\-O\-R\-M\-A\-L\-S) $|$$|$(result==vtk\-Data\-Set\-Attributes\-::\-T\-C\-O\-O\-R\-D\-S) $|$$|$(result==vtk\-Data\-Set\-Attributes\-::\-T\-E\-N\-S\-O\-R\-S)  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Get\-Component\-Type ()} -\/ Type of the components of the attribute\-: int, float, double \begin{DoxyPostcond}{Postcondition}
valid\-\_\-result\-: (result==V\-T\-K\-\_\-\-B\-I\-T) $|$$|$(result==V\-T\-K\-\_\-\-C\-H\-A\-R) $|$$|$(result==V\-T\-K\-\_\-\-U\-N\-S\-I\-G\-N\-E\-D\-\_\-\-C\-H\-A\-R) $|$$|$(result==V\-T\-K\-\_\-\-S\-H\-O\-R\-T) $|$$|$(result==V\-T\-K\-\_\-\-U\-N\-S\-I\-G\-N\-E\-D\-\_\-\-S\-H\-O\-R\-T)$|$$|$(result==V\-T\-K\-\_\-\-I\-N\-T) $|$$|$(result==V\-T\-K\-\_\-\-U\-N\-S\-I\-G\-N\-E\-D\-\_\-\-I\-N\-T) $|$$|$(result==V\-T\-K\-\_\-\-L\-O\-N\-G) $|$$|$(result==V\-T\-K\-\_\-\-U\-N\-S\-I\-G\-N\-E\-D\-\_\-\-L\-O\-N\-G) $|$$|$(result==V\-T\-K\-\_\-\-F\-L\-O\-A\-T) $|$$|$(result==V\-T\-K\-\_\-\-D\-O\-U\-B\-L\-E) $|$$|$(result==V\-T\-K\-\_\-\-I\-D\-\_\-\-T\-Y\-P\-E)  
\end{DoxyPostcond}

\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Size ()} -\/ Number of tuples. \begin{DoxyPostcond}{Postcondition}
valid\-\_\-result\-: result$>$=0  
\end{DoxyPostcond}

\item {\ttfamily long = obj.\-Get\-Actual\-Memory\-Size ()} -\/ Size in kilobytes taken by the attribute.  
\item {\ttfamily obj.\-Get\-Range (int component, double range\mbox{[}2\mbox{]})} -\/ Range of the attribute component `component'. If `component'==-\/1, it returns the range of the magnitude (euclidean norm). T\-H\-R\-E\-A\-D S\-A\-F\-E \begin{DoxyPrecond}{Precondition}
valid\-\_\-component\-: (component$>$=-\/1)\&\&(component$<$Get\-Number\-Of\-Components())  
\end{DoxyPrecond}

\item {\ttfamily double = obj.\-Get\-Max\-Norm ()} -\/ Return the maximum euclidean norm for the tuples. \begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$=0  
\end{DoxyPostcond}

\item {\ttfamily obj.\-Get\-Tuple (vtk\-Generic\-Adaptor\-Cell c, double tuple)} -\/ Put attribute at all points of cell `c' in `tuple'. \begin{DoxyPrecond}{Precondition}
c\-\_\-exists\-: c!=0 

c\-\_\-valid\-: !c-\/$>$Is\-At\-End() 

tuple\-\_\-exists\-: tuple!=0 

valid\-\_\-tuple\-: sizeof(tuple)$>$=Get\-Number\-Of\-Components()$\ast$c-\/$>$Get\-Cell()-\/$>$Get\-Number\-Of\-Points()  
\end{DoxyPrecond}

\item {\ttfamily obj.\-Get\-Tuple (vtk\-Generic\-Cell\-Iterator c, double tuple)} -\/ Put attribute at all points of cell `c' in `tuple'. \begin{DoxyPrecond}{Precondition}
c\-\_\-exists\-: c!=0 

c\-\_\-valid\-: !c-\/$>$Is\-At\-End() 

tuple\-\_\-exists\-: tuple!=0 

valid\-\_\-tuple\-: sizeof(tuple)$>$=Get\-Number\-Of\-Components()$\ast$c-\/$>$Get\-Cell()-\/$>$Get\-Number\-Of\-Points()  
\end{DoxyPrecond}

\item {\ttfamily obj.\-Get\-Tuple (vtk\-Generic\-Point\-Iterator p, double tuple)} -\/ Put the value of the attribute at position `p' into `tuple'. \begin{DoxyPrecond}{Precondition}
p\-\_\-exists\-: p!=0 

p\-\_\-valid\-: !p-\/$>$Is\-At\-End() 

tuple\-\_\-exists\-: tuple!=0 

valid\-\_\-tuple\-\_\-size\-: sizeof(tuple)$>$=Get\-Number\-Of\-Components()  
\end{DoxyPrecond}

\item {\ttfamily obj.\-Get\-Component (int i, vtk\-Generic\-Cell\-Iterator c, double values)} -\/ Put component `i' of the attribute at all points of cell `c' in `values'. \begin{DoxyPrecond}{Precondition}
valid\-\_\-component\-: (i$>$=0) \&\& (i$<$Get\-Number\-Of\-Components()) 

c\-\_\-exists\-: c!=0 

c\-\_\-valid\-: !c-\/$>$Is\-At\-End() 

values\-\_\-exist\-: values!=0 

valid\-\_\-values\-: sizeof(values)$>$=c-\/$>$Get\-Cell()-\/$>$Get\-Number\-Of\-Points()  
\end{DoxyPrecond}

\item {\ttfamily double = obj.\-Get\-Component (int i, vtk\-Generic\-Point\-Iterator p)} -\/ Value of the component `i' of the attribute at position `p'. \begin{DoxyPrecond}{Precondition}
valid\-\_\-component\-: (i$>$=0) \&\& (i$<$Get\-Number\-Of\-Components()) 

p\-\_\-exists\-: p!=0 

p\-\_\-valid\-: !p-\/$>$Is\-At\-End()  
\end{DoxyPrecond}

\item {\ttfamily obj.\-Deep\-Copy (vtk\-Generic\-Attribute other)} -\/ Recursive duplication of `other' in `this'. \begin{DoxyPrecond}{Precondition}
other\-\_\-exists\-: other!=0 

not\-\_\-self\-: other!=this  
\end{DoxyPrecond}

\item {\ttfamily obj.\-Shallow\-Copy (vtk\-Generic\-Attribute other)} -\/ Update `this' using fields of `other'. \begin{DoxyPrecond}{Precondition}
other\-\_\-exists\-: other!=0 

not\-\_\-self\-: other!=this  
\end{DoxyPrecond}

\end{DoxyItemize}\hypertarget{vtkfiltering_vtkgenericattributecollection}{}\section{vtk\-Generic\-Attribute\-Collection}\label{vtkfiltering_vtkgenericattributecollection}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Generic\-Attribute\-Collection is a class that collects attributes (represented by vtk\-Generic\-Attribute).

To create an instance of class vtk\-Generic\-Attribute\-Collection, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkGenericAttributeCollection
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Generic\-Attribute\-Collection has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Generic\-Attribute\-Collection class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()} -\/ Standard type definition and print methods for a V\-T\-K class.  
\item {\ttfamily int = obj.\-Is\-A (string name)} -\/ Standard type definition and print methods for a V\-T\-K class.  
\item {\ttfamily vtk\-Generic\-Attribute\-Collection = obj.\-New\-Instance ()} -\/ Standard type definition and print methods for a V\-T\-K class.  
\item {\ttfamily vtk\-Generic\-Attribute\-Collection = obj.\-Safe\-Down\-Cast (vtk\-Object o)} -\/ Standard type definition and print methods for a V\-T\-K class.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Attributes ()} -\/ Return the number of attributes (e.\-g., instances of vtk\-Generic\-Attribute) in the collection. \begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$=0  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Get\-Number\-Of\-Components ()} -\/ Return the number of components. This is the sum of all components found in all attributes. \begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$=0  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Get\-Number\-Of\-Point\-Centered\-Components ()} -\/ Return the number of components. This is the sum of all components found in all point centered attributes. \begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$=0  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Get\-Max\-Number\-Of\-Components ()} -\/ Maximum number of components encountered among all attributes. \begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$=0 

valid\-\_\-result\-: result$<$=Get\-Number\-Of\-Components()  
\end{DoxyPostcond}

\item {\ttfamily long = obj.\-Get\-Actual\-Memory\-Size ()} -\/ Actual size of the data in kilobytes; only valid after the pipeline has updated. It is guaranteed to be greater than or equal to the memory required to represent the data.  
\item {\ttfamily int = obj.\-Is\-Empty ()} -\/ Indicate whether the collection contains any attributes. \begin{DoxyPostcond}{Postcondition}
definition\-: result==(Get\-Number\-Of\-Attributes()==0)  
\end{DoxyPostcond}

\item {\ttfamily vtk\-Generic\-Attribute = obj.\-Get\-Attribute (int i)} -\/ Return a pointer to the ith instance of vtk\-Generic\-Attribute. \begin{DoxyPrecond}{Precondition}
not\-\_\-empty\-: !\-Is\-Empty() 

valid\-\_\-i\-: i$>$=0 \&\& i$<$Get\-Number\-Of\-Attributes() 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
result\-\_\-exists\-: result!=0  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Find\-Attribute (string name)} -\/ Return the index of the attribute named `name'. Return the non-\/negative index if found. Return -\/1 otherwise. \begin{DoxyPrecond}{Precondition}
name\-\_\-exists\-: name!=0 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
valid\-\_\-result\-: (result==-\/1) $|$$|$ (result$>$=0) \&\& (result$<$=Get\-Number\-Of\-Attributes())  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Get\-Attribute\-Index (int i)} -\/ Return the index of the first component of attribute `i' in an array of format attrib0comp0 attrib0comp1 ... attrib4comp0 ... \begin{DoxyPrecond}{Precondition}
valid\-\_\-i\-: i$>$=0 \&\& i$<$Get\-Number\-Of\-Attributes() 

is\-\_\-point\-\_\-centered\-: Get\-Attribute(i)-\/$>$Get\-Centering()==vtk\-Point\-Centered  
\end{DoxyPrecond}

\item {\ttfamily obj.\-Insert\-Next\-Attribute (vtk\-Generic\-Attribute a)} -\/ Add the attribute `a' to the end of the collection. \begin{DoxyPrecond}{Precondition}
a\-\_\-exists\-: a!=0 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
more\-\_\-items\-: Get\-Number\-Of\-Attributes()==old Get\-Number\-Of\-Attributes()+1 

a\-\_\-is\-\_\-set\-: Get\-Attribute(Get\-Number\-Of\-Attributes()-\/1)==a  
\end{DoxyPostcond}

\item {\ttfamily obj.\-Insert\-Attribute (int i, vtk\-Generic\-Attribute a)} -\/ Replace the attribute at index `i' by `a'. \begin{DoxyPrecond}{Precondition}
not\-\_\-empty\-: !\-Is\-Empty() 

a\-\_\-exists\-: a!=0 

valid\-\_\-i\-: i$>$=0 \&\& i$<$Get\-Number\-Of\-Attributes() 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
same\-\_\-size\-: Get\-Number\-Of\-Attributes()==old Get\-Number\-Of\-Attributes() 

item\-\_\-is\-\_\-set\-: Get\-Attribute(i)==a  
\end{DoxyPostcond}

\item {\ttfamily obj.\-Remove\-Attribute (int i)} -\/ Remove the attribute at `i'. \begin{DoxyPrecond}{Precondition}
not\-\_\-empty\-: !\-Is\-Empty() 

valid\-\_\-i\-: i$>$=0 \&\& i$<$Get\-Number\-Of\-Attributes() 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
fewer\-\_\-items\-: Get\-Number\-Of\-Attributes()==old Get\-Number\-Of\-Attributes()-\/1  
\end{DoxyPostcond}

\item {\ttfamily obj.\-Reset ()} -\/ Remove all attributes. \begin{DoxyPostcond}{Postcondition}
is\-\_\-empty\-: Get\-Number\-Of\-Attributes()==0  
\end{DoxyPostcond}

\item {\ttfamily obj.\-Deep\-Copy (vtk\-Generic\-Attribute\-Collection other)} -\/ Copy, without reference counting, the other attribute array. \begin{DoxyPrecond}{Precondition}
other\-\_\-exists\-: other!=0 

not\-\_\-self\-: other!=this 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
same\-\_\-size\-: Get\-Number\-Of\-Attributes()==other-\/$>$Get\-Number\-Of\-Attributes()  
\end{DoxyPostcond}

\item {\ttfamily obj.\-Shallow\-Copy (vtk\-Generic\-Attribute\-Collection other)} -\/ Copy, via reference counting, the other attribute array. \begin{DoxyPrecond}{Precondition}
other\-\_\-exists\-: other!=0 

not\-\_\-self\-: other!=this 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
same\-\_\-size\-: Get\-Number\-Of\-Attributes()==other-\/$>$Get\-Number\-Of\-Attributes()  
\end{DoxyPostcond}

\item {\ttfamily long = obj.\-Get\-M\-Time ()} -\/ vtk\-Attribute\-Collection is a composite object and needs to check each member of its collection for modified time.  
\item {\ttfamily int = obj.\-Get\-Active\-Attribute ()} -\/ Index of the attribute to be processed (not necessarily scalar). \begin{DoxyPrecond}{Precondition}
not\-\_\-empty\-: !\-Is\-Empty() 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
valid\-\_\-result\-: result$>$=0 \&\& result$<$Get\-Number\-Of\-Attributes()  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Get\-Active\-Component ()} -\/ Component of the active attribute to be processed. -\/1 means module. \begin{DoxyPrecond}{Precondition}
not\-\_\-empty\-: Get\-Number\-Of\-Attributes()$>$0 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
valid\-\_\-result\-: result$>$=-\/1 \&\& result$<$Get\-Attribute(Get\-Active\-Attribute())-\/$>$Get\-Number\-Of\-Components()  
\end{DoxyPostcond}

\item {\ttfamily obj.\-Set\-Active\-Attribute (int attribute, int component)} -\/ Set the scalar attribute to be processed. -\/1 means module. \begin{DoxyPrecond}{Precondition}
not\-\_\-empty\-: !\-Is\-Empty() 

valid\-\_\-attribute\-: attribute$>$=0 \&\& attribute$<$Get\-Number\-Of\-Attributes() 

valid\-\_\-component\-: component$>$=-\/1 \&\& component$<$Get\-Attribute(attribute)-\/$>$Get\-Number\-Of\-Components() 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
is\-\_\-set\-: Get\-Active\-Attribute()==attribute \&\& Get\-Active\-Component()==component  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Get\-Number\-Of\-Attributes\-To\-Interpolate ()} -\/ Number of attributes to interpolate. \begin{DoxyPrecond}{Precondition}
not\-\_\-empty\-: !\-Is\-Empty() 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$=0  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Has\-Attribute (int size, int attributes, int attribute)}  
\item {\ttfamily obj.\-Set\-Attributes\-To\-Interpolate (int size, int attributes)} -\/ Set the attributes to interpolate. \begin{DoxyPrecond}{Precondition}
not\-\_\-empty\-: !\-Is\-Empty() 

positive\-\_\-size\-: size$>$=0 

valid\-\_\-attributes\-: size$>$0 implies attributes!=0 

valid\-\_\-attributes\-\_\-contents\-: attributes!=0 implies !\-Has\-Attributes(size,attributes,Get\-Active\-Attribute()) 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
is\-\_\-set\-: (Get\-Number\-Of\-Attributes\-To\-Interpolate()==size)\&\& (Get\-Attributes\-To\-Interpolate()==attributes)  
\end{DoxyPostcond}

\item {\ttfamily obj.\-Set\-Attributes\-To\-Interpolate\-To\-All ()} -\/ Set the attributes to interpolate. \begin{DoxyPrecond}{Precondition}
not\-\_\-empty\-: !\-Is\-Empty() 

positive\-\_\-size\-: size$>$=0 

valid\-\_\-attributes\-: size$>$0 implies attributes!=0 

valid\-\_\-attributes\-\_\-contents\-: attributes!=0 implies !\-Has\-Attributes(size,attributes,Get\-Active\-Attribute()) 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
is\-\_\-set\-: (Get\-Number\-Of\-Attributes\-To\-Interpolate()==size)\&\& (Get\-Attributes\-To\-Interpolate()==attributes)  
\end{DoxyPostcond}

\end{DoxyItemize}\hypertarget{vtkfiltering_vtkgenericcell}{}\section{vtk\-Generic\-Cell}\label{vtkfiltering_vtkgenericcell}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Generic\-Cell is a class that provides access to concrete types of cells. It's main purpose is to allow thread-\/safe access to cells, supporting the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. vtk\-Generic\-Cell acts like any type of cell, it just dereferences an internal representation. The Set\-Cell\-Type() methods use \#define constants; these are defined in the file vtk\-Cell\-Type.\-h.

To create an instance of class vtk\-Generic\-Cell, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkGenericCell
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Generic\-Cell has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Generic\-Cell class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Generic\-Cell = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Generic\-Cell = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Shallow\-Copy (vtk\-Cell c)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Deep\-Copy (vtk\-Cell c)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Is\-Linear ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Requires\-Initialization ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Initialize ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int edge\-Id)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int face\-Id)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Clip (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array connectivity, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd, int inside\-Out)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Parametric\-Center (double pcoords\mbox{[}3\mbox{]})} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Is\-Primary\-Cell ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double weights)} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs)} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Set\-Cell\-Type (int cell\-Type)} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Empty\-Cell ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Vertex ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Poly\-Vertex ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Line ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Poly\-Line ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Triangle ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Triangle\-Strip ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Polygon ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Pixel ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Quad ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Tetra ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Voxel ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Hexahedron ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Wedge ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Pyramid ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Pentagonal\-Prism ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Hexagonal\-Prism ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Convex\-Point\-Set ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Quadratic\-Edge ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Cubic\-Line ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Quadratic\-Triangle ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Bi\-Quadratic\-Triangle ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Quadratic\-Quad ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Quadratic\-Tetra ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Quadratic\-Hexahedron ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Quadratic\-Wedge ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Quadratic\-Pyramid ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Quadratic\-Linear\-Quad ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Bi\-Quadratic\-Quad ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Quadratic\-Linear\-Wedge ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Bi\-Quadratic\-Quadratic\-Wedge ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Tri\-Quadratic\-Hexahedron ()} -\/ This method is used to support the vtk\-Data\-Set\-::\-Get\-Cell(vtk\-Generic\-Cell $\ast$) method. It allows vtk\-Generic\-Cell to act like any cell type by dereferencing an internal instance of a concrete cell type. When you set the cell type, you are resetting a pointer to an internal cell which is then used for computation.  
\item {\ttfamily obj.\-Set\-Cell\-Type\-To\-Bi\-Quadratic\-Quadratic\-Hexahedron ()} -\/ Instantiate a new vtk\-Cell based on it's cell type value  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkgenericcelliterator}{}\section{vtk\-Generic\-Cell\-Iterator}\label{vtkfiltering_vtkgenericcelliterator}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This class (and subclasses) are used to iterate over cells. Use it only in conjunction with vtk\-Generic\-Data\-Set (i.\-e., the adaptor framework).

Typical use is\-: 
\begin{DoxyPre}
 vtkGenericDataSet *dataset;
 vtkGenericCellIterator *it = dataset->NewCellIterator(2);
 for (it->Begin(); !it->IsAtEnd(); it->Next());
   \{
   spec=it->GetCell();
   \}
 \end{DoxyPre}


To create an instance of class vtk\-Generic\-Cell\-Iterator, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkGenericCellIterator
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Generic\-Cell\-Iterator has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Generic\-Cell\-Iterator class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()} -\/ Standard V\-T\-K construction and type macros.  
\item {\ttfamily int = obj.\-Is\-A (string name)} -\/ Standard V\-T\-K construction and type macros.  
\item {\ttfamily vtk\-Generic\-Cell\-Iterator = obj.\-New\-Instance ()} -\/ Standard V\-T\-K construction and type macros.  
\item {\ttfamily vtk\-Generic\-Cell\-Iterator = obj.\-Safe\-Down\-Cast (vtk\-Object o)} -\/ Standard V\-T\-K construction and type macros.  
\item {\ttfamily obj.\-Begin ()} -\/ Move iterator to first position if any (loop initialization).  
\item {\ttfamily int = obj.\-Is\-At\-End ()} -\/ Is the iterator at the end of traversal?  
\item {\ttfamily vtk\-Generic\-Adaptor\-Cell = obj.\-New\-Cell ()} -\/ Create an empty cell. The user is responsible for deleting it. \begin{DoxyPostcond}{Postcondition}
result\-\_\-exists\-: result!=0  
\end{DoxyPostcond}

\item {\ttfamily obj.\-Get\-Cell (vtk\-Generic\-Adaptor\-Cell c)} -\/ Get the cell at current position. The cell should be instantiated with the New\-Cell() method. \begin{DoxyPrecond}{Precondition}
not\-\_\-at\-\_\-end\-: !\-Is\-At\-End() 

c\-\_\-exists\-: c!=0 T\-H\-R\-E\-A\-D S\-A\-F\-E  
\end{DoxyPrecond}

\item {\ttfamily vtk\-Generic\-Adaptor\-Cell = obj.\-Get\-Cell ()} -\/ Get the cell at the current traversal position. N\-O\-T T\-H\-R\-E\-A\-D S\-A\-F\-E \begin{DoxyPrecond}{Precondition}
not\-\_\-at\-\_\-end\-: !\-Is\-At\-End() 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
result\-\_\-exits\-: result!=0  
\end{DoxyPostcond}

\item {\ttfamily obj.\-Next ()} -\/ Move the iterator to the next position in the list. \begin{DoxyPrecond}{Precondition}
not\-\_\-at\-\_\-end\-: !\-Is\-At\-End()  
\end{DoxyPrecond}

\end{DoxyItemize}\hypertarget{vtkfiltering_vtkgenericcelltessellator}{}\section{vtk\-Generic\-Cell\-Tessellator}\label{vtkfiltering_vtkgenericcelltessellator}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Generic\-Cell\-Tessellator is a helper class to perform adaptive tessellation of particular cell topologies. The major purpose for this class is to transform higher-\/order cell types (e.\-g., higher-\/order finite elements) into linear cells that can then be easily visualized by V\-T\-K. This class works in conjunction with the vtk\-Generic\-Data\-Set and vtk\-Generic\-Adaptor\-Cell classes.

This algorithm is based on edge subdivision. An error metric along each edge is evaluated, and if the error is greater than some tolerance, the edge is subdivided (as well as all connected 2\-D and 3\-D cells). The process repeats until the error metric is satisfied.

A significant issue addressed by this algorithm is to insure face compatibility across neigboring cells. That is, diagonals due to face triangulation must match to insure that the mesh is compatible. The algorithm employs a precomputed table to accelerate the tessellation process. The table was generated with the help of vtk\-Ordered\-Triangulator; the basic idea is that the choice of diagonal is made by considering the relative value of the point ids.

To create an instance of class vtk\-Generic\-Cell\-Tessellator, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkGenericCellTessellator
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Generic\-Cell\-Tessellator has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Generic\-Cell\-Tessellator class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Generic\-Cell\-Tessellator = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Generic\-Cell\-Tessellator = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Tessellate\-Face (vtk\-Generic\-Adaptor\-Cell cell, vtk\-Generic\-Attribute\-Collection att, vtk\-Id\-Type index, vtk\-Double\-Array points, vtk\-Cell\-Array cell\-Array, vtk\-Point\-Data internal\-Pd)} -\/ Tessellate a face of a 3\-D `cell'. The face is specified by the index value. The result is a set of smaller linear triangles in `cell\-Array' with `points' and point data `internal\-Pd'. \begin{DoxyPrecond}{Precondition}
cell\-\_\-exists\-: cell!=0 

valid\-\_\-dimension\-: cell-\/$>$Get\-Dimension()==3 

valid\-\_\-index\-\_\-range\-: (index$>$=0) \&\& (index$<$cell-\/$>$Get\-Number\-Of\-Boundaries(2)) 

att\-\_\-exists\-: att!=0 

points\-\_\-exists\-: points!=0 

cell\-Array\-\_\-exists\-: cell\-Array!=0 

internal\-Pd\-\_\-exists\-: internal\-Pd!=0  
\end{DoxyPrecond}

\item {\ttfamily obj.\-Tessellate (vtk\-Generic\-Adaptor\-Cell cell, vtk\-Generic\-Attribute\-Collection att, vtk\-Double\-Array points, vtk\-Cell\-Array cell\-Array, vtk\-Point\-Data internal\-Pd)} -\/ Tessellate a 3\-D `cell'. The result is a set of smaller linear tetrahedra in `cell\-Array' with `points' and point data `internal\-Pd'. \begin{DoxyPrecond}{Precondition}
cell\-\_\-exists\-: cell!=0 

valid\-\_\-dimension\-: cell-\/$>$Get\-Dimension()==3 

att\-\_\-exists\-: att!=0 

points\-\_\-exists\-: points!=0 

cell\-Array\-\_\-exists\-: cell\-Array!=0 

internal\-Pd\-\_\-exists\-: internal\-Pd!=0  
\end{DoxyPrecond}

\item {\ttfamily obj.\-Triangulate (vtk\-Generic\-Adaptor\-Cell cell, vtk\-Generic\-Attribute\-Collection att, vtk\-Double\-Array points, vtk\-Cell\-Array cell\-Array, vtk\-Point\-Data internal\-Pd)} -\/ Triangulate a 2\-D `cell'. The result is a set of smaller linear triangles in `cell\-Array' with `points' and point data `internal\-Pd'. \begin{DoxyPrecond}{Precondition}
cell\-\_\-exists\-: cell!=0 

valid\-\_\-dimension\-: cell-\/$>$Get\-Dimension()==2 

att\-\_\-exists\-: att!=0 

points\-\_\-exists\-: points!=0 

cell\-Array\-\_\-exists\-: cell\-Array!=0 

internal\-Pd\-\_\-exists\-: internal\-Pd!=0  
\end{DoxyPrecond}

\item {\ttfamily obj.\-Set\-Error\-Metrics (vtk\-Collection some\-Error\-Metrics)} -\/ Specify the list of error metrics used to decide if an edge has to be splitted or not. It is a collection of vtk\-Generic\-Subdivision\-Error\-Metric-\/s.  
\item {\ttfamily vtk\-Collection = obj.\-Get\-Error\-Metrics ()} -\/ Specify the list of error metrics used to decide if an edge has to be splitted or not. It is a collection of vtk\-Generic\-Subdivision\-Error\-Metric-\/s.  
\item {\ttfamily obj.\-Initialize (vtk\-Generic\-Data\-Set ds)} -\/ Initialize the tessellator with a data set `ds'.  
\item {\ttfamily obj.\-Init\-Error\-Metrics (vtk\-Generic\-Data\-Set ds)} -\/ Init the error metric with the dataset. Should be called in each filter before any tessellation of any cell.  
\item {\ttfamily int = obj.\-Get\-Measurement ()} -\/ If true, measure the quality of the fixed subdivision.  
\item {\ttfamily obj.\-Set\-Measurement (int )} -\/ If true, measure the quality of the fixed subdivision.  
\item {\ttfamily obj.\-Get\-Max\-Errors (double errors)} -\/ Get the maximum error measured after the fixed subdivision. \begin{DoxyPrecond}{Precondition}
errors\-\_\-exists\-: errors!=0 

valid\-\_\-size\-: sizeof(errors)==Get\-Error\-Metrics()-\/$>$Get\-Number\-Of\-Items()  
\end{DoxyPrecond}

\end{DoxyItemize}\hypertarget{vtkfiltering_vtkgenericdataset}{}\section{vtk\-Generic\-Data\-Set}\label{vtkfiltering_vtkgenericdataset}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
In V\-T\-K, spatial-\/temporal data is defined in terms of a dataset. The dataset consists of geometry (e.\-g., points), topology (e.\-g., cells), and attributes (e.\-g., scalars, vectors, etc.) vtk\-Generic\-Data\-Set is an abstract class defining this abstraction.

Since vtk\-Generic\-Data\-Set provides a general interface to manipulate data, algorithms that process it tend to be slower than those specialized for a particular data type. For this reason, there are concrete, non-\/abstract subclasses that represent and provide access to data more efficiently. Note that filters to process this dataset type are currently found in the V\-T\-K/\-Generic\-Filtering/ subdirectory.

Unlike the vtk\-Data\-Set class, vtk\-Generic\-Data\-Set provides a more flexible interface including support for iterators. vtk\-Generic\-Data\-Set is also designed to interface V\-T\-K to external simulation packages without the penalty of copying memory (see V\-T\-K/\-Generic\-Filtering/\-R\-E\-A\-D\-M\-E.\-html) for more information. Thus vtk\-Generic\-Data\-Set plays a central role in the adaptor framework.

Please note that this class introduces the concepts of \char`\"{}boundary cells\char`\"{}. This refers to the boundaries of a cell (e.\-g., face of a tetrahedron) which may in turn be represented as a cell. Boundary cells are derivative topological features of cells, and are therefore never explicitly represented in the dataset. Often in visualization algorithms, looping over boundaries (edges or faces) is employed, while the actual dataset cells may not traversed. Thus there are methods to loop over these boundary cells.

Finally, as a point of clarification, points are not the same as vertices. Vertices refer to points, and points specify a position is space. Vertices are a type of 0-\/\-D cell. Also, the concept of a D\-O\-F\-Node, which is where coefficients for higher-\/order cells are kept, is a new concept introduced by the adaptor framework (see vtk\-Generic\-Adaptor\-Cell for more information).

To create an instance of class vtk\-Generic\-Data\-Set, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkGenericDataSet
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Generic\-Data\-Set has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Generic\-Data\-Set class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()} -\/ Standard V\-T\-K type and print macros.  
\item {\ttfamily int = obj.\-Is\-A (string name)} -\/ Standard V\-T\-K type and print macros.  
\item {\ttfamily vtk\-Generic\-Data\-Set = obj.\-New\-Instance ()} -\/ Standard V\-T\-K type and print macros.  
\item {\ttfamily vtk\-Generic\-Data\-Set = obj.\-Safe\-Down\-Cast (vtk\-Object o)} -\/ Standard V\-T\-K type and print macros.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Points ()} -\/ Return the number of points composing the dataset. See New\-Point\-Iterator() for more details. \begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$=0  
\end{DoxyPostcond}

\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Cells (int dim)} -\/ Return the number of cells that explicitly define the dataset. See New\-Cell\-Iterator() for more details. \begin{DoxyPrecond}{Precondition}
valid\-\_\-dim\-\_\-range\-: (dim$>$=-\/1) \&\& (dim$<$=3) 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$=0  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ Return -\/1 if the dataset is explicitly defined by cells of varying dimensions or if there are no cells. If the dataset is explicitly defined by cells of a unique dimension, return this dimension. \begin{DoxyPostcond}{Postcondition}
valid\-\_\-range\-: (result$>$=-\/1) \&\& (result$<$=3)  
\end{DoxyPostcond}

\item {\ttfamily obj.\-Get\-Cell\-Types (vtk\-Cell\-Types types)} -\/ Get a list of types of cells in a dataset. The list consists of an array of types (not necessarily in any order), with a single entry per type. For example a dataset 5 triangles, 3 lines, and 100 hexahedra would result a list of three entries, corresponding to the types V\-T\-K\-\_\-\-T\-R\-I\-A\-N\-G\-L\-E, V\-T\-K\-\_\-\-L\-I\-N\-E, and V\-T\-K\-\_\-\-H\-E\-X\-A\-H\-E\-D\-R\-O\-N. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E I\-F F\-I\-R\-S\-T C\-A\-L\-L\-E\-D F\-R\-O\-M A S\-I\-N\-G\-L\-E T\-H\-R\-E\-A\-D A\-N\-D T\-H\-E D\-A\-T\-A\-S\-E\-T I\-S N\-O\-T M\-O\-D\-I\-F\-I\-E\-D \begin{DoxyPrecond}{Precondition}
types\-\_\-exist\-: types!=0  
\end{DoxyPrecond}

\item {\ttfamily vtk\-Generic\-Cell\-Iterator = obj.\-New\-Cell\-Iterator (int dim)} -\/ Return an iterator to traverse cells of dimension `dim' (or all dimensions if -\/1) that explicitly define the dataset. For instance, it will return only tetrahedra if the mesh is defined by tetrahedra. If the mesh is composed of two parts, one with tetrahedra and another part with triangles, it will return both, but will not return the boundary edges and vertices of these cells. The user is responsible for deleting the iterator. \begin{DoxyPrecond}{Precondition}
valid\-\_\-dim\-\_\-range\-: (dim$>$=-\/1) \&\& (dim$<$=3) 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
result\-\_\-exists\-: result!=0  
\end{DoxyPostcond}

\item {\ttfamily vtk\-Generic\-Cell\-Iterator = obj.\-New\-Boundary\-Iterator (int dim, int exterior\-Only)} -\/ Return an iterator to traverse cell boundaries of dimension `dim' (or all dimensions if -\/1) of the dataset. If `exterior\-Only' is true, only the exterior cell boundaries of the dataset will be returned, otherwise it will return exterior and interior cell boundaries. The user is responsible for deleting the iterator. \begin{DoxyPrecond}{Precondition}
valid\-\_\-dim\-\_\-range\-: (dim$>$=-\/1) \&\& (dim$<$=2) 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
result\-\_\-exists\-: result!=0  
\end{DoxyPostcond}

\item {\ttfamily vtk\-Generic\-Point\-Iterator = obj.\-New\-Point\-Iterator ()} -\/ Return an iterator to traverse the points composing the dataset; they can be points that define a cell (corner points) or isolated points. The user is responsible for deleting the iterator. \begin{DoxyPostcond}{Postcondition}
result\-\_\-exists\-: result!=0  
\end{DoxyPostcond}

\item {\ttfamily obj.\-Find\-Point (double x\mbox{[}3\mbox{]}, vtk\-Generic\-Point\-Iterator p)} -\/ Locate the closest point `p' to position `x' (global coordinates). \begin{DoxyPrecond}{Precondition}
not\-\_\-empty\-: Get\-Number\-Of\-Points()$>$0 

p\-\_\-exists\-: p!=0  
\end{DoxyPrecond}

\item {\ttfamily long = obj.\-Get\-M\-Time ()} -\/ Datasets are composite objects and need to check each part for their modified time.  
\item {\ttfamily obj.\-Compute\-Bounds ()} -\/ Compute the geometry bounding box.  
\item {\ttfamily obj.\-Get\-Bounds (double bounds\mbox{[}6\mbox{]})} -\/ Return the geometry bounding box in global coordinates in the form (xmin,xmax, ymin,ymax, zmin,zmax) in the `bounds' array.  
\item {\ttfamily obj.\-Get\-Center (double center\mbox{[}3\mbox{]})} -\/ Get the center of the bounding box in global coordinates.  
\item {\ttfamily double = obj.\-Get\-Length ()} -\/ Return the length of the diagonal of the bounding box. \begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$=0  
\end{DoxyPostcond}

\item {\ttfamily vtk\-Generic\-Attribute\-Collection = obj.\-Get\-Attributes ()} -\/ Get the collection of attributes associated with this dataset.  
\item {\ttfamily vtk\-Data\-Set\-Attributes = obj.\-Get\-Attributes (int type)} -\/ Set/\-Get a cell tessellator if cells must be tessellated during processing. \begin{DoxyPrecond}{Precondition}
tessellator\-\_\-exists\-: tessellator!=0  
\end{DoxyPrecond}

\item {\ttfamily obj.\-Set\-Tessellator (vtk\-Generic\-Cell\-Tessellator tessellator)} -\/ Set/\-Get a cell tessellator if cells must be tessellated during processing. \begin{DoxyPrecond}{Precondition}
tessellator\-\_\-exists\-: tessellator!=0  
\end{DoxyPrecond}

\item {\ttfamily vtk\-Generic\-Cell\-Tessellator = obj.\-Get\-Tessellator ()} -\/ Set/\-Get a cell tessellator if cells must be tessellated during processing. \begin{DoxyPrecond}{Precondition}
tessellator\-\_\-exists\-: tessellator!=0  
\end{DoxyPrecond}

\item {\ttfamily long = obj.\-Get\-Actual\-Memory\-Size ()} -\/ Actual size of the data in kilobytes; only valid after the pipeline has updated. It is guaranteed to be greater than or equal to the memory required to represent the data.  
\item {\ttfamily int = obj.\-Get\-Data\-Object\-Type ()} -\/ Return the type of data object.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Estimated\-Size ()} -\/ Estimated size needed after tessellation (or special operation)  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkgenericdatasetalgorithm}{}\section{vtk\-Generic\-Data\-Set\-Algorithm}\label{vtkfiltering_vtkgenericdatasetalgorithm}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
To create an instance of class vtk\-Generic\-Data\-Set\-Algorithm, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkGenericDataSetAlgorithm
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Generic\-Data\-Set\-Algorithm has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Generic\-Data\-Set\-Algorithm class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Generic\-Data\-Set\-Algorithm = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Generic\-Data\-Set\-Algorithm = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Generic\-Data\-Set = obj.\-Get\-Output ()} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Generic\-Data\-Set = obj.\-Get\-Output (int )} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily obj.\-Set\-Output (vtk\-Data\-Object d)} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Input ()}  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Input (int port)}  
\item {\ttfamily vtk\-Generic\-Data\-Set = obj.\-Get\-Generic\-Data\-Set\-Input (int port)}  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Object )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Set\-Input (int , vtk\-Data\-Object )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Add\-Input (vtk\-Data\-Object )} -\/ Add an input of this algorithm. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Add\-Input\-Connection(). See Set\-Input() for details.  
\item {\ttfamily obj.\-Add\-Input (int , vtk\-Data\-Object )} -\/ Add an input of this algorithm. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Add\-Input\-Connection(). See Set\-Input() for details.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkgenericedgetable}{}\section{vtk\-Generic\-Edge\-Table}\label{vtkfiltering_vtkgenericedgetable}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Generic\-Edge\-Table is used to indicate the existance of and hold information about edges. Similar to vtk\-Edge\-Table, this class is more sophisticated in that it uses reference counting to keep track of when information about an edge should be deleted.

vtk\-Generic\-Edge\-Table is a helper class used in the adaptor framework. It is used during the tessellation process to hold information about the error metric on each edge. This avoids recomputing the error metric each time the same edge is visited.

To create an instance of class vtk\-Generic\-Edge\-Table, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkGenericEdgeTable
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Generic\-Edge\-Table has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Generic\-Edge\-Table class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()} -\/ Standard V\-T\-K type and print macros.  
\item {\ttfamily int = obj.\-Is\-A (string name)} -\/ Standard V\-T\-K type and print macros.  
\item {\ttfamily vtk\-Generic\-Edge\-Table = obj.\-New\-Instance ()} -\/ Standard V\-T\-K type and print macros.  
\item {\ttfamily vtk\-Generic\-Edge\-Table = obj.\-Safe\-Down\-Cast (vtk\-Object o)} -\/ Standard V\-T\-K type and print macros.  
\item {\ttfamily obj.\-Insert\-Edge (vtk\-Id\-Type e1, vtk\-Id\-Type e2, vtk\-Id\-Type cell\-Id, int ref)} -\/ Insert an edge but do not split it.  
\item {\ttfamily int = obj.\-Remove\-Edge (vtk\-Id\-Type e1, vtk\-Id\-Type e2)} -\/ Method to remove an edge from the table. The method returns the current reference count.  
\item {\ttfamily int = obj.\-Increment\-Edge\-Reference\-Count (vtk\-Id\-Type e1, vtk\-Id\-Type e2, vtk\-Id\-Type cell\-Id)} -\/ Method that increments the referencecount and returns it.  
\item {\ttfamily int = obj.\-Check\-Edge\-Reference\-Count (vtk\-Id\-Type e1, vtk\-Id\-Type e2)} -\/ Return the edge reference count.  
\item {\ttfamily obj.\-Initialize (vtk\-Id\-Type start)} -\/ To specify the starting point id. It will initialize Last\-Point\-Id This is very sensitive the start point should be cautiously chosen  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Components ()} -\/ Return the total number of components for the point-\/centered attributes. \begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$0  
\end{DoxyPostcond}

\item {\ttfamily obj.\-Set\-Number\-Of\-Components (int count)} -\/ Set the total number of components for the point-\/centered attributes. \begin{DoxyPrecond}{Precondition}
positive\-\_\-count\-: count$>$0  
\end{DoxyPrecond}

\item {\ttfamily int = obj.\-Check\-Point (vtk\-Id\-Type pt\-Id)} -\/ Check if a point is already in the point table.  
\item {\ttfamily int = obj.\-Check\-Point (vtk\-Id\-Type pt\-Id, double point\mbox{[}3\mbox{]}, double scalar)} -\/ Check for the existence of a point and return its coordinate value. \begin{DoxyPrecond}{Precondition}
scalar\-\_\-size\-: sizeof(scalar)==this-\/$>$Get\-Number\-Of\-Components()  
\end{DoxyPrecond}

\item {\ttfamily obj.\-Insert\-Point (vtk\-Id\-Type pt\-Id, double point\mbox{[}3\mbox{]})} -\/ Insert point associated with an edge.  
\item {\ttfamily obj.\-Insert\-Point\-And\-Scalar (vtk\-Id\-Type pt\-Id, double pt\mbox{[}3\mbox{]}, double s)} -\/ Insert point associated with an edge. \begin{DoxyPrecond}{Precondition}
\-: sizeof(s)==Get\-Number\-Of\-Components()  
\end{DoxyPrecond}

\item {\ttfamily obj.\-Remove\-Point (vtk\-Id\-Type pt\-Id)} -\/ Remove a point from the point table.  
\item {\ttfamily obj.\-Increment\-Point\-Reference\-Count (vtk\-Id\-Type pt\-Id)} -\/ Increment the reference count for the indicated point.  
\item {\ttfamily obj.\-Dump\-Table ()} -\/ For debugging purposes. It is particularly useful to dump the table and check that nothing is left after a complete iteration. Load\-Factor should ideally be very low to be able to have a constant time access  
\item {\ttfamily obj.\-Load\-Factor ()} -\/ For debugging purposes. It is particularly useful to dump the table and check that nothing is left after a complete iteration. Load\-Factor should ideally be very low to be able to have a constant time access  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkgenericinterpolatedvelocityfield}{}\section{vtk\-Generic\-Interpolated\-Velocity\-Field}\label{vtkfiltering_vtkgenericinterpolatedvelocityfield}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Generic\-Interpolated\-Velocity\-Field acts as a continuous velocity field by performing cell interpolation on the underlying vtk\-Data\-Set. This is a concrete sub-\/class of vtk\-Function\-Set with Number\-Of\-Independent\-Variables = 4 (x,y,z,t) and Number\-Of\-Functions = 3 (u,v,w). Normally, every time an evaluation is performed, the cell which contains the point (x,y,z) has to be found by calling Find\-Cell. This is a computationally expansive operation. In certain cases, the cell search can be avoided or shortened by providing a guess for the cell iterator. For example, in streamline integration, the next evaluation is usually in the same or a neighbour cell. For this reason, vtk\-Generic\-Interpolated\-Velocity\-Field stores the last cell iterator. If caching is turned on, it uses this iterator as the starting point.

To create an instance of class vtk\-Generic\-Interpolated\-Velocity\-Field, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkGenericInterpolatedVelocityField
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Generic\-Interpolated\-Velocity\-Field has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Generic\-Interpolated\-Velocity\-Field class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Generic\-Interpolated\-Velocity\-Field = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Generic\-Interpolated\-Velocity\-Field = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Function\-Values (double x, double f)} -\/ Evaluate the velocity field, f, at (x, y, z, t). For now, t is ignored.  
\item {\ttfamily obj.\-Add\-Data\-Set (vtk\-Generic\-Data\-Set dataset)} -\/ Add a dataset used for the implicit function evaluation. If more than one dataset is added, the evaluation point is searched in all until a match is found. T\-H\-I\-S F\-U\-N\-C\-T\-I\-O\-N D\-O\-E\-S N\-O\-T C\-H\-A\-N\-G\-E T\-H\-E R\-E\-F\-E\-R\-E\-N\-C\-E C\-O\-U\-N\-T O\-F dataset F\-O\-R T\-H\-R\-E\-A\-D S\-A\-F\-E\-T\-Y R\-E\-A\-S\-O\-N\-S.  
\item {\ttfamily obj.\-Clear\-Last\-Cell ()} -\/ Set the last cell id to -\/1 so that the next search does not start from the previous cell  
\item {\ttfamily vtk\-Generic\-Adaptor\-Cell = obj.\-Get\-Last\-Cell ()} -\/ Return the cell cached from last evaluation.  
\item {\ttfamily int = obj.\-Get\-Last\-Local\-Coordinates (double pcoords\mbox{[}3\mbox{]})} -\/ Returns the interpolation weights cached from last evaluation if the cached cell is valid (returns 1). Otherwise, it does not change w and returns 0.  
\item {\ttfamily int = obj.\-Get\-Caching ()} -\/ Turn caching on/off.  
\item {\ttfamily obj.\-Set\-Caching (int )} -\/ Turn caching on/off.  
\item {\ttfamily obj.\-Caching\-On ()} -\/ Turn caching on/off.  
\item {\ttfamily obj.\-Caching\-Off ()} -\/ Turn caching on/off.  
\item {\ttfamily int = obj.\-Get\-Cache\-Hit ()} -\/ Caching statistics.  
\item {\ttfamily int = obj.\-Get\-Cache\-Miss ()} -\/ Caching statistics.  
\item {\ttfamily string = obj.\-Get\-Vectors\-Selection ()} -\/ If you want to work with an arbitrary vector array, then set its name here. By default this in N\-U\-L\-L and the filter will use the active vector array.  
\item {\ttfamily obj.\-Select\-Vectors (string field\-Name)} -\/ Returns the last dataset that was visited. Can be used as a first guess as to where the next point will be as well as to avoid searching through all datasets to get more information about the point.  
\item {\ttfamily vtk\-Generic\-Data\-Set = obj.\-Get\-Last\-Data\-Set ()} -\/ Returns the last dataset that was visited. Can be used as a first guess as to where the next point will be as well as to avoid searching through all datasets to get more information about the point.  
\item {\ttfamily obj.\-Copy\-Parameters (vtk\-Generic\-Interpolated\-Velocity\-Field from)} -\/ Copy the user set parameters from source. This copies the Caching parameters. Sub-\/classes can add more after chaining.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkgenericpointiterator}{}\section{vtk\-Generic\-Point\-Iterator}\label{vtkfiltering_vtkgenericpointiterator}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This class (and subclasses) are used to iterate over points. Use it only in conjunction with vtk\-Generic\-Data\-Set (i.\-e., the adaptor framework).

Typical use is\-: 
\begin{DoxyPre}
 vtkGenericDataSet *dataset;
 vtkGenericPointIterator *it = dataset->NewPointIterator();
 for (it->Begin(); !it->IsAtEnd(); it->Next());
   \{
   x=it->GetPosition();
   \}
 \end{DoxyPre}


To create an instance of class vtk\-Generic\-Point\-Iterator, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkGenericPointIterator
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Generic\-Point\-Iterator has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Generic\-Point\-Iterator class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()} -\/ Standard V\-T\-K construction and type macros.  
\item {\ttfamily int = obj.\-Is\-A (string name)} -\/ Standard V\-T\-K construction and type macros.  
\item {\ttfamily vtk\-Generic\-Point\-Iterator = obj.\-New\-Instance ()} -\/ Standard V\-T\-K construction and type macros.  
\item {\ttfamily vtk\-Generic\-Point\-Iterator = obj.\-Safe\-Down\-Cast (vtk\-Object o)} -\/ Standard V\-T\-K construction and type macros.  
\item {\ttfamily obj.\-Begin ()} -\/ Move iterator to first position if any (loop initialization).  
\item {\ttfamily int = obj.\-Is\-At\-End ()} -\/ Is the iterator at the end of traversal?  
\item {\ttfamily obj.\-Next ()} -\/ Move the iterator to the next position in the list. \begin{DoxyPrecond}{Precondition}
not\-\_\-off\-: !\-Is\-At\-End()  
\end{DoxyPrecond}

\item {\ttfamily obj.\-Get\-Position (double x\mbox{[}3\mbox{]})} -\/ Get the coordinates of the point at the current iterator position. \begin{DoxyPrecond}{Precondition}
not\-\_\-off\-: !\-Is\-At\-End() 

x\-\_\-exists\-: x!=0  
\end{DoxyPrecond}

\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Id ()} -\/ Return the unique identifier for the point, could be non-\/contiguous. \begin{DoxyPrecond}{Precondition}
not\-\_\-off\-: !\-Is\-At\-End()  
\end{DoxyPrecond}

\end{DoxyItemize}\hypertarget{vtkfiltering_vtkgenericsubdivisionerrormetric}{}\section{vtk\-Generic\-Subdivision\-Error\-Metric}\label{vtkfiltering_vtkgenericsubdivisionerrormetric}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Objects of that class answer the following question during the cell subdivision\-: \char`\"{}does the edge need to be subdivided?\char`\"{} through Requires\-Edge\-Subdivision(). The answer depends on the criterium actually used in the subclass of this abstract class\-: a geometric-\/based error metric (variation of edge from a straight line), an attribute-\/based error metric (variation of the active attribute/component value from a linear ramp) , a view-\/depend error metric, ... Cell subdivision is performed in the context of the adaptor framework\-: higher-\/order, or complex cells, are automatically tessellated into simplices so that they can be processed with conventional visualization algorithms.

To create an instance of class vtk\-Generic\-Subdivision\-Error\-Metric, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkGenericSubdivisionErrorMetric
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Generic\-Subdivision\-Error\-Metric has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Generic\-Subdivision\-Error\-Metric class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()} -\/ Standard V\-T\-K type and error macros.  
\item {\ttfamily int = obj.\-Is\-A (string name)} -\/ Standard V\-T\-K type and error macros.  
\item {\ttfamily vtk\-Generic\-Subdivision\-Error\-Metric = obj.\-New\-Instance ()} -\/ Standard V\-T\-K type and error macros.  
\item {\ttfamily vtk\-Generic\-Subdivision\-Error\-Metric = obj.\-Safe\-Down\-Cast (vtk\-Object o)} -\/ Standard V\-T\-K type and error macros.  
\item {\ttfamily int = obj.\-Requires\-Edge\-Subdivision (double left\-Point, double mid\-Point, double right\-Point, double alpha)} -\/ Does the edge need to be subdivided according to the implemented computation? The edge is defined by its `left\-Point' and its `right\-Point'. `left\-Point', `mid\-Point' and `right\-Point' have to be initialized before calling Requires\-Edge\-Subdivision(). Their format is global coordinates, parametric coordinates and point centered attributes\-: xyx rst abc de... `alpha' is the normalized abscissa of the midpoint along the edge. (close to 0 means close to the left point, close to 1 means close to the right point) \begin{DoxyPrecond}{Precondition}
left\-Point\-\_\-exists\-: left\-Point!=0 

mid\-Point\-\_\-exists\-: mid\-Point!=0 

right\-Point\-\_\-exists\-: right\-Point!=0 

clamped\-\_\-alpha\-: alpha$>$0 \&\& alpha$<$1 

valid\-\_\-size\-: sizeof(left\-Point)=sizeof(mid\-Point)=sizeof(right\-Point) =Get\-Attribute\-Collection()-\/$>$Get\-Number\-Of\-Point\-Centered\-Components()+6  
\end{DoxyPrecond}

\item {\ttfamily double = obj.\-Get\-Error (double left\-Point, double mid\-Point, double right\-Point, double alpha)} -\/ Return the error at the mid-\/point. The type of error depends on the state of the concrete error metric. For instance, it can return an absolute or relative error metric. See Requires\-Edge\-Subdivision() for a description of the arguments. \begin{DoxyPrecond}{Precondition}
left\-Point\-\_\-exists\-: left\-Point!=0 

mid\-Point\-\_\-exists\-: mid\-Point!=0 

right\-Point\-\_\-exists\-: right\-Point!=0 

clamped\-\_\-alpha\-: alpha$>$0 \&\& alpha$<$1 

valid\-\_\-size\-: sizeof(left\-Point)=sizeof(mid\-Point)=sizeof(right\-Point) =Get\-Attribute\-Collection()-\/$>$Get\-Number\-Of\-Point\-Centered\-Components()+6 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$=0  
\end{DoxyPostcond}

\item {\ttfamily obj.\-Set\-Generic\-Cell (vtk\-Generic\-Adaptor\-Cell cell)} -\/ The cell that the edge belongs to.  
\item {\ttfamily vtk\-Generic\-Adaptor\-Cell = obj.\-Get\-Generic\-Cell ()} -\/ The cell that the edge belongs to.  
\item {\ttfamily obj.\-Set\-Data\-Set (vtk\-Generic\-Data\-Set ds)} -\/ Set/\-Get the dataset to be tessellated.  
\item {\ttfamily vtk\-Generic\-Data\-Set = obj.\-Get\-Data\-Set ()} -\/ Set/\-Get the dataset to be tessellated.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkgeometricerrormetric}{}\section{vtk\-Geometric\-Error\-Metric}\label{vtkfiltering_vtkgeometricerrormetric}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
It is a concrete error metric, based on a geometric criterium\-: the variation of the edge from a straight line.

To create an instance of class vtk\-Geometric\-Error\-Metric, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkGeometricErrorMetric
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Geometric\-Error\-Metric has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Geometric\-Error\-Metric class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()} -\/ Standard V\-T\-K type and error macros.  
\item {\ttfamily int = obj.\-Is\-A (string name)} -\/ Standard V\-T\-K type and error macros.  
\item {\ttfamily vtk\-Geometric\-Error\-Metric = obj.\-New\-Instance ()} -\/ Standard V\-T\-K type and error macros.  
\item {\ttfamily vtk\-Geometric\-Error\-Metric = obj.\-Safe\-Down\-Cast (vtk\-Object o)} -\/ Standard V\-T\-K type and error macros.  
\item {\ttfamily double = obj.\-Get\-Absolute\-Geometric\-Tolerance ()} -\/ Return the squared absolute geometric accuracy. See Set\-Absolute\-Geometric\-Tolerance() for details. \begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$0  
\end{DoxyPostcond}

\item {\ttfamily obj.\-Set\-Absolute\-Geometric\-Tolerance (double value)} -\/ Set the geometric accuracy with a squared absolute value. This is the geometric object-\/based accuracy. Subdivision will be required if the square distance between the real point and the straight line passing through the vertices of the edge is greater than `value'. For instance 0.\-01 will give better result than 0.\-1. \begin{DoxyPrecond}{Precondition}
positive\-\_\-value\-: value$>$0  
\end{DoxyPrecond}

\item {\ttfamily obj.\-Set\-Relative\-Geometric\-Tolerance (double value, vtk\-Generic\-Data\-Set ds)} -\/ Set the geometric accuracy with a value relative to the length of the bounding box of the dataset. Internally compute the absolute tolerance. For instance 0.\-01 will give better result than 0.\-1. \begin{DoxyPrecond}{Precondition}
valid\-\_\-range\-\_\-value\-: value$>$0 \&\& value$<$1 

ds\-\_\-exists\-: ds!=0  
\end{DoxyPrecond}

\item {\ttfamily int = obj.\-Requires\-Edge\-Subdivision (double left\-Point, double mid\-Point, double right\-Point, double alpha)} -\/ Does the edge need to be subdivided according to the distance between the line passing through its endpoints and the mid point? The edge is defined by its `left\-Point' and its `right\-Point'. `left\-Point', `mid\-Point' and `right\-Point' have to be initialized before calling Requires\-Edge\-Subdivision(). Their format is global coordinates, parametric coordinates and point centered attributes\-: xyx rst abc de... `alpha' is the normalized abscissa of the midpoint along the edge. (close to 0 means close to the left point, close to 1 means close to the right point) \begin{DoxyPrecond}{Precondition}
left\-Point\-\_\-exists\-: left\-Point!=0 

mid\-Point\-\_\-exists\-: mid\-Point!=0 

right\-Point\-\_\-exists\-: right\-Point!=0 

clamped\-\_\-alpha\-: alpha$>$0 \&\& alpha$<$1 

valid\-\_\-size\-: sizeof(left\-Point)=sizeof(mid\-Point)=sizeof(right\-Point) =Get\-Attribute\-Collection()-\/$>$Get\-Number\-Of\-Point\-Centered\-Components()+6  
\end{DoxyPrecond}

\item {\ttfamily double = obj.\-Get\-Error (double left\-Point, double mid\-Point, double right\-Point, double alpha)} -\/ Return the error at the mid-\/point. It will return an error relative to the bounding box size if Get\-Relative() is true, a square absolute error otherwise. See Requires\-Edge\-Subdivision() for a description of the arguments. \begin{DoxyPrecond}{Precondition}
left\-Point\-\_\-exists\-: left\-Point!=0 

mid\-Point\-\_\-exists\-: mid\-Point!=0 

right\-Point\-\_\-exists\-: right\-Point!=0 

clamped\-\_\-alpha\-: alpha$>$0 \&\& alpha$<$1 

valid\-\_\-size\-: sizeof(left\-Point)=sizeof(mid\-Point)=sizeof(right\-Point) =Get\-Attribute\-Collection()-\/$>$Get\-Number\-Of\-Point\-Centered\-Components()+6 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$=0  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Get\-Relative ()} -\/ Return the type of output of Get\-Error()  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkgraph}{}\section{vtk\-Graph}\label{vtkfiltering_vtkgraph}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Graph is the abstract base class that provides all read-\/only A\-P\-I for graph data types. A graph consists of a collection of vertices and a collection of edges connecting pairs of vertices. The vtk\-Directed\-Graph subclass represents a graph whose edges have inherent order from source vertex to target vertex, while vtk\-Undirected\-Graph is a graph whose edges have no inherent ordering.

Graph vertices may be traversed in two ways. In the current implementation, all vertices are assigned consecutive ids starting at zero, so they may be traversed in a simple for loop from 0 to graph-\/$>$Get\-Number\-Of\-Vertices() -\/ 1. You may alternately create a vtk\-Vertex\-List\-Iterator and call graph-\/$>$Get\-Vertices(it). it-\/$>$Next() will return the id of the next vertex, while it-\/$>$Has\-Next() indicates whether there are more vertices in the graph. This is the preferred method, since in the future graphs may support filtering or subsetting where the vertex ids may not be contiguous.

Graph edges must be traversed through iterators. To traverse all edges in a graph, create an instance of vtk\-Edge\-List\-Iterator and call graph-\/$>$Get\-Edges(it). it-\/$>$Next() returns lightweight vtk\-Edge\-Type structures, which contain the public fields Id, Source and Target. Id is the identifier for the edge, which may be used to look up values in assiciated edge data arrays. Source and Target store the ids of the source and target vertices of the edge. Note that the edge list iterator D\-O\-E\-S N\-O\-T necessarily iterate over edges in order of ascending id. To traverse edges from wrapper code (Python, Tcl, Java), use it-\/$>$Next\-Graph\-Edge() instead of it-\/$>$Next(). This will return a heavyweight, wrappable vtk\-Graph\-Edge object, which has the same fields as vtk\-Edge\-Type accessible through getter methods.

To traverse all edges outgoing from a vertex, create a vtk\-Out\-Edge\-Iterator and call graph-\/$>$Get\-Out\-Edges(v, it). it-\/$>$Next() returns a lightweight vtk\-Out\-Edge\-Type containing the fields Id and Target. The source of the edge is always the vertex that was passed as an argument to Get\-Out\-Edges(). Incoming edges may be similarly traversed with vtk\-In\-Edge\-Iterator, which returns vtk\-In\-Edge\-Type structures with Id and Source fields. Both vtk\-Out\-Edge\-Iterator and vtk\-In\-Edge\-Iterator also provide the wrapper functions Next\-Graph\-Edge() which return vtk\-Graph\-Edge objects.

An additional iterator, vtk\-Adjacent\-Vertex\-Iterator can traverse outgoing vertices directly, instead needing to parse through edges. Initialize the iterator by calling graph-\/$>$Get\-Adjacent\-Vertices(v, it).

vtk\-Graph has two instances of vtk\-Data\-Set\-Attributes for associated vertex and edge data. It also has a vtk\-Points instance which may store x,y,z locations for each vertex. This is populated by filters such as vtk\-Graph\-Layout and vtk\-Assign\-Coordinates.

All graph types share the same implementation, so the structure of one may be shared among multiple graphs, even graphs of different types. Structures from vtk\-Undirected\-Graph and vtk\-Mutable\-Undirected\-Graph may be shared directly. Structures from vtk\-Directed\-Graph, vtk\-Mutable\-Directed\-Graph, and vtk\-Tree may be shared directly with the exception that setting a structure to a tree requires that a \char`\"{}is a tree\char`\"{} test passes.

For graph types that are known to be compatible, calling Shallow\-Copy() or Deep\-Copy() will work as expected. When the outcome of a conversion is unknown (i.\-e. setting a graph to a tree), Checked\-Shallow\-Copy() and Checked\-Deep\-Copy() exist which are identical to Shallow\-Copy() and Deep\-Copy(), except that instead of emitting an error for an incompatible structure, the function returns false. This allows you to programmatically check structure compatibility without causing error messages.

To construct a graph, use vtk\-Mutable\-Directed\-Graph or vtk\-Mutable\-Undirected\-Graph. You may then use Checked\-Shallow\-Copy to set the contents of a mutable graph type into one of the non-\/mutable types vtk\-Directed\-Graph, vtk\-Undirected\-Graph. To construct a tree, use vtk\-Mutable\-Directed\-Graph, with directed edges which point from the parent to the child, then use Checked\-Shallow\-Copy to set the structure to a vtk\-Tree.

To create an instance of class vtk\-Graph, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkGraph
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Graph has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Graph class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Graph = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Graph = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Data\-Set\-Attributes = obj.\-Get\-Vertex\-Data ()} -\/ Get the vertex or edge data.  
\item {\ttfamily vtk\-Data\-Set\-Attributes = obj.\-Get\-Edge\-Data ()} -\/ Get the vertex or edge data.  
\item {\ttfamily int = obj.\-Get\-Data\-Object\-Type ()} -\/ Initialize to an empty graph.  
\item {\ttfamily obj.\-Initialize ()} -\/ Initialize to an empty graph.  
\item {\ttfamily obj.\-Get\-Point (vtk\-Id\-Type pt\-Id, double x\mbox{[}3\mbox{]})} -\/ These methods return the point (0,0,0) until the points structure is created, when it returns the actual point position. In a distributed graph, only the points for local vertices can be retrieved.  
\item {\ttfamily vtk\-Points = obj.\-Get\-Points ()} -\/ Returns the points array for this graph. If points is not yet constructed, generates and returns a new points array filled with (0,0,0) coordinates. In a distributed graph, only the points for local vertices can be retrieved or modified.  
\item {\ttfamily obj.\-Set\-Points (vtk\-Points points)} -\/ Returns the points array for this graph. If points is not yet constructed, generates and returns a new points array filled with (0,0,0) coordinates. In a distributed graph, only the points for local vertices can be retrieved or modified.  
\item {\ttfamily obj.\-Compute\-Bounds ()} -\/ Compute the bounds of the graph. In a distributed graph, this computes the bounds around the local part of the graph.  
\item {\ttfamily obj.\-Get\-Bounds (double bounds\mbox{[}6\mbox{]})} -\/ Return a pointer to the geometry bounding box in the form (xmin,xmax, ymin,ymax, zmin,zmax). In a distributed graph, this computes the bounds around the local part of the graph.  
\item {\ttfamily long = obj.\-Get\-M\-Time ()} -\/ The modified time of the graph.  
\item {\ttfamily obj.\-Get\-Out\-Edges (vtk\-Id\-Type v, vtk\-Out\-Edge\-Iterator it)} -\/ Initializes the out edge iterator to iterate over all outgoing edges of vertex v. For an undirected graph, returns all incident edges. In a distributed graph, the vertex v must be local to this processor.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Degree (vtk\-Id\-Type v)} -\/ The total of all incoming and outgoing vertices for vertex v. For undirected graphs, this is simply the number of edges incident to v. In a distributed graph, the vertex v must be local to this processor.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Out\-Degree (vtk\-Id\-Type v)} -\/ The number of outgoing edges from vertex v. For undirected graphs, returns the same as Get\-Degree(). In a distributed graph, the vertex v must be local to this processor.  
\item {\ttfamily obj.\-Get\-Out\-Edge (vtk\-Id\-Type v, vtk\-Id\-Type index, vtk\-Graph\-Edge e)} -\/ Random-\/access method for retrieving outgoing edges from vertex v. The method fills the vtk\-Graph\-Edge instance with the id, source, and target of the edge. This method is provided for wrappers, Get\-Out\-Edge(vtk\-Id\-Type, vtk\-Id\-Type) is preferred.  
\item {\ttfamily obj.\-Get\-In\-Edges (vtk\-Id\-Type v, vtk\-In\-Edge\-Iterator it)} -\/ Initializes the in edge iterator to iterate over all incoming edges to vertex v. For an undirected graph, returns all incident edges. In a distributed graph, the vertex v must be local to this processor.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-In\-Degree (vtk\-Id\-Type v)} -\/ The number of incoming edges to vertex v. For undirected graphs, returns the same as Get\-Degree(). In a distributed graph, the vertex v must be local to this processor.  
\item {\ttfamily obj.\-Get\-In\-Edge (vtk\-Id\-Type v, vtk\-Id\-Type index, vtk\-Graph\-Edge e)} -\/ Random-\/access method for retrieving incoming edges to vertex v. The method fills the vtk\-Graph\-Edge instance with the id, source, and target of the edge. This method is provided for wrappers, Get\-In\-Edge(vtk\-Id\-Type, vtk\-Id\-Type) is preferred.  
\item {\ttfamily obj.\-Get\-Adjacent\-Vertices (vtk\-Id\-Type v, vtk\-Adjacent\-Vertex\-Iterator it)} -\/ Initializes the adjacent vertex iterator to iterate over all outgoing vertices from vertex v. For an undirected graph, returns all adjacent vertices. In a distributed graph, the vertex v must be local to this processor.  
\item {\ttfamily obj.\-Get\-Edges (vtk\-Edge\-List\-Iterator it)} -\/ Initializes the edge list iterator to iterate over all edges in the graph. Edges may not be traversed in order of increasing edge id. In a distributed graph, this returns edges that are stored locally.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Edges ()} -\/ The number of edges in the graph. In a distributed graph, this returns the number of edges stored locally.  
\item {\ttfamily obj.\-Get\-Vertices (vtk\-Vertex\-List\-Iterator it)} -\/ Initializes the vertex list iterator to iterate over all vertices in the graph. In a distributed graph, the iterator traverses all local vertices.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Vertices ()} -\/ The number of vertices in the graph. In a distributed graph, returns the number of local vertices in the graph.  
\item {\ttfamily obj.\-Set\-Distributed\-Graph\-Helper (vtk\-Distributed\-Graph\-Helper helper)} -\/ Sets the distributed graph helper of this graph, turning it into a distributed graph. This operation can only be executed on an empty graph.  
\item {\ttfamily vtk\-Distributed\-Graph\-Helper = obj.\-Get\-Distributed\-Graph\-Helper ()} -\/ Retrieves the distributed graph helper for this graph  
\item {\ttfamily obj.\-Shallow\-Copy (vtk\-Data\-Object obj)} -\/ Shallow copies the data object into this graph. If it is an incompatible graph, reports an error.  
\item {\ttfamily obj.\-Deep\-Copy (vtk\-Data\-Object obj)} -\/ Deep copies the data object into this graph. If it is an incompatible graph, reports an error.  
\item {\ttfamily obj.\-Copy\-Structure (vtk\-Graph g)} -\/ Does a shallow copy of the topological information, but not the associated attributes.  
\item {\ttfamily bool = obj.\-Checked\-Shallow\-Copy (vtk\-Graph g)} -\/ Performs the same operation as Shallow\-Copy(), but instead of reporting an error for an incompatible graph, returns false.  
\item {\ttfamily bool = obj.\-Checked\-Deep\-Copy (vtk\-Graph g)} -\/ Performs the same operation as Deep\-Copy(), but instead of reporting an error for an incompatible graph, returns false.  
\item {\ttfamily obj.\-Squeeze ()}  
\item {\ttfamily obj.\-Reorder\-Out\-Vertices (vtk\-Id\-Type v, vtk\-Id\-Type\-Array vertices)} -\/ Reorder the outgoing vertices of a vertex. The vertex list must have the same elements as the current out edge list, just in a different order. This method does not change the topology of the graph. In a distributed graph, the vertex v must be local.  
\item {\ttfamily bool = obj.\-Is\-Same\-Structure (vtk\-Graph other)} -\/ Returns true if both graphs point to the same adjacency structure. Can be used to test the copy-\/on-\/write feature of the graph.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Source\-Vertex (vtk\-Id\-Type e)} -\/ Retrieve the source and target vertices for an edge id. N\-O\-T\-E\-: The first time this is called, the graph will build a mapping array from edge id to source/target that is the same size as the number of edges in the graph. If you have access to a vtk\-Out\-Edge\-Type, vtk\-In\-Edge\-Type, vtk\-Edge\-Type, or vtk\-Graph\-Edge, you should directly use these structures to look up the source or target instead of this method.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Target\-Vertex (vtk\-Id\-Type e)} -\/ Retrieve the source and target vertices for an edge id. N\-O\-T\-E\-: The first time this is called, the graph will build a mapping array from edge id to source/target that is the same size as the number of edges in the graph. If you have access to a vtk\-Out\-Edge\-Type, vtk\-In\-Edge\-Type, vtk\-Edge\-Type, or vtk\-Graph\-Edge, you should directly use these structures to look up the source or target instead of this method.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Edge\-Points (vtk\-Id\-Type e)} -\/ Get the number of edge points associated with an edge.  
\item {\ttfamily double = obj.\-Get\-Edge\-Point (vtk\-Id\-Type e, vtk\-Id\-Type i)} -\/ Get the x,y,z location of a point along edge e.  
\item {\ttfamily obj.\-Clear\-Edge\-Points (vtk\-Id\-Type e)} -\/ Clear all points associated with an edge.  
\item {\ttfamily obj.\-Set\-Edge\-Point (vtk\-Id\-Type e, vtk\-Id\-Type i, double x\mbox{[}3\mbox{]})} -\/ Set an x,y,z location of a point along an edge. This assumes there is already a point at location i, and simply overwrites it.  
\item {\ttfamily obj.\-Set\-Edge\-Point (vtk\-Id\-Type e, vtk\-Id\-Type i, double x, double y, double z)} -\/ Adds a point to the end of the list of edge points for a certain edge.  
\item {\ttfamily obj.\-Add\-Edge\-Point (vtk\-Id\-Type e, double x\mbox{[}3\mbox{]})} -\/ Adds a point to the end of the list of edge points for a certain edge.  
\item {\ttfamily obj.\-Add\-Edge\-Point (vtk\-Id\-Type e, double x, double y, double z)} -\/ Copy the internal edge point data from another graph into this graph. Both graphs must have the same number of edges.  
\item {\ttfamily obj.\-Shallow\-Copy\-Edge\-Points (vtk\-Graph g)} -\/ Copy the internal edge point data from another graph into this graph. Both graphs must have the same number of edges.  
\item {\ttfamily obj.\-Deep\-Copy\-Edge\-Points (vtk\-Graph g)} -\/ Copy the internal edge point data from another graph into this graph. Both graphs must have the same number of edges.  
\item {\ttfamily vtk\-Graph\-Internals = obj.\-Get\-Graph\-Internals (bool modifying)} -\/ Returns the internal representation of the graph. If modifying is true, then the returned vtk\-Graph\-Internals object will be unique to this vtk\-Graph object.  
\item {\ttfamily obj.\-Get\-Induced\-Edges (vtk\-Id\-Type\-Array verts, vtk\-Id\-Type\-Array edges)} -\/ Fills a list of edge indices with the edges contained in the induced subgraph formed by the vertices in the vertex list.  
\item {\ttfamily vtk\-Field\-Data = obj.\-Get\-Attributes\-As\-Field\-Data (int type)} -\/ Returns the attributes of the data object as a vtk\-Field\-Data. This returns non-\/null values in all the same cases as Get\-Attributes, in addition to the case of F\-I\-E\-L\-D, which will return the field data for any vtk\-Data\-Object subclass.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Elements (int type)} -\/ Get the number of elements for a specific attribute type (V\-E\-R\-T\-E\-X, E\-D\-G\-E, etc.).  
\item {\ttfamily obj.\-Dump ()} -\/ Dump the contents of the graph to standard output.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkgraphalgorithm}{}\section{vtk\-Graph\-Algorithm}\label{vtkfiltering_vtkgraphalgorithm}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Graph\-Algorithm is a convenience class to make writing algorithms easier. It is also designed to help transition old algorithms to the new pipeline architecture. There are some assumptions and defaults made by this class you should be aware of. This class defaults such that your filter will have one input port and one output port. If that is not the case simply change it with Set\-Number\-Of\-Input\-Ports etc. See this class constructor for the default. This class also provides a Fill\-Input\-Port\-Info method that by default says that all inputs will be Graph. If that isn't the case then please override this method in your subclass. This class breaks out the downstream requests into separate functions such as Execute\-Data and Execute\-Information. For new algorithms you should implement Request\-Data( request, input\-Vec, output\-Vec) but for older filters there is a default implementation that calls the old Execute\-Data(output) signature. For even older filters that don't implement Execute\-Data the default implementation calls the even older Execute() signature.

.S\-E\-C\-T\-I\-O\-N Thanks Thanks to Patricia Crossno, Ken Moreland, Andrew Wilson and Brian Wylie from Sandia National Laboratories for their help in developing this class.

To create an instance of class vtk\-Graph\-Algorithm, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkGraphAlgorithm
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Graph\-Algorithm has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Graph\-Algorithm class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Graph\-Algorithm = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Graph\-Algorithm = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Graph = obj.\-Get\-Output ()} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Graph = obj.\-Get\-Output (int index)} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Object obj)} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Set\-Input (int index, vtk\-Data\-Object obj)} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkgraphedge}{}\section{vtk\-Graph\-Edge}\label{vtkfiltering_vtkgraphedge}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
A heavy-\/weight (vtk\-Object subclass) graph edge object that may be used instead of the vtk\-Edge\-Type struct, for use with wrappers. The edge contains the source and target vertex ids, and the edge id.

To create an instance of class vtk\-Graph\-Edge, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkGraphEdge
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Graph\-Edge has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Graph\-Edge class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Graph\-Edge = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Graph\-Edge = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Source (vtk\-Id\-Type )} -\/ The source of the edge.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Source ()} -\/ The source of the edge.  
\item {\ttfamily obj.\-Set\-Target (vtk\-Id\-Type )} -\/ The target of the edge.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Target ()} -\/ The target of the edge.  
\item {\ttfamily obj.\-Set\-Id (vtk\-Id\-Type )} -\/ The id of the edge.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Id ()} -\/ The id of the edge.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkgraphinternals}{}\section{vtk\-Graph\-Internals}\label{vtkfiltering_vtkgraphinternals}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This is the internal representation of vtk\-Graph, used only in rare cases where one must modify that representation.

To create an instance of class vtk\-Graph\-Internals, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkGraphInternals
\end{DoxyVerb}
 \hypertarget{vtkfiltering_vtkhexagonalprism}{}\section{vtk\-Hexagonal\-Prism}\label{vtkfiltering_vtkhexagonalprism}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Hexagonal\-Prism is a concrete implementation of vtk\-Cell to represent a linear 3\-D prism with hexagonal base. Such prism is defined by the twelve points (0-\/12) where (0,1,2,3,4,5) is the base of the prism which, using the right hand rule, forms a hexagon whose normal points is in the direction of the opposite face (6,7,8,9,10,11).

To create an instance of class vtk\-Hexagonal\-Prism, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkHexagonalPrism
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Hexagonal\-Prism has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Hexagonal\-Prism class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Hexagonal\-Prism = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Hexagonal\-Prism = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int edge\-Id)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int face\-Id)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)}  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)}  
\item {\ttfamily int = obj.\-Get\-Parametric\-Center (double pcoords\mbox{[}3\mbox{]})} -\/ Return the center of the wedge in parametric coordinates.  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double weights\mbox{[}12\mbox{]})} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs\mbox{[}36\mbox{]})} -\/ Return the ids of the vertices defining edge/face ({\ttfamily edge\-Id}/`face\-Id'). Ids are related to the cell, not to the dataset.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkhexahedron}{}\section{vtk\-Hexahedron}\label{vtkfiltering_vtkhexahedron}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Hexahedron is a concrete implementation of vtk\-Cell to represent a linear, 3\-D rectangular hexahedron (e.\-g., \char`\"{}brick\char`\"{} topology). vtk\-Hexahedron uses the standard isoparametric shape functions for a linear hexahedron. The hexahedron is defined by the eight points (0-\/7) where (0,1,2,3) is the base of the hexahedron which, using the right hand rule, forms a quadrilaterial whose normal points in the direction of the opposite face (4,5,6,7).

To create an instance of class vtk\-Hexahedron, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkHexahedron
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Hexahedron has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Hexahedron class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Hexahedron = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Hexahedron = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int edge\-Id)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int face\-Id)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)}  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)}  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double weights\mbox{[}8\mbox{]})} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs\mbox{[}24\mbox{]})} -\/ Return the ids of the vertices defining edge/face ({\ttfamily edge\-Id}/`face\-Id'). Ids are related to the cell, not to the dataset.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkhierarchicalboxdataiterator}{}\section{vtk\-Hierarchical\-Box\-Data\-Iterator}\label{vtkfiltering_vtkhierarchicalboxdataiterator}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
To create an instance of class vtk\-Hierarchical\-Box\-Data\-Iterator, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkHierarchicalBoxDataIterator
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Hierarchical\-Box\-Data\-Iterator has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Hierarchical\-Box\-Data\-Iterator class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Hierarchical\-Box\-Data\-Iterator = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Hierarchical\-Box\-Data\-Iterator = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Current\-Level ()} -\/ Returns the level for the current dataset.  
\item {\ttfamily int = obj.\-Get\-Current\-Index ()} -\/ Returns the dataset index for the current data object. Valid only if the current data is a leaf node i.\-e. no a composite dataset.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkhierarchicalboxdataset}{}\section{vtk\-Hierarchical\-Box\-Data\-Set}\label{vtkfiltering_vtkhierarchicalboxdataset}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Hierarchical\-Box\-Data\-Set is a concrete implementation of vtk\-Composite\-Data\-Set. The dataset type is restricted to vtk\-Uniform\-Grid. Each dataset has an associated vtk\-A\-M\-R\-Box that represents it's region (similar to extent) in space.

.S\-E\-C\-T\-I\-O\-N Warning To compute the cell\-Id of a cell within a vtk\-Uniform\-Grid with A\-M\-R\-Box=box, you should not use vtk\-Uniform\-Grid\-::\-Compute\-Cell\-Id( \{x,y,z\} ) but instead use the following pseudo code\-: for (int i=0; i$<$3; i++) \{ cell\-Dims\mbox{[}i\mbox{]} = box.\-Hi\-Corner\mbox{[}i\mbox{]} -\/ box.\-Lo\-Corner\mbox{[}i\mbox{]} + 1; \} vtk\-Id\-Type cell\-Id = (z-\/box.\-Lo\-Corner\mbox{[}2\mbox{]})$\ast$cell\-Dims\mbox{[}0\mbox{]}$\ast$cell\-Dims\mbox{[}1\mbox{]} + (y-\/box.\-Lo\-Corner\mbox{[}1\mbox{]})$\ast$cell\-Dims\mbox{[}0\mbox{]} + (x-\/box.\-Lo\-Corner\mbox{[}0\mbox{]});

N\-O\-T\-E vtk\-A\-M\-R\-Box is used to compute cell visibility, therefor it should be dimensioned according to the visible region.

To create an instance of class vtk\-Hierarchical\-Box\-Data\-Set, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkHierarchicalBoxDataSet
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Hierarchical\-Box\-Data\-Set has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Hierarchical\-Box\-Data\-Set class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Hierarchical\-Box\-Data\-Set = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Hierarchical\-Box\-Data\-Set = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Composite\-Data\-Iterator = obj.\-New\-Iterator ()} -\/ Return a new iterator (the iterator has to be deleted by user).  
\item {\ttfamily int = obj.\-Get\-Data\-Object\-Type ()} -\/ Set the number of refinement levels. This call might cause allocation if the new number of levels is larger than the current one.  
\item {\ttfamily obj.\-Set\-Number\-Of\-Levels (int num\-Levels)} -\/ Set the number of refinement levels. This call might cause allocation if the new number of levels is larger than the current one.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Levels ()} -\/ Returns the number of levels.  
\item {\ttfamily obj.\-Set\-Number\-Of\-Data\-Sets (int level, int numdatasets)} -\/ Set the number of data set at a given level.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Data\-Sets (int level)} -\/ Returns the number of data sets available at any level.  
\item {\ttfamily obj.\-Set\-Data\-Set (vtk\-Composite\-Data\-Iterator iter, vtk\-Data\-Object data\-Obj)} -\/ Set the dataset pointer for a given node. This will resize the number of levels and the number of datasets in the level to fit level, id requested.  
\item {\ttfamily obj.\-Set\-Data\-Set (int level, int id, int Lo\-Corner\mbox{[}3\mbox{]}, int Hi\-Corner\mbox{[}3\mbox{]}, vtk\-Uniform\-Grid data\-Set)} -\/ Set the dataset pointer for a given node. This will resize the number of levels and the number of datasets in the level to fit level, id requested.  
\item {\ttfamily vtk\-Information = obj.\-Get\-Level\-Meta\-Data (int level)} -\/ Returns if meta-\/data exists for a given level.  
\item {\ttfamily int = obj.\-Has\-Level\-Meta\-Data (int level)} -\/ Get meta-\/data associated with a dataset. This may allocate a new vtk\-Information object if none is already present. Use Has\-Meta\-Data to avoid unnecessary allocations.  
\item {\ttfamily vtk\-Information = obj.\-Get\-Meta\-Data (int level, int index)} -\/ Get meta-\/data associated with a dataset. This may allocate a new vtk\-Information object if none is already present. Use Has\-Meta\-Data to avoid unnecessary allocations.  
\item {\ttfamily int = obj.\-Has\-Meta\-Data (int level, int index)} -\/ Returns if meta-\/data exists for a given dataset under a given level.  
\item {\ttfamily obj.\-Set\-Refinement\-Ratio (int level, int ref\-Ratio)} -\/ Sets the refinement of a given level. The spacing at level level+1 is defined as spacing(level+1) = spacing(level)/ref\-Ratio(level). Note that currently, this is not enforced by this class however some algorithms might not function properly if the spacing in the blocks (vtk\-Uniform\-Grid) does not match the one described by the refinement ratio.  
\item {\ttfamily int = obj.\-Get\-Refinement\-Ratio (int level)} -\/ Returns the refinement of a given level.  
\item {\ttfamily int = obj.\-Get\-Refinement\-Ratio (vtk\-Composite\-Data\-Iterator iter)} -\/ Returns the refinement ratio for the position pointed by the iterator.  
\item {\ttfamily obj.\-Generate\-Visibility\-Arrays ()} -\/ Blank lower level cells if they are overlapped by higher level ones.  
\item {\ttfamily obj.\-Get\-Scalar\-Range (double range\mbox{[}\mbox{]})} -\/ Copy the cached scalar range into range.  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Data\-Set (vtk\-Composite\-Data\-Iterator iter)} -\/ Unhiding superclass method.  
\item {\ttfamily vtk\-Information = obj.\-Get\-Meta\-Data (vtk\-Composite\-Data\-Iterator iter)} -\/ Unhiding superclass method.  
\item {\ttfamily int = obj.\-Has\-Meta\-Data (vtk\-Composite\-Data\-Iterator iter)} -\/ Given the level and dataset index, returns the flat index provided level and dataset index are valid.  
\item {\ttfamily int = obj.\-Get\-Flat\-Index (int level, int index)} -\/ Given the level and dataset index, returns the flat index provided level and dataset index are valid.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkhierarchicalboxdatasetalgorithm}{}\section{vtk\-Hierarchical\-Box\-Data\-Set\-Algorithm}\label{vtkfiltering_vtkhierarchicalboxdatasetalgorithm}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Algorithms that take any type of data object (including composite dataset) and produce a vtk\-Hierarchical\-Box\-Data\-Set in the output can subclass from this class.

To create an instance of class vtk\-Hierarchical\-Box\-Data\-Set\-Algorithm, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkHierarchicalBoxDataSetAlgorithm
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Hierarchical\-Box\-Data\-Set\-Algorithm has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Hierarchical\-Box\-Data\-Set\-Algorithm class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Hierarchical\-Box\-Data\-Set\-Algorithm = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Hierarchical\-Box\-Data\-Set\-Algorithm = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Hierarchical\-Box\-Data\-Set = obj.\-Get\-Output ()} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Hierarchical\-Box\-Data\-Set = obj.\-Get\-Output (int )} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Object )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Set\-Input (int , vtk\-Data\-Object )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkhyperoctree}{}\section{vtk\-Hyper\-Octree}\label{vtkfiltering_vtkhyperoctree}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
An hyperoctree is a dataset where each node has either exactly 2$^\wedge$n children or no child at all if the node is a leaf. `n' is the dimension of the dataset (1 (binary tree), 2 (quadtree) or 3 (octree) ). The class name comes from the following paper\-:

\begin{DoxyVerb} @ARTICLE{yau-srihari-1983,
  author={Mann-May Yau and Sargur N. Srihari},
  title={A Hierarchical Data Structure for Multidimensional Digital Images},
  journal={Communications of the ACM},
  month={July},
  year={1983},
  volume={26},
  number={7},
  pages={504--515}
  }\end{DoxyVerb}


Each node is a cell. Attributes are associated with cells, not with points. The geometry is implicitly given by the size of the root node on each axis and position of the center and the orientation. (T\-O\-D\-O\-: review center position and orientation). The geometry is then not limited to an hybercube but can have a rectangular shape. Attributes are associated with leaves. For L\-O\-D (Level-\/\-Of-\/\-Detail) purpose, attributes can be computed on none-\/leaf nodes by computing the average values from its children (which can be leaves or not).

By construction, an hyperoctree is efficient in memory usage when the geometry is sparse. The L\-O\-D feature allows to cull quickly part of the dataset.

A couple of filters can be applied on this dataset\-: contour, outline, geometry.

3\-D case (octree) for each node, each child index (from 0 to 7) is encoded in the following orientation. It is easy to access each child as a cell of a grid. Note also that the binary representation is relevant, each bit code a side\-: bit 0 encodes -\/x side (0) or +x side (1) bit 1 encodes -\/y side (0) or +y side (1) bit 2 encodes -\/z side (0) or +z side (2)
\begin{DoxyItemize}
\item the -\/z side first
\item 0\-: -\/y -\/x sides
\item 1\-: -\/y +x sides
\item 2\-: +y -\/x sides
\item 3\-: +y +x sides \begin{DoxyVerb}              +y
 +-+-+        ^
 |2|3|        |
 +-+-+  O +z  +-> +x
 |0|1|
 +-+-+\end{DoxyVerb}

\end{DoxyItemize}


\begin{DoxyItemize}
\item then the +z side, in counter-\/clockwise
\item 4\-: -\/y -\/x sides
\item 5\-: -\/y +x sides
\item 6\-: +y -\/x sides
\item 7\-: +y +x sides \begin{DoxyVerb}              +y
 +-+-+        ^
 |6|7|        |
 +-+-+  O +z  +-> +x
 |4|5|
 +-+-+\end{DoxyVerb}

\end{DoxyItemize}

The cases with fewer dimensions are consistent with the octree case\-:

Quadtree\-: in counter-\/clockwise
\begin{DoxyItemize}
\item 0\-: -\/y -\/x edges
\item 1\-: -\/y +x edges
\item 2\-: +y -\/x edges
\item 3\-: +y +x edges \begin{DoxyVerb}         +y
 +-+-+   ^
 |2|3|   |
 +-+-+  O+-> +x
 |0|1|
 +-+-+\end{DoxyVerb}


Binary tree\-: \begin{DoxyVerb} +0+1+  O+-> +x\end{DoxyVerb}

\end{DoxyItemize}

To create an instance of class vtk\-Hyper\-Octree, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkHyperOctree
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Hyper\-Octree has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Hyper\-Octree class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Hyper\-Octree = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Hyper\-Octree = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Data\-Object\-Type ()} -\/ Return what type of dataset this is.  
\item {\ttfamily obj.\-Copy\-Structure (vtk\-Data\-Set ds)} -\/ Copy the geometric and topological structure of an input rectilinear grid object.  
\item {\ttfamily int = obj.\-Get\-Dimension ()} -\/ Return the dimension of the tree (1\-D\-:binary tree(2 children), 2\-D\-:quadtree(4 children), 3\-D\-:octree (8 children)) \begin{DoxyPostcond}{Postcondition}
valid\-\_\-result\-: result$>$=1 \&\& result$<$=3  
\end{DoxyPostcond}

\item {\ttfamily obj.\-Set\-Dimension (int dim)} -\/ Set the dimension of the tree with `dim'. See Get\-Dimension() for details. \begin{DoxyPrecond}{Precondition}
valid\-\_\-dim\-: dim$>$=1 \&\& dim$<$=3 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
dimension\-\_\-is\-\_\-set\-: Get\-Dimension()==dim  
\end{DoxyPostcond}

\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Cells ()} -\/ Return the number of cells in the dual grid. \begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$=0  
\end{DoxyPostcond}

\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Leaves ()} -\/ Get the number of leaves in the tree.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Points ()} -\/ Return the number of points in the dual grid. \begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$=0  
\end{DoxyPostcond}

\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Max\-Number\-Of\-Points (int level)} -\/ Return the number of points corresponding to an hyperoctree starting at level `level' where all the leaves at at the last level. In this case, the hyperoctree is like a uniform grid. So this number is the number of points of the uniform grid. \begin{DoxyPrecond}{Precondition}
positive\-\_\-level\-: level$>$=0 \&\& level$<$this-\/$>$Get\-Number\-Of\-Levels() 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
definition\-: result==(2$^\wedge$(Get\-Number\-Of\-Levels()-\/level-\/1)+1)$^\wedge$\-Get\-Dimension()  
\end{DoxyPostcond}

\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Max\-Number\-Of\-Points\-On\-Boundary (int level)} -\/ Return the number of points corresponding to the boundary of an hyperoctree starting at level `level' where all the leaves at at the last level. In this case, the hyperoctree is like a uniform grid. So this number is the number of points of on the boundary of the uniform grid. For an octree, the boundary are the faces. For a quadtree, the boundary are the edges. \begin{DoxyPrecond}{Precondition}
2d\-\_\-or\-\_\-3d\-: this-\/$>$Get\-Dimension()==2 $|$$|$ this-\/$>$Get\-Dimension()==3 

positive\-\_\-level\-: level$>$=0 \&\& level$<$this-\/$>$Get\-Number\-Of\-Levels() 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
min\-\_\-result\-: result$>$=Get\-Max\-Number\-Of\-Points(this-\/$>$Get\-Number\-Of\-Levels()-\/1) 

max\-\_\-result\-: result$<$=Get\-Max\-Number\-Of\-Points(level)  
\end{DoxyPostcond}

\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Max\-Number\-Of\-Cells\-On\-Boundary (int level)} -\/ Return the number of cells corresponding to the boundary of a cell of level `level' where all the leaves at at the last level. \begin{DoxyPrecond}{Precondition}
positive\-\_\-level\-: level$>$=0 \&\& level$<$this-\/$>$Get\-Number\-Of\-Levels() 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$=0  
\end{DoxyPostcond}

\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Levels ()} -\/ Return the number of levels. \begin{DoxyPostcond}{Postcondition}
result\-\_\-greater\-\_\-or\-\_\-equal\-\_\-to\-\_\-one\-: result$>$=1  
\end{DoxyPostcond}

\item {\ttfamily obj.\-Set\-Size (double , double , double )} -\/ Set the size on each axis.  
\item {\ttfamily obj.\-Set\-Size (double a\mbox{[}3\mbox{]})} -\/ Set the size on each axis.  
\item {\ttfamily double = obj. Get\-Size ()} -\/ Return the size on each axis.  
\item {\ttfamily obj.\-Set\-Origin (double , double , double )} -\/ Set the origin (position of corner (0,0,0) of the root.  
\item {\ttfamily obj.\-Set\-Origin (double a\mbox{[}3\mbox{]})} -\/ Set the origin (position of corner (0,0,0) of the root.  
\item {\ttfamily double = obj. Get\-Origin ()} -\/ Set the origin (position of corner (0,0,0) of the root. Return the origin (position of corner (0,0,0) ) of the root.  
\item {\ttfamily vtk\-Hyper\-Octree\-Cursor = obj.\-New\-Cell\-Cursor ()} -\/ Create a new cursor\-: an object that can traverse the cell of an hyperoctree. \begin{DoxyPostcond}{Postcondition}
result\-\_\-exists\-: result!=0  
\end{DoxyPostcond}

\item {\ttfamily obj.\-Subdivide\-Leaf (vtk\-Hyper\-Octree\-Cursor leaf)} -\/ Subdivide node pointed by cursor, only if its a leaf. At the end, cursor points on the node that used to be leaf. \begin{DoxyPrecond}{Precondition}
leaf\-\_\-exists\-: leaf!=0 

is\-\_\-a\-\_\-leaf\-: leaf-\/$>$Current\-Is\-Leaf()  
\end{DoxyPrecond}

\item {\ttfamily obj.\-Collapse\-Terminal\-Node (vtk\-Hyper\-Octree\-Cursor node)} -\/ Collapse a node for which all children are leaves. At the end, cursor points on the leaf that used to be a node. \begin{DoxyPrecond}{Precondition}
node\-\_\-exists\-: node!=0 

node\-\_\-is\-\_\-node\-: !node-\/$>$Current\-Is\-Leaf() 

children\-\_\-are\-\_\-leaves\-: node-\/$>$Current\-Is\-Terminal\-Node()  
\end{DoxyPrecond}

\item {\ttfamily double = obj.\-Get\-Point (vtk\-Id\-Type pt\-Id)} -\/ Get point coordinates with pt\-Id such that\-: 0 $<$= pt\-Id $<$ Number\-Of\-Points. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S N\-O\-T T\-H\-R\-E\-A\-D S\-A\-F\-E.  
\item {\ttfamily obj.\-Get\-Point (vtk\-Id\-Type id, double x\mbox{[}3\mbox{]})} -\/ Copy point coordinates into user provided array x\mbox{[}3\mbox{]} for specified point id. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E I\-F F\-I\-R\-S\-T C\-A\-L\-L\-E\-D F\-R\-O\-M A S\-I\-N\-G\-L\-E T\-H\-R\-E\-A\-D A\-N\-D T\-H\-E D\-A\-T\-A\-S\-E\-T I\-S N\-O\-T M\-O\-D\-I\-F\-I\-E\-D  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Cell (vtk\-Id\-Type cell\-Id)} -\/ Get cell with cell\-Id such that\-: 0 $<$= cell\-Id $<$ Number\-Of\-Cells. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S N\-O\-T T\-H\-R\-E\-A\-D S\-A\-F\-E.  
\item {\ttfamily obj.\-Get\-Cell (vtk\-Id\-Type cell\-Id, vtk\-Generic\-Cell cell)} -\/ Get cell with cell\-Id such that\-: 0 $<$= cell\-Id $<$ Number\-Of\-Cells. This is a thread-\/safe alternative to the previous Get\-Cell() method. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E I\-F F\-I\-R\-S\-T C\-A\-L\-L\-E\-D F\-R\-O\-M A S\-I\-N\-G\-L\-E T\-H\-R\-E\-A\-D A\-N\-D T\-H\-E D\-A\-T\-A\-S\-E\-T I\-S N\-O\-T M\-O\-D\-I\-F\-I\-E\-D  
\item {\ttfamily int = obj.\-Get\-Cell\-Type (vtk\-Id\-Type cell\-Id)} -\/ Get type of cell with cell\-Id such that\-: 0 $<$= cell\-Id $<$ Number\-Of\-Cells. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E I\-F F\-I\-R\-S\-T C\-A\-L\-L\-E\-D F\-R\-O\-M A S\-I\-N\-G\-L\-E T\-H\-R\-E\-A\-D A\-N\-D T\-H\-E D\-A\-T\-A\-S\-E\-T I\-S N\-O\-T M\-O\-D\-I\-F\-I\-E\-D  
\item {\ttfamily obj.\-Get\-Cell\-Points (vtk\-Id\-Type cell\-Id, vtk\-Id\-List pt\-Ids)} -\/ Topological inquiry to get points defining cell. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E I\-F F\-I\-R\-S\-T C\-A\-L\-L\-E\-D F\-R\-O\-M A S\-I\-N\-G\-L\-E T\-H\-R\-E\-A\-D A\-N\-D T\-H\-E D\-A\-T\-A\-S\-E\-T I\-S N\-O\-T M\-O\-D\-I\-F\-I\-E\-D  
\item {\ttfamily obj.\-Get\-Point\-Cells (vtk\-Id\-Type pt\-Id, vtk\-Id\-List cell\-Ids)} -\/ Topological inquiry to get cells using point. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E I\-F F\-I\-R\-S\-T C\-A\-L\-L\-E\-D F\-R\-O\-M A S\-I\-N\-G\-L\-E T\-H\-R\-E\-A\-D A\-N\-D T\-H\-E D\-A\-T\-A\-S\-E\-T I\-S N\-O\-T M\-O\-D\-I\-F\-I\-E\-D  
\item {\ttfamily obj.\-Get\-Cell\-Neighbors (vtk\-Id\-Type cell\-Id, vtk\-Id\-List pt\-Ids, vtk\-Id\-List cell\-Ids)} -\/ Topological inquiry to get all cells using list of points exclusive of cell specified (e.\-g., cell\-Id). Note that the list consists of only cells that use A\-L\-L the points provided. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E I\-F F\-I\-R\-S\-T C\-A\-L\-L\-E\-D F\-R\-O\-M A S\-I\-N\-G\-L\-E T\-H\-R\-E\-A\-D A\-N\-D T\-H\-E D\-A\-T\-A\-S\-E\-T I\-S N\-O\-T M\-O\-D\-I\-F\-I\-E\-D  
\item {\ttfamily vtk\-Id\-Type = obj.\-Find\-Point (double x\mbox{[}3\mbox{]})}  
\item {\ttfamily obj.\-Initialize ()} -\/ Restore data object to initial state, T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S N\-O\-T T\-H\-R\-E\-A\-D S\-A\-F\-E.  
\item {\ttfamily int = obj.\-Get\-Max\-Cell\-Size ()} -\/ Convenience method returns largest cell size in dataset. This is generally used to allocate memory for supporting data structures. This is the number of points of a cell. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E  
\item {\ttfamily obj.\-Shallow\-Copy (vtk\-Data\-Object src)} -\/ Shallow and Deep copy.  
\item {\ttfamily obj.\-Deep\-Copy (vtk\-Data\-Object src)} -\/ Shallow and Deep copy.  
\item {\ttfamily obj.\-Get\-Points\-On\-Face (vtk\-Hyper\-Octree\-Cursor sibling, int face, int level, vtk\-Hyper\-Octree\-Points\-Grabber grabber)} -\/ Get the points of node `sibling' on its face `face'. \begin{DoxyPrecond}{Precondition}
sibling\-\_\-exists\-: sibling!=0 

sibling\-\_\-not\-\_\-leaf\-: !sibling-\/$>$Current\-Is\-Leaf() 

sibling\-\_\-3d\-: sibling-\/$>$Get\-Dimension()==3 

valid\-\_\-face\-: face$>$=0 \&\& face$<$6 

valid\-\_\-level\-\_\-not\-\_\-leaf\-: level$>$=0 level$<$(this-\/$>$Get\-Number\-Of\-Levels()-\/1)  
\end{DoxyPrecond}

\item {\ttfamily obj.\-Get\-Points\-On\-Parent\-Faces (int faces\mbox{[}3\mbox{]}, int level, vtk\-Hyper\-Octree\-Cursor cursor, vtk\-Hyper\-Octree\-Points\-Grabber grabber)} -\/ Get the points of the parent node of `cursor' on its faces `faces' at level `level' or deeper. \begin{DoxyPrecond}{Precondition}
cursor\-\_\-exists\-: cursor!=0 

cursor\-\_\-3d\-: cursor-\/$>$Get\-Dimension()==3 

valid\-\_\-level\-: level$>$=0 

boolean\-\_\-faces\-: (faces\mbox{[}0\mbox{]}==0 $|$$|$ faces\mbox{[}0\mbox{]}==1) \&\& (faces\mbox{[}1\mbox{]}==0 $|$$|$ faces\mbox{[}1\mbox{]}==1) \&\& (faces\mbox{[}2\mbox{]}==0 $|$$|$ faces\mbox{[}2\mbox{]}==1)  
\end{DoxyPrecond}

\item {\ttfamily obj.\-Get\-Points\-On\-Edge (vtk\-Hyper\-Octree\-Cursor sibling, int level, int axis, int k, int j, vtk\-Hyper\-Octree\-Points\-Grabber grabber)} -\/ Get the points of node `sibling' on its edge `axis','k','j'. If axis==0, the edge is X-\/aligned and k gives the z coordinate and j the y-\/coordinate. If axis==1, the edge is Y-\/aligned and k gives the x coordinate and j the z coordinate. If axis==2, the edge is Z-\/aligned and k gives the y coordinate and j the x coordinate. \begin{DoxyPrecond}{Precondition}
sibling\-\_\-exists\-: sibling!=0 

sibling\-\_\-3d\-: sibling-\/$>$Get\-Dimension()==3 

sibling\-\_\-not\-\_\-leaf\-: !sibling-\/$>$Current\-Is\-Leaf() 

valid\-\_\-axis\-: axis$>$=0 \&\& axis$<$3 

valid\-\_\-k\-: k$>$=0 \&\& k$<$=1 

valid\-\_\-j\-: j$>$=0 \&\& j$<$=1 

valid\-\_\-level\-\_\-not\-\_\-leaf\-: level$>$=0 level$<$(this-\/$>$Input-\/$>$Get\-Number\-Of\-Levels()-\/1)  
\end{DoxyPrecond}

\item {\ttfamily obj.\-Get\-Points\-On\-Parent\-Edge (vtk\-Hyper\-Octree\-Cursor cursor, int level, int axis, int k, int j, vtk\-Hyper\-Octree\-Points\-Grabber grabber)} -\/ Get the points of the parent node of `cursor' on its edge `axis','k','j' at level `level' or deeper. If axis==0, the edge is X-\/aligned and k gives the z coordinate and j the y-\/coordinate. If axis==1, the edge is Y-\/aligned and k gives the x coordinate and j the z coordinate. If axis==2, the edge is Z-\/aligned and k gives the y coordinate and j the x coordinate. \begin{DoxyPrecond}{Precondition}
cursor\-\_\-exists\-: cursor!=0 

cursor\-\_\-3d\-: cursor-\/$>$Get\-Dimension()==3 

valid\-\_\-level\-: level$>$=0 

valid\-\_\-range\-\_\-axis\-: axis$>$=0 \&\& axis$<$3 

valid\-\_\-range\-\_\-k\-: k$>$=0 \&\& k$<$=1 

valid\-\_\-range\-\_\-j\-: j$>$=0 \&\& j$<$=1  
\end{DoxyPrecond}

\item {\ttfamily obj.\-Get\-Points\-On\-Edge2\-D (vtk\-Hyper\-Octree\-Cursor sibling, int edge, int level, vtk\-Hyper\-Octree\-Points\-Grabber grabber)} -\/ Get the points of node `sibling' on its edge `edge'. \begin{DoxyPrecond}{Precondition}
sibling\-\_\-exists\-: sibling!=0 

sibling\-\_\-not\-\_\-leaf\-: !sibling-\/$>$Current\-Is\-Leaf() 

sibling\-\_\-2d\-: sibling-\/$>$Get\-Dimension()==2 

valid\-\_\-edge\-: edge$>$=0 \&\& edge$<$4 

valid\-\_\-level\-\_\-not\-\_\-leaf\-: level$>$=0 level$<$(this-\/$>$Input-\/$>$Get\-Number\-Of\-Levels()-\/1)  
\end{DoxyPrecond}

\item {\ttfamily obj.\-Get\-Points\-On\-Parent\-Edge2\-D (vtk\-Hyper\-Octree\-Cursor cursor, int edge, int level, vtk\-Hyper\-Octree\-Points\-Grabber grabber)} -\/ Get the points of the parent node of `cursor' on its edge `edge' at level `level' or deeper. (edge=0 for -\/\-X, 1 for +\-X, 2 for -\/\-Y, 3 for +\-Y) \begin{DoxyPrecond}{Precondition}
cursor\-\_\-exists\-: cursor!=0 

cursor\-\_\-2d\-: cursor-\/$>$Get\-Dimension()==2 

valid\-\_\-level\-: level$>$=0 

valid\-\_\-edge\-: edge$>$=0 \&\& edge$<$4  
\end{DoxyPrecond}

\item {\ttfamily vtk\-Data\-Set\-Attributes = obj.\-Get\-Leaf\-Data ()} -\/ A generic way to set the leaf data attributes. This can be either point data for dual or cell data for normal grid.  
\item {\ttfamily obj.\-Set\-Dual\-Grid\-Flag (int flag)} -\/ Switch between returning leaves as cells, or the dual grid.  
\item {\ttfamily int = obj.\-Get\-Dual\-Grid\-Flag ()} -\/ Switch between returning leaves as cells, or the dual grid.  
\item {\ttfamily long = obj.\-Get\-Actual\-Memory\-Size ()} -\/ Return the actual size of the data in kilobytes. This number is valid only after the pipeline has updated. The memory size returned is guaranteed to be greater than or equal to the memory required to represent the data (e.\-g., extra space in arrays, etc. are not included in the return value). T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkhyperoctreealgorithm}{}\section{vtk\-Hyper\-Octree\-Algorithm}\label{vtkfiltering_vtkhyperoctreealgorithm}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
To create an instance of class vtk\-Hyper\-Octree\-Algorithm, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkHyperOctreeAlgorithm
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Hyper\-Octree\-Algorithm has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Hyper\-Octree\-Algorithm class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Hyper\-Octree\-Algorithm = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Hyper\-Octree\-Algorithm = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Hyper\-Octree = obj.\-Get\-Output ()} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Hyper\-Octree = obj.\-Get\-Output (int )} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily obj.\-Set\-Output (vtk\-Data\-Object d)} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Input ()}  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Input (int port)}  
\item {\ttfamily vtk\-Hyper\-Octree = obj.\-Get\-Hyper\-Octree\-Input (int port)}  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Object )} -\/ Set an input of this algorithm.  
\item {\ttfamily obj.\-Set\-Input (int , vtk\-Data\-Object )} -\/ Set an input of this algorithm.  
\item {\ttfamily obj.\-Add\-Input (vtk\-Data\-Object )} -\/ Add an input of this algorithm.  
\item {\ttfamily obj.\-Add\-Input (int , vtk\-Data\-Object )} -\/ Add an input of this algorithm.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkhyperoctreecursor}{}\section{vtk\-Hyper\-Octree\-Cursor}\label{vtkfiltering_vtkhyperoctreecursor}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Objects that can traverse hyperoctree nodes. It is an abstract class. Cursors are created by the hyperoctree.

To create an instance of class vtk\-Hyper\-Octree\-Cursor, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkHyperOctreeCursor
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Hyper\-Octree\-Cursor has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Hyper\-Octree\-Cursor class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Hyper\-Octree\-Cursor = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Hyper\-Octree\-Cursor = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Leaf\-Id ()} -\/ Return the index of the current leaf in the data arrays. \begin{DoxyPrecond}{Precondition}
is\-\_\-leaf\-: Current\-Is\-Leaf()  
\end{DoxyPrecond}

\item {\ttfamily int = obj.\-Current\-Is\-Leaf ()} -\/ Is the node pointed by the cursor a leaf?  
\item {\ttfamily int = obj.\-Current\-Is\-Root ()} -\/ Is the node pointed by the cursor the root?  
\item {\ttfamily int = obj.\-Get\-Current\-Level ()} -\/ Return the level of the node pointed by the cursor. \begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$=0  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Get\-Child\-Index ()} -\/ Return the child number of the current node relative to its parent. \begin{DoxyPrecond}{Precondition}
not\-\_\-root\-: !\-Current\-Is\-Root(). 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
valid\-\_\-range\-: result$>$=0 \&\& result$<$Get\-Number\-Of\-Children()  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Current\-Is\-Terminal\-Node ()}  
\item {\ttfamily obj.\-To\-Root ()} -\/ Move the cursor the root node. \begin{DoxyPrecond}{Precondition}
can be root 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
is\-\_\-root\-: Current\-Is\-Root()  
\end{DoxyPostcond}

\item {\ttfamily obj.\-To\-Parent ()} -\/ Move the cursor to the parent of the current node. \begin{DoxyPrecond}{Precondition}
not\-\_\-root\-: !\-Current\-Is\-Root()  
\end{DoxyPrecond}

\item {\ttfamily obj.\-To\-Child (int child)} -\/ Move the cursor to child `child' of the current node. \begin{DoxyPrecond}{Precondition}
not\-\_\-leaf\-: !\-Current\-Is\-Leaf() 

valid\-\_\-child\-: child$>$=0 \&\& child$<$this-\/$>$Get\-Number\-Of\-Children()  
\end{DoxyPrecond}

\item {\ttfamily obj.\-To\-Same\-Node (vtk\-Hyper\-Octree\-Cursor other)} -\/ Move the cursor to the same node pointed by `other'. \begin{DoxyPrecond}{Precondition}
other\-\_\-exists\-: other!=0 

same\-\_\-hyperoctree\-: this-\/$>$Same\-Tree(other); 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
equal\-: this-\/$>$Is\-Equal(other)  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Is\-Equal (vtk\-Hyper\-Octree\-Cursor other)} -\/ Is `this' equal to `other'? \begin{DoxyPrecond}{Precondition}
other\-\_\-exists\-: other!=0 

same\-\_\-hyperoctree\-: this-\/$>$Same\-Tree(other);  
\end{DoxyPrecond}

\item {\ttfamily vtk\-Hyper\-Octree\-Cursor = obj.\-Clone ()} -\/ Create a copy of `this'. \begin{DoxyPostcond}{Postcondition}
results\-\_\-exists\-:result!=0 

same\-\_\-tree\-: result-\/$>$Same\-Tree(this)  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Same\-Tree (vtk\-Hyper\-Octree\-Cursor other)} -\/ Are `this' and `other' pointing on the same hyperoctree? \begin{DoxyPrecond}{Precondition}
other\-\_\-exists\-: other!=0  
\end{DoxyPrecond}

\item {\ttfamily int = obj.\-Get\-Index (int d)} -\/ Return the index in dimension `d', as if the node was a cell of a uniform grid of 1$<$$<$Get\-Current\-Level() cells in each dimension. \begin{DoxyPrecond}{Precondition}
valid\-\_\-range\-: d$>$=0 \&\& d$<$Get\-Dimension() 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
valid\-\_\-result\-: result$>$=0 \&\& result$<$(1$<$$<$Get\-Current\-Level())  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Get\-Number\-Of\-Children ()} -\/ Return the number of children for each node of the tree. \begin{DoxyPostcond}{Postcondition}
positive\-\_\-number\-: result$>$0  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Get\-Dimension ()} -\/ Return the dimension of the tree. \begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$0  
\end{DoxyPostcond}

\item {\ttfamily obj.\-Move\-To\-Node (int indices, int level)} -\/ Move to the node described by its indices in each dimension and at a given level. If there is actually a node or a leaf at this location, Found() returns true. Otherwise, Found() returns false and the cursor moves to the closest parent of the query. It can be the root in the worst case. \begin{DoxyPrecond}{Precondition}
indices\-\_\-exists\-: indices!=0 

valid\-\_\-size\-: sizeof(indices)==Get\-Dimension() 

valid\-\_\-level\-: level$>$=0  
\end{DoxyPrecond}

\item {\ttfamily int = obj.\-Found ()}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkimagealgorithm}{}\section{vtk\-Image\-Algorithm}\label{vtkfiltering_vtkimagealgorithm}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Image\-Algorithm is a filter superclass that hides much of the pipeline complexity. It handles breaking the pipeline execution into smaller extents so that the vtk\-Image\-Data limits are observed. It also provides support for multithreading. If you don't need any of this functionality, consider using vtk\-Simple\-Image\-To\-Image\-Filter instead. .S\-E\-C\-T\-I\-O\-N See also vtk\-Simple\-Image\-To\-Image\-Filter

To create an instance of class vtk\-Image\-Algorithm, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkImageAlgorithm
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Image\-Algorithm has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Image\-Algorithm class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Image\-Algorithm = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Image\-Algorithm = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Image\-Data = obj.\-Get\-Output ()} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Image\-Data = obj.\-Get\-Output (int )} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily obj.\-Set\-Output (vtk\-Data\-Object d)} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Object )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Set\-Input (int , vtk\-Data\-Object )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Input (int port)}  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Input ()}  
\item {\ttfamily vtk\-Image\-Data = obj.\-Get\-Image\-Data\-Input (int port)}  
\item {\ttfamily obj.\-Add\-Input (vtk\-Data\-Object )} -\/ Add an input of this algorithm. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Add\-Input\-Connection(). See Set\-Input() for details.  
\item {\ttfamily obj.\-Add\-Input (int , vtk\-Data\-Object )} -\/ Add an input of this algorithm. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Add\-Input\-Connection(). See Set\-Input() for details.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkimagedata}{}\section{vtk\-Image\-Data}\label{vtkfiltering_vtkimagedata}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Image\-Data is a data object that is a concrete implementation of vtk\-Data\-Set. vtk\-Image\-Data represents a geometric structure that is a topological and geometrical regular array of points. Examples include volumes (voxel data) and pixmaps.

To create an instance of class vtk\-Image\-Data, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkImageData
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Image\-Data has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Image\-Data class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Image\-Data = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Image\-Data = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Copy\-Structure (vtk\-Data\-Set ds)} -\/ Copy the geometric and topological structure of an input image data object.  
\item {\ttfamily int = obj.\-Get\-Data\-Object\-Type ()} -\/ Return what type of dataset this is.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Cells ()} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Points ()} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily double = obj.\-Get\-Point (vtk\-Id\-Type pt\-Id)} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily obj.\-Get\-Point (vtk\-Id\-Type id, double x\mbox{[}3\mbox{]})} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Cell (vtk\-Id\-Type cell\-Id)} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily obj.\-Get\-Cell (vtk\-Id\-Type cell\-Id, vtk\-Generic\-Cell cell)} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily obj.\-Get\-Cell\-Bounds (vtk\-Id\-Type cell\-Id, double bounds\mbox{[}6\mbox{]})} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Find\-Point (double x, double y, double z)} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Find\-Point (double x\mbox{[}3\mbox{]})} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily int = obj.\-Get\-Cell\-Type (vtk\-Id\-Type cell\-Id)} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily obj.\-Get\-Cell\-Points (vtk\-Id\-Type cell\-Id, vtk\-Id\-List pt\-Ids)} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily obj.\-Get\-Point\-Cells (vtk\-Id\-Type pt\-Id, vtk\-Id\-List cell\-Ids)} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily obj.\-Compute\-Bounds ()} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily int = obj.\-Get\-Max\-Cell\-Size ()} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily obj.\-Initialize ()} -\/ Restore data object to initial state,  
\item {\ttfamily obj.\-Set\-Dimensions (int i, int j, int k)} -\/ Pass your way. This is for backward compatibility only. Use Set\-Extent() instead. Same as Set\-Extent(0, i-\/1, 0, j-\/1, 0, k-\/1)  
\item {\ttfamily obj.\-Set\-Dimensions (int dims\mbox{[}3\mbox{]})} -\/ Pass your way. This is for backward compatibility only. Use Set\-Extent() instead. Same as Set\-Extent(0, dims\mbox{[}0\mbox{]}-\/1, 0, dims\mbox{[}1\mbox{]}-\/1, 0, dims\mbox{[}2\mbox{]}-\/1)  
\item {\ttfamily int = obj.\-Get\-Dimensions ()} -\/ Get dimensions of this structured points dataset. It is the number of points on each axis. Dimensions are computed from Extents during this call.  
\item {\ttfamily obj.\-Get\-Dimensions (int dims\mbox{[}3\mbox{]})} -\/ Get dimensions of this structured points dataset. It is the number of points on each axis. Dimensions are computed from Extents during this call.  
\item {\ttfamily int = obj.\-Compute\-Structured\-Coordinates (double x\mbox{[}3\mbox{]}, int ijk\mbox{[}3\mbox{]}, double pcoords\mbox{[}3\mbox{]})} -\/ Convenience function computes the structured coordinates for a point x\mbox{[}3\mbox{]}. The voxel is specified by the array ijk\mbox{[}3\mbox{]}, and the parametric coordinates in the cell are specified with pcoords\mbox{[}3\mbox{]}. The function returns a 0 if the point x is outside of the volume, and a 1 if inside the volume.  
\item {\ttfamily obj.\-Get\-Voxel\-Gradient (int i, int j, int k, vtk\-Data\-Array s, vtk\-Data\-Array g)} -\/ Given structured coordinates (i,j,k) for a voxel cell, compute the eight gradient values for the voxel corners. The order in which the gradient vectors are arranged corresponds to the ordering of the voxel points. Gradient vector is computed by central differences (except on edges of volume where forward difference is used). The scalars s are the scalars from which the gradient is to be computed. This method will treat only 3\-D structured point datasets (i.\-e., volumes).  
\item {\ttfamily obj.\-Get\-Point\-Gradient (int i, int j, int k, vtk\-Data\-Array s, double g\mbox{[}3\mbox{]})} -\/ Given structured coordinates (i,j,k) for a point in a structured point dataset, compute the gradient vector from the scalar data at that point. The scalars s are the scalars from which the gradient is to be computed. This method will treat structured point datasets of any dimension.  
\item {\ttfamily int = obj.\-Get\-Data\-Dimension ()} -\/ Return the dimensionality of the data.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Compute\-Point\-Id (int ijk\mbox{[}3\mbox{]})} -\/ Given a location in structured coordinates (i-\/j-\/k), return the point id.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Compute\-Cell\-Id (int ijk\mbox{[}3\mbox{]})} -\/ Given a location in structured coordinates (i-\/j-\/k), return the cell id.  
\item {\ttfamily obj.\-Set\-Axis\-Update\-Extent (int axis, int min, int max)} -\/ Set / Get the extent on just one axis  
\item {\ttfamily obj.\-Update\-Information ()} -\/ Override to copy information from pipeline information to data information for backward compatibility. See vtk\-Data\-Object\-::\-Update\-Information for details.  
\item {\ttfamily obj.\-Set\-Extent (int extent\mbox{[}6\mbox{]})} -\/ Set/\-Get the extent. On each axis, the extent is defined by the index of the first point and the index of the last point. The extent should be set before the \char`\"{}\-Scalars\char`\"{} are set or allocated. The Extent is stored in the order (X, Y, Z). The dataset extent does not have to start at (0,0,0). (0,0,0) is just the extent of the origin. The first point (the one with Id=0) is at extent (Extent\mbox{[}0\mbox{]},Extent\mbox{[}2\mbox{]},Extent\mbox{[}4\mbox{]}). As for any dataset, a data array on point data starts at Id=0.  
\item {\ttfamily obj.\-Set\-Extent (int x1, int x2, int y1, int y2, int z1, int z2)} -\/ Set/\-Get the extent. On each axis, the extent is defined by the index of the first point and the index of the last point. The extent should be set before the \char`\"{}\-Scalars\char`\"{} are set or allocated. The Extent is stored in the order (X, Y, Z). The dataset extent does not have to start at (0,0,0). (0,0,0) is just the extent of the origin. The first point (the one with Id=0) is at extent (Extent\mbox{[}0\mbox{]},Extent\mbox{[}2\mbox{]},Extent\mbox{[}4\mbox{]}). As for any dataset, a data array on point data starts at Id=0.  
\item {\ttfamily int = obj. Get\-Extent ()} -\/ Set/\-Get the extent. On each axis, the extent is defined by the index of the first point and the index of the last point. The extent should be set before the \char`\"{}\-Scalars\char`\"{} are set or allocated. The Extent is stored in the order (X, Y, Z). The dataset extent does not have to start at (0,0,0). (0,0,0) is just the extent of the origin. The first point (the one with Id=0) is at extent (Extent\mbox{[}0\mbox{]},Extent\mbox{[}2\mbox{]},Extent\mbox{[}4\mbox{]}). As for any dataset, a data array on point data starts at Id=0.  
\item {\ttfamily long = obj.\-Get\-Estimated\-Memory\-Size ()} -\/ Get the estimated size of this data object itself. Should be called after Update\-Information() and Propagate\-Update\-Extent() have both been called. This estimate should be fairly accurate since this is structured data.  
\item {\ttfamily double = obj.\-Get\-Scalar\-Type\-Min ()} -\/ These returns the minimum and maximum values the Scalar\-Type can hold without overflowing.  
\item {\ttfamily double = obj.\-Get\-Scalar\-Type\-Max ()} -\/ These returns the minimum and maximum values the Scalar\-Type can hold without overflowing.  
\item {\ttfamily int = obj.\-Get\-Scalar\-Size ()} -\/ Set the size of the scalar type in bytes.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Increments ()} -\/ Different ways to get the increments for moving around the data. Get\-Increments() calls Compute\-Increments() to ensure the increments are up to date.  
\item {\ttfamily obj.\-Get\-Increments (vtk\-Id\-Type inc\mbox{[}3\mbox{]})} -\/ Different ways to get the increments for moving around the data. Get\-Increments() calls Compute\-Increments() to ensure the increments are up to date.  
\item {\ttfamily float = obj.\-Get\-Scalar\-Component\-As\-Float (int x, int y, int z, int component)} -\/ For access to data from tcl  
\item {\ttfamily obj.\-Set\-Scalar\-Component\-From\-Float (int x, int y, int z, int component, float v)} -\/ For access to data from tcl  
\item {\ttfamily double = obj.\-Get\-Scalar\-Component\-As\-Double (int x, int y, int z, int component)} -\/ For access to data from tcl  
\item {\ttfamily obj.\-Set\-Scalar\-Component\-From\-Double (int x, int y, int z, int component, double v)} -\/ For access to data from tcl  
\item {\ttfamily obj.\-Allocate\-Scalars ()} -\/ Allocate the vtk\-Scalars object associated with this object.  
\item {\ttfamily obj.\-Copy\-And\-Cast\-From (vtk\-Image\-Data in\-Data, int extent\mbox{[}6\mbox{]})} -\/ This method is passed a input and output region, and executes the filter algorithm to fill the output from the input. It just executes a switch statement to call the correct function for the regions data types.  
\item {\ttfamily obj.\-Copy\-And\-Cast\-From (vtk\-Image\-Data in\-Data, int x0, int x1, int y0, int y1, int z0, int z1)} -\/ Reallocates and copies to set the Extent to the Update\-Extent. This is used internally when the exact extent is requested, and the source generated more than the update extent.  
\item {\ttfamily obj.\-Crop ()} -\/ Reallocates and copies to set the Extent to the Update\-Extent. This is used internally when the exact extent is requested, and the source generated more than the update extent.  
\item {\ttfamily long = obj.\-Get\-Actual\-Memory\-Size ()} -\/ Return the actual size of the data in kilobytes. This number is valid only after the pipeline has updated. The memory size returned is guaranteed to be greater than or equal to the memory required to represent the data (e.\-g., extra space in arrays, etc. are not included in the return value). T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E.  
\item {\ttfamily obj.\-Set\-Spacing (double , double , double )} -\/ Set the spacing (width,height,length) of the cubical cells that compose the data set.  
\item {\ttfamily obj.\-Set\-Spacing (double a\mbox{[}3\mbox{]})} -\/ Set the spacing (width,height,length) of the cubical cells that compose the data set.  
\item {\ttfamily double = obj. Get\-Spacing ()} -\/ Set the spacing (width,height,length) of the cubical cells that compose the data set.  
\item {\ttfamily obj.\-Set\-Origin (double , double , double )} -\/ Set/\-Get the origin of the dataset. The origin is the position in world coordinates of the point of extent (0,0,0). This point does not have to be part of the dataset, in other words, the dataset extent does not have to start at (0,0,0) and the origin can be outside of the dataset bounding box. The origin plus spacing determine the position in space of the points.  
\item {\ttfamily obj.\-Set\-Origin (double a\mbox{[}3\mbox{]})} -\/ Set/\-Get the origin of the dataset. The origin is the position in world coordinates of the point of extent (0,0,0). This point does not have to be part of the dataset, in other words, the dataset extent does not have to start at (0,0,0) and the origin can be outside of the dataset bounding box. The origin plus spacing determine the position in space of the points.  
\item {\ttfamily double = obj. Get\-Origin ()} -\/ Set/\-Get the origin of the dataset. The origin is the position in world coordinates of the point of extent (0,0,0). This point does not have to be part of the dataset, in other words, the dataset extent does not have to start at (0,0,0) and the origin can be outside of the dataset bounding box. The origin plus spacing determine the position in space of the points.  
\item {\ttfamily obj.\-Set\-Scalar\-Type\-To\-Float ()} -\/ Set/\-Get the data scalar type (i.\-e V\-T\-K\-\_\-\-D\-O\-U\-B\-L\-E). Note that these methods are setting and getting the pipeline scalar type. i.\-e. they are setting the type that the image data will be once it has executed. Until the R\-E\-Q\-U\-E\-S\-T\-\_\-\-D\-A\-T\-A pass the actual scalars may be of some other type. This is for backwards compatibility  
\item {\ttfamily obj.\-Set\-Scalar\-Type\-To\-Double ()} -\/ Set/\-Get the data scalar type (i.\-e V\-T\-K\-\_\-\-D\-O\-U\-B\-L\-E). Note that these methods are setting and getting the pipeline scalar type. i.\-e. they are setting the type that the image data will be once it has executed. Until the R\-E\-Q\-U\-E\-S\-T\-\_\-\-D\-A\-T\-A pass the actual scalars may be of some other type. This is for backwards compatibility  
\item {\ttfamily obj.\-Set\-Scalar\-Type\-To\-Int ()} -\/ Set/\-Get the data scalar type (i.\-e V\-T\-K\-\_\-\-D\-O\-U\-B\-L\-E). Note that these methods are setting and getting the pipeline scalar type. i.\-e. they are setting the type that the image data will be once it has executed. Until the R\-E\-Q\-U\-E\-S\-T\-\_\-\-D\-A\-T\-A pass the actual scalars may be of some other type. This is for backwards compatibility  
\item {\ttfamily obj.\-Set\-Scalar\-Type\-To\-Unsigned\-Int ()} -\/ Set/\-Get the data scalar type (i.\-e V\-T\-K\-\_\-\-D\-O\-U\-B\-L\-E). Note that these methods are setting and getting the pipeline scalar type. i.\-e. they are setting the type that the image data will be once it has executed. Until the R\-E\-Q\-U\-E\-S\-T\-\_\-\-D\-A\-T\-A pass the actual scalars may be of some other type. This is for backwards compatibility  
\item {\ttfamily obj.\-Set\-Scalar\-Type\-To\-Long ()} -\/ Set/\-Get the data scalar type (i.\-e V\-T\-K\-\_\-\-D\-O\-U\-B\-L\-E). Note that these methods are setting and getting the pipeline scalar type. i.\-e. they are setting the type that the image data will be once it has executed. Until the R\-E\-Q\-U\-E\-S\-T\-\_\-\-D\-A\-T\-A pass the actual scalars may be of some other type. This is for backwards compatibility  
\item {\ttfamily obj.\-Set\-Scalar\-Type\-To\-Unsigned\-Long ()} -\/ Set/\-Get the data scalar type (i.\-e V\-T\-K\-\_\-\-D\-O\-U\-B\-L\-E). Note that these methods are setting and getting the pipeline scalar type. i.\-e. they are setting the type that the image data will be once it has executed. Until the R\-E\-Q\-U\-E\-S\-T\-\_\-\-D\-A\-T\-A pass the actual scalars may be of some other type. This is for backwards compatibility  
\item {\ttfamily obj.\-Set\-Scalar\-Type\-To\-Short ()} -\/ Set/\-Get the data scalar type (i.\-e V\-T\-K\-\_\-\-D\-O\-U\-B\-L\-E). Note that these methods are setting and getting the pipeline scalar type. i.\-e. they are setting the type that the image data will be once it has executed. Until the R\-E\-Q\-U\-E\-S\-T\-\_\-\-D\-A\-T\-A pass the actual scalars may be of some other type. This is for backwards compatibility  
\item {\ttfamily obj.\-Set\-Scalar\-Type\-To\-Unsigned\-Short ()} -\/ Set/\-Get the data scalar type (i.\-e V\-T\-K\-\_\-\-D\-O\-U\-B\-L\-E). Note that these methods are setting and getting the pipeline scalar type. i.\-e. they are setting the type that the image data will be once it has executed. Until the R\-E\-Q\-U\-E\-S\-T\-\_\-\-D\-A\-T\-A pass the actual scalars may be of some other type. This is for backwards compatibility  
\item {\ttfamily obj.\-Set\-Scalar\-Type\-To\-Unsigned\-Char ()} -\/ Set/\-Get the data scalar type (i.\-e V\-T\-K\-\_\-\-D\-O\-U\-B\-L\-E). Note that these methods are setting and getting the pipeline scalar type. i.\-e. they are setting the type that the image data will be once it has executed. Until the R\-E\-Q\-U\-E\-S\-T\-\_\-\-D\-A\-T\-A pass the actual scalars may be of some other type. This is for backwards compatibility  
\item {\ttfamily obj.\-Set\-Scalar\-Type\-To\-Signed\-Char ()} -\/ Set/\-Get the data scalar type (i.\-e V\-T\-K\-\_\-\-D\-O\-U\-B\-L\-E). Note that these methods are setting and getting the pipeline scalar type. i.\-e. they are setting the type that the image data will be once it has executed. Until the R\-E\-Q\-U\-E\-S\-T\-\_\-\-D\-A\-T\-A pass the actual scalars may be of some other type. This is for backwards compatibility  
\item {\ttfamily obj.\-Set\-Scalar\-Type\-To\-Char ()} -\/ Set/\-Get the data scalar type (i.\-e V\-T\-K\-\_\-\-D\-O\-U\-B\-L\-E). Note that these methods are setting and getting the pipeline scalar type. i.\-e. they are setting the type that the image data will be once it has executed. Until the R\-E\-Q\-U\-E\-S\-T\-\_\-\-D\-A\-T\-A pass the actual scalars may be of some other type. This is for backwards compatibility  
\item {\ttfamily obj.\-Set\-Scalar\-Type (int )} -\/ Set/\-Get the data scalar type (i.\-e V\-T\-K\-\_\-\-D\-O\-U\-B\-L\-E). Note that these methods are setting and getting the pipeline scalar type. i.\-e. they are setting the type that the image data will be once it has executed. Until the R\-E\-Q\-U\-E\-S\-T\-\_\-\-D\-A\-T\-A pass the actual scalars may be of some other type. This is for backwards compatibility  
\item {\ttfamily int = obj.\-Get\-Scalar\-Type ()} -\/ Set/\-Get the data scalar type (i.\-e V\-T\-K\-\_\-\-D\-O\-U\-B\-L\-E). Note that these methods are setting and getting the pipeline scalar type. i.\-e. they are setting the type that the image data will be once it has executed. Until the R\-E\-Q\-U\-E\-S\-T\-\_\-\-D\-A\-T\-A pass the actual scalars may be of some other type. This is for backwards compatibility  
\item {\ttfamily string = obj.\-Get\-Scalar\-Type\-As\-String ()} -\/ Set/\-Get the data scalar type (i.\-e V\-T\-K\-\_\-\-D\-O\-U\-B\-L\-E). Note that these methods are setting and getting the pipeline scalar type. i.\-e. they are setting the type that the image data will be once it has executed. Until the R\-E\-Q\-U\-E\-S\-T\-\_\-\-D\-A\-T\-A pass the actual scalars may be of some other type. This is for backwards compatibility  
\item {\ttfamily obj.\-Set\-Number\-Of\-Scalar\-Components (int n)} -\/ Set/\-Get the number of scalar components for points. As with the Set\-Scalar\-Type method this is setting pipeline info.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Scalar\-Components ()} -\/ Set/\-Get the number of scalar components for points. As with the Set\-Scalar\-Type method this is setting pipeline info.  
\item {\ttfamily obj.\-Copy\-Type\-Specific\-Information (vtk\-Data\-Object image)}  
\item {\ttfamily obj.\-Copy\-Information\-To\-Pipeline (vtk\-Information request, vtk\-Information input, vtk\-Information output, int force\-Copy)} -\/ Override these to handle origin, spacing, scalar type, and scalar number of components. See vtk\-Data\-Object for details.  
\item {\ttfamily obj.\-Copy\-Information\-From\-Pipeline (vtk\-Information request)} -\/ Override these to handle origin, spacing, scalar type, and scalar number of components. See vtk\-Data\-Object for details.  
\item {\ttfamily obj.\-Prepare\-For\-New\-Data ()} -\/ make the output data ready for new data to be inserted. For most objects we just call Initialize. But for image data we leave the old data in case the memory can be reused.  
\item {\ttfamily obj.\-Shallow\-Copy (vtk\-Data\-Object src)} -\/ Shallow and Deep copy.  
\item {\ttfamily obj.\-Deep\-Copy (vtk\-Data\-Object src)} -\/ Shallow and Deep copy.  
\item {\ttfamily obj.\-Compute\-Internal\-Extent (int int\-Ext, int tgt\-Ext, int bnds)} -\/ Given how many pixel are required on a side for bounrary conditions (in bnds), the target extent to traverse, compute the internal extent (the extent for this Image\-Data that does nto suffer from any boundary conditions) and place it in int\-Ext  
\item {\ttfamily int = obj.\-Get\-Extent\-Type ()} -\/ The extent type is a 3\-D extent  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkimageinplacefilter}{}\section{vtk\-Image\-In\-Place\-Filter}\label{vtkfiltering_vtkimageinplacefilter}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Image\-In\-Place\-Filter is a filter super class that operates directly on the input region. The data is copied if the requested region has different extent than the input region or some other object is referencing the input region.

To create an instance of class vtk\-Image\-In\-Place\-Filter, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkImageInPlaceFilter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Image\-In\-Place\-Filter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Image\-In\-Place\-Filter class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Image\-In\-Place\-Filter = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Image\-In\-Place\-Filter = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkimagemultipleinputfilter}{}\section{vtk\-Image\-Multiple\-Input\-Filter}\label{vtkfiltering_vtkimagemultipleinputfilter}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Image\-Multiple\-Input\-Filter is a super class for filters that have any number of inputs. Streaming is not available in this class yet.

To create an instance of class vtk\-Image\-Multiple\-Input\-Filter, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkImageMultipleInputFilter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Image\-Multiple\-Input\-Filter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Image\-Multiple\-Input\-Filter class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Image\-Multiple\-Input\-Filter = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Image\-Multiple\-Input\-Filter = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Input (int num, vtk\-Image\-Data input)} -\/ Set an Input of this filter.  
\item {\ttfamily obj.\-Add\-Input (vtk\-Image\-Data input)} -\/ Adds an input to the first null position in the input list. Expands the list memory if necessary  
\item {\ttfamily obj.\-Remove\-Input (vtk\-Image\-Data input)} -\/ Adds an input to the first null position in the input list. Expands the list memory if necessary  
\item {\ttfamily vtk\-Image\-Data = obj.\-Get\-Input (int num)} -\/ Get one input to this filter.  
\item {\ttfamily vtk\-Image\-Data = obj.\-Get\-Input ()} -\/ Get one input to this filter.  
\item {\ttfamily obj.\-Set\-Bypass (int )} -\/ Turning bypass on will cause the filter to turn off and simply pass the data from the first input (input0) through. It is implemented for consistency with vtk\-Image\-To\-Image\-Filter.  
\item {\ttfamily int = obj.\-Get\-Bypass ()} -\/ Turning bypass on will cause the filter to turn off and simply pass the data from the first input (input0) through. It is implemented for consistency with vtk\-Image\-To\-Image\-Filter.  
\item {\ttfamily obj.\-Bypass\-On ()} -\/ Turning bypass on will cause the filter to turn off and simply pass the data from the first input (input0) through. It is implemented for consistency with vtk\-Image\-To\-Image\-Filter.  
\item {\ttfamily obj.\-Bypass\-Off ()} -\/ Turning bypass on will cause the filter to turn off and simply pass the data from the first input (input0) through. It is implemented for consistency with vtk\-Image\-To\-Image\-Filter.  
\item {\ttfamily obj.\-Set\-Number\-Of\-Threads (int )} -\/ Get/\-Set the number of threads to create when rendering  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Threads\-Min\-Value ()} -\/ Get/\-Set the number of threads to create when rendering  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Threads\-Max\-Value ()} -\/ Get/\-Set the number of threads to create when rendering  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Threads ()} -\/ Get/\-Set the number of threads to create when rendering  
\item {\ttfamily int = obj.\-Split\-Extent (int split\-Ext\mbox{[}6\mbox{]}, int start\-Ext\mbox{[}6\mbox{]}, int num, int total)} -\/ Putting this here until I merge graphics and imaging streaming.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkimagemultipleinputoutputfilter}{}\section{vtk\-Image\-Multiple\-Input\-Output\-Filter}\label{vtkfiltering_vtkimagemultipleinputoutputfilter}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Image\-Multiple\-Input\-Output\-Filter is a super class for filters that have any number of inputs. Streaming is not available in this class yet.

To create an instance of class vtk\-Image\-Multiple\-Input\-Output\-Filter, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkImageMultipleInputOutputFilter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Image\-Multiple\-Input\-Output\-Filter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Image\-Multiple\-Input\-Output\-Filter class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Image\-Multiple\-Input\-Output\-Filter = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Image\-Multiple\-Input\-Output\-Filter = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Image\-Data = obj.\-Get\-Output (int num)} -\/ Get one input to this filter.  
\item {\ttfamily vtk\-Image\-Data = obj.\-Get\-Output ()} -\/ Get one input to this filter.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkimagesource}{}\section{vtk\-Image\-Source}\label{vtkfiltering_vtkimagesource}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Image\-Source is the superclass for all imaging sources and filters. The method Update(), called by the cache, is the major interface to the source.

To create an instance of class vtk\-Image\-Source, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkImageSource
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Image\-Source has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Image\-Source class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Image\-Source = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Image\-Source = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Output (vtk\-Image\-Data output)} -\/ Get the output of this source.  
\item {\ttfamily vtk\-Image\-Data = obj.\-Get\-Output ()} -\/ Get the output of this source.  
\item {\ttfamily vtk\-Image\-Data = obj.\-Get\-Output (int idx)} -\/ Get the output of this source.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkimagetoimagefilter}{}\section{vtk\-Image\-To\-Image\-Filter}\label{vtkfiltering_vtkimagetoimagefilter}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Image\-To\-Image\-Filter is a filter superclass that hides much of the pipeline complexity. It handles breaking the pipeline execution into smaller extents so that the vtk\-Image\-Data limits are observed. It also provides support for multithreading. If you don't need any of this functionality, consider using vtk\-Simple\-Image\-To\-Image\-Filter instead. .S\-E\-C\-T\-I\-O\-N Warning This used to be the parent class for most imaging filter in V\-T\-K4.\-x, now this role has been replaced by vtk\-Image\-Algorithm. You should consider using vtk\-Image\-Algorithm instead, when writing filter for V\-T\-K5 and above. This class was kept to ensure full backward compatibility. .S\-E\-C\-T\-I\-O\-N See also vtk\-Simple\-Image\-To\-Image\-Filter vtk\-Image\-Spatial\-Filter vtk\-Image\-Algorithm

To create an instance of class vtk\-Image\-To\-Image\-Filter, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkImageToImageFilter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Image\-To\-Image\-Filter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Image\-To\-Image\-Filter class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Image\-To\-Image\-Filter = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Image\-To\-Image\-Filter = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Input (vtk\-Image\-Data input)} -\/ Set the Input of a filter.  
\item {\ttfamily vtk\-Image\-Data = obj.\-Get\-Input ()} -\/ Set the Input of a filter.  
\item {\ttfamily obj.\-Set\-Bypass (int )} -\/ Obsolete feature -\/ do not use.  
\item {\ttfamily obj.\-Bypass\-On ()} -\/ Obsolete feature -\/ do not use.  
\item {\ttfamily obj.\-Bypass\-Off ()} -\/ Obsolete feature -\/ do not use.  
\item {\ttfamily int = obj.\-Get\-Bypass ()} -\/ Obsolete feature -\/ do not use.  
\item {\ttfamily obj.\-Threaded\-Execute (vtk\-Image\-Data in\-Data, vtk\-Image\-Data out\-Data, int extent\mbox{[}6\mbox{]}, int thread\-Id)} -\/ If the subclass does not define an Execute method, then the task will be broken up, multiple threads will be spawned, and each thread will call this method. It is public so that the thread functions can call this method.  
\item {\ttfamily obj.\-Set\-Number\-Of\-Threads (int )} -\/ Get/\-Set the number of threads to create when rendering  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Threads\-Min\-Value ()} -\/ Get/\-Set the number of threads to create when rendering  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Threads\-Max\-Value ()} -\/ Get/\-Set the number of threads to create when rendering  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Threads ()} -\/ Get/\-Set the number of threads to create when rendering  
\item {\ttfamily obj.\-Set\-Input\-Memory\-Limit (int )}  
\item {\ttfamily long = obj.\-Get\-Input\-Memory\-Limit ()}  
\item {\ttfamily int = obj.\-Split\-Extent (int split\-Ext\mbox{[}6\mbox{]}, int start\-Ext\mbox{[}6\mbox{]}, int num, int total)} -\/ Putting this here until I merge graphics and imaging streaming.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkimagetostructuredpoints}{}\section{vtk\-Image\-To\-Structured\-Points}\label{vtkfiltering_vtkimagetostructuredpoints}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Image\-To\-Structured\-Points changes an image cache format to a structured points dataset. It takes an Input plus an optional Vector\-Input. The Vector\-Input converts the R\-G\-B scalar components of the Vector\-Input to vector pointdata attributes. This filter will try to reference count the data but in some cases it must make a copy.

To create an instance of class vtk\-Image\-To\-Structured\-Points, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkImageToStructuredPoints
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Image\-To\-Structured\-Points has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Image\-To\-Structured\-Points class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Image\-To\-Structured\-Points = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Image\-To\-Structured\-Points = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Vector\-Input (vtk\-Image\-Data input)} -\/ Set/\-Get the input object from the image pipeline.  
\item {\ttfamily vtk\-Image\-Data = obj.\-Get\-Vector\-Input ()} -\/ Set/\-Get the input object from the image pipeline.  
\item {\ttfamily vtk\-Structured\-Points = obj.\-Get\-Structured\-Points\-Output ()} -\/ Get the output of the filter.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkimagetwoinputfilter}{}\section{vtk\-Image\-Two\-Input\-Filter}\label{vtkfiltering_vtkimagetwoinputfilter}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Image\-Two\-Input\-Filter handles two inputs. It is just a subclass of vtk\-Image\-Multiple\-Input\-Filter with some methods that are specific to two inputs. Although the inputs are labeled input1 and input2, they are stored in an array indexed starting at 0.

To create an instance of class vtk\-Image\-Two\-Input\-Filter, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkImageTwoInputFilter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Image\-Two\-Input\-Filter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Image\-Two\-Input\-Filter class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Image\-Two\-Input\-Filter = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Image\-Two\-Input\-Filter = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Input1 (vtk\-Image\-Data input)} -\/ Set the Input1 of this filter. If a Scalar\-Type has not been set, then the Scalar\-Type of the input is used.  
\item {\ttfamily obj.\-Set\-Input2 (vtk\-Image\-Data input)} -\/ Set the Input2 of this filter. If a Scalar\-Type has not been set, then the Scalar\-Type of the input is used.  
\item {\ttfamily vtk\-Image\-Data = obj.\-Get\-Input1 ()} -\/ Get the inputs to this filter.  
\item {\ttfamily vtk\-Image\-Data = obj.\-Get\-Input2 ()} -\/ Get the inputs to this filter.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkimplicitboolean}{}\section{vtk\-Implicit\-Boolean}\label{vtkfiltering_vtkimplicitboolean}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Implicit\-Boolean is an implicit function consisting of boolean combinations of implicit functions. The class has a list of functions (Function\-List) that are combined according to a specified operator (V\-T\-K\-\_\-\-U\-N\-I\-O\-N or V\-T\-K\-\_\-\-I\-N\-T\-E\-R\-S\-E\-C\-T\-I\-O\-N or V\-T\-K\-\_\-\-D\-I\-F\-F\-E\-R\-E\-N\-C\-E). You can use nested combinations of vtk\-Implicit\-Function's (and/or vtk\-Implicit\-Boolean) to create elaborate implicit functions. vtk\-Implicit\-Boolean is a concrete implementation of vtk\-Implicit\-Function.

The operators work as follows. The V\-T\-K\-\_\-\-U\-N\-I\-O\-N operator takes the minimum value of all implicit functions. The V\-T\-K\-\_\-\-I\-N\-T\-E\-R\-S\-E\-C\-T\-I\-O\-N operator takes the maximum value of all implicit functions. The V\-T\-K\-\_\-\-D\-I\-F\-F\-E\-R\-E\-N\-C\-E operator subtracts the 2nd through last implicit functions from the first. The V\-T\-K\-\_\-\-U\-N\-I\-O\-N\-\_\-\-O\-F\-\_\-\-M\-A\-G\-N\-I\-T\-U\-D\-E\-S takes the minimum absolute value of the implicit functions.

To create an instance of class vtk\-Implicit\-Boolean, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkImplicitBoolean
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Implicit\-Boolean has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Implicit\-Boolean class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Implicit\-Boolean = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Implicit\-Boolean = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily double = obj.\-Evaluate\-Function (double x\mbox{[}3\mbox{]})} -\/ Evaluate boolean combinations of implicit function using current operator.  
\item {\ttfamily double = obj.\-Evaluate\-Function (double x, double y, double z)} -\/ Evaluate boolean combinations of implicit function using current operator.  
\item {\ttfamily obj.\-Evaluate\-Gradient (double x\mbox{[}3\mbox{]}, double g\mbox{[}3\mbox{]})} -\/ Evaluate gradient of boolean combination.  
\item {\ttfamily long = obj.\-Get\-M\-Time ()} -\/ Override modified time retrieval because of object dependencies.  
\item {\ttfamily obj.\-Add\-Function (vtk\-Implicit\-Function in)} -\/ Add another implicit function to the list of functions.  
\item {\ttfamily obj.\-Remove\-Function (vtk\-Implicit\-Function in)} -\/ Remove a function from the list of implicit functions to boolean.  
\item {\ttfamily vtk\-Implicit\-Function\-Collection = obj.\-Get\-Function ()} -\/ Return the collection of implicit functions.  
\item {\ttfamily obj.\-Set\-Operation\-Type (int )} -\/ Specify the type of boolean operation.  
\item {\ttfamily int = obj.\-Get\-Operation\-Type\-Min\-Value ()} -\/ Specify the type of boolean operation.  
\item {\ttfamily int = obj.\-Get\-Operation\-Type\-Max\-Value ()} -\/ Specify the type of boolean operation.  
\item {\ttfamily int = obj.\-Get\-Operation\-Type ()} -\/ Specify the type of boolean operation.  
\item {\ttfamily obj.\-Set\-Operation\-Type\-To\-Union ()} -\/ Specify the type of boolean operation.  
\item {\ttfamily obj.\-Set\-Operation\-Type\-To\-Intersection ()} -\/ Specify the type of boolean operation.  
\item {\ttfamily obj.\-Set\-Operation\-Type\-To\-Difference ()} -\/ Specify the type of boolean operation.  
\item {\ttfamily obj.\-Set\-Operation\-Type\-To\-Union\-Of\-Magnitudes ()} -\/ Specify the type of boolean operation.  
\item {\ttfamily string = obj.\-Get\-Operation\-Type\-As\-String ()} -\/ Specify the type of boolean operation.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkimplicitdataset}{}\section{vtk\-Implicit\-Data\-Set}\label{vtkfiltering_vtkimplicitdataset}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Implicit\-Data\-Set treats any type of dataset as if it were an implicit function. This means it computes a function value and gradient. vtk\-Implicit\-Data\-Set is a concrete implementation of vtk\-Implicit\-Function.

vtk\-Implicit\-Data\-Set computes the function (at the point x) by performing cell interpolation. That is, it finds the cell containing x, and then uses the cell's interpolation functions to compute an interpolated scalar value at x. (A similar approach is used to find the gradient, if requested.) Points outside of the dataset are assigned the value of the ivar Out\-Value, and the gradient value Out\-Gradient.

To create an instance of class vtk\-Implicit\-Data\-Set, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkImplicitDataSet
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Implicit\-Data\-Set has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Implicit\-Data\-Set class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Implicit\-Data\-Set = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Implicit\-Data\-Set = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily long = obj.\-Get\-M\-Time ()} -\/ Return the M\-Time also considering the Data\-Set dependency.  
\item {\ttfamily double = obj.\-Evaluate\-Function (double x\mbox{[}3\mbox{]})}  
\item {\ttfamily double = obj.\-Evaluate\-Function (double x, double y, double z)}  
\item {\ttfamily obj.\-Evaluate\-Gradient (double x\mbox{[}3\mbox{]}, double n\mbox{[}3\mbox{]})}  
\item {\ttfamily obj.\-Set\-Data\-Set (vtk\-Data\-Set )} -\/ Set / get the dataset used for the implicit function evaluation.  
\item {\ttfamily vtk\-Data\-Set = obj.\-Get\-Data\-Set ()} -\/ Set / get the dataset used for the implicit function evaluation.  
\item {\ttfamily obj.\-Set\-Out\-Value (double )} -\/ Set / get the function value to use for points outside of the dataset.  
\item {\ttfamily double = obj.\-Get\-Out\-Value ()} -\/ Set / get the function value to use for points outside of the dataset.  
\item {\ttfamily obj.\-Set\-Out\-Gradient (double , double , double )} -\/ Set / get the function gradient to use for points outside of the dataset.  
\item {\ttfamily obj.\-Set\-Out\-Gradient (double a\mbox{[}3\mbox{]})} -\/ Set / get the function gradient to use for points outside of the dataset.  
\item {\ttfamily double = obj. Get\-Out\-Gradient ()} -\/ Set / get the function gradient to use for points outside of the dataset.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkimplicithalo}{}\section{vtk\-Implicit\-Halo}\label{vtkfiltering_vtkimplicithalo}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Implicit\-Halo evaluates to 1.\-0 for each position in the sphere of a given center and radius Radius$\ast$(1-\/\-Fade\-Out). It evaluates to 0.\-0 for each position out the sphere of a given Center and radius Radius. It fades out linearly from 1.\-0 to 0.\-0 for points in a radius from Radius$\ast$(1-\/\-Fade\-Out) to Radius. vtk\-Implicit\-Halo is a concrete implementation of vtk\-Implicit\-Function. It is useful as an input to vtk\-Sample\-Function to generate an 2\-D image of an halo. It is used this way by vtk\-Shadow\-Map\-Pass.

To create an instance of class vtk\-Implicit\-Halo, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkImplicitHalo
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Implicit\-Halo has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Implicit\-Halo class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Implicit\-Halo = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Implicit\-Halo = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily double = obj.\-Evaluate\-Function (double x\mbox{[}3\mbox{]})}  
\item {\ttfamily double = obj.\-Evaluate\-Function (double x, double y, double z)}  
\item {\ttfamily obj.\-Evaluate\-Gradient (double x\mbox{[}3\mbox{]}, double g\mbox{[}3\mbox{]})}  
\item {\ttfamily obj.\-Set\-Radius (double )} -\/ Radius of the sphere.  
\item {\ttfamily double = obj.\-Get\-Radius ()} -\/ Radius of the sphere.  
\item {\ttfamily obj.\-Set\-Center (double , double , double )} -\/ Center of the sphere.  
\item {\ttfamily obj.\-Set\-Center (double a\mbox{[}3\mbox{]})} -\/ Center of the sphere.  
\item {\ttfamily double = obj. Get\-Center ()} -\/ Center of the sphere.  
\item {\ttfamily obj.\-Set\-Fade\-Out (double )} -\/ Fade\-Out ratio. Valid values are between 0.\-0 and 1.\-0.  
\item {\ttfamily double = obj.\-Get\-Fade\-Out ()} -\/ Fade\-Out ratio. Valid values are between 0.\-0 and 1.\-0.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkimplicitselectionloop}{}\section{vtk\-Implicit\-Selection\-Loop}\label{vtkfiltering_vtkimplicitselectionloop}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Implicit\-Selection\-Loop computes the implicit function value and function gradient for a irregular, cylinder-\/like object whose cross section is defined by a set of points forming a loop. The loop need not be convex nor its points coplanar. However, the loop must be non-\/self-\/intersecting when projected onto the plane defined by the accumulated cross product around the loop (i.\-e., the axis of the loop). (Alternatively, you can specify the normal to use.)

The following procedure is used to compute the implicit function value for a point x. Each point of the loop is first projected onto the plane defined by the loop normal. This forms a polygon. Then, to evaluate the implicit function value, inside/outside tests are used to determine if x is inside the polygon, and the distance to the loop boundary is computed (negative values are inside the loop).

One example application of this implicit function class is to draw a loop on the surface of a mesh, and use the loop to clip or extract cells from within the loop. Remember, the selection loop is \char`\"{}infinite\char`\"{} in length, you can use a plane (in boolean combination) to cap the extent of the selection loop. Another trick is to use a connectivity filter to extract the closest region to a given point (i.\-e., one of the points used to define the selection loop).

To create an instance of class vtk\-Implicit\-Selection\-Loop, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkImplicitSelectionLoop
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Implicit\-Selection\-Loop has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Implicit\-Selection\-Loop class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()} -\/ Standard V\-T\-K methods for printing and type information.  
\item {\ttfamily int = obj.\-Is\-A (string name)} -\/ Standard V\-T\-K methods for printing and type information.  
\item {\ttfamily vtk\-Implicit\-Selection\-Loop = obj.\-New\-Instance ()} -\/ Standard V\-T\-K methods for printing and type information.  
\item {\ttfamily vtk\-Implicit\-Selection\-Loop = obj.\-Safe\-Down\-Cast (vtk\-Object o)} -\/ Standard V\-T\-K methods for printing and type information.  
\item {\ttfamily double = obj.\-Evaluate\-Function (double x\mbox{[}3\mbox{]})} -\/ Evaluate selection loop returning a signed distance.  
\item {\ttfamily double = obj.\-Evaluate\-Function (double x, double y, double z)} -\/ Evaluate selection loop returning a signed distance.  
\item {\ttfamily obj.\-Evaluate\-Gradient (double x\mbox{[}3\mbox{]}, double n\mbox{[}3\mbox{]})} -\/ Evaluate selection loop returning the gradient.  
\item {\ttfamily obj.\-Set\-Loop (vtk\-Points )} -\/ Set/\-Get the array of point coordinates defining the loop. There must be at least three points used to define a loop.  
\item {\ttfamily vtk\-Points = obj.\-Get\-Loop ()} -\/ Set/\-Get the array of point coordinates defining the loop. There must be at least three points used to define a loop.  
\item {\ttfamily obj.\-Set\-Automatic\-Normal\-Generation (int )} -\/ Turn on/off automatic normal generation. By default, the normal is computed from the accumulated cross product of the edges. You can also specify the normal to use.  
\item {\ttfamily int = obj.\-Get\-Automatic\-Normal\-Generation ()} -\/ Turn on/off automatic normal generation. By default, the normal is computed from the accumulated cross product of the edges. You can also specify the normal to use.  
\item {\ttfamily obj.\-Automatic\-Normal\-Generation\-On ()} -\/ Turn on/off automatic normal generation. By default, the normal is computed from the accumulated cross product of the edges. You can also specify the normal to use.  
\item {\ttfamily obj.\-Automatic\-Normal\-Generation\-Off ()} -\/ Turn on/off automatic normal generation. By default, the normal is computed from the accumulated cross product of the edges. You can also specify the normal to use.  
\item {\ttfamily obj.\-Set\-Normal (double , double , double )} -\/ Set / get the normal used to determine whether a point is inside or outside the selection loop.  
\item {\ttfamily obj.\-Set\-Normal (double a\mbox{[}3\mbox{]})} -\/ Set / get the normal used to determine whether a point is inside or outside the selection loop.  
\item {\ttfamily double = obj. Get\-Normal ()} -\/ Set / get the normal used to determine whether a point is inside or outside the selection loop.  
\item {\ttfamily long = obj.\-Get\-M\-Time ()} -\/ Overload Get\-M\-Time() because we depend on the Loop  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkimplicitsum}{}\section{vtk\-Implicit\-Sum}\label{vtkfiltering_vtkimplicitsum}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Implicit\-Sum produces a linear combination of other implicit functions. The contribution of each function is weighted by a scalar coefficient. The Normalize\-By\-Weight option normalizes the output so that the scalar weights add up to 1. Note that this function gives accurate sums and gradients only if the input functions are linear.

To create an instance of class vtk\-Implicit\-Sum, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkImplicitSum
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Implicit\-Sum has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Implicit\-Sum class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Implicit\-Sum = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Implicit\-Sum = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily double = obj.\-Evaluate\-Function (double x\mbox{[}3\mbox{]})} -\/ Evaluate implicit function using current functions and weights.  
\item {\ttfamily double = obj.\-Evaluate\-Function (double x, double y, double z)} -\/ Evaluate implicit function using current functions and weights.  
\item {\ttfamily obj.\-Evaluate\-Gradient (double x\mbox{[}3\mbox{]}, double g\mbox{[}3\mbox{]})} -\/ Evaluate gradient of the weighted sum of functions. Input functions should be linear.  
\item {\ttfamily long = obj.\-Get\-M\-Time ()} -\/ Override modified time retrieval because of object dependencies.  
\item {\ttfamily obj.\-Add\-Function (vtk\-Implicit\-Function in, double weight)} -\/ Add another implicit function to the list of functions, along with a weighting factor.  
\item {\ttfamily obj.\-Add\-Function (vtk\-Implicit\-Function in)} -\/ Remove all functions from the list.  
\item {\ttfamily obj.\-Remove\-All\-Functions ()} -\/ Remove all functions from the list.  
\item {\ttfamily obj.\-Set\-Function\-Weight (vtk\-Implicit\-Function f, double weight)} -\/ Set the weight (coefficient) of the given function to be weight.  
\item {\ttfamily obj.\-Set\-Normalize\-By\-Weight (int )} -\/ When calculating the function and gradient values of the composite function, setting Normalize\-By\-Weight on will divide the final result by the total weight of the component functions. This process does not otherwise normalize the gradient vector. By default, Normalize\-By\-Weight is off.  
\item {\ttfamily int = obj.\-Get\-Normalize\-By\-Weight ()} -\/ When calculating the function and gradient values of the composite function, setting Normalize\-By\-Weight on will divide the final result by the total weight of the component functions. This process does not otherwise normalize the gradient vector. By default, Normalize\-By\-Weight is off.  
\item {\ttfamily obj.\-Normalize\-By\-Weight\-On ()} -\/ When calculating the function and gradient values of the composite function, setting Normalize\-By\-Weight on will divide the final result by the total weight of the component functions. This process does not otherwise normalize the gradient vector. By default, Normalize\-By\-Weight is off.  
\item {\ttfamily obj.\-Normalize\-By\-Weight\-Off ()} -\/ When calculating the function and gradient values of the composite function, setting Normalize\-By\-Weight on will divide the final result by the total weight of the component functions. This process does not otherwise normalize the gradient vector. By default, Normalize\-By\-Weight is off.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkimplicitvolume}{}\section{vtk\-Implicit\-Volume}\label{vtkfiltering_vtkimplicitvolume}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Implicit\-Volume treats a volume (e.\-g., structured point dataset) as if it were an implicit function. This means it computes a function value and gradient. vtk\-Implicit\-Volume is a concrete implementation of vtk\-Implicit\-Function.

vtk\-Implicit\-Data\-Set computes the function (at the point x) by performing cell interpolation. That is, it finds the cell containing x, and then uses the cell's interpolation functions to compute an interpolated scalar value at x. (A similar approach is used to find the gradient, if requested.) Points outside of the dataset are assigned the value of the ivar Out\-Value, and the gradient value Out\-Gradient.

To create an instance of class vtk\-Implicit\-Volume, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkImplicitVolume
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Implicit\-Volume has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Implicit\-Volume class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Implicit\-Volume = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Implicit\-Volume = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily long = obj.\-Get\-M\-Time ()} -\/ Returns the mtime also considering the volume. This also calls Update on the volume, and it therefore must be called before the function is evaluated.  
\item {\ttfamily double = obj.\-Evaluate\-Function (double x\mbox{[}3\mbox{]})}  
\item {\ttfamily double = obj.\-Evaluate\-Function (double x, double y, double z)}  
\item {\ttfamily obj.\-Evaluate\-Gradient (double x\mbox{[}3\mbox{]}, double n\mbox{[}3\mbox{]})}  
\item {\ttfamily obj.\-Set\-Volume (vtk\-Image\-Data )} -\/ Specify the volume for the implicit function.  
\item {\ttfamily vtk\-Image\-Data = obj.\-Get\-Volume ()} -\/ Specify the volume for the implicit function.  
\item {\ttfamily obj.\-Set\-Out\-Value (double )} -\/ Set the function value to use for points outside of the dataset.  
\item {\ttfamily double = obj.\-Get\-Out\-Value ()} -\/ Set the function value to use for points outside of the dataset.  
\item {\ttfamily obj.\-Set\-Out\-Gradient (double , double , double )} -\/ Set the function gradient to use for points outside of the dataset.  
\item {\ttfamily obj.\-Set\-Out\-Gradient (double a\mbox{[}3\mbox{]})} -\/ Set the function gradient to use for points outside of the dataset.  
\item {\ttfamily double = obj. Get\-Out\-Gradient ()} -\/ Set the function gradient to use for points outside of the dataset.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkimplicitwindowfunction}{}\section{vtk\-Implicit\-Window\-Function}\label{vtkfiltering_vtkimplicitwindowfunction}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Implicit\-Window\-Function is used to modify the output of another implicit function to lie within a specified \char`\"{}window\char`\"{}, or function range. This can be used to add \char`\"{}thickness\char`\"{} to cutting or clipping functions.

This class works as follows. First, it evaluates the function value of the user-\/specified implicit function. Then, based on the window range specified, it maps the function value into the window values specified.

To create an instance of class vtk\-Implicit\-Window\-Function, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkImplicitWindowFunction
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Implicit\-Window\-Function has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Implicit\-Window\-Function class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Implicit\-Window\-Function = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Implicit\-Window\-Function = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily double = obj.\-Evaluate\-Function (double x\mbox{[}3\mbox{]})}  
\item {\ttfamily double = obj.\-Evaluate\-Function (double x, double y, double z)}  
\item {\ttfamily obj.\-Evaluate\-Gradient (double x\mbox{[}3\mbox{]}, double n\mbox{[}3\mbox{]})}  
\item {\ttfamily obj.\-Set\-Implicit\-Function (vtk\-Implicit\-Function )} -\/ Specify an implicit function to operate on.  
\item {\ttfamily vtk\-Implicit\-Function = obj.\-Get\-Implicit\-Function ()} -\/ Specify an implicit function to operate on.  
\item {\ttfamily obj.\-Set\-Window\-Range (double , double )} -\/ Specify the range of function values which are considered to lie within the window. Window\-Range\mbox{[}0\mbox{]} is assumed to be less than Window\-Range\mbox{[}1\mbox{]}.  
\item {\ttfamily obj.\-Set\-Window\-Range (double a\mbox{[}2\mbox{]})} -\/ Specify the range of function values which are considered to lie within the window. Window\-Range\mbox{[}0\mbox{]} is assumed to be less than Window\-Range\mbox{[}1\mbox{]}.  
\item {\ttfamily double = obj. Get\-Window\-Range ()} -\/ Specify the range of function values which are considered to lie within the window. Window\-Range\mbox{[}0\mbox{]} is assumed to be less than Window\-Range\mbox{[}1\mbox{]}.  
\item {\ttfamily obj.\-Set\-Window\-Values (double , double )} -\/ Specify the range of output values that the window range is mapped into. This is effectively a scaling and shifting of the original function values.  
\item {\ttfamily obj.\-Set\-Window\-Values (double a\mbox{[}2\mbox{]})} -\/ Specify the range of output values that the window range is mapped into. This is effectively a scaling and shifting of the original function values.  
\item {\ttfamily double = obj. Get\-Window\-Values ()} -\/ Specify the range of output values that the window range is mapped into. This is effectively a scaling and shifting of the original function values.  
\item {\ttfamily long = obj.\-Get\-M\-Time ()} -\/ Override modified time retrieval because of object dependencies.  
\item {\ttfamily obj.\-Register (vtk\-Object\-Base o)} -\/ Participate in garbage collection.  
\item {\ttfamily obj.\-Un\-Register (vtk\-Object\-Base o)} -\/ Participate in garbage collection.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkincrementaloctreenode}{}\section{vtk\-Incremental\-Octree\-Node}\label{vtkfiltering_vtkincrementaloctreenode}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Octree nodes serve as spatial sub-\/division primitives to build the search structure of an incremental octree in a recursive top-\/down manner. The hierarchy takes the form of a tree-\/like representation by which a parent node contains eight mutually non-\/overlapping child nodes. Each child is assigned with an axis-\/aligned rectangular volume (Spatial Bounding Box) and the eight children together cover exactly the same region as governed by their parent. The eight child nodes / octants are ordered as

\{ (x\-B\-Box\-Min, x\-B\-Box\-Mid\mbox{]} \& (y\-B\-Box\-Min, y\-B\-Box\-Mid\mbox{]} \& (z\-B\-Box\-Min, z\-B\-Box\-Mid\mbox{]} \}, \{ (x\-B\-Box\-Mid, x\-B\-Box\-Max\mbox{]} \& (y\-B\-Box\-Min, y\-B\-Box\-Mid\mbox{]} \& (z\-B\-Box\-Min, z\-B\-Box\-Mid\mbox{]} \}, \{ (x\-B\-Box\-Min, x\-B\-Box\-Mid\mbox{]} \& (y\-B\-Box\-Mid, y\-B\-Box\-Max\mbox{]} \& (z\-B\-Box\-Min, z\-B\-Box\-Mid\mbox{]} \}, \{ (x\-B\-Box\-Mid, x\-B\-Box\-Max\mbox{]} \& (y\-B\-Box\-Mid, y\-B\-Box\-Max\mbox{]} \& (z\-B\-Box\-Min, z\-B\-Box\-Mid\mbox{]} \}, \{ (x\-B\-Box\-Min, x\-B\-Box\-Mid\mbox{]} \& (y\-B\-Box\-Min, y\-B\-Box\-Mid\mbox{]} \& (z\-B\-Box\-Mid, z\-B\-Box\-Max\mbox{]} \}, \{ (x\-B\-Box\-Mid, x\-B\-Box\-Max\mbox{]} \& (y\-B\-Box\-Min, y\-B\-Box\-Mid\mbox{]} \& (z\-B\-Box\-Mid, z\-B\-Box\-Max\mbox{]} \}, \{ (x\-B\-Box\-Min, x\-B\-Box\-Mid\mbox{]} \& (y\-B\-Box\-Mid, y\-B\-Box\-Max\mbox{]} \& (z\-B\-Box\-Mid, z\-B\-Box\-Max\mbox{]} \}, \{ (x\-B\-Box\-Mid, x\-B\-Box\-Max\mbox{]} \& (y\-B\-Box\-Mid, y\-B\-Box\-Max\mbox{]} \& (z\-B\-Box\-Mid, z\-B\-Box\-Max\mbox{]} \},

where \{ xrange \& y\-Range \& z\-Range \} defines the region of each 3\-D octant. In addition, the points falling within and registered, by means of point indices, in the parent node are distributed to the child nodes for delegated maintenance. In fact, only leaf nodes, i.\-e., those without any descendants, actually store point indices while each node, regardless of a leaf or non-\/ leaf node, keeps a dynamically updated Data Bounding Box of the inhabitant points, if any. Given a maximum number of points per leaf node, an octree is initialized with an empty leaf node that is then recursively sub-\/divided, but only on demand as points are incrementally inserted, to construct a populated tree.

Please note that this octree node class is able to handle a large number of E\-X\-A\-C\-T\-L\-Y duplicate points that is greater than the specified maximum number of points per leaf node. In other words, as an exception, a leaf node may maintain an arbitrary number of exactly duplicate points to deal with possible extreme cases.

To create an instance of class vtk\-Incremental\-Octree\-Node, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkIncrementalOctreeNode
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Incremental\-Octree\-Node has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Incremental\-Octree\-Node class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Incremental\-Octree\-Node = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Incremental\-Octree\-Node = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Points ()} -\/ Get the number of points inside or under this node.  
\item {\ttfamily vtk\-Id\-List = obj.\-Get\-Point\-Id\-Set ()} -\/ Get the list of point indices, N\-U\-L\-L for a non-\/leaf node.  
\item {\ttfamily obj.\-Delete\-Child\-Nodes ()} -\/ Delete the eight child nodes.  
\item {\ttfamily obj.\-Set\-Bounds (double x1, double x2, double y1, double y2, double z1, double z2)} -\/ Set the spatial bounding box of the node. This function sets a default data bounding box.  
\item {\ttfamily obj.\-Get\-Bounds (double bounds\mbox{[}6\mbox{]}) const} -\/ Get the spatial bounding box of the node. The values are returned via an array in order of\-: x\-\_\-min, x\-\_\-max, y\-\_\-min, y\-\_\-max, z\-\_\-min, z\-\_\-max.  
\item {\ttfamily double = obj. Get\-Min\-Bounds ()} -\/ Get access to Min\-Bounds. Do not free this pointer.  
\item {\ttfamily double = obj. Get\-Max\-Bounds ()} -\/ Get access to Max\-Bounds. Do not free this pointer.  
\item {\ttfamily int = obj.\-Is\-Leaf ()} -\/ Determine which specific child / octant contains a given point. Note that the point is assumed to be inside this node and no checking is performed on the inside issue.  
\item {\ttfamily int = obj.\-Get\-Child\-Index (double point\mbox{[}3\mbox{]})} -\/ Determine which specific child / octant contains a given point. Note that the point is assumed to be inside this node and no checking is performed on the inside issue.  
\item {\ttfamily vtk\-Incremental\-Octree\-Node = obj.\-Get\-Child (int i)} -\/ A point is in a node if and only if Min\-Bounds\mbox{[}i\mbox{]} $<$ p\mbox{[}i\mbox{]} $<$= Max\-Bounds\mbox{[}i\mbox{]}, which allows a node to be divided into eight non-\/overlapping children.  
\item {\ttfamily int = obj.\-Contains\-Point (double pnt\mbox{[}3\mbox{]})} -\/ A point is in a node if and only if Min\-Bounds\mbox{[}i\mbox{]} $<$ p\mbox{[}i\mbox{]} $<$= Max\-Bounds\mbox{[}i\mbox{]}, which allows a node to be divided into eight non-\/overlapping children.  
\item {\ttfamily int = obj.\-Contains\-Point\-By\-Data (double pnt\mbox{[}3\mbox{]})} -\/ A point is in a node, in terms of data, if and only if Min\-Data\-Bounds\mbox{[}i\mbox{]} $<$= p\mbox{[}i\mbox{]} $<$= Max\-Data\-Bounds\mbox{[}i\mbox{]}.  
\item {\ttfamily double = obj.\-Get\-Distance2\-To\-Inner\-Boundary (double point\mbox{[}3\mbox{]}, vtk\-Incremental\-Octree\-Node root\-Node)} -\/ Given a point inside this node, get the minimum squared distance to all inner boundaries. An inner boundary is a node's face that is shared by another non-\/root node.  
\item {\ttfamily double = obj.\-Get\-Distance2\-To\-Boundary (double point\mbox{[}3\mbox{]}, vtk\-Incremental\-Octree\-Node root\-Node, int check\-Data)} -\/ Compute the minimum squared distance from a point to this node, with all six boundaries considered. The data bounding box is checked if check\-Data is non-\/zero.  
\item {\ttfamily double = obj.\-Get\-Distance2\-To\-Boundary (double point\mbox{[}3\mbox{]}, double closest\mbox{[}3\mbox{]}, vtk\-Incremental\-Octree\-Node root\-Node, int check\-Data)} -\/ Compute the minimum squared distance from a point to this node, with all six boundaries considered. The data bounding box is checked if check\-Data is non-\/zero. The closest on-\/boundary point is returned via closest.  
\item {\ttfamily obj.\-Export\-All\-Point\-Ids\-By\-Insertion (vtk\-Id\-List id\-List)} -\/ Export all the indices of the points (contained in or under this node) by inserting them to an allocated vtk\-Id\-List via vtk\-Id\-List\-::\-Insert\-Next\-Id().  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkincrementaloctreepointlocator}{}\section{vtk\-Incremental\-Octree\-Point\-Locator}\label{vtkfiltering_vtkincrementaloctreepointlocator}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
As opposed to the uniform bin-\/based search structure (adopted in class vtk\-Point\-Locator) with a fixed spatial resolution, an octree mechanism employs a hierarchy of tree-\/like sub-\/division of the 3\-D data domain. Thus it enables data-\/aware multi-\/resolution and accordingly accelerated point location as well as insertion, particularly when handling a radically imbalanced layout of points as not uncommon in datasets defined on adaptive meshes. Compared to a static point locator supporting pure location functionalities through some search structure established from a fixed set of points, an incremental point locator allows for, in addition, point insertion capabilities, with the search structure maintaining a dynamically increasing number of points. Class vtk\-Incremental\-Octree\-Point\-Locator is an octree-\/based accelerated implementation of the functionalities of the uniform bin-\/based incremental point locator vtk\-Point\-Locator. For point location, an octree is built by accessing a vtk\-Data\-Set, specifically a vtk\-Point\-Set. For point insertion, an empty octree is inited and then incrementally populated as points are inserted. Three increasingly complex point insertion modes, i.\-e., direct check-\/free insertion, zero tolerance insertion, and non-\/zero tolerance insertion, are supported. In fact, the octree used in the point location mode is actually constructed via direct check-\/free point insertion. This class also provides a polygonal representation of the octree boundary.

To create an instance of class vtk\-Incremental\-Octree\-Point\-Locator, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkIncrementalOctreePointLocator
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Incremental\-Octree\-Point\-Locator has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Incremental\-Octree\-Point\-Locator class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Incremental\-Octree\-Point\-Locator = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Incremental\-Octree\-Point\-Locator = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Max\-Points\-Per\-Leaf (int )} -\/ Set/\-Get the maximum number of points that a leaf node may maintain. Note that the actual number of points maintained by a leaf node might exceed this threshold if there is a large number (equal to or greater than the threshold) of exactly duplicate points (with zero distance) to be inserted (e.\-g., to construct an octree for subsequent point location) in extreme cases. Respecting this threshold in such scenarios would cause endless node sub-\/division. Thus this threshold is broken, but only in case of such situations.  
\item {\ttfamily int = obj.\-Get\-Max\-Points\-Per\-Leaf\-Min\-Value ()} -\/ Set/\-Get the maximum number of points that a leaf node may maintain. Note that the actual number of points maintained by a leaf node might exceed this threshold if there is a large number (equal to or greater than the threshold) of exactly duplicate points (with zero distance) to be inserted (e.\-g., to construct an octree for subsequent point location) in extreme cases. Respecting this threshold in such scenarios would cause endless node sub-\/division. Thus this threshold is broken, but only in case of such situations.  
\item {\ttfamily int = obj.\-Get\-Max\-Points\-Per\-Leaf\-Max\-Value ()} -\/ Set/\-Get the maximum number of points that a leaf node may maintain. Note that the actual number of points maintained by a leaf node might exceed this threshold if there is a large number (equal to or greater than the threshold) of exactly duplicate points (with zero distance) to be inserted (e.\-g., to construct an octree for subsequent point location) in extreme cases. Respecting this threshold in such scenarios would cause endless node sub-\/division. Thus this threshold is broken, but only in case of such situations.  
\item {\ttfamily int = obj.\-Get\-Max\-Points\-Per\-Leaf ()} -\/ Set/\-Get the maximum number of points that a leaf node may maintain. Note that the actual number of points maintained by a leaf node might exceed this threshold if there is a large number (equal to or greater than the threshold) of exactly duplicate points (with zero distance) to be inserted (e.\-g., to construct an octree for subsequent point location) in extreme cases. Respecting this threshold in such scenarios would cause endless node sub-\/division. Thus this threshold is broken, but only in case of such situations.  
\item {\ttfamily obj.\-Set\-Build\-Cubic\-Octree (int )} -\/ Set/\-Get whether the search octree is built as a cubic shape or not.  
\item {\ttfamily int = obj.\-Get\-Build\-Cubic\-Octree ()} -\/ Set/\-Get whether the search octree is built as a cubic shape or not.  
\item {\ttfamily obj.\-Build\-Cubic\-Octree\-On ()} -\/ Set/\-Get whether the search octree is built as a cubic shape or not.  
\item {\ttfamily obj.\-Build\-Cubic\-Octree\-Off ()} -\/ Set/\-Get whether the search octree is built as a cubic shape or not.  
\item {\ttfamily vtk\-Points = obj.\-Get\-Locator\-Points ()} -\/ Get access to the vtk\-Points object in which point coordinates are stored for either point location or point insertion.  
\item {\ttfamily obj.\-Initialize ()} -\/ Delete the octree search structure.  
\item {\ttfamily obj.\-Free\-Search\-Structure ()} -\/ Delete the octree search structure.  
\item {\ttfamily obj.\-Get\-Bounds (double bounds)} -\/ Get the spatial bounding box of the octree.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Points ()} -\/ Get the number of points maintained by the octree.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Find\-Closest\-Inserted\-Point (double x\mbox{[}3\mbox{]})} -\/ Given a point x assumed to be covered by the octree, return the index of the closest in-\/octree point regardless of the associated minimum squared distance relative to the squared insertion-\/tolerance distance. This method is used when performing incremental point insertion. Note -\/1 indicates that no point is found. Init\-Point\-Insertion() should have been called in advance.  
\item {\ttfamily obj.\-Generate\-Representation (int node\-Level, vtk\-Poly\-Data polys\-Data)} -\/ Create a polygonal representation of the octree boundary (from the root node to a specified level).  
\item {\ttfamily obj.\-Build\-Locator ()} -\/ Load points from a dataset to construct an octree for point location. This function resorts to Init\-Point\-Insertion() to fulfill some of the work.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Find\-Closest\-Point (double x\mbox{[}3\mbox{]})} -\/ Given a point x, return the id of the closest point. Build\-Locator() should have been called prior to this function. This method is thread safe if Build\-Locator() is directly or indirectly called from a single thread first.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Find\-Closest\-Point (double x, double y, double z)} -\/ Given a point (x, y, z), return the id of the closest point. Note that Build\-Locator() should have been called prior to this function. This method is thread safe if Build\-Locator() is directly or indirectly called from a single thread first.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Find\-Closest\-Point (double x\mbox{[}3\mbox{]}, double mini\-Dist2)} -\/ Given a point x, return the id of the closest point and the associated minimum squared distance (via mini\-Dist2). Note Build\-Locator() should have been called prior to this function. This method is thread safe if Build\-Locator() is directly or indirectly called from a single thread first.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Find\-Closest\-Point (double x, double y, double z, double mini\-Dist2)} -\/ Given a point (x, y, z), return the id of the closest point and the associated minimum squared distance (via mini\-Dist2). Build\-Locator() should have been called prior to this function. This method is thread safe if Build\-Locator() is directly or indirectly called from a single thread first.  
\item {\ttfamily obj.\-Find\-Points\-Within\-Radius (double R, double x\mbox{[}3\mbox{]}, vtk\-Id\-List result)} -\/ Find all points within a radius R relative to a given point x. The returned point ids (stored in result) are not sorted in any way. Build\-Locator() should have been called prior to this function. This method is thread safe if Build\-Locator() is directly or indirectly called from a single thread first.  
\item {\ttfamily obj.\-Find\-Points\-Within\-Squared\-Radius (double R2, double x\mbox{[}3\mbox{]}, vtk\-Id\-List result)} -\/ Find all points within a squared radius R2 relative to a given point x. The returned point ids (stored in result) are not sorted in any way. Build\-Locator() should have been called prior to this function. This method is thread safe if Build\-Locator() is directly or indirectly called from a single thread first.  
\item {\ttfamily obj.\-Find\-Closest\-N\-Points (int N, double x\mbox{[}3\mbox{]}, vtk\-Id\-List result)} -\/ Find the closest N points to a given point. The returned point ids (via result) are sorted from closest to farthest. Build\-Locator() should have been called prior to this function. This method is thread safe if Build\-Locator() is directly or indirectly called from a single thread first.  
\item {\ttfamily int = obj.\-Init\-Point\-Insertion (vtk\-Points points, double bounds\mbox{[}6\mbox{]})} -\/ Initialize the point insertion process. points is an object, storing 3\-D point coordinates, to which incremental point insertion put coordinates. It is created and provided by an external V\-T\-K class. Argument bounds represents the spatial bounding box, into which the points fall. In fact, an adjusted version of the bounding box is used to build the octree to make sure no any point (to be inserted) falls outside the octree. This function is not thread safe.  
\item {\ttfamily int = obj.\-Init\-Point\-Insertion (vtk\-Points points, double bounds\mbox{[}6\mbox{]}, vtk\-Id\-Type est\-Size)} -\/ Initialize the point insertion process. points is an object, storing 3\-D point coordinates, to which incremental point insertion put coordinates. It is created and provided by an external V\-T\-K class. Argument bounds represents the spatial bounding box, into which the points fall. In fact, an adjusted version of the bounding box is used to build the octree to make sure no any point (to be inserted) falls outside the octree. Argument est\-Size specifies the initial estimated size of the vtk\-Points object. This function is not thread safe.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Is\-Inserted\-Point (double x\mbox{[}3\mbox{]})} -\/ Determine whether or not a given point has been inserted into the octree. Return the id of the already inserted point if true, otherwise return -\/1. Init\-Point\-Insertion() should have been called in advance.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Is\-Inserted\-Point (double x, double y, double z)} -\/ Determine whether or not a given point has been inserted into the octree. Return the id of the already inserted point if true, otherwise return -\/1. Init\-Point\-Insertion() should have been called in advance.  
\item {\ttfamily obj.\-Insert\-Point (vtk\-Id\-Type pt\-Id, double x\mbox{[}3\mbox{]})} -\/ Insert a given point into the octree with a specified point index pt\-Id. Init\-Point\-Insertion() should have been called prior to this function. In addition, Is\-Inserted\-Point() should have been called in advance to ensure that the given point has not been inserted unless point duplication is allowed (Note that in this case, this function involves a repeated leaf container location). vtk\-Points\-::\-Insert\-Point() is invoked.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Insert\-Next\-Point (double x\mbox{[}3\mbox{]})} -\/ Insert a given point into the octree and return the point index. Note that Init\-Point\-Insertion() should have been called prior to this function. In addition, Is\-Inserted\-Point() should have been called in advance to ensure that the given point has not been inserted unless point duplication is allowed (in this case, this function invovles a repeated leaf container location). vtk\-Points\-::\-Insert\-Next\-Point() is invoked.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkincrementalpointlocator}{}\section{vtk\-Incremental\-Point\-Locator}\label{vtkfiltering_vtkincrementalpointlocator}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Compared to a static point locator for pure location functionalities through some search structure established from a fixed set of points, an incremental point locator allows for, in addition, point insertion capabilities, with the search structure maintaining a dynamically increasing number of points. There are two incremental point locators, i.\-e., vtk\-Point\-Locator and vtk\-Incremental\-Octree\-Point\-Locator. As opposed to the uniform bin-\/based search structure (adopted in vtk\-Point\-Locator) with a fixed spatial resolution, an octree mechanism (employed in vtk\-Incremental\-Octree\-Pointlocator) resorts to a hierarchy of tree-\/like sub-\/division of the 3\-D data domain. Thus it enables data-\/aware multi-\/ resolution and accordingly accelerated point location as well as point insertion, particularly when handling a radically imbalanced layout of points as not uncommon in datasets defined on adaptive meshes. In other words, vtk\-Incremental\-Octree\-Point\-Locator is an octree-\/based accelerated implementation of all functionalities of vtk\-Point\-Locator.

To create an instance of class vtk\-Incremental\-Point\-Locator, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkIncrementalPointLocator
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Incremental\-Point\-Locator has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Incremental\-Point\-Locator class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Incremental\-Point\-Locator = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Incremental\-Point\-Locator = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Initialize ()} -\/ Delete the search structure.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Find\-Closest\-Inserted\-Point (double x\mbox{[}3\mbox{]})} -\/ Given a point x assumed to be covered by the search structure, return the index of the closest point (already inserted to the search structure) regardless of the associated minimum squared distance relative to the squared insertion-\/tolerance distance. This method is used when performing incremental point insertion. Note -\/1 indicates that no point is found. Init\-Point\-Insertion() should have been called in advance.  
\item {\ttfamily int = obj.\-Init\-Point\-Insertion (vtk\-Points new\-Pts, double bounds\mbox{[}6\mbox{]})} -\/ Initialize the point insertion process. new\-Pts is an object, storing 3\-D point coordinates, to which incremental point insertion puts coordinates. It is created and provided by an external V\-T\-K class. Argument bounds represents the spatial bounding box, into which the points fall.  
\item {\ttfamily int = obj.\-Init\-Point\-Insertion (vtk\-Points new\-Pts, double bounds\mbox{[}6\mbox{]}, vtk\-Id\-Type est\-Size)} -\/ Initialize the point insertion process. new\-Pts is an object, storing 3\-D point coordinates, to which incremental point insertion puts coordinates. It is created and provided by an external V\-T\-K class. Argument bounds represents the spatial bounding box, into which the points fall.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Is\-Inserted\-Point (double x, double y, double z)} -\/ Determine whether or not a given point has been inserted. Return the id of the already inserted point if true, else return -\/1. Init\-Point\-Insertion() should have been called in advance.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Is\-Inserted\-Point (double x\mbox{[}3\mbox{]})} -\/ Determine whether or not a given point has been inserted. Return the id of the already inserted point if true, else return -\/1. Init\-Point\-Insertion() should have been called in advance.  
\item {\ttfamily obj.\-Insert\-Point (vtk\-Id\-Type pt\-Id, double x\mbox{[}3\mbox{]})} -\/ Insert a given point with a specified point index pt\-Id. Init\-Point\-Insertion() should have been called prior to this function. Also, Is\-Inserted\-Point() should have been called in advance to ensure that the given point has not been inserted unless point duplication is allowed.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Insert\-Next\-Point (double x\mbox{[}3\mbox{]})} -\/ Insert a given point and return the point index. Init\-Point\-Insertion() should have been called prior to this function. Also, Is\-Inserted\-Point() should have been called in advance to ensure that the given point has not been inserted unless point duplication is allowed.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkinedgeiterator}{}\section{vtk\-In\-Edge\-Iterator}\label{vtkfiltering_vtkinedgeiterator}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-In\-Edge\-Iterator iterates through all edges whose target is a particular vertex. Instantiate this class directly and call Initialize() to traverse the vertex of a graph. Alternately, use Get\-In\-Edges() on the graph to initialize the iterator. it-\/$>$Next() returns a vtk\-In\-Edge\-Type structure, which contains Id, the edge's id, and Source, the edge's source vertex.

To create an instance of class vtk\-In\-Edge\-Iterator, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkInEdgeIterator
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-In\-Edge\-Iterator has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-In\-Edge\-Iterator class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-In\-Edge\-Iterator = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-In\-Edge\-Iterator = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Initialize (vtk\-Graph g, vtk\-Id\-Type v)} -\/ Initialize the iterator with a graph and vertex.  
\item {\ttfamily vtk\-Graph = obj.\-Get\-Graph ()} -\/ Get the graph and vertex associated with this iterator.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Vertex ()} -\/ Get the graph and vertex associated with this iterator.  
\item {\ttfamily vtk\-Graph\-Edge = obj.\-Next\-Graph\-Edge ()} -\/ Just like Next(), but returns heavy-\/weight vtk\-Graph\-Edge object instead of the vtk\-Edge\-Type struct, for use with wrappers. The graph edge is owned by this iterator, and changes after each call to Next\-Graph\-Edge().  
\item {\ttfamily bool = obj.\-Has\-Next ()}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkinformationexecutiveportkey}{}\section{vtk\-Information\-Executive\-Port\-Key}\label{vtkfiltering_vtkinformationexecutiveportkey}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Information\-Executive\-Port\-Key is used to represent keys in vtk\-Information for values that are vtk\-Executive instances paired with port numbers.

To create an instance of class vtk\-Information\-Executive\-Port\-Key, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkInformationExecutivePortKey
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Information\-Executive\-Port\-Key has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Information\-Executive\-Port\-Key class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Information\-Executive\-Port\-Key = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Information\-Executive\-Port\-Key = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Information\-Executive\-Port\-Key = obj.(string name, string location)}  
\item {\ttfamily $\sim$vtk\-Information\-Executive\-Port\-Key = obj.()}  
\item {\ttfamily obj.\-Set (vtk\-Information info, vtk\-Executive , int )} -\/ Get/\-Set the value associated with this key in the given information object.  
\item {\ttfamily vtk\-Executive = obj.\-Get\-Executive (vtk\-Information info)} -\/ Get/\-Set the value associated with this key in the given information object.  
\item {\ttfamily int = obj.\-Get\-Port (vtk\-Information info)} -\/ Get/\-Set the value associated with this key in the given information object.  
\item {\ttfamily obj.\-Shallow\-Copy (vtk\-Information from, vtk\-Information to)} -\/ Copy the entry associated with this key from one information object to another. If there is no entry in the first information object for this key, the value is removed from the second.  
\item {\ttfamily obj.\-Report (vtk\-Information info, vtk\-Garbage\-Collector collector)} -\/ Report a reference this key has in the given information object.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkinformationexecutiveportvectorkey}{}\section{vtk\-Information\-Executive\-Port\-Vector\-Key}\label{vtkfiltering_vtkinformationexecutiveportvectorkey}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Information\-Executive\-Port\-Vector\-Key is used to represent keys in vtk\-Information for values that are vectors of vtk\-Executive instances paired with port numbers.

To create an instance of class vtk\-Information\-Executive\-Port\-Vector\-Key, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkInformationExecutivePortVectorKey
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Information\-Executive\-Port\-Vector\-Key has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Information\-Executive\-Port\-Vector\-Key class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Information\-Executive\-Port\-Vector\-Key = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Information\-Executive\-Port\-Vector\-Key = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Information\-Executive\-Port\-Vector\-Key = obj.(string name, string location)}  
\item {\ttfamily $\sim$vtk\-Information\-Executive\-Port\-Vector\-Key = obj.()}  
\item {\ttfamily obj.\-Append (vtk\-Information info, vtk\-Executive executive, int port)} -\/ Get/\-Set the value associated with this key in the given information object.  
\item {\ttfamily obj.\-Remove (vtk\-Information info, vtk\-Executive executive, int port)} -\/ Get/\-Set the value associated with this key in the given information object.  
\item {\ttfamily int = obj.\-Length (vtk\-Information info)} -\/ Get/\-Set the value associated with this key in the given information object.  
\item {\ttfamily obj.\-Shallow\-Copy (vtk\-Information from, vtk\-Information to)} -\/ Copy the entry associated with this key from one information object to another. If there is no entry in the first information object for this key, the value is removed from the second.  
\item {\ttfamily obj.\-Remove (vtk\-Information info)} -\/ Remove this key from the given information object.  
\item {\ttfamily obj.\-Report (vtk\-Information info, vtk\-Garbage\-Collector collector)} -\/ Report a reference this key has in the given information object.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkinterpolatedvelocityfield}{}\section{vtk\-Interpolated\-Velocity\-Field}\label{vtkfiltering_vtkinterpolatedvelocityfield}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Interpolated\-Velocity\-Field acts as a continuous velocity field via cell interpolation on a vtk\-Data\-Set, Number\-Of\-Independent\-Variables = 4 (x,y,z,t) and Number\-Of\-Functions = 3 (u,v,w). As a concrete sub-\/class of vtk\-Abstract\-Interpolated\-Velocity\-Field, this class adopts two levels of cell caching for faster though less robust cell location than its sibling class vtk\-Cell\-Locator\-Interpolated\-Velocity\-Field. Level \#0 begins with intra-\/cell caching. Specifically, if the previous cell is valid and the nex point is still within it, ( vtk\-Cell\-::\-Evaluate\-Position() returns 1, coupled with the new parametric coordinates and weights ), the function values are interpolated and vtk\-Cell\-::\-Evaluate\-Position() is invoked only. If it fails, level \#1 follows by inter-\/cell location of the target cell (that contains the next point). By inter-\/cell, the previous cell gives an important clue / guess or serves as an immediate neighbor to aid in the location of the target cell (as is typically the case with integrating a streamline across cells) by means of vtk\-Data\-Set\-:\-: Find\-Cell(). If this still fails, a global cell search is invoked via vtk\-Data\-Set\-::\-Find\-Cell().

Regardless of inter-\/cell or global search, vtk\-Point\-Locator is employed as a crucial tool underlying the cell locator. The use of vtk\-Point\-Locator casues vtk\-Interpolated\-Velocity\-Field to return false target cells for datasets defined on complex grids.

To create an instance of class vtk\-Interpolated\-Velocity\-Field, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkInterpolatedVelocityField
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Interpolated\-Velocity\-Field has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Interpolated\-Velocity\-Field class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Interpolated\-Velocity\-Field = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Interpolated\-Velocity\-Field = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Add\-Data\-Set (vtk\-Data\-Set dataset)} -\/ Add a dataset used for the implicit function evaluation. If more than one dataset is added, the evaluation point is searched in all until a match is found. T\-H\-I\-S F\-U\-N\-C\-T\-I\-O\-N D\-O\-E\-S N\-O\-T C\-H\-A\-N\-G\-E T\-H\-E R\-E\-F\-E\-R\-E\-N\-C\-E C\-O\-U\-N\-T O\-F D\-A\-T\-A\-S\-E\-T F\-O\-R T\-H\-R\-E\-A\-D S\-A\-F\-E\-T\-Y R\-E\-A\-S\-O\-N\-S.  
\item {\ttfamily int = obj.\-Function\-Values (double x, double f)} -\/ Evaluate the velocity field f at point (x, y, z).  
\item {\ttfamily obj.\-Set\-Last\-Cell\-Id (vtk\-Id\-Type c, int dataindex)} -\/ Set the cell id cached by the last evaluation within a specified dataset.  
\item {\ttfamily obj.\-Set\-Last\-Cell\-Id (vtk\-Id\-Type c)}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkkdnode}{}\section{vtk\-Kd\-Node}\label{vtkfiltering_vtkkdnode}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
To create an instance of class vtk\-Kd\-Node, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkKdNode
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Kd\-Node has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Kd\-Node class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Kd\-Node = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Kd\-Node = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Dim (int )} -\/ Set/\-Get the dimension along which this region is divided. (0 -\/ x, 1 -\/ y, 2 -\/ z, 3 -\/ leaf node (default)).  
\item {\ttfamily int = obj.\-Get\-Dim ()} -\/ Set/\-Get the dimension along which this region is divided. (0 -\/ x, 1 -\/ y, 2 -\/ z, 3 -\/ leaf node (default)).  
\item {\ttfamily double = obj.\-Get\-Division\-Position ()} -\/ Get the location of the division plane along the axis the region is divided. See also Get\-Dim(). The result is undertermined if this node is not divided (a leaf node).  
\item {\ttfamily obj.\-Set\-Number\-Of\-Points (int )} -\/ Set/\-Get the number of points contained in this region.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Points ()} -\/ Set/\-Get the number of points contained in this region.  
\item {\ttfamily obj.\-Set\-Bounds (double x1, double x2, double y1, double y2, double z1, double z2)} -\/ Set/\-Get the bounds of the spatial region represented by this node. Caller allocates storage for 6-\/vector in Get\-Bounds.  
\item {\ttfamily obj.\-Set\-Bounds (double b\mbox{[}6\mbox{]})} -\/ Set/\-Get the bounds of the spatial region represented by this node. Caller allocates storage for 6-\/vector in Get\-Bounds.  
\item {\ttfamily obj.\-Get\-Bounds (double b) const} -\/ Set/\-Get the bounds of the spatial region represented by this node. Caller allocates storage for 6-\/vector in Get\-Bounds.  
\item {\ttfamily obj.\-Set\-Data\-Bounds (double x1, double x2, double y1, double y2, double z1, double z2)} -\/ Set/\-Get the bounds of the points contained in this spatial region. This may be smaller than the bounds of the region itself. Caller allocates storage for 6-\/vector in Get\-Data\-Bounds.  
\item {\ttfamily obj.\-Get\-Data\-Bounds (double b) const} -\/ Set/\-Get the bounds of the points contained in this spatial region. This may be smaller than the bounds of the region itself. Caller allocates storage for 6-\/vector in Get\-Data\-Bounds.  
\item {\ttfamily obj.\-Set\-Data\-Bounds (float v)} -\/ Given a pointer to Number\-Of\-Points points, set the Data\-Bounds of this node to the bounds of these points.  
\item {\ttfamily double = obj.\-Get\-Min\-Bounds ()} -\/ Get a pointer to the 3 bound minima (xmin, ymin and zmin) or the 3 bound maxima (xmax, ymax, zmax). Don't free this pointer.  
\item {\ttfamily double = obj.\-Get\-Max\-Bounds ()} -\/ Set the xmin, ymin and zmin value of the bounds of this region  
\item {\ttfamily obj.\-Set\-Min\-Bounds (double mb)} -\/ Set the xmin, ymin and zmin value of the bounds of this region  
\item {\ttfamily obj.\-Set\-Max\-Bounds (double mb)} -\/ Set the xmax, ymax and zmax value of the bounds of this region  
\item {\ttfamily double = obj.\-Get\-Min\-Data\-Bounds ()} -\/ Get a pointer to the 3 data bound minima (xmin, ymin and zmin) or the 3 data bound maxima (xmax, ymax, zmax). Don't free this pointer.  
\item {\ttfamily double = obj.\-Get\-Max\-Data\-Bounds ()} -\/ Set the xmin, ymin and zmin value of the bounds of this data within this region  
\item {\ttfamily obj.\-Set\-Min\-Data\-Bounds (double mb)} -\/ Set the xmin, ymin and zmin value of the bounds of this data within this region  
\item {\ttfamily obj.\-Set\-Max\-Data\-Bounds (double mb)} -\/ Set the xmax, ymax and zmax value of the bounds of this data within this region  
\item {\ttfamily obj.\-Set\-I\-D (int )} -\/ Set/\-Get the I\-D associated with the region described by this node. If this is not a leaf node, this value should be -\/1.  
\item {\ttfamily int = obj.\-Get\-I\-D ()} -\/ Set/\-Get the I\-D associated with the region described by this node. If this is not a leaf node, this value should be -\/1.  
\item {\ttfamily int = obj.\-Get\-Min\-I\-D ()} -\/ If this node is not a leaf node, there are leaf nodes below it whose regions represent a partitioning of this region. The I\-Ds of these leaf nodes form a contigous set. Set/\-Get the range of the I\-Ds of the leaf nodes below this node. If this is already a leaf node, these values should be the same as the I\-D.  
\item {\ttfamily int = obj.\-Get\-Max\-I\-D ()} -\/ If this node is not a leaf node, there are leaf nodes below it whose regions represent a partitioning of this region. The I\-Ds of these leaf nodes form a contigous set. Set/\-Get the range of the I\-Ds of the leaf nodes below this node. If this is already a leaf node, these values should be the same as the I\-D.  
\item {\ttfamily obj.\-Set\-Min\-I\-D (int )} -\/ If this node is not a leaf node, there are leaf nodes below it whose regions represent a partitioning of this region. The I\-Ds of these leaf nodes form a contigous set. Set/\-Get the range of the I\-Ds of the leaf nodes below this node. If this is already a leaf node, these values should be the same as the I\-D.  
\item {\ttfamily obj.\-Set\-Max\-I\-D (int )} -\/ If this node is not a leaf node, there are leaf nodes below it whose regions represent a partitioning of this region. The I\-Ds of these leaf nodes form a contigous set. Set/\-Get the range of the I\-Ds of the leaf nodes below this node. If this is already a leaf node, these values should be the same as the I\-D.  
\item {\ttfamily obj.\-Add\-Child\-Nodes (vtk\-Kd\-Node left, vtk\-Kd\-Node right)} -\/ Add the left and right children.  
\item {\ttfamily obj.\-Delete\-Child\-Nodes ()} -\/ Delete the left and right children.  
\item {\ttfamily vtk\-Kd\-Node = obj.\-Get\-Left ()} -\/ Set/\-Get a pointer to the left child of this node.  
\item {\ttfamily obj.\-Set\-Left (vtk\-Kd\-Node left)} -\/ Set/\-Get a pointer to the left child of this node.  
\item {\ttfamily vtk\-Kd\-Node = obj.\-Get\-Right ()} -\/ Set/\-Get a pointer to the right child of this node.  
\item {\ttfamily obj.\-Set\-Right (vtk\-Kd\-Node right)} -\/ Set/\-Get a pointer to the right child of this node.  
\item {\ttfamily vtk\-Kd\-Node = obj.\-Get\-Up ()} -\/ Set/\-Get a pointer to the parent of this node.  
\item {\ttfamily obj.\-Set\-Up (vtk\-Kd\-Node up)} -\/ Set/\-Get a pointer to the parent of this node.  
\item {\ttfamily int = obj.\-Intersects\-Box (double x1, double x2, double y1, double y2, double z1, double z2, int use\-Data\-Bounds)} -\/ Return 1 if this spatial region intersects the axis-\/aligned box given by the bounds passed in. Use the possibly smaller bounds of the points within the region if use\-Data\-Bounds is non-\/zero.  
\item {\ttfamily int = obj.\-Intersects\-Sphere2 (double x, double y, double z, double r\-Squared, int use\-Data\-Bounds)} -\/ Return 1 if this spatial region intersects a sphere described by it's center and the square of it's radius. Use the possibly smaller bounds of the points within the region if use\-Data\-Bounds is non-\/zero.  
\item {\ttfamily int = obj.\-Intersects\-Region (vtk\-Planes\-Intersection pi, int use\-Data\-Bounds)} -\/ A vtk\-Planes\-Intersection object represents a convex 3\-D region bounded by planes, and it is capable of computing intersections of boxes with itself. Return 1 if this spatial region intersects the spatial region described by the vtk\-Planes\-Intersection object. Use the possibly smaller bounds of the points within the region if use\-Data\-Bounds is non-\/zero.  
\item {\ttfamily int = obj.\-Intersects\-Cell (vtk\-Cell cell, int use\-Data\-Bounds, int cell\-Region, double cell\-Bounds\-N\-U\-L\-L)} -\/ Return 1 if the cell specified intersects this region. If you already know the I\-D of the region containing the cell's centroid, provide that as an argument. If you already know the bounds of the cell, provide that as well, in the form of xmin,xmax,ymin,ymax,zmin, zmax. Either of these may speed the calculation. Use the possibly smaller bounds of the points within the region if use\-Data\-Bounds is non-\/zero.  
\item {\ttfamily int = obj.\-Contains\-Box (double x1, double x2, double y1, double y2, double z1, double z2, int use\-Data\-Bounds)} -\/ Return 1 if this spatial region entirely contains a box specified by it's bounds. Use the possibly smaller bounds of the points within the region if use\-Data\-Bounds is non-\/zero.  
\item {\ttfamily int = obj.\-Contains\-Point (double x, double y, double z, int use\-Data\-Bounds)} -\/ Return 1 if this spatial region entirely contains the given point. Use the possibly smaller bounds of the points within the region if use\-Data\-Bounds is non-\/zero.  
\item {\ttfamily double = obj.\-Get\-Distance2\-To\-Boundary (double x, double y, double z, int use\-Data\-Bounds)} -\/ Calculate the distance squared from any point to the boundary of this region. Use the boundary of the points within the region if use\-Data\-Bounds is non-\/zero.  
\item {\ttfamily double = obj.\-Get\-Distance2\-To\-Boundary (double x, double y, double z, double boundary\-Pt, int use\-Data\-Bounds)} -\/ Calculate the distance squared from any point to the boundary of this region. Use the boundary of the points within the region if use\-Data\-Bounds is non-\/zero. Set boundary\-Pt to the point on the boundary.  
\item {\ttfamily double = obj.\-Get\-Distance2\-To\-Inner\-Boundary (double x, double y, double z)} -\/ Calculate the distance from the specified point (which is required to be inside this spatial region) to an interior boundary. An interior boundary is one that is not also an boundary of the entire space partitioned by the tree of vtk\-Kd\-Node's.  
\item {\ttfamily obj.\-Print\-Node (int depth)} -\/ For debugging purposes, print out this node.  
\item {\ttfamily obj.\-Print\-Verbose\-Node (int depth)} -\/ For debugging purposes, print out this node.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkkdtree}{}\section{vtk\-Kd\-Tree}\label{vtkfiltering_vtkkdtree}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Given one or more vtk\-Data\-Sets, create a load balancing k-\/d tree decomposition of the points at the center of the cells. Or, create a k-\/d tree point locator from a list of points.

This class can also generate a Poly\-Data representation of the boundaries of the spatial regions in the decomposition.

It can sort the regions with respect to a viewing direction, and it can decompose a list of regions into subsets, each of which represent a convex spatial region (since many algorithms require a convex region).

If the points were derived from cells, vtk\-Kd\-Tree can create a list of cell Ids for each region for each data set. Two lists are available -\/ all cells with centroid in the region, and all cells that intersect the region but whose centroid lies in another region.

For the purpose of removing duplicate points quickly from large data sets, or for finding nearby points, we added another mode for building the locator. Build\-Locator\-From\-Points will build a k-\/d tree from one or more vtk\-Points objects. This can be followed by Build\-Map\-For\-Duplicate\-Points which returns a mapping from the original ids to a subset of the ids that is unique within a supplied tolerance, or you can use Find\-Point and Find\-Closest\-Point to locate points in the original set that the tree was built from.

To create an instance of class vtk\-Kd\-Tree, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkKdTree
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Kd\-Tree has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Kd\-Tree class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Kd\-Tree = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Kd\-Tree = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Timing\-On ()} -\/ Turn on timing of the k-\/d tree build  
\item {\ttfamily obj.\-Timing\-Off ()} -\/ Turn on timing of the k-\/d tree build  
\item {\ttfamily obj.\-Set\-Timing (int )} -\/ Turn on timing of the k-\/d tree build  
\item {\ttfamily int = obj.\-Get\-Timing ()} -\/ Turn on timing of the k-\/d tree build  
\item {\ttfamily obj.\-Set\-Min\-Cells (int )} -\/ Minimum number of cells per spatial region. Default is 100.  
\item {\ttfamily int = obj.\-Get\-Min\-Cells ()} -\/ Minimum number of cells per spatial region. Default is 100.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Regions\-Or\-Less ()}  
\item {\ttfamily obj.\-Set\-Number\-Of\-Regions\-Or\-Less (int )}  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Regions\-Or\-More ()}  
\item {\ttfamily obj.\-Set\-Number\-Of\-Regions\-Or\-More (int )}  
\item {\ttfamily double = obj.\-Get\-Fudge\-Factor ()}  
\item {\ttfamily obj.\-Set\-Fudge\-Factor (double )}  
\item {\ttfamily vtk\-B\-S\-P\-Cuts = obj.\-Get\-Cuts ()}  
\item {\ttfamily obj.\-Set\-Cuts (vtk\-B\-S\-P\-Cuts cuts)}  
\item {\ttfamily obj.\-Omit\-X\-Partitioning ()} -\/ Omit partitions along the X axis, yielding shafts in the X direction  
\item {\ttfamily obj.\-Omit\-Y\-Partitioning ()} -\/ Omit partitions along the Y axis, yielding shafts in the Y direction  
\item {\ttfamily obj.\-Omit\-Z\-Partitioning ()} -\/ Omit partitions along the Z axis, yielding shafts in the Z direction  
\item {\ttfamily obj.\-Omit\-X\-Y\-Partitioning ()} -\/ Omit partitions along the X and Y axes, yielding slabs along Z  
\item {\ttfamily obj.\-Omit\-Y\-Z\-Partitioning ()} -\/ Omit partitions along the Y and Z axes, yielding slabs along X  
\item {\ttfamily obj.\-Omit\-Z\-X\-Partitioning ()} -\/ Omit partitions along the Z and X axes, yielding slabs along Y  
\item {\ttfamily obj.\-Omit\-No\-Partitioning ()} -\/ Partition along all three axes -\/ this is the default  
\item {\ttfamily obj.\-Set\-Data\-Set (vtk\-Data\-Set set)} -\/ Clear out all data sets and replace with single data set. For backward compatibility with superclass.  
\item {\ttfamily obj.\-Add\-Data\-Set (vtk\-Data\-Set set)} -\/ This class can compute a spatial decomposition based on the cells in a list of one or more input data sets. Add them one at a time with this method.  
\item {\ttfamily obj.\-Remove\-Data\-Set (int index)} -\/ Remove the given data set.  
\item {\ttfamily obj.\-Remove\-Data\-Set (vtk\-Data\-Set set)} -\/ Remove the given data set.  
\item {\ttfamily obj.\-Remove\-All\-Data\-Sets ()} -\/ Remove the given data set.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Data\-Sets ()} -\/ Get the number of data sets included in spatial paritioning  
\item {\ttfamily vtk\-Data\-Set = obj.\-Get\-Data\-Set (int n)} -\/ Return the n'th data set.  
\item {\ttfamily vtk\-Data\-Set = obj.\-Get\-Data\-Set ()} -\/ Return a collection of all the data sets.  
\item {\ttfamily vtk\-Data\-Set\-Collection = obj.\-Get\-Data\-Sets ()} -\/ Return a collection of all the data sets.  
\item {\ttfamily int = obj.\-Get\-Data\-Set\-Index (vtk\-Data\-Set set)} -\/ Return the index of the given data set. Returns -\/1 if that data set does not exist.  
\item {\ttfamily obj.\-Get\-Bounds (double bounds)} -\/ Get the spatial bounds of the entire k-\/d tree space. Sets bounds array to xmin, xmax, ymin, ymax, zmin, zmax.  
\item {\ttfamily obj.\-Set\-New\-Bounds (double bounds)}  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Regions ()} -\/ The number of leaf nodes of the tree, the spatial regions  
\item {\ttfamily obj.\-Get\-Region\-Bounds (int region\-I\-D, double bounds\mbox{[}6\mbox{]})} -\/ Get the spatial bounds of k-\/d tree region  
\item {\ttfamily obj.\-Get\-Region\-Data\-Bounds (int region\-I\-D, double bounds\mbox{[}6\mbox{]})} -\/ Get the bounds of the data within the k-\/d tree region  
\item {\ttfamily obj.\-Print\-Tree ()} -\/ Print out nodes of kd tree  
\item {\ttfamily obj.\-Print\-Verbose\-Tree ()} -\/ Print out nodes of kd tree  
\item {\ttfamily obj.\-Print\-Region (int id)} -\/ Print out leaf node data for given id  
\item {\ttfamily obj.\-Create\-Cell\-Lists (int data\-Set\-Index, int region\-Req\-List, int req\-List\-Size)}  
\item {\ttfamily obj.\-Create\-Cell\-Lists (vtk\-Data\-Set set, int region\-Req\-List, int req\-List\-Size)}  
\item {\ttfamily obj.\-Create\-Cell\-Lists (int region\-Req\-List, int list\-Size)}  
\item {\ttfamily obj.\-Create\-Cell\-Lists ()}  
\item {\ttfamily obj.\-Set\-Include\-Region\-Boundary\-Cells (int )} -\/ If Include\-Region\-Boundary\-Cells is O\-N, Create\-Cell\-Lists() will also create a list of cells which intersect a given region, but are not assigned to the region. These lists are obtained with Get\-Boundary\-Cell\-List(). Default is O\-F\-F.  
\item {\ttfamily int = obj.\-Get\-Include\-Region\-Boundary\-Cells ()} -\/ If Include\-Region\-Boundary\-Cells is O\-N, Create\-Cell\-Lists() will also create a list of cells which intersect a given region, but are not assigned to the region. These lists are obtained with Get\-Boundary\-Cell\-List(). Default is O\-F\-F.  
\item {\ttfamily obj.\-Include\-Region\-Boundary\-Cells\-On ()} -\/ If Include\-Region\-Boundary\-Cells is O\-N, Create\-Cell\-Lists() will also create a list of cells which intersect a given region, but are not assigned to the region. These lists are obtained with Get\-Boundary\-Cell\-List(). Default is O\-F\-F.  
\item {\ttfamily obj.\-Include\-Region\-Boundary\-Cells\-Off ()} -\/ If Include\-Region\-Boundary\-Cells is O\-N, Create\-Cell\-Lists() will also create a list of cells which intersect a given region, but are not assigned to the region. These lists are obtained with Get\-Boundary\-Cell\-List(). Default is O\-F\-F.  
\item {\ttfamily obj.\-Delete\-Cell\-Lists ()} -\/ Free the memory used by the cell lists.  
\item {\ttfamily vtk\-Id\-List = obj.\-Get\-Cell\-List (int region\-I\-D)} -\/ Get the cell list for a region. This returns a pointer to vtk\-Kd\-Tree's memory, so don't free it.  
\item {\ttfamily vtk\-Id\-List = obj.\-Get\-Boundary\-Cell\-List (int region\-I\-D)} -\/ The cell list obtained with Get\-Cell\-List is the list of all cells such that their centroid is contained in the spatial region. It may also be desirable to get a list of all cells intersecting a spatial region, but with centroid in some other region. This is that list. This list is computed in Create\-Cell\-Lists() if and only if Include\-Region\-Boundary\-Cells is O\-N. This returns a pointer to Kd\-Tree's memory, so don't free it.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Cell\-Lists (vtk\-Int\-Array regions, int set, vtk\-Id\-List in\-Region\-Cells, vtk\-Id\-List on\-Boundary\-Cells)} -\/ For a list of regions, get two cell lists. The first lists the I\-Ds all cells whose centroids lie in one of the regions. The second lists the I\-Ds of all cells that intersect the regions, but whose centroid lies in a region not on the list.

The total number of cell I\-Ds written to both lists is returned. Either list pointer passed in can be N\-U\-L\-L, and it will be ignored. If there are multiple data sets, you must specify which data set you wish cell I\-Ds for.

The caller should delete these two lists when done. This method uses the cell lists created in Create\-Cell\-Lists(). If the cell list for any of the requested regions does not exist, then this method will call Create\-Cell\-Lists() to create cell lists for {\itshape every} region of the k-\/d tree. You must remember to Delete\-Cell\-Lists() when done with all calls to this method, as cell lists can require a great deal of memory.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Cell\-Lists (vtk\-Int\-Array regions, vtk\-Data\-Set set, vtk\-Id\-List in\-Region\-Cells, vtk\-Id\-List on\-Boundary\-Cells)} -\/ For a list of regions, get two cell lists. The first lists the I\-Ds all cells whose centroids lie in one of the regions. The second lists the I\-Ds of all cells that intersect the regions, but whose centroid lies in a region not on the list.

The total number of cell I\-Ds written to both lists is returned. Either list pointer passed in can be N\-U\-L\-L, and it will be ignored. If there are multiple data sets, you must specify which data set you wish cell I\-Ds for.

The caller should delete these two lists when done. This method uses the cell lists created in Create\-Cell\-Lists(). If the cell list for any of the requested regions does not exist, then this method will call Create\-Cell\-Lists() to create cell lists for {\itshape every} region of the k-\/d tree. You must remember to Delete\-Cell\-Lists() when done with all calls to this method, as cell lists can require a great deal of memory.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Cell\-Lists (vtk\-Int\-Array regions, vtk\-Id\-List in\-Region\-Cells, vtk\-Id\-List on\-Boundary\-Cells)} -\/ For a list of regions, get two cell lists. The first lists the I\-Ds all cells whose centroids lie in one of the regions. The second lists the I\-Ds of all cells that intersect the regions, but whose centroid lies in a region not on the list.

The total number of cell I\-Ds written to both lists is returned. Either list pointer passed in can be N\-U\-L\-L, and it will be ignored. If there are multiple data sets, you must specify which data set you wish cell I\-Ds for.

The caller should delete these two lists when done. This method uses the cell lists created in Create\-Cell\-Lists(). If the cell list for any of the requested regions does not exist, then this method will call Create\-Cell\-Lists() to create cell lists for {\itshape every} region of the k-\/d tree. You must remember to Delete\-Cell\-Lists() when done with all calls to this method, as cell lists can require a great deal of memory.  
\item {\ttfamily int = obj.\-Get\-Region\-Containing\-Cell (vtk\-Data\-Set set, vtk\-Id\-Type cell\-I\-D)} -\/ Get the id of the region containing the cell centroid. If no Data\-Set is specified, assume Data\-Set 0. If you need the region I\-D for every cell, use All\-Get\-Region\-Containing\-Cell instead. It is more efficient.  
\item {\ttfamily int = obj.\-Get\-Region\-Containing\-Cell (int set, vtk\-Id\-Type cell\-I\-D)} -\/ Get the id of the region containing the cell centroid. If no Data\-Set is specified, assume Data\-Set 0. If you need the region I\-D for every cell, use All\-Get\-Region\-Containing\-Cell instead. It is more efficient.  
\item {\ttfamily int = obj.\-Get\-Region\-Containing\-Cell (vtk\-Id\-Type cell\-I\-D)} -\/ Get the id of the region containing the cell centroid. If no Data\-Set is specified, assume Data\-Set 0. If you need the region I\-D for every cell, use All\-Get\-Region\-Containing\-Cell instead. It is more efficient.  
\item {\ttfamily int = obj.\-Get\-Region\-Containing\-Point (double x, double y, double z)} -\/ Get the id of the region containing the specified location.  
\item {\ttfamily obj.\-Build\-Locator ()} -\/ Create the k-\/d tree decomposition of the cells of the data set or data sets. Cells are assigned to k-\/d tree spatial regions based on the location of their centroids.  
\item {\ttfamily int = obj.\-Depth\-Order\-All\-Regions (double dop, vtk\-Int\-Array ordered\-List)} -\/ D\-O N\-O\-T C\-A\-L\-L. Depricated in V\-T\-K 5.\-2. Use View\-Order\-All\-Regions\-In\-Direction or View\-Order\-All\-Regions\-From\-Position.  
\item {\ttfamily int = obj.\-Depth\-Order\-Regions (vtk\-Int\-Array region\-Ids, double dop, vtk\-Int\-Array ordered\-List)} -\/ D\-O N\-O\-T C\-A\-L\-L. Depricated in V\-T\-K 5.\-2. Use View\-Order\-Regions\-In\-Direction or View\-Order\-Regions\-From\-Position.  
\item {\ttfamily int = obj.\-View\-Order\-All\-Regions\-In\-Direction (double direction\-Of\-Projection\mbox{[}3\mbox{]}, vtk\-Int\-Array ordered\-List)} -\/ Given a direction of projection (typically obtained with vtk\-Camera\-::\-Get\-Direction\-Of\-Projection()), this method, creates a list of the k-\/d tree region I\-Ds in order from front to back with respect to that direction. The number of ordered regions is returned. Use this method to view order regions for cameras that use parallel projection.  
\item {\ttfamily int = obj.\-View\-Order\-Regions\-In\-Direction (vtk\-Int\-Array region\-Ids, double direction\-Of\-Projection\mbox{[}3\mbox{]}, vtk\-Int\-Array ordered\-List)} -\/ Given a direction of projection and a list of k-\/d tree region I\-Ds, this method, creates a list of the k-\/d tree region I\-Ds in order from front to back with respect to that direction. The number of ordered regions is returned. Use this method to view order regions for cameras that use parallel projection.  
\item {\ttfamily int = obj.\-View\-Order\-All\-Regions\-From\-Position (double direction\-Of\-Projection\mbox{[}3\mbox{]}, vtk\-Int\-Array ordered\-List)} -\/ Given a camera position (typically obtained with vtk\-Camera\-::\-Get\-Position()), this method, creates a list of the k-\/d tree region I\-Ds in order from front to back with respect to that direction. The number of ordered regions is returned. Use this method to view order regions for cameras that use perspective projection.  
\item {\ttfamily int = obj.\-View\-Order\-Regions\-From\-Position (vtk\-Int\-Array region\-Ids, double direction\-Of\-Projection\mbox{[}3\mbox{]}, vtk\-Int\-Array ordered\-List)} -\/ Given a camera position and a list of k-\/d tree region I\-Ds, this method, creates a list of the k-\/d tree region I\-Ds in order from front to back with respect to that direction. The number of ordered regions is returned. Use this method to view order regions for cameras that use perspective projection.  
\item {\ttfamily obj.\-Build\-Locator\-From\-Points (vtk\-Point\-Set pointset)} -\/ This is a special purpose locator that builds a k-\/d tree to find duplicate and near-\/by points. It builds the tree from one or more vtk\-Points objects instead of from the cells of a vtk\-Data\-Set. This build would normally be followed by Build\-Map\-For\-Duplicate\-Points, Find\-Point, or Find\-Closest\-Point. Since this will build a normal k-\/d tree, all the region intersection queries will still work, as will most other calls except those that have \char`\"{}\-Cell\char`\"{} in the name.

This method works most efficiently when the point arrays are float arrays.  
\item {\ttfamily obj.\-Build\-Locator\-From\-Points (vtk\-Points pt\-Array)} -\/ This is a special purpose locator that builds a k-\/d tree to find duplicate and near-\/by points. It builds the tree from one or more vtk\-Points objects instead of from the cells of a vtk\-Data\-Set. This build would normally be followed by Build\-Map\-For\-Duplicate\-Points, Find\-Point, or Find\-Closest\-Point. Since this will build a normal k-\/d tree, all the region intersection queries will still work, as will most other calls except those that have \char`\"{}\-Cell\char`\"{} in the name.

This method works most efficiently when the point arrays are float arrays.  
\item {\ttfamily vtk\-Id\-Type\-Array = obj.\-Build\-Map\-For\-Duplicate\-Points (float tolerance)} -\/ This call returns a mapping from the original point I\-Ds supplied to Build\-Locator\-From\-Points to a subset of those I\-Ds that is unique within the specified tolerance. If points 2, 5, and 12 are the same, then Id\-Map\mbox{[}2\mbox{]} = Id\-Map\mbox{[}5\mbox{]} = Id\-Map\mbox{[}12\mbox{]} = 2 (or 5 or 12).

\char`\"{}original point I\-Ds\char`\"{} -\/ For point I\-Ds we start at 0 for the first point in the first vtk\-Points object, and increase by 1 for subsequent points and subsequent vtk\-Points objects.

You must have called Build\-Locator\-From\-Points() before calling this. You are responsible for deleting the returned array.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Find\-Point (double x)} -\/ Find the Id of the point that was previously supplied to Build\-Locator\-From\-Points(). Returns -\/1 if the point was not in the original array.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Find\-Point (double x, double y, double z)} -\/ Find the Id of the point that was previously supplied to Build\-Locator\-From\-Points(). Returns -\/1 if the point was not in the original array.  
\item {\ttfamily obj.\-Find\-Points\-Within\-Radius (double R, double x\mbox{[}3\mbox{]}, vtk\-Id\-List result)} -\/ Find all points within a specified radius R of position x. The result is not sorted in any specific manner. These methods are thread safe if Build\-Locator() is directly or indirectly called from a single thread first.  
\item {\ttfamily obj.\-Find\-Closest\-N\-Points (int N, double x\mbox{[}3\mbox{]}, vtk\-Id\-List result)} -\/ Find the closest N points to a position. This returns the closest N points to a position. A faster method could be created that returned N close points to a position, but necessarily the exact N closest. The returned points are sorted from closest to farthest. These methods are thread safe if Build\-Locator() is directly or indirectly called from a single thread first.  
\item {\ttfamily vtk\-Id\-Type\-Array = obj.\-Get\-Points\-In\-Region (int region\-Id)} -\/ Get a list of the original I\-Ds of all points in a region. You must have called Build\-Locator\-From\-Points before calling this.  
\item {\ttfamily obj.\-Free\-Search\-Structure ()} -\/ Delete the k-\/d tree data structure. Also delete any cell lists that were computed with Create\-Cell\-Lists().  
\item {\ttfamily obj.\-Generate\-Representation (int level, vtk\-Poly\-Data pd)} -\/ Create a polydata representation of the boundaries of the k-\/d tree regions. If level equals Get\-Level(), the leaf nodes are represented.  
\item {\ttfamily obj.\-Generate\-Representation (int region\-List, int len, vtk\-Poly\-Data pd)} -\/ Generate a polygonal representation of a list of regions. Only leaf nodes have region I\-Ds, so these will be leaf nodes.  
\item {\ttfamily obj.\-Generate\-Representation\-Using\-Data\-Bounds\-On ()} -\/ The polydata representation of the k-\/d tree shows the boundaries of the k-\/d tree decomposition spatial regions. The data inside the regions may not occupy the entire space. To draw just the bounds of the data in the regions, set this variable O\-N.  
\item {\ttfamily obj.\-Generate\-Representation\-Using\-Data\-Bounds\-Off ()} -\/ The polydata representation of the k-\/d tree shows the boundaries of the k-\/d tree decomposition spatial regions. The data inside the regions may not occupy the entire space. To draw just the bounds of the data in the regions, set this variable O\-N.  
\item {\ttfamily obj.\-Set\-Generate\-Representation\-Using\-Data\-Bounds (int )} -\/ The polydata representation of the k-\/d tree shows the boundaries of the k-\/d tree decomposition spatial regions. The data inside the regions may not occupy the entire space. To draw just the bounds of the data in the regions, set this variable O\-N.  
\item {\ttfamily int = obj.\-Get\-Generate\-Representation\-Using\-Data\-Bounds ()} -\/ The polydata representation of the k-\/d tree shows the boundaries of the k-\/d tree decomposition spatial regions. The data inside the regions may not occupy the entire space. To draw just the bounds of the data in the regions, set this variable O\-N.  
\item {\ttfamily int = obj.\-New\-Geometry ()} -\/ Return 1 if the geometry of the input data sets has changed since the last time the k-\/d tree was built.  
\item {\ttfamily obj.\-Invalidate\-Geometry ()} -\/ Forget about the last geometry used. The next call to New\-Geometry will return 1. A new k-\/d tree will be built the next time Build\-Locator is called.  
\item {\ttfamily obj.\-Find\-Points\-In\-Area (double area, vtk\-Id\-Type\-Array ids, bool clear\-Arraytrue)} -\/ Fill ids with points found in area. The area is a 6-\/tuple containing (xmin, xmax, ymin, ymax, zmin, zmax). This method will clear the array by default. To append ids to an array, set clear\-Array to false.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkkdtreepointlocator}{}\section{vtk\-Kd\-Tree\-Point\-Locator}\label{vtkfiltering_vtkkdtreepointlocator}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Kd\-Tree\-Point\-Locator is a wrapper class that derives from vtk\-Abstract\-Point\-Locator and calls the search functions in vtk\-Kd\-Tree.

To create an instance of class vtk\-Kd\-Tree\-Point\-Locator, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkKdTreePointLocator
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Kd\-Tree\-Point\-Locator has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Kd\-Tree\-Point\-Locator class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Kd\-Tree\-Point\-Locator = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Kd\-Tree\-Point\-Locator = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Id\-Type = obj.\-Find\-Closest\-Point (double x\mbox{[}3\mbox{]})} -\/ Given a position x, return the id of the point closest to it. Alternative method requires separate x-\/y-\/z values. These methods are thread safe if Build\-Locator() is directly or indirectly called from a single thread first.  
\item {\ttfamily obj.\-Find\-Closest\-N\-Points (int N, double x\mbox{[}3\mbox{]}, vtk\-Id\-List result)} -\/ Find the closest N points to a position. This returns the closest N points to a position. A faster method could be created that returned N close points to a position, but necessarily the exact N closest. The returned points are sorted from closest to farthest. These methods are thread safe if Build\-Locator() is directly or indirectly called from a single thread first.  
\item {\ttfamily obj.\-Find\-Points\-Within\-Radius (double R, double x\mbox{[}3\mbox{]}, vtk\-Id\-List result)} -\/ Find all points within a specified radius R of position x. The result is not sorted in any specific manner. These methods are thread safe if Build\-Locator() is directly or indirectly called from a single thread first.  
\item {\ttfamily obj.\-Free\-Search\-Structure ()} -\/ See vtk\-Locator interface documentation. These methods are not thread safe.  
\item {\ttfamily obj.\-Build\-Locator ()} -\/ See vtk\-Locator interface documentation. These methods are not thread safe.  
\item {\ttfamily obj.\-Generate\-Representation (int level, vtk\-Poly\-Data pd)} -\/ See vtk\-Locator interface documentation. These methods are not thread safe.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkkochanekspline}{}\section{vtk\-Kochanek\-Spline}\label{vtkfiltering_vtkkochanekspline}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Implements the Kochenek interpolating spline described in\-: Kochanek, D., Bartels, R., \char`\"{}\-Interpolating Splines with Local Tension, Continuity, and
 Bias Control,\char`\"{} Computer Graphics, vol. 18, no. 3, pp. 33-\/41, July 1984. These splines give the user more control over the shape of the curve than the cardinal splines implemented in vtk\-Cardinal\-Spline. Three parameters can be specified. All have a range from -\/1 to 1.

Tension controls how sharply the curve bends at an input point. A value of -\/1 produces more slack in the curve. A value of 1 tightens the curve.

Continuity controls the continuity of the first derivative at input points.

Bias controls the direction of the curve at it passes through an input point. A value of -\/1 undershoots the point while a value of 1 overshoots the point.

These three parameters give the user broad control over the shape of the interpolating spline. The original Kochanek paper describes the effects nicely and is recommended reading.

To create an instance of class vtk\-Kochanek\-Spline, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkKochanekSpline
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Kochanek\-Spline has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Kochanek\-Spline class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Kochanek\-Spline = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Kochanek\-Spline = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Compute ()} -\/ Compute Kochanek Spline coefficients.  
\item {\ttfamily double = obj.\-Evaluate (double t)} -\/ Evaluate a 1\-D Kochanek spline.  
\item {\ttfamily obj.\-Set\-Default\-Bias (double )} -\/ Set the bias for all points. Default is 0.  
\item {\ttfamily double = obj.\-Get\-Default\-Bias ()} -\/ Set the bias for all points. Default is 0.  
\item {\ttfamily obj.\-Set\-Default\-Tension (double )} -\/ Set the tension for all points. Default is 0.  
\item {\ttfamily double = obj.\-Get\-Default\-Tension ()} -\/ Set the tension for all points. Default is 0.  
\item {\ttfamily obj.\-Set\-Default\-Continuity (double )} -\/ Set the continuity for all points. Default is 0.  
\item {\ttfamily double = obj.\-Get\-Default\-Continuity ()} -\/ Set the continuity for all points. Default is 0.  
\item {\ttfamily obj.\-Deep\-Copy (vtk\-Spline s)} -\/ Deep copy of cardinal spline data.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkline}{}\section{vtk\-Line}\label{vtkfiltering_vtkline}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Line is a concrete implementation of vtk\-Cell to represent a 1\-D line.

To create an instance of class vtk\-Line, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkLine
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Line has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Line class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Line = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Line = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int )} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int )} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Clip (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array lines, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd, int inside\-Out)} -\/ Clip this line using scalar value provided. Like contouring, except that it cuts the line to produce other lines.  
\item {\ttfamily int = obj.\-Get\-Parametric\-Center (double pcoords\mbox{[}3\mbox{]})} -\/ Return the center of the triangle in parametric coordinates.  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double weights\mbox{[}2\mbox{]})} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs\mbox{[}2\mbox{]})}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtklocator}{}\section{vtk\-Locator}\label{vtkfiltering_vtklocator}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Locator is an abstract base class for spatial search objects, or locators. The principle behind locators is that they divide 3-\/space into small pieces (or \char`\"{}buckets\char`\"{}) that can be quickly found in response to queries like point location, line intersection, or object-\/object intersection.

The purpose of this base class is to provide ivars and methods shared by all locators. The Generate\-Representation() is one such interesting method. This method works in conjunction with vtk\-Locator\-Filter to create polygonal representations for the locator. For example, if the locator is an O\-B\-B tree (i.\-e., vtk\-O\-B\-B\-Tree.\-h), then the representation is a set of one or more oriented bounding boxes, depending upon the specified level.

Locators typically work as follows. One or more \char`\"{}entities\char`\"{}, such as points or cells, are inserted into the tree. These entities are associated with one or more buckets. Then, when performing geometric operations, the operations are performed first on the buckets, and then if the operation tests positive, then on the entities in the bucket. For example, during collision tests, the locators are collided first to identify intersecting buckets. If an intersection is found, more expensive operations are then carried out on the entities in the bucket.

To obtain good performance, locators are often organized in a tree structure. In such a structure, there are frequently multiple \char`\"{}levels\char`\"{} corresponding to different nodes in the tree. So the word level (in the context of the locator) can be used to specify a particular representation in the tree. For example, in an octree (which is a tree with 8 children), level 0 is the bounding box, or root octant, and level 1 consists of its eight children.

To create an instance of class vtk\-Locator, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkLocator
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Locator has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Locator class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Locator = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Locator = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Data\-Set (vtk\-Data\-Set )} -\/ Build the locator from the points/cells defining this dataset.  
\item {\ttfamily vtk\-Data\-Set = obj.\-Get\-Data\-Set ()} -\/ Build the locator from the points/cells defining this dataset.  
\item {\ttfamily obj.\-Set\-Max\-Level (int )} -\/ Set the maximum allowable level for the tree. If the Automatic ivar is off, this will be the target depth of the locator. Initial value is 8.  
\item {\ttfamily int = obj.\-Get\-Max\-Level\-Min\-Value ()} -\/ Set the maximum allowable level for the tree. If the Automatic ivar is off, this will be the target depth of the locator. Initial value is 8.  
\item {\ttfamily int = obj.\-Get\-Max\-Level\-Max\-Value ()} -\/ Set the maximum allowable level for the tree. If the Automatic ivar is off, this will be the target depth of the locator. Initial value is 8.  
\item {\ttfamily int = obj.\-Get\-Max\-Level ()} -\/ Set the maximum allowable level for the tree. If the Automatic ivar is off, this will be the target depth of the locator. Initial value is 8.  
\item {\ttfamily int = obj.\-Get\-Level ()} -\/ Get the level of the locator (determined automatically if Automatic is true). The value of this ivar may change each time the locator is built. Initial value is 8.  
\item {\ttfamily obj.\-Set\-Automatic (int )} -\/ Boolean controls whether locator depth/resolution of locator is computed automatically from average number of entities in bucket. If not set, there will be an explicit method to control the construction of the locator (found in the subclass).  
\item {\ttfamily int = obj.\-Get\-Automatic ()} -\/ Boolean controls whether locator depth/resolution of locator is computed automatically from average number of entities in bucket. If not set, there will be an explicit method to control the construction of the locator (found in the subclass).  
\item {\ttfamily obj.\-Automatic\-On ()} -\/ Boolean controls whether locator depth/resolution of locator is computed automatically from average number of entities in bucket. If not set, there will be an explicit method to control the construction of the locator (found in the subclass).  
\item {\ttfamily obj.\-Automatic\-Off ()} -\/ Boolean controls whether locator depth/resolution of locator is computed automatically from average number of entities in bucket. If not set, there will be an explicit method to control the construction of the locator (found in the subclass).  
\item {\ttfamily obj.\-Set\-Tolerance (double )} -\/ Specify absolute tolerance (in world coordinates) for performing geometric operations.  
\item {\ttfamily double = obj.\-Get\-Tolerance\-Min\-Value ()} -\/ Specify absolute tolerance (in world coordinates) for performing geometric operations.  
\item {\ttfamily double = obj.\-Get\-Tolerance\-Max\-Value ()} -\/ Specify absolute tolerance (in world coordinates) for performing geometric operations.  
\item {\ttfamily double = obj.\-Get\-Tolerance ()} -\/ Specify absolute tolerance (in world coordinates) for performing geometric operations.  
\item {\ttfamily obj.\-Update ()} -\/ Cause the locator to rebuild itself if it or its input dataset has changed.  
\item {\ttfamily obj.\-Initialize ()} -\/ Initialize locator. Frees memory and resets object as appropriate.  
\item {\ttfamily obj.\-Build\-Locator ()} -\/ Build the locator from the input dataset.  
\item {\ttfamily obj.\-Free\-Search\-Structure ()} -\/ Free the memory required for the spatial data structure.  
\item {\ttfamily obj.\-Generate\-Representation (int level, vtk\-Poly\-Data pd)} -\/ Method to build a representation at a particular level. Note that the method Get\-Level() returns the maximum number of levels available for the tree. You must provide a vtk\-Poly\-Data object into which to place the data.  
\item {\ttfamily long = obj.\-Get\-Build\-Time ()} -\/ Return the time of the last data structure build.  
\item {\ttfamily obj.\-Register (vtk\-Object\-Base o)} -\/ Handle the Point\-Set $<$-\/$>$ Locator loop.  
\item {\ttfamily obj.\-Un\-Register (vtk\-Object\-Base o)} -\/ Handle the Point\-Set $<$-\/$>$ Locator loop.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkmapper2d}{}\section{vtk\-Mapper2\-D}\label{vtkfiltering_vtkmapper2d}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Mapper2\-D is an abstract class which defines the interface for objects which render two dimensional actors (vtk\-Actor2\-D).

To create an instance of class vtk\-Mapper2\-D, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkMapper2D
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Mapper2\-D has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Mapper2\-D class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Mapper2\-D = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Mapper2\-D = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Render\-Overlay (vtk\-Viewport , vtk\-Actor2\-D )}  
\item {\ttfamily obj.\-Render\-Opaque\-Geometry (vtk\-Viewport , vtk\-Actor2\-D )}  
\item {\ttfamily obj.\-Render\-Translucent\-Polygonal\-Geometry (vtk\-Viewport , vtk\-Actor2\-D )}  
\item {\ttfamily int = obj.\-Has\-Translucent\-Polygonal\-Geometry ()}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkmergepoints}{}\section{vtk\-Merge\-Points}\label{vtkfiltering_vtkmergepoints}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Merge\-Points is a locator object to quickly locate points in 3\-D. The primary difference between vtk\-Merge\-Points and its superclass vtk\-Point\-Locator is that vtk\-Merge\-Points merges precisely coincident points and is therefore much faster.

To create an instance of class vtk\-Merge\-Points, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkMergePoints
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Merge\-Points has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Merge\-Points class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Merge\-Points = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Merge\-Points = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Id\-Type = obj.\-Is\-Inserted\-Point (double x\mbox{[}3\mbox{]})} -\/ Determine whether point given by x\mbox{[}3\mbox{]} has been inserted into points list. Return id of previously inserted point if this is true, otherwise return -\/1.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Is\-Inserted\-Point (double x, double y, double z)} -\/ Determine whether point given by x\mbox{[}3\mbox{]} has been inserted into points list. Return id of previously inserted point if this is true, otherwise return -\/1.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkmodifiedbsptree}{}\section{vtk\-Modified\-B\-S\-P\-Tree}\label{vtkfiltering_vtkmodifiedbsptree}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Modified\-B\-S\-P\-Tree creates an evenly balanced B\-S\-P tree using a top down implementation. Axis aligned split planes are found which evenly divide cells into two buckets. Generally a split plane will intersect some cells and these are usually stored in both child nodes of the current parent. (Or split into separate cells which we cannot consider in this case). Storing cells in multiple buckets creates problems associated with multiple tests against rays and increases the required storage as complex meshes will have many cells straddling a split plane (and further splits may cause multiple copies of these).

During a discussion with Arno Formella in 1998 he suggested using a third child node to store objects which straddle split planes. I've not seen this published (Yes! -\/ see below), but thought it worth trying. This implementation of the B\-S\-P tree creates a third child node for storing cells lying across split planes, the third cell may overlap the other two, but the two 'proper' nodes otherwise conform to usual B\-S\-P rules.

The advantage of this implementation is cells only ever lie in one node and mailbox testing is avoided. All B\-Boxes are axis aligned and a ray cast uses an efficient search strategy based on near/far nodes and rejects all B\-Boxes using simple tests.

For fast raytracing, 6 copies of cell lists are stored in each leaf node each list is in axis sorted order +/-\/ x,y,z and cells are always tested in the direction of the ray dominant axis. Once an intersection is found any cell or B\-Box with a closest point further than the I-\/point can be instantly rejected and raytracing stops as soon as no nodes can be closer than the current best intersection point.

The addition of the 'middle' node upsets the optimal balance of the tree, but is a minor overhead during the raytrace. Each child node is contracted such that it tightly fits all cells inside it, enabling further ray/box rejections.

This class is intented for persons requiring many ray tests and is optimized for this purpose. As no cell ever lies in more than one leaf node, and parent nodes do not maintain cell lists, the memory overhead of the sorted cell lists is 6$\ast$num\-\_\-cells$\ast$4 for 6 lists of ints, each num\-\_\-cells in length. The memory requirement of the nodes themselves is usually of minor significance.

Subdividision is controlled by Max\-Cells\-Per\-Node -\/ any node with more than this number will be subdivided providing a good split plane can be found and the max depth is not exceeded.

The average cells per leaf will usually be around half the Max\-Cells\-Per\-Node, though the middle node is usually sparsely populated and lowers the average slightly. The middle node will not be created when not needed. Subdividing down to very small cells per node is not generally suggested as then the 6 stored cell lists are effectively redundant.

Values of Maxcells\-Per\-Node of around 16-\/$>$128 depending on dataset size will usually give good results.

Cells are only sorted into 6 lists once -\/ before tree creation, each node segments the lists and passes them down to the new child nodes whilst maintaining sorted order. This makes for an efficient subdivision strategy.

N\-B. The following reference has been sent to me \{formella-\/1995-\/ray, author = \char`\"{}\-Arno Formella and Christian Gill\char`\"{}, title = \char`\"{}\{\-Ray Tracing\-: A Quantitative Analysis and a New
                   Practical Algorithm\}\char`\"{}, journal = \char`\"{}\{\-The Visual Computer\}\char`\"{}, year = \char`\"{}\{1995\}\char`\"{}, month = dec, pages = \char`\"{}\{465-\/-\/476\}\char`\"{}, volume = \char`\"{}\{11\}\char`\"{}, number = \char`\"{}\{9\}\char`\"{}, publisher = \char`\"{}\{\-Springer\}\char`\"{}, keywords = \char`\"{}\{ray tracing, space subdivision, plane traversal,
                    octree, clustering, benchmark scenes\}\char`\"{}, annote = "\{We present a new method to accelerate the process of finding nearest ray--object intersections in ray tracing. The algorithm consumes an amount of memory more or less linear in the number of objects. The basic ideas can be characterized with a modified B\-S\-P--tree and plane traversal. Plane traversal is a fast linear time algorithm to find the closest intersection point in a list of bounding volumes hit by a ray. We use plane traversal at every node of the high outdegree B\-S\-P--tree. Our implementation is competitive to fast ray tracing programs. We present a benchmark suite which allows for an extensive comparison of ray tracing algorithms.\}", \}

.S\-E\-C\-T\-I\-O\-N Thanks John Biddiscombe for developing and contributing this class

\subsection*{.S\-E\-C\-T\-I\-O\-N To\-Do}

Implement intersection heap for testing rays against transparent objects

\subsection*{.S\-E\-C\-T\-I\-O\-N Style}

This class is currently maintained by J. Biddiscombe who has specially requested that the code style not be modified to the kitware standard. Please respect the contribution of this class by keeping the style as close as possible to the author's original.

To create an instance of class vtk\-Modified\-B\-S\-P\-Tree, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkModifiedBSPTree
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Modified\-B\-S\-P\-Tree has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Modified\-B\-S\-P\-Tree class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()} -\/ Standard Type-\/\-Macro  
\item {\ttfamily int = obj.\-Is\-A (string name)} -\/ Standard Type-\/\-Macro  
\item {\ttfamily vtk\-Modified\-B\-S\-P\-Tree = obj.\-New\-Instance ()} -\/ Standard Type-\/\-Macro  
\item {\ttfamily vtk\-Modified\-B\-S\-P\-Tree = obj.\-Safe\-Down\-Cast (vtk\-Object o)} -\/ Standard Type-\/\-Macro  
\item {\ttfamily obj.\-Free\-Search\-Structure ()} -\/ Free tree memory  
\item {\ttfamily obj.\-Build\-Locator ()} -\/ Build Tree  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkmultiblockdataset}{}\section{vtk\-Multi\-Block\-Data\-Set}\label{vtkfiltering_vtkmultiblockdataset}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Multi\-Block\-Data\-Set is a vtk\-Composite\-Data\-Set that stores a hierarchy of datasets. The dataset collection consists of multiple blocks. Each block can itself be a vtk\-Multi\-Block\-Data\-Set, thus providing for a full tree structure. Sub-\/blocks are usually used to distribute blocks across processors. For example, a 1 block dataset can be distributed as following\-: \begin{DoxyVerb} proc 0:
 Block 0:
   * ds 0
   * (null)

 proc 1:
 Block 0:
   * (null)
   * ds 1\end{DoxyVerb}


To create an instance of class vtk\-Multi\-Block\-Data\-Set, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkMultiBlockDataSet
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Multi\-Block\-Data\-Set has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Multi\-Block\-Data\-Set class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Multi\-Block\-Data\-Set = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Multi\-Block\-Data\-Set = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Data\-Object\-Type ()} -\/ Set the number of blocks. This will cause allocation if the new number of blocks is greater than the current size. All new blocks are initialized to null.  
\item {\ttfamily obj.\-Set\-Number\-Of\-Blocks (int num\-Blocks)} -\/ Set the number of blocks. This will cause allocation if the new number of blocks is greater than the current size. All new blocks are initialized to null.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Blocks ()} -\/ Returns the number of blocks.  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Block (int blockno)} -\/ Returns the block at the given index. It is recommended that one uses the iterators to iterate over composite datasets rather than using this A\-P\-I.  
\item {\ttfamily obj.\-Set\-Block (int blockno, vtk\-Data\-Object block)} -\/ Sets the data object as the given block. The total number of blocks will be resized to fit the requested block no.  
\item {\ttfamily obj.\-Remove\-Block (int blockno)} -\/ Remove the given block from the dataset.  
\item {\ttfamily int = obj.\-Has\-Meta\-Data (int blockno)} -\/ Returns the meta-\/data for the block. If none is already present, a new vtk\-Information object will be allocated. Use Has\-Meta\-Data to avoid allocating vtk\-Information objects.  
\item {\ttfamily vtk\-Information = obj.\-Get\-Meta\-Data (int blockno)} -\/ Unhiding superclass method.  
\item {\ttfamily vtk\-Information = obj.\-Get\-Meta\-Data (vtk\-Composite\-Data\-Iterator iter)} -\/ Unhiding superclass method.  
\item {\ttfamily int = obj.\-Has\-Meta\-Data (vtk\-Composite\-Data\-Iterator iter)}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkmultiblockdatasetalgorithm}{}\section{vtk\-Multi\-Block\-Data\-Set\-Algorithm}\label{vtkfiltering_vtkmultiblockdatasetalgorithm}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Algorithms that take any type of data object (including composite dataset) and produce a vtk\-Multi\-Block\-Data\-Set in the output can subclass from this class.

To create an instance of class vtk\-Multi\-Block\-Data\-Set\-Algorithm, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkMultiBlockDataSetAlgorithm
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Multi\-Block\-Data\-Set\-Algorithm has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Multi\-Block\-Data\-Set\-Algorithm class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Multi\-Block\-Data\-Set\-Algorithm = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Multi\-Block\-Data\-Set\-Algorithm = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Multi\-Block\-Data\-Set = obj.\-Get\-Output ()} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Multi\-Block\-Data\-Set = obj.\-Get\-Output (int )} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Object )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Set\-Input (int , vtk\-Data\-Object )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkmultipiecedataset}{}\section{vtk\-Multi\-Piece\-Data\-Set}\label{vtkfiltering_vtkmultipiecedataset}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
A vtk\-Multi\-Piece\-Data\-Set dataset groups multiple data pieces together. For example, say that a simulation broke a volume into 16 piece so that each piece can be processed with 1 process in parallel. We want to load this volume in a visualization cluster of 4 nodes. Each node will get 4 pieces, not necessarily forming a whole rectangular piece. In this case, it is not possible to append the 4 pieces together into a vtk\-Image\-Data. In this case, these 4 pieces can be collected together using a vtk\-Multi\-Piece\-Data\-Set. Note that vtk\-Multi\-Piece\-Data\-Set is intended to be included in other composite datasets eg. vtk\-Multi\-Block\-Data\-Set, vtk\-Hierarchical\-Box\-Data\-Set. Hence the lack of algorithms producting vtk\-Multi\-Piece\-Data\-Set.

To create an instance of class vtk\-Multi\-Piece\-Data\-Set, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkMultiPieceDataSet
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Multi\-Piece\-Data\-Set has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Multi\-Piece\-Data\-Set class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Multi\-Piece\-Data\-Set = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Multi\-Piece\-Data\-Set = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Data\-Object\-Type ()} -\/ Set the number of pieces. This will cause allocation if the new number of pieces is greater than the current size. All new pieces are initialized to null.  
\item {\ttfamily obj.\-Set\-Number\-Of\-Pieces (int numpieces)} -\/ Set the number of pieces. This will cause allocation if the new number of pieces is greater than the current size. All new pieces are initialized to null.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Pieces ()} -\/ Returns the number of pieces.  
\item {\ttfamily vtk\-Data\-Set = obj.\-Get\-Piece (int pieceno)} -\/ Returns the piece at the given index.  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Piece\-As\-Data\-Object (int pieceno)} -\/ Returns the piece at the given index.  
\item {\ttfamily obj.\-Set\-Piece (int pieceno, vtk\-Data\-Object piece)} -\/ Sets the data object as the given piece. The total number of pieces will be resized to fit the requested piece no.  
\item {\ttfamily int = obj.\-Has\-Meta\-Data (int piece)} -\/ Returns the meta-\/data for the piece. If none is already present, a new vtk\-Information object will be allocated. Use Has\-Meta\-Data to avoid allocating vtk\-Information objects.  
\item {\ttfamily vtk\-Information = obj.\-Get\-Meta\-Data (int pieceno)} -\/ Unhiding superclass method.  
\item {\ttfamily vtk\-Information = obj.\-Get\-Meta\-Data (vtk\-Composite\-Data\-Iterator iter)} -\/ Unhiding superclass method.  
\item {\ttfamily int = obj.\-Has\-Meta\-Data (vtk\-Composite\-Data\-Iterator iter)}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkmutabledirectedgraph}{}\section{vtk\-Mutable\-Directed\-Graph}\label{vtkfiltering_vtkmutabledirectedgraph}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Mutable\-Directed\-Graph is a directed graph which has additional methods for adding edges and vertices. Add\-Child() is a convenience method for constructing trees. Shallow\-Copy(), Deep\-Copy(), Checked\-Shallow\-Copy() and Checked\-Deep\-Copy() will succeed for instances of vtk\-Directed\-Graph, vtk\-Mutable\-Directed\-Graph and vtk\-Tree.

To create an instance of class vtk\-Mutable\-Directed\-Graph, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkMutableDirectedGraph
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Mutable\-Directed\-Graph has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Mutable\-Directed\-Graph class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Mutable\-Directed\-Graph = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Mutable\-Directed\-Graph = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Id\-Type = obj.\-Add\-Vertex ()} -\/ Adds a vertex to the graph and returns the index of the new vertex.

Note\-: In a distributed graph (i.\-e. a graph whose Distributed\-Helper is non-\/null), this routine cannot be used to add a vertex if the vertices in the graph have pedigree I\-Ds, because this routine will always add the vertex locally, which may conflict with the proper location of the vertex based on the distribution of the pedigree I\-Ds.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Add\-Vertex (vtk\-Variant\-Array property\-Arr)} -\/ Adds a vertex to the graph with associated properties defined in {\ttfamily property\-Arr} and returns the index of the new vertex. The number and order of values in {\ttfamily property\-Arr} must match up with the arrays in the vertex data retrieved by Get\-Vertex\-Data().

If a vertex with the given pedigree I\-D already exists, its properties will be overwritten with the properties in {\ttfamily property\-Arr} and the existing vertex index will be returned.

Note\-: In a distributed graph (i.\-e. a graph whose Distributed\-Helper is non-\/null) the vertex added or found might not be local. In this case, Add\-Vertex will wait until the vertex can be added or found remotely, so that the proper vertex index can be returned. If you don't actually need to use the vertex index, consider calling Lazy\-Add\-Vertex, which provides better performance by eliminating the delays associated with returning the vertex index.  
\item {\ttfamily obj.\-Lazy\-Add\-Vertex ()} -\/ Adds a vertex to the graph.

This method is lazily evaluated for distributed graphs (i.\-e. graphs whose Distributed\-Helper is non-\/null) the next time Synchronize is called on the helper.  
\item {\ttfamily obj.\-Lazy\-Add\-Vertex (vtk\-Variant\-Array property\-Arr)} -\/ Adds a vertex to the graph with associated properties defined in {\ttfamily property\-Arr}. The number and order of values in {\ttfamily property\-Arr} must match up with the arrays in the vertex data retrieved by Get\-Vertex\-Data().

If a vertex with the given pedigree I\-D already exists, its properties will be overwritten with the properties in {\ttfamily property\-Arr}.

This method is lazily evaluated for distributed graphs (i.\-e. graphs whose Distributed\-Helper is non-\/null) the next time Synchronize is called on the helper.  
\item {\ttfamily vtk\-Graph\-Edge = obj.\-Add\-Graph\-Edge (vtk\-Id\-Type u, vtk\-Id\-Type v)} -\/ Variant of Add\-Edge() that returns a heavyweight {\ttfamily vtk\-Graph\-Edge} object. The graph owns the reference of the edge and will replace its contents on the next call to Add\-Graph\-Edge().

Note\-: This is a less efficient method for use with wrappers. In C++ you should use the faster Add\-Edge().  
\item {\ttfamily vtk\-Id\-Type = obj.\-Add\-Child (vtk\-Id\-Type parent, vtk\-Variant\-Array property\-Arr)} -\/ Convenience method for creating trees. Returns the newly created vertex id. Shortcut for \begin{DoxyVerb} vtkIdType v = g->AddVertex();
 g->AddEdge(parent, v);\end{DoxyVerb}
 If non-\/null, {\ttfamily property\-Arr} provides edge properties for the newly-\/created edge. The values in {\ttfamily property\-Arr} must match up with the arrays in the edge data returned by Get\-Edge\-Data().  
\item {\ttfamily vtk\-Id\-Type = obj.\-Add\-Child (vtk\-Id\-Type parent)} -\/ Removes the vertex from the graph along with any connected edges. Note\-: This invalidates the last vertex index, which is reassigned to v.  
\item {\ttfamily obj.\-Remove\-Vertex (vtk\-Id\-Type v)} -\/ Removes the vertex from the graph along with any connected edges. Note\-: This invalidates the last vertex index, which is reassigned to v.  
\item {\ttfamily obj.\-Remove\-Edge (vtk\-Id\-Type e)} -\/ Removes the edge from the graph. Note\-: This invalidates the last edge index, which is reassigned to e.  
\item {\ttfamily obj.\-Remove\-Vertices (vtk\-Id\-Type\-Array arr)} -\/ Removes a collection of vertices from the graph along with any connected edges.  
\item {\ttfamily obj.\-Remove\-Edges (vtk\-Id\-Type\-Array arr)} -\/ Removes a collection of edges from the graph.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkmutableundirectedgraph}{}\section{vtk\-Mutable\-Undirected\-Graph}\label{vtkfiltering_vtkmutableundirectedgraph}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Mutable\-Undirected\-Graph is an undirected graph with additional functions for adding vertices and edges. Shallow\-Copy(), Deep\-Copy(), Checked\-Shallow\-Copy(), and Checked\-Deep\-Copy() will succeed when the argument is a vtk\-Undirected\-Graph or vtk\-Mutable\-Undirected\-Graph.

To create an instance of class vtk\-Mutable\-Undirected\-Graph, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkMutableUndirectedGraph
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Mutable\-Undirected\-Graph has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Mutable\-Undirected\-Graph class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Mutable\-Undirected\-Graph = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Mutable\-Undirected\-Graph = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Id\-Type = obj.\-Add\-Vertex ()} -\/ Adds a vertex to the graph and returns the index of the new vertex.

Note\-: In a distributed graph (i.\-e. a graph whose Distributed\-Helper is non-\/null), this routine cannot be used to add a vertex if the vertices in the graph have pedigree I\-Ds, because this routine will always add the vertex locally, which may conflict with the proper location of the vertex based on the distribution of the pedigree I\-Ds.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Add\-Vertex (vtk\-Variant\-Array property\-Arr)} -\/ Adds a vertex to the graph with associated properties defined in {\ttfamily property\-Arr} and returns the index of the new vertex. The number and order of values in {\ttfamily property\-Arr} must match up with the arrays in the vertex data retrieved by Get\-Vertex\-Data().

If a vertex with the given pedigree I\-D already exists, its properties will be overwritten with the properties in {\ttfamily property\-Arr} and the existing vertex index will be returned.

Note\-: In a distributed graph (i.\-e. a graph whose Distributed\-Helper is non-\/null) the vertex added or found might not be local. In this case, Add\-Vertex will wait until the vertex can be added or found remotely, so that the proper vertex index can be returned. If you don't actually need to use the vertex index, consider calling Lazy\-Add\-Vertex, which provides better performance by eliminating the delays associated with returning the vertex index.  
\item {\ttfamily obj.\-Lazy\-Add\-Vertex ()} -\/ Adds a vertex to the graph.

This method is lazily evaluated for distributed graphs (i.\-e. graphs whose Distributed\-Helper is non-\/null) the next time Synchronize is called on the helper.  
\item {\ttfamily obj.\-Lazy\-Add\-Vertex (vtk\-Variant\-Array property\-Arr)} -\/ Adds a vertex to the graph with associated properties defined in {\ttfamily property\-Arr}. The number and order of values in {\ttfamily property\-Arr} must match up with the arrays in the vertex data retrieved by Get\-Vertex\-Data().

If a vertex with the given pedigree I\-D already exists, its properties will be overwritten with the properties in {\ttfamily property\-Arr}.

This method is lazily evaluated for distributed graphs (i.\-e. graphs whose Distributed\-Helper is non-\/null) the next time Synchronize is called on the helper.  
\item {\ttfamily obj.\-Lazy\-Add\-Edge (vtk\-Id\-Type u, vtk\-Id\-Type v)} -\/ Adds an undirected edge from {\ttfamily u} to {\ttfamily v}, where {\ttfamily u} and {\ttfamily v} are vertex indices.

This method is lazily evaluated for distributed graphs (i.\-e. graphs whose Distributed\-Helper is non-\/null) the next time Synchronize is called on the helper.  
\item {\ttfamily obj.\-Lazy\-Add\-Edge (vtk\-Id\-Type u, vtk\-Id\-Type v, vtk\-Variant\-Array property\-Arr)} -\/ Adds an undirected edge from {\ttfamily u} to {\ttfamily v}, where {\ttfamily u} and {\ttfamily v} are vertex indices.

The number and order of values in {\ttfamily property\-Arr} must match up with the arrays in the edge data retrieved by Get\-Edge\-Data().

This method is lazily evaluated for distributed graphs (i.\-e. graphs whose Distributed\-Helper is non-\/null) the next time Synchronize is called on the helper.  
\item {\ttfamily vtk\-Graph\-Edge = obj.\-Add\-Graph\-Edge (vtk\-Id\-Type u, vtk\-Id\-Type v)} -\/ Variant of Add\-Edge() that returns a heavyweight {\ttfamily vtk\-Graph\-Edge} object. The graph owns the reference of the edge and will replace its contents on the next call to Add\-Graph\-Edge().

Note\-: This is a less efficient method for use with wrappers. In C++ you should use the faster Add\-Edge().  
\item {\ttfamily obj.\-Remove\-Vertex (vtk\-Id\-Type v)} -\/ Removes the vertex from the graph along with any connected edges. Note\-: This invalidates the last vertex index, which is reassigned to v.  
\item {\ttfamily obj.\-Remove\-Edge (vtk\-Id\-Type e)} -\/ Removes the edge from the graph. Note\-: This invalidates the last edge index, which is reassigned to e.  
\item {\ttfamily obj.\-Remove\-Vertices (vtk\-Id\-Type\-Array arr)} -\/ Removes a collection of vertices from the graph along with any connected edges.  
\item {\ttfamily obj.\-Remove\-Edges (vtk\-Id\-Type\-Array arr)} -\/ Removes a collection of edges from the graph.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtknonlinearcell}{}\section{vtk\-Non\-Linear\-Cell}\label{vtkfiltering_vtknonlinearcell}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Non\-Linear\-Cell is an abstract superclass for non-\/linear cell types. Cells that are a direct subclass of vtk\-Cell or vtk\-Cell3\-D are linear; cells that are a subclass of vtk\-Non\-Linear\-Cell have non-\/linear interpolation functions. Non-\/linear cells require special treatment when tessellating or converting to graphics primitives. Note that the linearity of the cell is a function of whether the cell needs tessellation, which does not strictly correlate with interpolation order (e.\-g., vtk\-Hexahedron has non-\/linear interpolation functions (a product of three linear functions in r-\/s-\/t) even thought vtk\-Hexahedron is considered linear.)

To create an instance of class vtk\-Non\-Linear\-Cell, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkNonLinearCell
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Non\-Linear\-Cell has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Non\-Linear\-Cell class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Non\-Linear\-Cell = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Non\-Linear\-Cell = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Is\-Linear ()}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtknonmergingpointlocator}{}\section{vtk\-Non\-Merging\-Point\-Locator}\label{vtkfiltering_vtknonmergingpointlocator}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
As a special sub-\/class of vtk\-Point\-Locator, vtk\-Non\-Merging\-Point\-Locator is intended for direct / check-\/free insertion of points into a vtk\-Points object. In other words, any given point is always directly inserted. The name emphasizes the difference between this class and its sibling class vtk\-Merge\-Points in that the latter class performs check-\/based zero tolerance point insertion (or to 'merge' exactly duplicate / coincident points) by exploiting the uniform bin mechanism employed by the parent class vtk\-Point\-Locator. vtk\-Point\-Locator allows for generic (zero and non-\/ zero) tolerance point insertion as well as point location.

To create an instance of class vtk\-Non\-Merging\-Point\-Locator, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkNonMergingPointLocator
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Non\-Merging\-Point\-Locator has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Non\-Merging\-Point\-Locator class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Non\-Merging\-Point\-Locator = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Non\-Merging\-Point\-Locator = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkoctreepointlocator}{}\section{vtk\-Octree\-Point\-Locator}\label{vtkfiltering_vtkoctreepointlocator}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Given a vtk\-Data\-Setxs, create an octree that is locally refined such that all leaf octants contain less than a certain amount of points. Note that there is no size constraint that a leaf octant in relation to any of its neighbors.

This class can also generate a Poly\-Data representation of the boundaries of the spatial regions in the decomposition.

To create an instance of class vtk\-Octree\-Point\-Locator, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkOctreePointLocator
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Octree\-Point\-Locator has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Octree\-Point\-Locator class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Octree\-Point\-Locator = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Octree\-Point\-Locator = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Maximum\-Points\-Per\-Region (int )} -\/ Maximum number of points per spatial region. Default is 100.  
\item {\ttfamily int = obj.\-Get\-Maximum\-Points\-Per\-Region ()} -\/ Maximum number of points per spatial region. Default is 100.  
\item {\ttfamily obj.\-Set\-Create\-Cubic\-Octants (int )} -\/ Get/\-Set macro for Create\-Cubic\-Octants.  
\item {\ttfamily int = obj.\-Get\-Create\-Cubic\-Octants ()} -\/ Get/\-Set macro for Create\-Cubic\-Octants.  
\item {\ttfamily double = obj.\-Get\-Fudge\-Factor ()} -\/ Some algorithms on octrees require a value that is a very small distance relative to the diameter of the entire space divided by the octree. This factor is the maximum axis-\/aligned width of the space multipled by 10e-\/6.  
\item {\ttfamily obj.\-Set\-Fudge\-Factor (double )} -\/ Some algorithms on octrees require a value that is a very small distance relative to the diameter of the entire space divided by the octree. This factor is the maximum axis-\/aligned width of the space multipled by 10e-\/6.  
\item {\ttfamily obj.\-Get\-Bounds (double bounds)} -\/ Get the spatial bounds of the entire octree space. Sets bounds array to xmin, xmax, ymin, ymax, zmin, zmax.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Leaf\-Nodes ()} -\/ The number of leaf nodes of the tree, the spatial regions  
\item {\ttfamily obj.\-Get\-Region\-Bounds (int region\-I\-D, double bounds\mbox{[}6\mbox{]})} -\/ Get the spatial bounds of octree region  
\item {\ttfamily obj.\-Get\-Region\-Data\-Bounds (int leaf\-Node\-I\-D, double bounds\mbox{[}6\mbox{]})} -\/ Get the bounds of the data within the leaf node  
\item {\ttfamily int = obj.\-Get\-Region\-Containing\-Point (double x, double y, double z)} -\/ Get the id of the leaf region containing the specified location.  
\item {\ttfamily obj.\-Build\-Locator ()} -\/ Create the octree decomposition of the cells of the data set or data sets. Cells are assigned to octree spatial regions based on the location of their centroids.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Find\-Closest\-Point (double x\mbox{[}3\mbox{]})} -\/ Return the Id of the point that is closest to the given point. Set the square of the distance between the two points.  
\item {\ttfamily obj.\-Find\-Points\-Within\-Radius (double radius, double x\mbox{[}3\mbox{]}, vtk\-Id\-List result)} -\/ Find all points within a specified radius of position x. The result is not sorted in any specific manner.  
\item {\ttfamily obj.\-Find\-Closest\-N\-Points (int N, double x\mbox{[}3\mbox{]}, vtk\-Id\-List result)} -\/ Find the closest N points to a position. This returns the closest N points to a position. A faster method could be created that returned N close points to a position, but not necessarily the exact N closest. The returned points are sorted from closest to farthest. These methods are thread safe if Build\-Locator() is directly or indirectly called from a single thread first.  
\item {\ttfamily vtk\-Id\-Type\-Array = obj.\-Get\-Points\-In\-Region (int leaf\-Node\-Id)} -\/ Get a list of the original I\-Ds of all points in a leaf node.  
\item {\ttfamily obj.\-Free\-Search\-Structure ()} -\/ Delete the octree data structure.  
\item {\ttfamily obj.\-Generate\-Representation (int level, vtk\-Poly\-Data pd)} -\/ Create a polydata representation of the boundaries of the octree regions.  
\item {\ttfamily obj.\-Find\-Points\-In\-Area (double area, vtk\-Id\-Type\-Array ids, bool clear\-Arraytrue)} -\/ Fill ids with points found in area. The area is a 6-\/tuple containing (xmin, xmax, ymin, ymax, zmin, zmax). This method will clear the array by default. To append ids to an array, set clear\-Array to false.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkoctreepointlocatornode}{}\section{vtk\-Octree\-Point\-Locator\-Node}\label{vtkfiltering_vtkoctreepointlocatornode}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This class represents a single spatial region in a 3\-D axis octant partitioning. It is intended to work efficiently with the vtk\-Octree\-Point\-Locator and is not meant for general use. It is assumed the region bounds some set of points. The ordering of the children is (-\/x,-\/y,-\/z),(+x,-\/y,-\/z),(-\/x,+y,-\/z),(+x,+y,-\/z),(-\/x,-\/y,+z),(+x,-\/y,+z), (-\/x,+y,+z),(+x,+y,+z). The portion of the domain assigned to an octant is Min $<$ x $<$= Max.

To create an instance of class vtk\-Octree\-Point\-Locator\-Node, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkOctreePointLocatorNode
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Octree\-Point\-Locator\-Node has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Octree\-Point\-Locator\-Node class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Octree\-Point\-Locator\-Node = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Octree\-Point\-Locator\-Node = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Number\-Of\-Points (int number\-Of\-Points)} -\/ Set/\-Get the number of points contained in this region.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Points ()} -\/ Set/\-Get the number of points contained in this region.  
\item {\ttfamily obj.\-Set\-Bounds (double x\-Min, double x\-Max, double y\-Min, double y\-Max, double z\-Min, double z\-Max)} -\/ Set/\-Get the bounds of the spatial region represented by this node. Caller allocates storage for 6-\/vector in Get\-Bounds.  
\item {\ttfamily obj.\-Set\-Bounds (double b\mbox{[}6\mbox{]})} -\/ Set/\-Get the bounds of the spatial region represented by this node. Caller allocates storage for 6-\/vector in Get\-Bounds.  
\item {\ttfamily obj.\-Get\-Bounds (double b) const} -\/ Set/\-Get the bounds of the spatial region represented by this node. Caller allocates storage for 6-\/vector in Get\-Bounds.  
\item {\ttfamily obj.\-Set\-Data\-Bounds (double x\-Min, double x\-Max, double y\-Min, double y\-Max, double z\-Min, double z\-Max)} -\/ Set/\-Get the bounds of the points contained in this spatial region. This may be smaller than the bounds of the region itself. Caller allocates storage for 6-\/vector in Get\-Data\-Bounds.  
\item {\ttfamily obj.\-Get\-Data\-Bounds (double b) const} -\/ Set/\-Get the bounds of the points contained in this spatial region. This may be smaller than the bounds of the region itself. Caller allocates storage for 6-\/vector in Get\-Data\-Bounds.  
\item {\ttfamily obj.\-Set\-Min\-Bounds (double min\-Bounds\mbox{[}3\mbox{]})} -\/ Set the xmax, ymax and zmax value of the bounds of this region  
\item {\ttfamily obj.\-Set\-Max\-Bounds (double max\-Bounds\mbox{[}3\mbox{]})} -\/ Set the xmin, ymin and zmin value of the bounds of this data within this region.  
\item {\ttfamily obj.\-Set\-Min\-Data\-Bounds (double min\-Data\-Bounds\mbox{[}3\mbox{]})} -\/ Set the xmax, ymax and zmax value of the bounds of this data within this region.  
\item {\ttfamily obj.\-Set\-Max\-Data\-Bounds (double max\-Data\-Bounds\mbox{[}3\mbox{]})} -\/ Get the I\-D associated with the region described by this node. If this is not a leaf node, this value should be -\/1.  
\item {\ttfamily int = obj.\-Get\-I\-D ()} -\/ Get the I\-D associated with the region described by this node. If this is not a leaf node, this value should be -\/1.  
\item {\ttfamily int = obj.\-Get\-Min\-I\-D ()} -\/ If this node is not a leaf node, there are leaf nodes below it whose regions represent a partitioning of this region. The I\-Ds of these leaf nodes form a contigous set. Get the first of the first point's I\-D that is contained in this node.  
\item {\ttfamily obj.\-Create\-Child\-Nodes ()} -\/ Add the 8 children.  
\item {\ttfamily obj.\-Delete\-Child\-Nodes ()} -\/ Delete the 8 children.  
\item {\ttfamily vtk\-Octree\-Point\-Locator\-Node = obj.\-Get\-Child (int i)} -\/ Get a pointer to the ith child of this node.  
\item {\ttfamily int = obj.\-Intersects\-Region (vtk\-Planes\-Intersection pi, int use\-Data\-Bounds)} -\/ A vtk\-Planes\-Intersection object represents a convex 3\-D region bounded by planes, and it is capable of computing intersections of boxes with itself. Return 1 if this spatial region intersects the spatial region described by the vtk\-Planes\-Intersection object. Use the possibly smaller bounds of the points within the region if use\-Data\-Bounds is non-\/zero.  
\item {\ttfamily int = obj.\-Contains\-Point (double x, double y, double z, int use\-Data\-Bounds)} -\/ Return 1 if this spatial region entirely contains the given point. Use the possibly smaller bounds of the points within the region if use\-Data\-Bounds is non-\/zero.  
\item {\ttfamily double = obj.\-Get\-Distance2\-To\-Boundary (double x, double y, double z, vtk\-Octree\-Point\-Locator\-Node top, int use\-Data\-Bounds)} -\/ Calculate the distance squared from any point to the boundary of this region. Use the boundary of the points within the region if use\-Data\-Bounds is non-\/zero.  
\item {\ttfamily double = obj.\-Get\-Distance2\-To\-Boundary (double x, double y, double z, double boundary\-Pt, vtk\-Octree\-Point\-Locator\-Node top, int use\-Data\-Bounds)} -\/ Calculate the distance squared from any point to the boundary of this region. Use the boundary of the points within the region if use\-Data\-Bounds is non-\/zero. Set boundary\-Pt to the point on the boundary.  
\item {\ttfamily double = obj.\-Get\-Distance2\-To\-Inner\-Boundary (double x, double y, double z, vtk\-Octree\-Point\-Locator\-Node top)} -\/ Calculate the distance from the specified point (which is required to be inside this spatial region) to an interior boundary. An interior boundary is one that is not also an boundary of the entire space partitioned by the tree of vtk\-Octree\-Point\-Locator\-Node's.  
\item {\ttfamily int = obj.\-Get\-Sub\-Octant\-Index (double point, int Check\-Containment)} -\/ Return the id of the suboctant that a given point is in. If Check\-Containment is non-\/zero then it checks whether the point is in the actual bounding box of the suboctant, otherwise it only checks which octant the point is in that is created from the axis-\/aligned partitioning of the domain at this octant's center.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkorderedtriangulator}{}\section{vtk\-Ordered\-Triangulator}\label{vtkfiltering_vtkorderedtriangulator}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This class is used to generate unique triangulations of points. The uniqueness of the triangulation is controlled by the id of the inserted points in combination with a Delaunay criterion. The class is designed to be as fast as possible (since the algorithm can be slow) and uses block memory allocations to support rapid triangulation generation. Also, the assumption behind the class is that a maximum of hundreds of points are to be triangulated. If you desire more robust triangulation methods use vtk\-Polygon\-::\-Triangulate(), vtk\-Delaunay2\-D, or vtk\-Delaunay3\-D.

.S\-E\-C\-T\-I\-O\-N Background This work is documented in the technical paper\-: W.\-J. Schroeder, B. Geveci, M. Malaterre. Compatible Triangulations of Spatial Decompositions. In Proceedings of Visualization 2004, I\-E\-E\-E Press October 2004.

Delaunay triangulations are unique assuming a random distribution of input points. The 3\-D Delaunay criterion is as follows\-: the circumsphere of each tetrahedron contains no other points of the triangulation except for the four points defining the tetrahedron. In application this property is hard to satisfy because objects like cubes are defined by eight points all sharing the same circumsphere (center and radius); hence the Delaunay triangulation is not unique. These so-\/called degenerate situations are typically resolved by arbitrary selecting a triangulation. This code does something different\-: it resolves degenerate triangulations by modifying the \char`\"{}\-In\-Circumsphere\char`\"{} method to use a slightly smaller radius. Hence, degenerate points are always considered \char`\"{}out\char`\"{} of the circumsphere. This, in combination with an ordering (based on id) of the input points, guarantees a unique triangulation.

There is another related characteristic of Delaunay triangulations. Given a N-\/dimensional Delaunay triangulation, points lying on a (N-\/1) dimensional plane also form a (N-\/1) Delaunay triangulation. This means for example, that if a 3\-D cell is defined by a set of (2\-D) planar faces, then the face triangulations are Delaunay. Combining this with the method to generate unique triangulations described previously, the triangulations on the face are guaranteed unique. This fact can be used to triangulate 3\-D objects in such a way to guarantee compatible face triangulations. This is a very useful fact for parallel processing, or performing operations like clipping that require compatible triangulations across 3\-D cell faces. (See vtk\-Clip\-Volume for an example.)

A special feature of this class is that it can generate triangulation templates on the fly. If template triangulation is enabled, then the ordered triangulator will first triangulate the cell using the slower ordered Delaunay approach, and then store the result as a template. Later, if the same cell type and cell configuration is encountered, then the template is reused which greatly speeds the triangulation.

To create an instance of class vtk\-Ordered\-Triangulator, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkOrderedTriangulator
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Ordered\-Triangulator has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Ordered\-Triangulator class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Ordered\-Triangulator = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Ordered\-Triangulator = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Init\-Triangulation (double xmin, double xmax, double ymin, double ymax, double zmin, double zmax, int num\-Pts)} -\/ Initialize the triangulation process. Provide a bounding box and the maximum number of points to be inserted. Note that since the triangulation is performed using parametric coordinates (see Insert\-Point()) the bounds should be represent the range of the parametric coordinates inserted. \begin{DoxyPostcond}{Postcondition}
no\-\_\-point\-\_\-inserted\-: Get\-Number\-Of\-Points()==0  
\end{DoxyPostcond}

\item {\ttfamily obj.\-Init\-Triangulation (double bounds\mbox{[}6\mbox{]}, int num\-Pts)} -\/ Initialize the triangulation process. Provide a bounding box and the maximum number of points to be inserted. Note that since the triangulation is performed using parametric coordinates (see Insert\-Point()) the bounds should be represent the range of the parametric coordinates inserted. \begin{DoxyPostcond}{Postcondition}
no\-\_\-point\-\_\-inserted\-: Get\-Number\-Of\-Points()==0  
\end{DoxyPostcond}

\item {\ttfamily vtk\-Id\-Type = obj.\-Insert\-Point (vtk\-Id\-Type id, double x\mbox{[}3\mbox{]}, double p\mbox{[}3\mbox{]}, int type)} -\/ For each point to be inserted, provide an id, a position x, parametric coordinate p, and whether the point is inside (type=0), outside (type=1), or on the boundary (type=2). You must call Init\-Triangulation() prior to invoking this method. Make sure that the number of points inserted does not exceed the num\-Pts specified in Init\-Triangulation(). Also note that the \char`\"{}id\char`\"{} can be any integer and can be greater than num\-Pts. It is used to create tetras (in Add\-Tetras()) with the appropriate connectivity ids. The method returns an internal id that can be used prior to the Triangulate() method to update the type of the point with Update\-Point\-Type(). (Note\-: the algorithm triangulated with the parametric coordinate p\mbox{[}3\mbox{]} and creates tetras with the global coordinate x\mbox{[}3\mbox{]}. The parametric coordinates and global coordinates may be the same.)  
\item {\ttfamily vtk\-Id\-Type = obj.\-Insert\-Point (vtk\-Id\-Type id, vtk\-Id\-Type sortid, double x\mbox{[}3\mbox{]}, double p\mbox{[}3\mbox{]}, int type)} -\/ For each point to be inserted, provide an id, a position x, parametric coordinate p, and whether the point is inside (type=0), outside (type=1), or on the boundary (type=2). You must call Init\-Triangulation() prior to invoking this method. Make sure that the number of points inserted does not exceed the num\-Pts specified in Init\-Triangulation(). Also note that the \char`\"{}id\char`\"{} can be any integer and can be greater than num\-Pts. It is used to create tetras (in Add\-Tetras()) with the appropriate connectivity ids. The method returns an internal id that can be used prior to the Triangulate() method to update the type of the point with Update\-Point\-Type(). (Note\-: the algorithm triangulated with the parametric coordinate p\mbox{[}3\mbox{]} and creates tetras with the global coordinate x\mbox{[}3\mbox{]}. The parametric coordinates and global coordinates may be the same.)  
\item {\ttfamily vtk\-Id\-Type = obj.\-Insert\-Point (vtk\-Id\-Type id, vtk\-Id\-Type sortid, vtk\-Id\-Type sortid2, double x\mbox{[}3\mbox{]}, double p\mbox{[}3\mbox{]}, int type)} -\/ For each point to be inserted, provide an id, a position x, parametric coordinate p, and whether the point is inside (type=0), outside (type=1), or on the boundary (type=2). You must call Init\-Triangulation() prior to invoking this method. Make sure that the number of points inserted does not exceed the num\-Pts specified in Init\-Triangulation(). Also note that the \char`\"{}id\char`\"{} can be any integer and can be greater than num\-Pts. It is used to create tetras (in Add\-Tetras()) with the appropriate connectivity ids. The method returns an internal id that can be used prior to the Triangulate() method to update the type of the point with Update\-Point\-Type(). (Note\-: the algorithm triangulated with the parametric coordinate p\mbox{[}3\mbox{]} and creates tetras with the global coordinate x\mbox{[}3\mbox{]}. The parametric coordinates and global coordinates may be the same.)  
\item {\ttfamily obj.\-Triangulate ()} -\/ Perform the triangulation. (Complete all calls to Insert\-Point() prior to invoking this method.) A special version is available when templates should be used.  
\item {\ttfamily obj.\-Template\-Triangulate (int cell\-Type, int num\-Pts, int num\-Edges)} -\/ Perform the triangulation. (Complete all calls to Insert\-Point() prior to invoking this method.) A special version is available when templates should be used.  
\item {\ttfamily obj.\-Update\-Point\-Type (vtk\-Id\-Type internal\-Id, int type)} -\/ Update the point type. This is useful when the merging of nearly coincident points is performed. The id is the internal id returned from Insert\-Point(). The method should be invoked prior to the Triangulate method. The type is specified as inside (type=0), outside (type=1), or on the boundary (type=2). \begin{DoxyPrecond}{Precondition}
valid\-\_\-range\-: internal\-Id$>$=0 \&\& internal\-Id$<$this-\/$>$Get\-Number\-Of\-Points()  
\end{DoxyPrecond}

\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Point\-Id (vtk\-Id\-Type internal\-Id)} -\/ Return the Id of point `internal\-Id'. This id is the one passed in argument of Insert\-Point. It assumes that the point has already been inserted. The method should be invoked prior to the Triangulate method. \begin{DoxyPrecond}{Precondition}
valid\-\_\-range\-: internal\-Id$>$=0 \&\& internal\-Id$<$this-\/$>$Get\-Number\-Of\-Points()  
\end{DoxyPrecond}

\item {\ttfamily int = obj.\-Get\-Number\-Of\-Points ()} -\/ Return the number of inserted points.  
\item {\ttfamily obj.\-Set\-Use\-Templates (int )} -\/ If this flag is set, then the ordered triangulator will create and use templates for the triangulation. To use templates, the Template\-Triangulate() method should be called when appropriate. (Note\-: the Template\-Triangulate() method works for complete (interior) cells without extra points due to intersection, etc.)  
\item {\ttfamily int = obj.\-Get\-Use\-Templates ()} -\/ If this flag is set, then the ordered triangulator will create and use templates for the triangulation. To use templates, the Template\-Triangulate() method should be called when appropriate. (Note\-: the Template\-Triangulate() method works for complete (interior) cells without extra points due to intersection, etc.)  
\item {\ttfamily obj.\-Use\-Templates\-On ()} -\/ If this flag is set, then the ordered triangulator will create and use templates for the triangulation. To use templates, the Template\-Triangulate() method should be called when appropriate. (Note\-: the Template\-Triangulate() method works for complete (interior) cells without extra points due to intersection, etc.)  
\item {\ttfamily obj.\-Use\-Templates\-Off ()} -\/ If this flag is set, then the ordered triangulator will create and use templates for the triangulation. To use templates, the Template\-Triangulate() method should be called when appropriate. (Note\-: the Template\-Triangulate() method works for complete (interior) cells without extra points due to intersection, etc.)  
\item {\ttfamily obj.\-Set\-Pre\-Sorted (int )} -\/ Boolean indicates whether the points have been pre-\/sorted. If pre-\/sorted is enabled, the points are not sorted on point id. By default, presorted is off. (The point id is defined in Insert\-Point().)  
\item {\ttfamily int = obj.\-Get\-Pre\-Sorted ()} -\/ Boolean indicates whether the points have been pre-\/sorted. If pre-\/sorted is enabled, the points are not sorted on point id. By default, presorted is off. (The point id is defined in Insert\-Point().)  
\item {\ttfamily obj.\-Pre\-Sorted\-On ()} -\/ Boolean indicates whether the points have been pre-\/sorted. If pre-\/sorted is enabled, the points are not sorted on point id. By default, presorted is off. (The point id is defined in Insert\-Point().)  
\item {\ttfamily obj.\-Pre\-Sorted\-Off ()} -\/ Boolean indicates whether the points have been pre-\/sorted. If pre-\/sorted is enabled, the points are not sorted on point id. By default, presorted is off. (The point id is defined in Insert\-Point().)  
\item {\ttfamily obj.\-Set\-Use\-Two\-Sort\-Ids (int )} -\/ Tells the triangulator that a second sort id is provided for each point and should also be considered when sorting.  
\item {\ttfamily int = obj.\-Get\-Use\-Two\-Sort\-Ids ()} -\/ Tells the triangulator that a second sort id is provided for each point and should also be considered when sorting.  
\item {\ttfamily obj.\-Use\-Two\-Sort\-Ids\-On ()} -\/ Tells the triangulator that a second sort id is provided for each point and should also be considered when sorting.  
\item {\ttfamily obj.\-Use\-Two\-Sort\-Ids\-Off ()} -\/ Tells the triangulator that a second sort id is provided for each point and should also be considered when sorting.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Tetras (int classification, vtk\-Unstructured\-Grid ugrid)} -\/ Initialize and add the tetras and points from the triangulation to the unstructured grid provided. New points are created and the mesh is allocated. (This method differs from Add\-Tetras() in that it inserts points and cells; Add\-Tetras only adds the tetra cells.) The tetrahdera added are of the type specified (0=inside,1=outside,2=all). Inside tetrahedron are those whose points are classified \char`\"{}inside\char`\"{} or on the \char`\"{}boundary.\char`\"{} Outside tetrahedron have at least one point classified \char`\"{}outside.\char`\"{} The method returns the number of tetrahedrahedron of the type requested.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Add\-Tetras (int classification, vtk\-Unstructured\-Grid ugrid)} -\/ Add the tetras to the unstructured grid provided. The unstructured grid is assumed to have been initialized (with Allocate()) and points set (with Set\-Points()). The tetrahdera added are of the type specified (0=inside,1=outside,2=all). Inside tetrahedron are those whose points are classified \char`\"{}inside\char`\"{} or on the \char`\"{}boundary.\char`\"{} Outside tetrahedron have at least one point classified \char`\"{}outside.\char`\"{} The method returns the number of tetrahedrahedron of the type requested.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Add\-Tetras (int classification, vtk\-Cell\-Array connectivity)} -\/ Add the tetrahedra classified (0=inside,1=outside) to the connectivity list provided. Inside tetrahedron are those whose points are all classified \char`\"{}inside.\char`\"{} Outside tetrahedron have at least one point classified \char`\"{}outside.\char`\"{} The method returns the number of tetrahedron of the type requested.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Add\-Tetras (int classification, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array out\-Connectivity, vtk\-Point\-Data in\-P\-D, vtk\-Point\-Data out\-P\-D, vtk\-Cell\-Data in\-C\-D, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-C\-D)} -\/ Assuming that all the inserted points come from a cell `cell\-Id' to triangulate, get the tetrahedra in out\-Connectivity, the points in locator and copy point data and cell data. Return the number of added tetras. \begin{DoxyPrecond}{Precondition}
locator\-\_\-exists\-: locator!=0 

out\-Connectivity\-: out\-Connectivity!=0 

in\-P\-D\-\_\-exists\-: in\-P\-D!=0 

out\-P\-D\-\_\-exists\-: out\-P\-D!=0 

in\-C\-D\-\_\-exists\-: in\-C\-D!=0 

out\-C\-D\-\_\-exists\-: out\-C\-D!=0  
\end{DoxyPrecond}

\item {\ttfamily vtk\-Id\-Type = obj.\-Add\-Tetras (int classification, vtk\-Id\-List pt\-Ids, vtk\-Points pts)} -\/ Add the tetrahedra classified (0=inside,1=outside) to the list of ids and coordinates provided. These assume that the first four points form a tetrahedron, the next four the next, and so on.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Add\-Triangles (vtk\-Cell\-Array connectivity)} -\/ Add the triangle faces classified (2=boundary) to the connectivity list provided. The method returns the number of triangles.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Add\-Triangles (vtk\-Id\-Type id, vtk\-Cell\-Array connectivity)} -\/ Add the triangle faces classified (2=boundary) and attached to the specified point id to the connectivity list provided. (The id is the same as that specified in Insert\-Point().)  
\item {\ttfamily obj.\-Init\-Tetra\-Traversal ()} -\/ Methods to get one tetra at a time. Start with Init\-Tetra\-Traversal() and then invoke Get\-Next\-Tetra() until the method returns 0.  
\item {\ttfamily int = obj.\-Get\-Next\-Tetra (int classification, vtk\-Tetra tet, vtk\-Data\-Array cell\-Scalars, vtk\-Double\-Array tet\-Scalars)} -\/ Methods to get one tetra at a time. Start with Init\-Tetra\-Traversal() and then invoke Get\-Next\-Tetra() until the method returns 0. cell\-Scalars are point-\/centered scalars on the original cell. tet\-Scalars are point-\/centered scalars on the tetra\-: the values will be copied from cell\-Scalars. \begin{DoxyPrecond}{Precondition}
tet\-\_\-exists\-: tet!=0 

cell\-Scalars\-\_\-exists\-: cell\-Scalars!=0 

tet\-Scalars\-\_\-exists\-: tet\-Scalars!=0 

tet\-Scalars\-\_\-valid\-\_\-size\-: tet\-Scalars-\/$>$Get\-Number\-Of\-Tuples()==4  
\end{DoxyPrecond}

\end{DoxyItemize}\hypertarget{vtkfiltering_vtkoutedgeiterator}{}\section{vtk\-Out\-Edge\-Iterator}\label{vtkfiltering_vtkoutedgeiterator}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Out\-Edge\-Iterator iterates through all edges whose source is a particular vertex. Instantiate this class directly and call Initialize() to traverse the vertex of a graph. Alternately, use Get\-In\-Edges() on the graph to initialize the iterator. it-\/$>$Next() returns a vtk\-Out\-Edge\-Type structure, which contains Id, the edge's id, and Target, the edge's target vertex.

To create an instance of class vtk\-Out\-Edge\-Iterator, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkOutEdgeIterator
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Out\-Edge\-Iterator has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Out\-Edge\-Iterator class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Out\-Edge\-Iterator = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Out\-Edge\-Iterator = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Initialize (vtk\-Graph g, vtk\-Id\-Type v)} -\/ Initialize the iterator with a graph and vertex.  
\item {\ttfamily vtk\-Graph = obj.\-Get\-Graph ()} -\/ Get the graph and vertex associated with this iterator.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Vertex ()} -\/ Get the graph and vertex associated with this iterator.  
\item {\ttfamily vtk\-Graph\-Edge = obj.\-Next\-Graph\-Edge ()} -\/ Just like Next(), but returns heavy-\/weight vtk\-Graph\-Edge object instead of the vtk\-Edge\-Type struct, for use with wrappers. The graph edge is owned by this iterator, and changes after each call to Next\-Graph\-Edge().  
\item {\ttfamily bool = obj.\-Has\-Next ()}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkparametricspline}{}\section{vtk\-Parametric\-Spline}\label{vtkfiltering_vtkparametricspline}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Parametric\-Spline is a parametric function for 1\-D interpolating splines. vtk\-Parametric\-Spline maps the single parameter u into a 3\-D point (x,y,z) using three instances of interpolating splines. This family of 1\-D splines is quaranteed to be parameterized in the interval \mbox{[}0,1\mbox{]}. Attempting to evaluate outside this interval will cause the parameter u to be clamped in the range \mbox{[}0,1\mbox{]}.

When constructed, this class creates instances of vtk\-Cardinal\-Spline for each of the x-\/y-\/z coordinates. The user may choose to replace these with their own instances of subclasses of vtk\-Spline.

To create an instance of class vtk\-Parametric\-Spline, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkParametricSpline
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Parametric\-Spline has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Parametric\-Spline class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Parametric\-Spline = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Parametric\-Spline = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Dimension ()} -\/ Evaluate the spline at parametric coordinate u\mbox{[}0\mbox{]} returning the point coordinate Pt\mbox{[}3\mbox{]}.  
\item {\ttfamily obj.\-Evaluate (double u\mbox{[}3\mbox{]}, double Pt\mbox{[}3\mbox{]}, double Du\mbox{[}9\mbox{]})} -\/ Evaluate the spline at parametric coordinate u\mbox{[}0\mbox{]} returning the point coordinate Pt\mbox{[}3\mbox{]}.  
\item {\ttfamily double = obj.\-Evaluate\-Scalar (double u\mbox{[}3\mbox{]}, double Pt\mbox{[}3\mbox{]}, double Du\mbox{[}9\mbox{]})} -\/ Evaluate a scalar value at parametric coordinate u\mbox{[}0\mbox{]} and Pt\mbox{[}3\mbox{]}. The scalar value is just the parameter u\mbox{[}0\mbox{]}.  
\item {\ttfamily obj.\-Set\-X\-Spline (vtk\-Spline )} -\/ By default, this class is constructed with three instances of vtk\-Cardinal\-Spline (for each of the x-\/y-\/z coordinate axes). The user may choose to create and assign their own instances of vtk\-Spline.  
\item {\ttfamily obj.\-Set\-Y\-Spline (vtk\-Spline )} -\/ By default, this class is constructed with three instances of vtk\-Cardinal\-Spline (for each of the x-\/y-\/z coordinate axes). The user may choose to create and assign their own instances of vtk\-Spline.  
\item {\ttfamily obj.\-Set\-Z\-Spline (vtk\-Spline )} -\/ By default, this class is constructed with three instances of vtk\-Cardinal\-Spline (for each of the x-\/y-\/z coordinate axes). The user may choose to create and assign their own instances of vtk\-Spline.  
\item {\ttfamily vtk\-Spline = obj.\-Get\-X\-Spline ()} -\/ By default, this class is constructed with three instances of vtk\-Cardinal\-Spline (for each of the x-\/y-\/z coordinate axes). The user may choose to create and assign their own instances of vtk\-Spline.  
\item {\ttfamily vtk\-Spline = obj.\-Get\-Y\-Spline ()} -\/ By default, this class is constructed with three instances of vtk\-Cardinal\-Spline (for each of the x-\/y-\/z coordinate axes). The user may choose to create and assign their own instances of vtk\-Spline.  
\item {\ttfamily vtk\-Spline = obj.\-Get\-Z\-Spline ()} -\/ By default, this class is constructed with three instances of vtk\-Cardinal\-Spline (for each of the x-\/y-\/z coordinate axes). The user may choose to create and assign their own instances of vtk\-Spline.  
\item {\ttfamily obj.\-Set\-Points (vtk\-Points )} -\/ Specify the list of points defining the spline. Do this by specifying a vtk\-Points array containing the points. Note that the order of the points in vtk\-Points is the order that the splines will be fit.  
\item {\ttfamily vtk\-Points = obj.\-Get\-Points ()} -\/ Specify the list of points defining the spline. Do this by specifying a vtk\-Points array containing the points. Note that the order of the points in vtk\-Points is the order that the splines will be fit.  
\item {\ttfamily obj.\-Set\-Number\-Of\-Points (vtk\-Id\-Type num\-Pts)} -\/ Another A\-P\-I to set the points. Set the number of points and then set the individual point coordinates.  
\item {\ttfamily obj.\-Set\-Point (vtk\-Id\-Type index, double x, double y, double z)} -\/ Another A\-P\-I to set the points. Set the number of points and then set the individual point coordinates.  
\item {\ttfamily obj.\-Set\-Closed (int )} -\/ Control whether the spline is open or closed. A closed spline forms a continuous loop\-: the first and last points are the same, and derivatives are continuous.  
\item {\ttfamily int = obj.\-Get\-Closed ()} -\/ Control whether the spline is open or closed. A closed spline forms a continuous loop\-: the first and last points are the same, and derivatives are continuous.  
\item {\ttfamily obj.\-Closed\-On ()} -\/ Control whether the spline is open or closed. A closed spline forms a continuous loop\-: the first and last points are the same, and derivatives are continuous.  
\item {\ttfamily obj.\-Closed\-Off ()} -\/ Control whether the spline is open or closed. A closed spline forms a continuous loop\-: the first and last points are the same, and derivatives are continuous.  
\item {\ttfamily obj.\-Set\-Parameterize\-By\-Length (int )} -\/ Control whether the spline is parameterized by length or by point index. Default is by length.  
\item {\ttfamily int = obj.\-Get\-Parameterize\-By\-Length ()} -\/ Control whether the spline is parameterized by length or by point index. Default is by length.  
\item {\ttfamily obj.\-Parameterize\-By\-Length\-On ()} -\/ Control whether the spline is parameterized by length or by point index. Default is by length.  
\item {\ttfamily obj.\-Parameterize\-By\-Length\-Off ()} -\/ Control whether the spline is parameterized by length or by point index. Default is by length.  
\item {\ttfamily obj.\-Set\-Left\-Constraint (int )} -\/ Set the type of constraint of the left(right) end points. Four constraints are available\-:

0\-: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.

1\-: the first derivative at left(right) most point is set to Left(\-Right)Value.

2\-: the second derivative at left(right) most point is set to Left(\-Right)Value.

3\-: the second derivative at left(right)most points is Left(\-Right)Value times second derivative at first interior point.  
\item {\ttfamily int = obj.\-Get\-Left\-Constraint\-Min\-Value ()} -\/ Set the type of constraint of the left(right) end points. Four constraints are available\-:

0\-: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.

1\-: the first derivative at left(right) most point is set to Left(\-Right)Value.

2\-: the second derivative at left(right) most point is set to Left(\-Right)Value.

3\-: the second derivative at left(right)most points is Left(\-Right)Value times second derivative at first interior point.  
\item {\ttfamily int = obj.\-Get\-Left\-Constraint\-Max\-Value ()} -\/ Set the type of constraint of the left(right) end points. Four constraints are available\-:

0\-: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.

1\-: the first derivative at left(right) most point is set to Left(\-Right)Value.

2\-: the second derivative at left(right) most point is set to Left(\-Right)Value.

3\-: the second derivative at left(right)most points is Left(\-Right)Value times second derivative at first interior point.  
\item {\ttfamily int = obj.\-Get\-Left\-Constraint ()} -\/ Set the type of constraint of the left(right) end points. Four constraints are available\-:

0\-: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.

1\-: the first derivative at left(right) most point is set to Left(\-Right)Value.

2\-: the second derivative at left(right) most point is set to Left(\-Right)Value.

3\-: the second derivative at left(right)most points is Left(\-Right)Value times second derivative at first interior point.  
\item {\ttfamily obj.\-Set\-Right\-Constraint (int )} -\/ Set the type of constraint of the left(right) end points. Four constraints are available\-:

0\-: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.

1\-: the first derivative at left(right) most point is set to Left(\-Right)Value.

2\-: the second derivative at left(right) most point is set to Left(\-Right)Value.

3\-: the second derivative at left(right)most points is Left(\-Right)Value times second derivative at first interior point.  
\item {\ttfamily int = obj.\-Get\-Right\-Constraint\-Min\-Value ()} -\/ Set the type of constraint of the left(right) end points. Four constraints are available\-:

0\-: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.

1\-: the first derivative at left(right) most point is set to Left(\-Right)Value.

2\-: the second derivative at left(right) most point is set to Left(\-Right)Value.

3\-: the second derivative at left(right)most points is Left(\-Right)Value times second derivative at first interior point.  
\item {\ttfamily int = obj.\-Get\-Right\-Constraint\-Max\-Value ()} -\/ Set the type of constraint of the left(right) end points. Four constraints are available\-:

0\-: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.

1\-: the first derivative at left(right) most point is set to Left(\-Right)Value.

2\-: the second derivative at left(right) most point is set to Left(\-Right)Value.

3\-: the second derivative at left(right)most points is Left(\-Right)Value times second derivative at first interior point.  
\item {\ttfamily int = obj.\-Get\-Right\-Constraint ()} -\/ Set the type of constraint of the left(right) end points. Four constraints are available\-:

0\-: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.

1\-: the first derivative at left(right) most point is set to Left(\-Right)Value.

2\-: the second derivative at left(right) most point is set to Left(\-Right)Value.

3\-: the second derivative at left(right)most points is Left(\-Right)Value times second derivative at first interior point.  
\item {\ttfamily obj.\-Set\-Left\-Value (double )} -\/ The values of the derivative on the left and right sides. The value is used only if the left(right) constraint is type 1-\/3.  
\item {\ttfamily double = obj.\-Get\-Left\-Value ()} -\/ The values of the derivative on the left and right sides. The value is used only if the left(right) constraint is type 1-\/3.  
\item {\ttfamily obj.\-Set\-Right\-Value (double )} -\/ The values of the derivative on the left and right sides. The value is used only if the left(right) constraint is type 1-\/3.  
\item {\ttfamily double = obj.\-Get\-Right\-Value ()} -\/ The values of the derivative on the left and right sides. The value is used only if the left(right) constraint is type 1-\/3.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkpassinputtypealgorithm}{}\section{vtk\-Pass\-Input\-Type\-Algorithm}\label{vtkfiltering_vtkpassinputtypealgorithm}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Pass\-Input\-Type\-Algorithm is a convenience class to make writing algorithms easier. It is also designed to help transition old algorithms to the new pipeline architecture. Ther are some assumptions and defaults made by this class you should be aware of. This class defaults such that your filter will have one input port and one output port. If that is not the case simply change it with Set\-Number\-Of\-Input\-Ports etc. See this classes contstructor for the default. This class also provides a Fill\-Input\-Port\-Info method that by default says that all inputs will be Data\-Object. If that isn't the case then please override this method in your subclass. This class breaks out the downstream requests into seperate functions such as Request\-Data\-Object Request\-Data and Request\-Information. The default implementation of Request\-Data\-Object will create an output data of the same type as the input.

To create an instance of class vtk\-Pass\-Input\-Type\-Algorithm, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPassInputTypeAlgorithm
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Pass\-Input\-Type\-Algorithm has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Pass\-Input\-Type\-Algorithm class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Pass\-Input\-Type\-Algorithm = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Pass\-Input\-Type\-Algorithm = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Output ()} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Output (int )} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Poly\-Data = obj.\-Get\-Poly\-Data\-Output ()} -\/ Get the output as vtk\-Poly\-Data.  
\item {\ttfamily vtk\-Structured\-Points = obj.\-Get\-Structured\-Points\-Output ()} -\/ Get the output as vtk\-Structured\-Points.  
\item {\ttfamily vtk\-Image\-Data = obj.\-Get\-Image\-Data\-Output ()} -\/ Get the output as vtk\-Structured\-Points.  
\item {\ttfamily vtk\-Structured\-Grid = obj.\-Get\-Structured\-Grid\-Output ()} -\/ Get the output as vtk\-Structured\-Grid.  
\item {\ttfamily vtk\-Unstructured\-Grid = obj.\-Get\-Unstructured\-Grid\-Output ()} -\/ Get the output as vtk\-Unstructured\-Grid.  
\item {\ttfamily vtk\-Rectilinear\-Grid = obj.\-Get\-Rectilinear\-Grid\-Output ()} -\/ Get the output as vtk\-Rectilinear\-Grid.  
\item {\ttfamily vtk\-Table = obj.\-Get\-Table\-Output ()} -\/ Get the output as vtk\-Table.  
\item {\ttfamily vtk\-Graph = obj.\-Get\-Graph\-Output ()} -\/ Get the output as vtk\-Graph.  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Input ()} -\/ Get the input data object. This method is not recommended for use, but lots of old style filters use it.  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Object )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Set\-Input (int , vtk\-Data\-Object )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Add\-Input (vtk\-Data\-Object )} -\/ Add an input of this algorithm. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Add\-Input\-Connection(). See Set\-Input() for details.  
\item {\ttfamily obj.\-Add\-Input (int , vtk\-Data\-Object )} -\/ Add an input of this algorithm. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Add\-Input\-Connection(). See Set\-Input() for details.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkpentagonalprism}{}\section{vtk\-Pentagonal\-Prism}\label{vtkfiltering_vtkpentagonalprism}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Pentagonal\-Prism is a concrete implementation of vtk\-Cell to represent a linear 3\-D prism with pentagonal base. Such prism is defined by the ten points (0-\/9) where (0,1,2,3,4) is the base of the prism which, using the right hand rule, forms a pentagon whose normal points is in the direction of the opposite face (5,6,7,8,9).

To create an instance of class vtk\-Pentagonal\-Prism, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPentagonalPrism
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Pentagonal\-Prism has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Pentagonal\-Prism class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Pentagonal\-Prism = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Pentagonal\-Prism = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ See the vtk\-Cell3\-D A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ See the vtk\-Cell3\-D A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ See the vtk\-Cell3\-D A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ See the vtk\-Cell3\-D A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int edge\-Id)} -\/ See the vtk\-Cell3\-D A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int face\-Id)} -\/ See the vtk\-Cell3\-D A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)} -\/ See the vtk\-Cell3\-D A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)}  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)}  
\item {\ttfamily int = obj.\-Get\-Parametric\-Center (double pcoords\mbox{[}3\mbox{]})} -\/ Return the center of the wedge in parametric coordinates.  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double weights\mbox{[}10\mbox{]})} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs\mbox{[}30\mbox{]})} -\/ Return the ids of the vertices defining edge/face ({\ttfamily edge\-Id}/`face\-Id'). Ids are related to the cell, not to the dataset.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkperlinnoise}{}\section{vtk\-Perlin\-Noise}\label{vtkfiltering_vtkperlinnoise}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Perlin\-Noise computes a Perlin noise field as an implicit function. vtk\-Perlin\-Noise is a concrete implementation of vtk\-Implicit\-Function. Perlin noise, originally described by Ken Perlin, is a non-\/periodic and continuous noise function useful for modeling real-\/world objects.

The amplitude and frequency of the noise pattern are adjustable. This implementation of Perlin noise is derived closely from Greg Ward's version in Graphics Gems I\-I.

To create an instance of class vtk\-Perlin\-Noise, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPerlinNoise
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Perlin\-Noise has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Perlin\-Noise class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Perlin\-Noise = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Perlin\-Noise = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily double = obj.\-Evaluate\-Function (double x\mbox{[}3\mbox{]})} -\/ Evaluate Perlin\-Noise function.  
\item {\ttfamily double = obj.\-Evaluate\-Function (double x, double y, double z)} -\/ Evaluate Perlin\-Noise function.  
\item {\ttfamily obj.\-Evaluate\-Gradient (double x\mbox{[}3\mbox{]}, double n\mbox{[}3\mbox{]})} -\/ Evaluate Perlin\-Noise gradient. Currently, the method returns a 0 gradient.  
\item {\ttfamily obj.\-Set\-Frequency (double , double , double )} -\/ Set/get the frequency, or physical scale, of the noise function (higher is finer scale). The frequency can be adjusted per axis, or the same for all axes.  
\item {\ttfamily obj.\-Set\-Frequency (double a\mbox{[}3\mbox{]})} -\/ Set/get the frequency, or physical scale, of the noise function (higher is finer scale). The frequency can be adjusted per axis, or the same for all axes.  
\item {\ttfamily double = obj. Get\-Frequency ()} -\/ Set/get the frequency, or physical scale, of the noise function (higher is finer scale). The frequency can be adjusted per axis, or the same for all axes.  
\item {\ttfamily obj.\-Set\-Phase (double , double , double )} -\/ Set/get the phase of the noise function. This parameter can be used to shift the noise function within space (perhaps to avoid a beat with a noise pattern at another scale). Phase tends to repeat about every unit, so a phase of 0.\-5 is a half-\/cycle shift.  
\item {\ttfamily obj.\-Set\-Phase (double a\mbox{[}3\mbox{]})} -\/ Set/get the phase of the noise function. This parameter can be used to shift the noise function within space (perhaps to avoid a beat with a noise pattern at another scale). Phase tends to repeat about every unit, so a phase of 0.\-5 is a half-\/cycle shift.  
\item {\ttfamily double = obj. Get\-Phase ()} -\/ Set/get the phase of the noise function. This parameter can be used to shift the noise function within space (perhaps to avoid a beat with a noise pattern at another scale). Phase tends to repeat about every unit, so a phase of 0.\-5 is a half-\/cycle shift.  
\item {\ttfamily obj.\-Set\-Amplitude (double )} -\/ Set/get the amplitude of the noise function. Amplitude can be negative. The noise function varies randomly between -\/$|$\-Amplitude$|$ and $|$\-Amplitude$|$. Therefore the range of values is 2$\ast$$|$\-Amplitude$|$ large. The initial amplitude is 1.  
\item {\ttfamily double = obj.\-Get\-Amplitude ()} -\/ Set/get the amplitude of the noise function. Amplitude can be negative. The noise function varies randomly between -\/$|$\-Amplitude$|$ and $|$\-Amplitude$|$. Therefore the range of values is 2$\ast$$|$\-Amplitude$|$ large. The initial amplitude is 1.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkpiecewisefunction}{}\section{vtk\-Piecewise\-Function}\label{vtkfiltering_vtkpiecewisefunction}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Defines a piecewise function mapping. This mapping allows the addition of control points, and allows the user to control the function between the control points. A piecewise hermite curve is used between control points, based on the sharpness and midpoint parameters. A sharpness of 0 yields a piecewise linear function and a sharpness of 1 yields a piecewise constant function. The midpoint is the normalized distance between control points at which the curve reaches the median Y value. The midpoint and sharpness values specified when adding a node are used to control the transition to the next node (the last node's values are ignored) Outside the range of nodes, the values are 0 if Clamping is off, or the nearest node point if Clamping is on. Using the legacy methods for adding points (which do not have Sharpness and Midpoint parameters) will default to Midpoint = 0.\-5 (halfway between the control points) and Sharpness = 0.\-0 (linear).

To create an instance of class vtk\-Piecewise\-Function, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPiecewiseFunction
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Piecewise\-Function has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Piecewise\-Function class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Piecewise\-Function = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Piecewise\-Function = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Deep\-Copy (vtk\-Data\-Object f)}  
\item {\ttfamily obj.\-Shallow\-Copy (vtk\-Data\-Object f)}  
\item {\ttfamily int = obj.\-Get\-Data\-Object\-Type ()} -\/ Return what type of dataset this is.  
\item {\ttfamily int = obj.\-Get\-Size ()} -\/ Get the number of points used to specify the function  
\item {\ttfamily int = obj.\-Add\-Point (double x, double y)} -\/ Add/\-Remove points to/from the function. If a duplicate point is added then the function value is changed at that location. Return the index of the point (0 based), or -\/1 on error.  
\item {\ttfamily int = obj.\-Add\-Point (double x, double y, double midpoint, double sharpness)} -\/ Add/\-Remove points to/from the function. If a duplicate point is added then the function value is changed at that location. Return the index of the point (0 based), or -\/1 on error.  
\item {\ttfamily int = obj.\-Remove\-Point (double x)} -\/ Add/\-Remove points to/from the function. If a duplicate point is added then the function value is changed at that location. Return the index of the point (0 based), or -\/1 on error.  
\item {\ttfamily obj.\-Remove\-All\-Points ()} -\/ Removes all points from the function.  
\item {\ttfamily obj.\-Add\-Segment (double x1, double y1, double x2, double y2)} -\/ Add a line segment to the function. All points defined between the two points specified are removed from the function. This is a legacy method that does not allow the specification of the sharpness and midpoint values for the two nodes.  
\item {\ttfamily double = obj.\-Get\-Value (double x)} -\/ Returns the value of the function at the specified location using the specified interpolation.  
\item {\ttfamily int = obj.\-Get\-Node\-Value (int index, double val\mbox{[}4\mbox{]})} -\/ For the node specified by index, set/get the location (X), value (Y), midpoint, and sharpness values at the node.  
\item {\ttfamily int = obj.\-Set\-Node\-Value (int index, double val\mbox{[}4\mbox{]})} -\/ For the node specified by index, set/get the location (X), value (Y), midpoint, and sharpness values at the node.  
\item {\ttfamily obj.\-Fill\-From\-Data\-Pointer (int , double )} -\/ Returns a pointer to the data stored in the table. Fills from a pointer to data stored in a similar table. These are legacy methods which will be maintained for compatibility -\/ however, note that the vtk\-Piecewise\-Function no longer stores the nodes in a double array internally.  
\item {\ttfamily double = obj. Get\-Range ()} -\/ Returns the min and max node locations of the function.  
\item {\ttfamily int = obj.\-Adjust\-Range (double range\mbox{[}2\mbox{]})} -\/ Remove all points out of the new range, and make sure there is a point at each end of that range. Return 1 on success, 0 otherwise.  
\item {\ttfamily obj.\-Get\-Table (double x1, double x2, int size, float table, int stride)} -\/ Fills in an array of function values evaluated at regular intervals. Parameter \char`\"{}stride\char`\"{} is used to step through the output \char`\"{}table\char`\"{}.  
\item {\ttfamily obj.\-Get\-Table (double x1, double x2, int size, double table, int stride)} -\/ Fills in an array of function values evaluated at regular intervals. Parameter \char`\"{}stride\char`\"{} is used to step through the output \char`\"{}table\char`\"{}.  
\item {\ttfamily obj.\-Build\-Function\-From\-Table (double x1, double x2, int size, double table, int stride)} -\/ Constructs a piecewise function from a table. Function range is is set to \mbox{[}x1, x2\mbox{]}, function size is set to size, and function points are regularly spaced between x1 and x2. Parameter \char`\"{}stride\char`\"{} is is step through the input table.  
\item {\ttfamily obj.\-Set\-Clamping (int )} -\/ When zero range clamping is Off, Get\-Value() returns 0.\-0 when a value is requested outside of the points specified. When zero range clamping is On, Get\-Value() returns the value at the value at the lowest point for a request below all points specified and returns the value at the highest point for a request above all points specified. On is the default.  
\item {\ttfamily int = obj.\-Get\-Clamping ()} -\/ When zero range clamping is Off, Get\-Value() returns 0.\-0 when a value is requested outside of the points specified. When zero range clamping is On, Get\-Value() returns the value at the value at the lowest point for a request below all points specified and returns the value at the highest point for a request above all points specified. On is the default.  
\item {\ttfamily obj.\-Clamping\-On ()} -\/ When zero range clamping is Off, Get\-Value() returns 0.\-0 when a value is requested outside of the points specified. When zero range clamping is On, Get\-Value() returns the value at the value at the lowest point for a request below all points specified and returns the value at the highest point for a request above all points specified. On is the default.  
\item {\ttfamily obj.\-Clamping\-Off ()} -\/ When zero range clamping is Off, Get\-Value() returns 0.\-0 when a value is requested outside of the points specified. When zero range clamping is On, Get\-Value() returns the value at the value at the lowest point for a request below all points specified and returns the value at the highest point for a request above all points specified. On is the default.  
\item {\ttfamily string = obj.\-Get\-Type ()} -\/ Return the type of function\-: Function Types\-: 0 \-: Constant (No change in slope between end points) 1 \-: Non\-Decreasing (Always increasing or zero slope) 2 \-: Non\-Increasing (Always decreasing or zero slope) 3 \-: Varied (Contains both decreasing and increasing slopes)  
\item {\ttfamily double = obj.\-Get\-First\-Non\-Zero\-Value ()} -\/ Returns the first point location which precedes a non-\/zero segment of the function. Note that the value at this point may be zero.  
\item {\ttfamily obj.\-Initialize ()} -\/ Clears out the current function. A newly created vtk\-Piecewise\-Function is alreay initialized, so there is no need to call this method which in turn simply calls Remove\-All\-Points()  
\item {\ttfamily obj.\-Set\-Allow\-Duplicate\-Scalars (int )} -\/ Toggle whether to allow duplicate scalar values in the piecewise function (off by default).  
\item {\ttfamily int = obj.\-Get\-Allow\-Duplicate\-Scalars ()} -\/ Toggle whether to allow duplicate scalar values in the piecewise function (off by default).  
\item {\ttfamily obj.\-Allow\-Duplicate\-Scalars\-On ()} -\/ Toggle whether to allow duplicate scalar values in the piecewise function (off by default).  
\item {\ttfamily obj.\-Allow\-Duplicate\-Scalars\-Off ()} -\/ Toggle whether to allow duplicate scalar values in the piecewise function (off by default).  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkpiecewisefunctionalgorithm}{}\section{vtk\-Piecewise\-Function\-Algorithm}\label{vtkfiltering_vtkpiecewisefunctionalgorithm}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
To create an instance of class vtk\-Piecewise\-Function\-Algorithm, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPiecewiseFunctionAlgorithm
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Piecewise\-Function\-Algorithm has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Piecewise\-Function\-Algorithm class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Piecewise\-Function\-Algorithm = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Piecewise\-Function\-Algorithm = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Output ()} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Output (int )} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily obj.\-Set\-Output (vtk\-Data\-Object d)} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Input ()}  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Input (int port)}  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Object )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Set\-Input (int , vtk\-Data\-Object )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Add\-Input (vtk\-Data\-Object )} -\/ Add an input of this algorithm. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Add\-Input\-Connection(). See Set\-Input() for details.  
\item {\ttfamily obj.\-Add\-Input (int , vtk\-Data\-Object )} -\/ Add an input of this algorithm. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Add\-Input\-Connection(). See Set\-Input() for details.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkpiecewisefunctionshiftscale}{}\section{vtk\-Piecewise\-Function\-Shift\-Scale}\label{vtkfiltering_vtkpiecewisefunctionshiftscale}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
To create an instance of class vtk\-Piecewise\-Function\-Shift\-Scale, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPiecewiseFunctionShiftScale
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Piecewise\-Function\-Shift\-Scale has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Piecewise\-Function\-Shift\-Scale class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Piecewise\-Function\-Shift\-Scale = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Piecewise\-Function\-Shift\-Scale = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Position\-Shift (double )}  
\item {\ttfamily obj.\-Set\-Position\-Scale (double )}  
\item {\ttfamily obj.\-Set\-Value\-Shift (double )}  
\item {\ttfamily obj.\-Set\-Value\-Scale (double )}  
\item {\ttfamily double = obj.\-Get\-Position\-Shift ()}  
\item {\ttfamily double = obj.\-Get\-Position\-Scale ()}  
\item {\ttfamily double = obj.\-Get\-Value\-Shift ()}  
\item {\ttfamily double = obj.\-Get\-Value\-Scale ()}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkpixel}{}\section{vtk\-Pixel}\label{vtkfiltering_vtkpixel}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Pixel is a concrete implementation of vtk\-Cell to represent a 2\-D orthogonal quadrilateral. Unlike vtk\-Quad, the corners are at right angles, and aligned along x-\/y-\/z coordinate axes leading to large increases in computational efficiency.

To create an instance of class vtk\-Pixel, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPixel
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Pixel has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Pixel class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Pixel = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Pixel = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int edge\-Id)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int )} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Clip (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd, int inside\-Out)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Parametric\-Center (double pcoords\mbox{[}3\mbox{]})} -\/ Return the center of the triangle in parametric coordinates.  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)}  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)}  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double weights\mbox{[}4\mbox{]})} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs\mbox{[}8\mbox{]})}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkplanesintersection}{}\section{vtk\-Planes\-Intersection}\label{vtkfiltering_vtkplanesintersection}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
A subclass of vtk\-Planes, this class determines whether it intersects an axis aligned box. This is motivated by the need to intersect the axis aligned region of a spacial decomposition of volume data with various other regions. It uses the algorithm from Graphics Gems I\-V, page 81.

.S\-E\-C\-T\-I\-O\-N Caveat An instance of vtk\-Planes can be redefined by changing the planes, but this subclass then will not know if the region vertices are up to date. (Region vertices can be specified in Set\-Region\-Vertices or computed by the subclass.) So Delete and recreate if you want to change the set of planes.

To create an instance of class vtk\-Planes\-Intersection, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPlanesIntersection
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Planes\-Intersection has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Planes\-Intersection class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Planes\-Intersection = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Planes\-Intersection = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Region\-Vertices (vtk\-Points pts)}  
\item {\ttfamily obj.\-Set\-Region\-Vertices (double v, int nvertices)}  
\item {\ttfamily int = obj.\-Get\-Num\-Region\-Vertices ()}  
\item {\ttfamily int = obj.\-Get\-Region\-Vertices (double v, int nvertices)}  
\item {\ttfamily int = obj.\-Intersects\-Region (vtk\-Points R)}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkpointdata}{}\section{vtk\-Point\-Data}\label{vtkfiltering_vtkpointdata}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Point\-Data is a class that is used to represent and manipulate point attribute data (e.\-g., scalars, vectors, normals, texture coordinates, etc.) Most of the functionality is handled by vtk\-Data\-Set\-Attributes

To create an instance of class vtk\-Point\-Data, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPointData
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Point\-Data has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Point\-Data class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Point\-Data = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Point\-Data = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Null\-Point (vtk\-Id\-Type pt\-Id)}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkpointlocator}{}\section{vtk\-Point\-Locator}\label{vtkfiltering_vtkpointlocator}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Point\-Locator is a spatial search object to quickly locate points in 3\-D. vtk\-Point\-Locator works by dividing a specified region of space into a regular array of \char`\"{}rectangular\char`\"{} buckets, and then keeping a list of points that lie in each bucket. Typical operation involves giving a position in 3\-D and finding the closest point.

vtk\-Point\-Locator has two distinct methods of interaction. In the first method, you supply it with a dataset, and it operates on the points in the dataset. In the second method, you supply it with an array of points, and the object operates on the array.

To create an instance of class vtk\-Point\-Locator, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPointLocator
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Point\-Locator has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Point\-Locator class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Point\-Locator = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Point\-Locator = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Divisions (int , int , int )} -\/ Set the number of divisions in x-\/y-\/z directions.  
\item {\ttfamily obj.\-Set\-Divisions (int a\mbox{[}3\mbox{]})} -\/ Set the number of divisions in x-\/y-\/z directions.  
\item {\ttfamily int = obj. Get\-Divisions ()} -\/ Set the number of divisions in x-\/y-\/z directions.  
\item {\ttfamily obj.\-Set\-Number\-Of\-Points\-Per\-Bucket (int )} -\/ Specify the average number of points in each bucket.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Points\-Per\-Bucket\-Min\-Value ()} -\/ Specify the average number of points in each bucket.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Points\-Per\-Bucket\-Max\-Value ()} -\/ Specify the average number of points in each bucket.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Points\-Per\-Bucket ()} -\/ Specify the average number of points in each bucket.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Find\-Closest\-Point (double x\mbox{[}3\mbox{]})} -\/ Given a position x, return the id of the point closest to it. Alternative method requires separate x-\/y-\/z values. These methods are thread safe if Build\-Locator() is directly or indirectly called from a single thread first.  
\item {\ttfamily int = obj.\-Init\-Point\-Insertion (vtk\-Points new\-Pts, double bounds\mbox{[}6\mbox{]})} -\/ Initialize the point insertion process. The new\-Pts is an object representing point coordinates into which incremental insertion methods place their data. Bounds are the box that the points lie in. Not thread safe.  
\item {\ttfamily int = obj.\-Init\-Point\-Insertion (vtk\-Points new\-Pts, double bounds\mbox{[}6\mbox{]}, vtk\-Id\-Type est\-Size)} -\/ Initialize the point insertion process. The new\-Pts is an object representing point coordinates into which incremental insertion methods place their data. Bounds are the box that the points lie in. Not thread safe.  
\item {\ttfamily obj.\-Insert\-Point (vtk\-Id\-Type pt\-Id, double x\mbox{[}3\mbox{]})} -\/ Incrementally insert a point into search structure with a particular index value. You should use the method Is\-Inserted\-Point() to see whether this point has already been inserted (that is, if you desire to prevent duplicate points). Before using this method you must make sure that new\-Pts have been supplied, the bounds has been set properly, and that divs are properly set. (See Init\-Point\-Insertion().) Not thread safe.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Insert\-Next\-Point (double x\mbox{[}3\mbox{]})} -\/ Incrementally insert a point into search structure. The method returns the insertion location (i.\-e., point id). You should use the method Is\-Inserted\-Point() to see whether this point has already been inserted (that is, if you desire to prevent duplicate points). Before using this method you must make sure that new\-Pts have been supplied, the bounds has been set properly, and that divs are properly set. (See Init\-Point\-Insertion().) Not thread safe.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Is\-Inserted\-Point (double x, double y, double z)} -\/ Determine whether point given by x\mbox{[}3\mbox{]} has been inserted into points list. Return id of previously inserted point if this is true, otherwise return -\/1. This method is thread safe.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Is\-Inserted\-Point (double x\mbox{[}3\mbox{]})} -\/ Determine whether point given by x\mbox{[}3\mbox{]} has been inserted into points list. Return id of previously inserted point if this is true, otherwise return -\/1. This method is thread safe.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Find\-Closest\-Inserted\-Point (double x\mbox{[}3\mbox{]})} -\/ Given a position x, return the id of the point closest to it. This method is used when performing incremental point insertion. Note that -\/1 indicates that no point was found. This method is thread safe if Build\-Locator() is directly or indirectly called from a single thread first.  
\item {\ttfamily obj.\-Find\-Closest\-N\-Points (int N, double x\mbox{[}3\mbox{]}, vtk\-Id\-List result)} -\/ Find the closest N points to a position. This returns the closest N points to a position. A faster method could be created that returned N close points to a position, but necessarily the exact N closest. The returned points are sorted from closest to farthest. These methods are thread safe if Build\-Locator() is directly or indirectly called from a single thread first.  
\item {\ttfamily obj.\-Find\-Distributed\-Points (int N, double x\mbox{[}3\mbox{]}, vtk\-Id\-List result, int M)} -\/ Find the closest points to a position such that each octant of space around the position contains at least N points. Loosely limit the search to a maximum number of points evaluated, M. These methods are thread safe if Build\-Locator() is directly or indirectly called from a single thread first.  
\item {\ttfamily obj.\-Find\-Distributed\-Points (int N, double x, double y, double z, vtk\-Id\-List result, int M)} -\/ Find the closest points to a position such that each octant of space around the position contains at least N points. Loosely limit the search to a maximum number of points evaluated, M. These methods are thread safe if Build\-Locator() is directly or indirectly called from a single thread first.  
\item {\ttfamily obj.\-Find\-Points\-Within\-Radius (double R, double x\mbox{[}3\mbox{]}, vtk\-Id\-List result)} -\/ Find all points within a specified radius R of position x. The result is not sorted in any specific manner. These methods are thread safe if Build\-Locator() is directly or indirectly called from a single thread first.  
\item {\ttfamily vtk\-Id\-List = obj.\-Get\-Points\-In\-Bucket (double x\mbox{[}3\mbox{]}, int ijk\mbox{[}3\mbox{]})} -\/ Given a position x, return the list of points in the bucket that contains the point. It is possible that N\-U\-L\-L is returned. The user provides an ijk array that is the indices into the locator. This method is thread safe.  
\item {\ttfamily vtk\-Points = obj.\-Get\-Points ()} -\/ Provide an accessor to the points.  
\item {\ttfamily obj.\-Initialize ()} -\/ See vtk\-Locator interface documentation. These methods are not thread safe.  
\item {\ttfamily obj.\-Free\-Search\-Structure ()} -\/ See vtk\-Locator interface documentation. These methods are not thread safe.  
\item {\ttfamily obj.\-Build\-Locator ()} -\/ See vtk\-Locator interface documentation. These methods are not thread safe.  
\item {\ttfamily obj.\-Generate\-Representation (int level, vtk\-Poly\-Data pd)} -\/ See vtk\-Locator interface documentation. These methods are not thread safe.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkpointset}{}\section{vtk\-Point\-Set}\label{vtkfiltering_vtkpointset}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Point\-Set is an abstract class that specifies the interface for datasets that explicitly use \char`\"{}point\char`\"{} arrays to represent geometry. For example, vtk\-Poly\-Data and vtk\-Unstructured\-Grid require point arrays to specify point position, while vtk\-Structured\-Points generates point positions implicitly.

To create an instance of class vtk\-Point\-Set, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPointSet
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Point\-Set has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Point\-Set class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Point\-Set = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Point\-Set = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Initialize ()} -\/ Reset to an empty state and free any memory.  
\item {\ttfamily obj.\-Copy\-Structure (vtk\-Data\-Set pd)} -\/ Copy the geometric structure of an input point set object.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Points ()} -\/ See vtk\-Data\-Set for additional information.  
\item {\ttfamily double = obj.\-Get\-Point (vtk\-Id\-Type pt\-Id)} -\/ See vtk\-Data\-Set for additional information.  
\item {\ttfamily obj.\-Get\-Point (vtk\-Id\-Type pt\-Id, double x\mbox{[}3\mbox{]})} -\/ See vtk\-Data\-Set for additional information.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Find\-Point (double x\mbox{[}3\mbox{]})} -\/ See vtk\-Data\-Set for additional information.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Find\-Point (double x, double y, double z)} -\/ See vtk\-Data\-Set for additional information.  
\item {\ttfamily long = obj.\-Get\-M\-Time ()} -\/ Get M\-Time which also considers its vtk\-Points M\-Time.  
\item {\ttfamily obj.\-Compute\-Bounds ()} -\/ Compute the (X, Y, Z) bounds of the data.  
\item {\ttfamily obj.\-Squeeze ()} -\/ Reclaim any unused memory.  
\item {\ttfamily obj.\-Set\-Points (vtk\-Points )} -\/ Specify point array to define point coordinates.  
\item {\ttfamily vtk\-Points = obj.\-Get\-Points ()} -\/ Specify point array to define point coordinates.  
\item {\ttfamily long = obj.\-Get\-Actual\-Memory\-Size ()} -\/ Return the actual size of the data in kilobytes. This number is valid only after the pipeline has updated. The memory size returned is guaranteed to be greater than or equal to the memory required to represent the data (e.\-g., extra space in arrays, etc. are not included in the return value). T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E.  
\item {\ttfamily obj.\-Shallow\-Copy (vtk\-Data\-Object src)} -\/ Shallow and Deep copy.  
\item {\ttfamily obj.\-Deep\-Copy (vtk\-Data\-Object src)} -\/ Shallow and Deep copy.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkpointsetalgorithm}{}\section{vtk\-Point\-Set\-Algorithm}\label{vtkfiltering_vtkpointsetalgorithm}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Point\-Set\-Algorithm is a convenience class to make writing algorithms easier. It is also designed to help transition old algorithms to the new pipeline architecture. Ther are some assumptions and defaults made by this class you should be aware of. This class defaults such that your filter will have one input port and one output port. If that is not the case simply change it with Set\-Number\-Of\-Input\-Ports etc. See this classes contstructor for the default. This class also provides a Fill\-Input\-Port\-Info method that by default says that all inputs will be Point\-Set. If that isn't the case then please override this method in your subclass. This class breaks out the downstream requests into seperate functions such as Request\-Data\-Object Request\-Data and Execute\-Information. The default implementation of Request\-Data\-Object will create an output data of the same type as the input.

To create an instance of class vtk\-Point\-Set\-Algorithm, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPointSetAlgorithm
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Point\-Set\-Algorithm has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Point\-Set\-Algorithm class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Point\-Set\-Algorithm = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Point\-Set\-Algorithm = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Point\-Set = obj.\-Get\-Output ()} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Point\-Set = obj.\-Get\-Output (int )} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Poly\-Data = obj.\-Get\-Poly\-Data\-Output ()} -\/ Get the output as vtk\-Poly\-Data.  
\item {\ttfamily vtk\-Structured\-Grid = obj.\-Get\-Structured\-Grid\-Output ()} -\/ Get the output as vtk\-Structured\-Grid.  
\item {\ttfamily vtk\-Unstructured\-Grid = obj.\-Get\-Unstructured\-Grid\-Output ()} -\/ Get the output as vtk\-Unstructured\-Grid.  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Object )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Set\-Input (int , vtk\-Data\-Object )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Set\-Input (vtk\-Point\-Set )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Set\-Input (int , vtk\-Point\-Set )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Add\-Input (vtk\-Data\-Object )} -\/ Add an input of this algorithm. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Add\-Input\-Connection(). See Set\-Input() for details.  
\item {\ttfamily obj.\-Add\-Input (vtk\-Point\-Set )} -\/ Add an input of this algorithm. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Add\-Input\-Connection(). See Set\-Input() for details.  
\item {\ttfamily obj.\-Add\-Input (int , vtk\-Point\-Set )} -\/ Add an input of this algorithm. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Add\-Input\-Connection(). See Set\-Input() for details.  
\item {\ttfamily obj.\-Add\-Input (int , vtk\-Data\-Object )} -\/ Add an input of this algorithm. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Add\-Input\-Connection(). See Set\-Input() for details.  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Input ()}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkpointsetsource}{}\section{vtk\-Point\-Set\-Source}\label{vtkfiltering_vtkpointsetsource}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Point\-Set\-Source is an abstract class whose subclasses generate pointdata.

To create an instance of class vtk\-Point\-Set\-Source, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPointSetSource
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Point\-Set\-Source has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Point\-Set\-Source class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Point\-Set\-Source = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Point\-Set\-Source = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Point\-Set = obj.\-Get\-Output ()} -\/ Get the output of this source.  
\item {\ttfamily vtk\-Point\-Set = obj.\-Get\-Output (int idx)} -\/ Get the output of this source.  
\item {\ttfamily obj.\-Set\-Output (vtk\-Point\-Set output)} -\/ Get the output of this source.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkpointsettopointsetfilter}{}\section{vtk\-Point\-Set\-To\-Point\-Set\-Filter}\label{vtkfiltering_vtkpointsettopointsetfilter}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Point\-Set\-To\-Point\-Set\-Filter is an abstract filter class whose subclasses take as input a point set and generates a point set on output. At a minimum, the concrete subclasses of vtk\-Point\-Set\-To\-Point\-Set\-Filter modify their point coordinates. They never modify their topological form, however.

This is an abstract filter type. What that means is that the output of the filter is an abstract type (i.\-e., vtk\-Point\-Set), no matter what the input of the filter is. This can cause problems connecting together filters due to the change in dataset type. (For example, in a series of filters processing vtk\-Poly\-Data, when a vtk\-Point\-Set\-To\-Point\-Set\-Filter or subclass is introduced into the pipeline, if the filter downstream of it takes vtk\-Poly\-Data as input, the pipeline connection cannot be made.) To get around this problem, use one of the convenience methods to return a concrete type (e.\-g., vtk\-Get\-Poly\-Data\-Output(), Get\-Structured\-Grid\-Output(), etc.).

To create an instance of class vtk\-Point\-Set\-To\-Point\-Set\-Filter, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPointSetToPointSetFilter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Point\-Set\-To\-Point\-Set\-Filter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Point\-Set\-To\-Point\-Set\-Filter class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Point\-Set\-To\-Point\-Set\-Filter = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Point\-Set\-To\-Point\-Set\-Filter = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Input (vtk\-Point\-Set input)} -\/ Specify the input data or filter.  
\item {\ttfamily vtk\-Point\-Set = obj.\-Get\-Input ()} -\/ Get the input data or filter.  
\item {\ttfamily vtk\-Point\-Set = obj.\-Get\-Output ()} -\/ Get the output of this filter. If output is N\-U\-L\-L, then input hasn't been set, which is necessary for abstract filter objects.  
\item {\ttfamily vtk\-Point\-Set = obj.\-Get\-Output (int idx)} -\/ Get the output as vtk\-Poly\-Data. Performs run-\/time checking.  
\item {\ttfamily vtk\-Poly\-Data = obj.\-Get\-Poly\-Data\-Output ()} -\/ Get the output as vtk\-Poly\-Data. Performs run-\/time checking.  
\item {\ttfamily vtk\-Structured\-Grid = obj.\-Get\-Structured\-Grid\-Output ()} -\/ Get the output as vtk\-Structured\-Grid. Performs run-\/time checking.  
\item {\ttfamily vtk\-Unstructured\-Grid = obj.\-Get\-Unstructured\-Grid\-Output ()} -\/ Get the output as vtk\-Unstructured\-Grid. Performs run-\/time checking.  
\item {\ttfamily obj.\-Compute\-Input\-Update\-Extents (vtk\-Data\-Object output)} -\/ By default copy the output update extent to the input  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkpointsprojectedhull}{}\section{vtk\-Points\-Projected\-Hull}\label{vtkfiltering_vtkpointsprojectedhull}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
a subclass of vtk\-Points, it maintains the counter clockwise convex hull of the points (projected orthogonally in the three coordinate directions) and has a method to test for intersection of that hull with an axis aligned rectangle. This is used for intersection tests of 3\-D volumes.

To create an instance of class vtk\-Points\-Projected\-Hull, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPointsProjectedHull
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Points\-Projected\-Hull has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Points\-Projected\-Hull class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Points\-Projected\-Hull = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Points\-Projected\-Hull = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Rectangle\-Intersection\-X (vtk\-Points R)}  
\item {\ttfamily int = obj.\-Rectangle\-Intersection\-X (float ymin, float ymax, float zmin, float zmax)}  
\item {\ttfamily int = obj.\-Rectangle\-Intersection\-X (double ymin, double ymax, double zmin, double zmax)}  
\item {\ttfamily int = obj.\-Rectangle\-Intersection\-Y (vtk\-Points R)}  
\item {\ttfamily int = obj.\-Rectangle\-Intersection\-Y (float zmin, float zmax, float xmin, float xmax)}  
\item {\ttfamily int = obj.\-Rectangle\-Intersection\-Y (double zmin, double zmax, double xmin, double xmax)}  
\item {\ttfamily int = obj.\-Rectangle\-Intersection\-Z (vtk\-Points R)}  
\item {\ttfamily int = obj.\-Rectangle\-Intersection\-Z (float xmin, float xmax, float ymin, float ymax)}  
\item {\ttfamily int = obj.\-Rectangle\-Intersection\-Z (double xmin, double xmax, double ymin, double ymax)}  
\item {\ttfamily int = obj.\-Get\-C\-C\-W\-Hull\-X (float pts, int len)}  
\item {\ttfamily int = obj.\-Get\-C\-C\-W\-Hull\-X (double pts, int len)}  
\item {\ttfamily int = obj.\-Get\-C\-C\-W\-Hull\-Y (float pts, int len)}  
\item {\ttfamily int = obj.\-Get\-C\-C\-W\-Hull\-Y (double pts, int len)}  
\item {\ttfamily int = obj.\-Get\-C\-C\-W\-Hull\-Z (float pts, int len)}  
\item {\ttfamily int = obj.\-Get\-C\-C\-W\-Hull\-Z (double pts, int len)}  
\item {\ttfamily int = obj.\-Get\-Size\-C\-C\-W\-Hull\-X ()}  
\item {\ttfamily int = obj.\-Get\-Size\-C\-C\-W\-Hull\-Y ()}  
\item {\ttfamily int = obj.\-Get\-Size\-C\-C\-W\-Hull\-Z ()}  
\item {\ttfamily obj.\-Initialize ()}  
\item {\ttfamily obj.\-Reset ()}  
\item {\ttfamily obj.\-Update ()}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkpolydata}{}\section{vtk\-Poly\-Data}\label{vtkfiltering_vtkpolydata}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Poly\-Data is a data object that is a concrete implementation of vtk\-Data\-Set. vtk\-Poly\-Data represents a geometric structure consisting of vertices, lines, polygons, and/or triangle strips. Point and cell attribute values (e.\-g., scalars, vectors, etc.) also are represented.

The actual cell types (vtk\-Cell\-Type.\-h) supported by vtk\-Poly\-Data are\-: vtk\-Vertex, vtk\-Poly\-Vertex, vtk\-Line, vtk\-Poly\-Line, vtk\-Triangle, vtk\-Quad, vtk\-Polygon, and vtk\-Triangle\-Strip.

One important feature of vtk\-Poly\-Data objects is that special traversal and data manipulation methods are available to process data. These methods are generally more efficient than vtk\-Data\-Set methods and should be used whenever possible. For example, traversing the cells in a dataset we would use Get\-Cell(). To traverse cells with vtk\-Poly\-Data we would retrieve the cell array object representing polygons (for example using Get\-Polys()) and then use vtk\-Cell\-Array's Init\-Traversal() and Get\-Next\-Cell() methods.

To create an instance of class vtk\-Poly\-Data, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPolyData
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Poly\-Data has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Poly\-Data class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Poly\-Data = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Poly\-Data = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Data\-Object\-Type ()} -\/ Copy the geometric and topological structure of an input poly data object.  
\item {\ttfamily obj.\-Copy\-Structure (vtk\-Data\-Set ds)} -\/ Copy the geometric and topological structure of an input poly data object.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Cells ()} -\/ Standard vtk\-Data\-Set interface.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Cell (vtk\-Id\-Type cell\-Id)} -\/ Standard vtk\-Data\-Set interface.  
\item {\ttfamily obj.\-Get\-Cell (vtk\-Id\-Type cell\-Id, vtk\-Generic\-Cell cell)} -\/ Standard vtk\-Data\-Set interface.  
\item {\ttfamily int = obj.\-Get\-Cell\-Type (vtk\-Id\-Type cell\-Id)} -\/ Standard vtk\-Data\-Set interface.  
\item {\ttfamily obj.\-Get\-Cell\-Bounds (vtk\-Id\-Type cell\-Id, double bounds\mbox{[}6\mbox{]})} -\/ Standard vtk\-Data\-Set interface.  
\item {\ttfamily obj.\-Get\-Cell\-Neighbors (vtk\-Id\-Type cell\-Id, vtk\-Id\-List pt\-Ids, vtk\-Id\-List cell\-Ids)} -\/ Standard vtk\-Data\-Set interface.  
\item {\ttfamily obj.\-Copy\-Cells (vtk\-Poly\-Data pd, vtk\-Id\-List id\-List, vtk\-Point\-Locator locator\-N\-U\-L\-L)} -\/ Copy cells listed in id\-List from pd, including points, point data, and cell data. This method assumes that point and cell data have been allocated. If you pass in a point locator, then the points won't be duplicated in the output.  
\item {\ttfamily obj.\-Get\-Cell\-Points (vtk\-Id\-Type cell\-Id, vtk\-Id\-List pt\-Ids)} -\/ Copy a cells point ids into list provided. (Less efficient.)  
\item {\ttfamily obj.\-Get\-Point\-Cells (vtk\-Id\-Type pt\-Id, vtk\-Id\-List cell\-Ids)} -\/ Efficient method to obtain cells using a particular point. Make sure that routine Build\-Links() has been called.  
\item {\ttfamily obj.\-Compute\-Bounds ()} -\/ Compute the (X, Y, Z) bounds of the data.  
\item {\ttfamily obj.\-Squeeze ()} -\/ Recover extra allocated memory when creating data whose initial size is unknown. Examples include using the Insert\-Next\-Cell() method, or when using the Cell\-Array\-::\-Estimate\-Size() method to create vertices, lines, polygons, or triangle strips.  
\item {\ttfamily int = obj.\-Get\-Max\-Cell\-Size ()} -\/ Return the maximum cell size in this poly data.  
\item {\ttfamily obj.\-Set\-Verts (vtk\-Cell\-Array v)} -\/ Set the cell array defining vertices.  
\item {\ttfamily vtk\-Cell\-Array = obj.\-Get\-Verts ()} -\/ Get the cell array defining vertices. If there are no vertices, an empty array will be returned (convenience to simplify traversal).  
\item {\ttfamily obj.\-Set\-Lines (vtk\-Cell\-Array l)} -\/ Set the cell array defining lines.  
\item {\ttfamily vtk\-Cell\-Array = obj.\-Get\-Lines ()} -\/ Get the cell array defining lines. If there are no lines, an empty array will be returned (convenience to simplify traversal).  
\item {\ttfamily obj.\-Set\-Polys (vtk\-Cell\-Array p)} -\/ Set the cell array defining polygons.  
\item {\ttfamily vtk\-Cell\-Array = obj.\-Get\-Polys ()} -\/ Get the cell array defining polygons. If there are no polygons, an empty array will be returned (convenience to simplify traversal).  
\item {\ttfamily obj.\-Set\-Strips (vtk\-Cell\-Array s)} -\/ Set the cell array defining triangle strips.  
\item {\ttfamily vtk\-Cell\-Array = obj.\-Get\-Strips ()} -\/ Get the cell array defining triangle strips. If there are no triangle strips, an empty array will be returned (convenience to simplify traversal).  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Verts ()} -\/ Return the number of primitives of a particular type held..  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Lines ()} -\/ Return the number of primitives of a particular type held..  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Polys ()} -\/ Return the number of primitives of a particular type held..  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Strips ()} -\/ Return the number of primitives of a particular type held..  
\item {\ttfamily obj.\-Allocate (vtk\-Id\-Type num\-Cells, int ext\-Size)} -\/ Method allocates initial storage for vertex, line, polygon, and triangle strip arrays. Use this method before the method Poly\-Data\-::\-Insert\-Next\-Cell(). (Or, provide vertex, line, polygon, and triangle strip cell arrays.)  
\item {\ttfamily obj.\-Allocate (vtk\-Poly\-Data in\-Poly\-Data, vtk\-Id\-Type num\-Cells, int ext\-Size)} -\/ Similar to the method above, this method allocates initial storage for vertex, line, polygon, and triangle strip arrays. It does this more intelligently, examining the supplied in\-Poly\-Data to determine whether to allocate the verts, lines, polys, and strips arrays. (These arrays are allocated only if there is data in the corresponding arrays in the in\-Poly\-Data.) Caution\-: if the in\-Poly\-Data has no verts, and after allocating with this method an Poly\-Data\-::\-Insert\-Next\-Cell() is invoked where a vertex is inserted, bad things will happen.  
\item {\ttfamily int = obj.\-Insert\-Next\-Cell (int type, vtk\-Id\-List pts)} -\/ Insert a cell of type V\-T\-K\-\_\-\-V\-E\-R\-T\-E\-X, V\-T\-K\-\_\-\-P\-O\-L\-Y\-\_\-\-V\-E\-R\-T\-E\-X, V\-T\-K\-\_\-\-L\-I\-N\-E, V\-T\-K\-\_\-\-P\-O\-L\-Y\-\_\-\-L\-I\-N\-E, V\-T\-K\-\_\-\-T\-R\-I\-A\-N\-G\-L\-E, V\-T\-K\-\_\-\-Q\-U\-A\-D, V\-T\-K\-\_\-\-P\-O\-L\-Y\-G\-O\-N, or V\-T\-K\-\_\-\-T\-R\-I\-A\-N\-G\-L\-E\-\_\-\-S\-T\-R\-I\-P. Make sure that the Poly\-Data\-::\-Allocate() function has been called first or that vertex, line, polygon, and triangle strip arrays have been supplied. Note\-: will also insert V\-T\-K\-\_\-\-P\-I\-X\-E\-L, but converts it to V\-T\-K\-\_\-\-Q\-U\-A\-D.  
\item {\ttfamily obj.\-Reset ()} -\/ Begin inserting data all over again. Memory is not freed but otherwise objects are returned to their initial state.  
\item {\ttfamily obj.\-Build\-Cells ()} -\/ Create data structure that allows random access of cells.  
\item {\ttfamily obj.\-Build\-Links (int initial\-Size)} -\/ Create upward links from points to cells that use each point. Enables topologically complex queries. Normally the links array is allocated based on the number of points in the vtk\-Poly\-Data. The optional initial\-Size parameter can be used to allocate a larger size initially.  
\item {\ttfamily obj.\-Delete\-Cells ()} -\/ Release data structure that allows random access of the cells. This must be done before a 2nd call to Build\-Links(). Delete\-Cells implicitly deletes the links as well since they are no longer valid.  
\item {\ttfamily obj.\-Delete\-Links ()} -\/ Release the upward links from point to cells that use each point.  
\item {\ttfamily obj.\-Get\-Cell\-Edge\-Neighbors (vtk\-Id\-Type cell\-Id, vtk\-Id\-Type p1, vtk\-Id\-Type p2, vtk\-Id\-List cell\-Ids)} -\/ Get the neighbors at an edge. More efficient than the general Get\-Cell\-Neighbors(). Assumes links have been built (with Build\-Links()), and looks specifically for edge neighbors.  
\item {\ttfamily int = obj.\-Is\-Triangle (int v1, int v2, int v3)} -\/ Given three vertices, determine whether it's a triangle. Make sure Build\-Links() has been called first.  
\item {\ttfamily int = obj.\-Is\-Edge (vtk\-Id\-Type p1, vtk\-Id\-Type p2)} -\/ Determine whether two points form an edge. If they do, return non-\/zero. By definition Poly\-Vertex and Poly\-Line have no edges since 1-\/dimensional edges are only found on cells 2\-D and higher. Edges are defined as 1-\/\-D boundary entities to cells. Make sure Build\-Links() has been called first.  
\item {\ttfamily int = obj.\-Is\-Point\-Used\-By\-Cell (vtk\-Id\-Type pt\-Id, vtk\-Id\-Type cell\-Id)} -\/ Determine whether a point is used by a particular cell. If it is, return non-\/zero. Make sure Build\-Cells() has been called first.  
\item {\ttfamily obj.\-Replace\-Cell\-Point (vtk\-Id\-Type cell\-Id, vtk\-Id\-Type old\-Pt\-Id, vtk\-Id\-Type new\-Pt\-Id)} -\/ Replace a point in the cell connectivity list with a different point.  
\item {\ttfamily obj.\-Reverse\-Cell (vtk\-Id\-Type cell\-Id)} -\/ Reverse the order of point ids defining the cell.  
\item {\ttfamily obj.\-Delete\-Point (vtk\-Id\-Type pt\-Id)} -\/ Mark a point/cell as deleted from this vtk\-Poly\-Data.  
\item {\ttfamily obj.\-Delete\-Cell (vtk\-Id\-Type cell\-Id)} -\/ Mark a point/cell as deleted from this vtk\-Poly\-Data.  
\item {\ttfamily obj.\-Remove\-Deleted\-Cells ()} -\/ The cells marked by calls to Delete\-Cell are stored in the Cell Array V\-T\-K\-\_\-\-E\-M\-P\-T\-Y\-\_\-\-C\-E\-L\-L, but they still exist in the polys array. Calling Remove\-Deleted\-Cells will travers the poly array and remove/compact the cell array as well as any cell data thus truly removing the cells from the polydata object. W\-A\-R\-N\-I\-N\-G. This only handles the polys at the moment  
\item {\ttfamily int = obj.\-Insert\-Next\-Linked\-Point (int num\-Links)} -\/ Add a point to the cell data structure (after cell pointers have been built). This method adds the point and then allocates memory for the links to the cells. (To use this method, make sure points are available and Build\-Links() has been invoked.) Of the two methods below, one inserts a point coordinate and the other just makes room for cell links.  
\item {\ttfamily int = obj.\-Insert\-Next\-Linked\-Point (double x\mbox{[}3\mbox{]}, int num\-Links)} -\/ Add a point to the cell data structure (after cell pointers have been built). This method adds the point and then allocates memory for the links to the cells. (To use this method, make sure points are available and Build\-Links() has been invoked.) Of the two methods below, one inserts a point coordinate and the other just makes room for cell links.  
\item {\ttfamily obj.\-Remove\-Cell\-Reference (vtk\-Id\-Type cell\-Id)} -\/ Remove all references to cell in cell structure. This means the links from the cell's points to the cell are deleted. Memory is not reclaimed. Use the method Resize\-Cell\-List() to resize the link list from a point to its using cells. (This operator assumes Build\-Links() has been called.)  
\item {\ttfamily obj.\-Add\-Cell\-Reference (vtk\-Id\-Type cell\-Id)} -\/ Add references to cell in cell structure. This means the links from the cell's points to the cell are modified. Memory is not extended. Use the method Resize\-Cell\-List() to resize the link list from a point to its using cells. (This operator assumes Build\-Links() has been called.)  
\item {\ttfamily obj.\-Remove\-Reference\-To\-Cell (vtk\-Id\-Type pt\-Id, vtk\-Id\-Type cell\-Id)} -\/ Remove a reference to a cell in a particular point's link list. You may also consider using Remove\-Cell\-Reference() to remove the references from all the cell's points to the cell. This operator does not reallocate memory; use the operator Resize\-Cell\-List() to do this if necessary.  
\item {\ttfamily obj.\-Add\-Reference\-To\-Cell (vtk\-Id\-Type pt\-Id, vtk\-Id\-Type cell\-Id)} -\/ Add a reference to a cell in a particular point's link list. (You may also consider using Add\-Cell\-Reference() to add the references from all the cell's points to the cell.) This operator does not realloc memory; use the operator Resize\-Cell\-List() to do this if necessary.  
\item {\ttfamily obj.\-Resize\-Cell\-List (vtk\-Id\-Type pt\-Id, int size)} -\/ Resize the list of cells using a particular point. (This operator assumes that Build\-Links() has been called.)  
\item {\ttfamily obj.\-Initialize ()} -\/ Restore object to initial state. Release memory back to system.  
\item {\ttfamily int = obj.\-Get\-Update\-Extent ()} -\/ We need this here to avoid hiding superclass method  
\item {\ttfamily obj.\-Get\-Update\-Extent (int extent\mbox{[}6\mbox{]})} -\/ We need this here to avoid hiding superclass method  
\item {\ttfamily int = obj.\-Get\-Piece ()} -\/ Get the piece and the number of pieces. Similar to extent in 3\-D.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Pieces ()} -\/ Get the piece and the number of pieces. Similar to extent in 3\-D.  
\item {\ttfamily int = obj.\-Get\-Ghost\-Level ()} -\/ Get the ghost level.  
\item {\ttfamily long = obj.\-Get\-Actual\-Memory\-Size ()} -\/ Return the actual size of the data in kilobytes. This number is valid only after the pipeline has updated. The memory size returned is guaranteed to be greater than or equal to the memory required to represent the data (e.\-g., extra space in arrays, etc. are not included in the return value). T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E.  
\item {\ttfamily obj.\-Shallow\-Copy (vtk\-Data\-Object src)} -\/ Shallow and Deep copy.  
\item {\ttfamily obj.\-Deep\-Copy (vtk\-Data\-Object src)} -\/ Shallow and Deep copy.  
\item {\ttfamily obj.\-Remove\-Ghost\-Cells (int level)} -\/ This method will remove any cell that has a ghost level array value greater or equal to level. It does not remove unused points (yet).  
\item {\ttfamily int = obj.\-Get\-Scalar\-Field\-Critical\-Index (vtk\-Id\-Type point\-Id, vtk\-Data\-Array scalar\-Field)} -\/ Scalar field critical point classification (for manifold 2\-D meshes). Reference\-: J. Milnor \char`\"{}\-Morse Theory\char`\"{}, Princeton University Press, 1963.

Given a point\-Id and an attribute representing a scalar field, this member returns the index of the critical point\-: vtk\-Poly\-Data\-::\-M\-I\-N\-I\-M\-U\-M (index 0)\-: local minimum; vtk\-Poly\-Data\-::\-S\-A\-D\-D\-L\-E (index 1)\-: local saddle; vtk\-Poly\-Data\-::\-M\-A\-X\-I\-M\-U\-M (index 2)\-: local maximum.

Other returned values are\-: vtk\-Poly\-Data\-::\-R\-E\-G\-U\-L\-A\-R\-\_\-\-P\-O\-I\-N\-T\-: regular point (the gradient does not vanish); vtk\-Poly\-Data\-::\-E\-R\-R\-\_\-\-N\-O\-N\-\_\-\-M\-A\-N\-I\-F\-O\-L\-D\-\_\-\-S\-T\-A\-R\-: the star of the considered vertex is not manifold (could not evaluate the index) vtk\-Poly\-Data\-::\-E\-R\-R\-\_\-\-I\-N\-C\-O\-R\-R\-E\-C\-T\-\_\-\-F\-I\-E\-L\-D\-: the number of entries in the scalar field array is different form the number of vertices in the mesh. vtk\-Poly\-Data\-::\-E\-R\-R\-\_\-\-N\-O\-\_\-\-S\-U\-C\-H\-\_\-\-F\-I\-E\-L\-D\-: the specified scalar field does not exist.  
\item {\ttfamily int = obj.\-Get\-Scalar\-Field\-Critical\-Index (vtk\-Id\-Type point\-Id, int field\-Id)} -\/ Scalar field critical point classification (for manifold 2\-D meshes). Reference\-: J. Milnor \char`\"{}\-Morse Theory\char`\"{}, Princeton University Press, 1963.

Given a point\-Id and an attribute representing a scalar field, this member returns the index of the critical point\-: vtk\-Poly\-Data\-::\-M\-I\-N\-I\-M\-U\-M (index 0)\-: local minimum; vtk\-Poly\-Data\-::\-S\-A\-D\-D\-L\-E (index 1)\-: local saddle; vtk\-Poly\-Data\-::\-M\-A\-X\-I\-M\-U\-M (index 2)\-: local maximum.

Other returned values are\-: vtk\-Poly\-Data\-::\-R\-E\-G\-U\-L\-A\-R\-\_\-\-P\-O\-I\-N\-T\-: regular point (the gradient does not vanish); vtk\-Poly\-Data\-::\-E\-R\-R\-\_\-\-N\-O\-N\-\_\-\-M\-A\-N\-I\-F\-O\-L\-D\-\_\-\-S\-T\-A\-R\-: the star of the considered vertex is not manifold (could not evaluate the index) vtk\-Poly\-Data\-::\-E\-R\-R\-\_\-\-I\-N\-C\-O\-R\-R\-E\-C\-T\-\_\-\-F\-I\-E\-L\-D\-: the number of entries in the scalar field array is different form the number of vertices in the mesh. vtk\-Poly\-Data\-::\-E\-R\-R\-\_\-\-N\-O\-\_\-\-S\-U\-C\-H\-\_\-\-F\-I\-E\-L\-D\-: the specified scalar field does not exist.  
\item {\ttfamily int = obj.\-Get\-Scalar\-Field\-Critical\-Index (vtk\-Id\-Type point\-Id, string field\-Name)} -\/ Scalar field critical point classification (for manifold 2\-D meshes). Reference\-: J. Milnor \char`\"{}\-Morse Theory\char`\"{}, Princeton University Press, 1963.

Given a point\-Id and an attribute representing a scalar field, this member returns the index of the critical point\-: vtk\-Poly\-Data\-::\-M\-I\-N\-I\-M\-U\-M (index 0)\-: local minimum; vtk\-Poly\-Data\-::\-S\-A\-D\-D\-L\-E (index 1)\-: local saddle; vtk\-Poly\-Data\-::\-M\-A\-X\-I\-M\-U\-M (index 2)\-: local maximum.

Other returned values are\-: vtk\-Poly\-Data\-::\-R\-E\-G\-U\-L\-A\-R\-\_\-\-P\-O\-I\-N\-T\-: regular point (the gradient does not vanish); vtk\-Poly\-Data\-::\-E\-R\-R\-\_\-\-N\-O\-N\-\_\-\-M\-A\-N\-I\-F\-O\-L\-D\-\_\-\-S\-T\-A\-R\-: the star of the considered vertex is not manifold (could not evaluate the index) vtk\-Poly\-Data\-::\-E\-R\-R\-\_\-\-I\-N\-C\-O\-R\-R\-E\-C\-T\-\_\-\-F\-I\-E\-L\-D\-: the number of entries in the scalar field array is different form the number of vertices in the mesh. vtk\-Poly\-Data\-::\-E\-R\-R\-\_\-\-N\-O\-\_\-\-S\-U\-C\-H\-\_\-\-F\-I\-E\-L\-D\-: the specified scalar field does not exist.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkpolydataalgorithm}{}\section{vtk\-Poly\-Data\-Algorithm}\label{vtkfiltering_vtkpolydataalgorithm}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
To create an instance of class vtk\-Poly\-Data\-Algorithm, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPolyDataAlgorithm
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Poly\-Data\-Algorithm has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Poly\-Data\-Algorithm class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Poly\-Data\-Algorithm = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Poly\-Data\-Algorithm = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Poly\-Data = obj.\-Get\-Output ()} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Poly\-Data = obj.\-Get\-Output (int )} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily obj.\-Set\-Output (vtk\-Data\-Object d)} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Input ()}  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Input (int port)}  
\item {\ttfamily vtk\-Poly\-Data = obj.\-Get\-Poly\-Data\-Input (int port)}  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Object )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Set\-Input (int , vtk\-Data\-Object )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Add\-Input (vtk\-Data\-Object )} -\/ Add an input of this algorithm. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Add\-Input\-Connection(). See Set\-Input() for details.  
\item {\ttfamily obj.\-Add\-Input (int , vtk\-Data\-Object )} -\/ Add an input of this algorithm. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Add\-Input\-Connection(). See Set\-Input() for details.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkpolydatacollection}{}\section{vtk\-Poly\-Data\-Collection}\label{vtkfiltering_vtkpolydatacollection}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Poly\-Data\-Collection is an object that creates and manipulates lists of datasets of type vtk\-Poly\-Data.

To create an instance of class vtk\-Poly\-Data\-Collection, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPolyDataCollection
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Poly\-Data\-Collection has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Poly\-Data\-Collection class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Poly\-Data\-Collection = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Poly\-Data\-Collection = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Add\-Item (vtk\-Poly\-Data pd)} -\/ Get the next poly data in the list.  
\item {\ttfamily vtk\-Poly\-Data = obj.\-Get\-Next\-Item ()} -\/ Get the next poly data in the list.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkpolydatasource}{}\section{vtk\-Poly\-Data\-Source}\label{vtkfiltering_vtkpolydatasource}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Poly\-Data\-Source is an abstract class whose subclasses generate polygonal data.

To create an instance of class vtk\-Poly\-Data\-Source, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPolyDataSource
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Poly\-Data\-Source has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Poly\-Data\-Source class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Poly\-Data\-Source = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Poly\-Data\-Source = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Poly\-Data = obj.\-Get\-Output ()} -\/ Get the output of this source.  
\item {\ttfamily vtk\-Poly\-Data = obj.\-Get\-Output (int idx)} -\/ Get the output of this source.  
\item {\ttfamily obj.\-Set\-Output (vtk\-Poly\-Data output)} -\/ Get the output of this source.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkpolydatatopolydatafilter}{}\section{vtk\-Poly\-Data\-To\-Poly\-Data\-Filter}\label{vtkfiltering_vtkpolydatatopolydatafilter}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Poly\-Data\-To\-Poly\-Data\-Filter is an abstract filter class whose subclasses take as input polygonal data and generate polygonal data on output. .S\-E\-C\-T\-I\-O\-N Warning This used to be the parent class for most polydata filter in V\-T\-K4.\-x, now this role has been replaced by vtk\-Poly\-Data\-Algorithm. You should consider using vtk\-Poly\-Data\-Algorithm instead of this class, when writing filter for V\-T\-K5 and above. This class was kept to ensure full backward compatibility.

To create an instance of class vtk\-Poly\-Data\-To\-Poly\-Data\-Filter, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPolyDataToPolyDataFilter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Poly\-Data\-To\-Poly\-Data\-Filter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Poly\-Data\-To\-Poly\-Data\-Filter class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Poly\-Data\-To\-Poly\-Data\-Filter = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Poly\-Data\-To\-Poly\-Data\-Filter = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Input (vtk\-Poly\-Data input)} -\/ Set / get the input data or filter.  
\item {\ttfamily vtk\-Poly\-Data = obj.\-Get\-Input ()} -\/ Set / get the input data or filter.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkpolygon}{}\section{vtk\-Polygon}\label{vtkfiltering_vtkpolygon}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Polygon is a concrete implementation of vtk\-Cell to represent a 2\-D n-\/sided polygon. The polygons cannot have any internal holes, and cannot self-\/intersect. Define the polygon with n-\/points ordered in the counter-\/ clockwise direction; do not repeat the last point.

To create an instance of class vtk\-Polygon, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPolygon
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Polygon has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Polygon class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Polygon = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Polygon = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int edge\-Id)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int )} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Clip (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array tris, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd, int inside\-Out)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Is\-Primary\-Cell ()} -\/ Compute the area of a polygon. This is a convenience function which simply calls static double Compute\-Area(vtk\-Points $\ast$p, vtk\-Id\-Type num\-Pts, vtk\-Id\-Type $\ast$pts, double normal\mbox{[}3\mbox{]}); with the appropriate parameters from the instantiated vtk\-Polygon.  
\item {\ttfamily double = obj.\-Compute\-Area ()} -\/ Compute the area of a polygon. This is a convenience function which simply calls static double Compute\-Area(vtk\-Points $\ast$p, vtk\-Id\-Type num\-Pts, vtk\-Id\-Type $\ast$pts, double normal\mbox{[}3\mbox{]}); with the appropriate parameters from the instantiated vtk\-Polygon.  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double sf)} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs)} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Compute\-Weights (double x\mbox{[}3\mbox{]}, double weights)} -\/ Compute interpolation weights using 1/r$\ast$$\ast$2 normalized sum.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkpolyline}{}\section{vtk\-Poly\-Line}\label{vtkfiltering_vtkpolyline}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Poly\-Line is a concrete implementation of vtk\-Cell to represent a set of 1\-D lines.

To create an instance of class vtk\-Poly\-Line, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPolyLine
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Poly\-Line has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Poly\-Line class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Poly\-Line = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Poly\-Line = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int )} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int )} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Clip (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array lines, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd, int inside\-Out)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Is\-Primary\-Cell ()} -\/ Return the center of the point cloud in parametric coordinates.  
\item {\ttfamily int = obj.\-Get\-Parametric\-Center (double pcoords\mbox{[}3\mbox{]})} -\/ Return the center of the point cloud in parametric coordinates.  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double weights)} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs)} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkpolyvertex}{}\section{vtk\-Poly\-Vertex}\label{vtkfiltering_vtkpolyvertex}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Poly\-Vertex is a concrete implementation of vtk\-Cell to represent a set of 3\-D vertices.

To create an instance of class vtk\-Poly\-Vertex, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPolyVertex
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Poly\-Vertex has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Poly\-Vertex class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Poly\-Vertex = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Poly\-Vertex = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int )} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int )} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Clip (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd, int inside\-Out)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Is\-Primary\-Cell ()} -\/ Return the center of the point cloud in parametric coordinates.  
\item {\ttfamily int = obj.\-Get\-Parametric\-Center (double pcoords\mbox{[}3\mbox{]})} -\/ Return the center of the point cloud in parametric coordinates.  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double weights)} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs)} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkprocessobject}{}\section{vtk\-Process\-Object}\label{vtkfiltering_vtkprocessobject}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Process\-Object is an abstract object that specifies behavior and interface of visualization network process objects (sources, filters, mappers). Source objects are creators of visualization data; filters input, process, and output visualization data; and mappers transform data into another form (like rendering primitives or write data to a file).

vtk\-Process\-Object fires events for Start and End events before and after object execution (via Execute()). These events can be used for any purpose (e.\-g., debugging info, highlighting/notifying user interface, etc.)

Another event, Progress, can be observed. Some filters fire this event periodically during their execution. The use is similar to that of Start and End events. Filters may also check their Abort\-Execute flag to determine whether to prematurely end their execution.

An important feature of subclasses of vtk\-Process\-Object is that it is possible to control the memory-\/management model (i.\-e., retain output versus delete output data). If enabled the Release\-Data\-Flag enables the deletion of the output data once the downstream process object finishes processing the data (please see text).

To create an instance of class vtk\-Process\-Object, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkProcessObject
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Process\-Object has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Process\-Object class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Process\-Object = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Process\-Object = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Inputs ()} -\/ Return an array with all the inputs of this process object. This is useful for tracing back in the pipeline to construct graphs etc.  
\item {\ttfamily obj.\-Squeeze\-Input\-Array ()} -\/ This method will rearrange the input array so that all N\-U\-L\-L entries are removed.  
\item {\ttfamily obj.\-Remove\-All\-Inputs ()} -\/ Remove all the input data.  
\item {\ttfamily obj.\-Set\-Input\-Connection (vtk\-Algorithm\-Output input)} -\/ Reimplemented from vtk\-Algorithm to maintain backward compatibility for vtk\-Process\-Object.  
\item {\ttfamily obj.\-Set\-Input\-Connection (int port, vtk\-Algorithm\-Output input)} -\/ Reimplemented from vtk\-Algorithm to maintain backward compatibility for vtk\-Process\-Object.  
\item {\ttfamily obj.\-Add\-Input\-Connection (int port, vtk\-Algorithm\-Output input)} -\/ Reimplemented from vtk\-Algorithm to maintain backward compatibility for vtk\-Process\-Object.  
\item {\ttfamily obj.\-Add\-Input\-Connection (vtk\-Algorithm\-Output input)} -\/ Reimplemented from vtk\-Algorithm to maintain backward compatibility for vtk\-Process\-Object.  
\item {\ttfamily obj.\-Remove\-Input\-Connection (int port, vtk\-Algorithm\-Output input)} -\/ Reimplemented from vtk\-Algorithm to maintain backward compatibility for vtk\-Process\-Object.  
\item {\ttfamily obj.\-Set\-Nth\-Input\-Connection (int port, int index, vtk\-Algorithm\-Output input)} -\/ Reimplemented from vtk\-Algorithm to maintain backward compatibility for vtk\-Process\-Object.  
\item {\ttfamily obj.\-Set\-Number\-Of\-Input\-Connections (int port, int n)} -\/ Reimplemented from vtk\-Algorithm to maintain backward compatibility for vtk\-Process\-Object.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkpropassembly}{}\section{vtk\-Prop\-Assembly}\label{vtkfiltering_vtkpropassembly}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Prop\-Assembly is an object that groups props and other prop assemblies into a tree-\/like hierarchy. The props can then be treated as a group (e.\-g., turning visibility on and off).

A vtk\-Prop\-Assembly object can be used in place of an vtk\-Prop since it is a subclass of vtk\-Prop. The difference is that vtk\-Prop\-Assembly maintains a list of other prop and prop assembly instances (its \char`\"{}parts\char`\"{}) that form the assembly. Note that this process is recursive\-: you can create groups consisting of prop assemblies to arbitrary depth.

vtk\-Prop\-Assembly's and vtk\-Prop's that compose a prop assembly need not be added to a renderer's list of props, as long as the parent assembly is in the prop list. This is because they are automatically renderered during the hierarchical traversal process.

To create an instance of class vtk\-Prop\-Assembly, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPropAssembly
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Prop\-Assembly has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Prop\-Assembly class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Prop\-Assembly = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Prop\-Assembly = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Add\-Part (vtk\-Prop )} -\/ Add a part to the list of parts.  
\item {\ttfamily obj.\-Remove\-Part (vtk\-Prop )} -\/ Remove a part from the list of parts,  
\item {\ttfamily vtk\-Prop\-Collection = obj.\-Get\-Parts ()} -\/ Return the list of parts.  
\item {\ttfamily int = obj.\-Render\-Opaque\-Geometry (vtk\-Viewport ren)} -\/ Render this assembly and all its parts. The rendering process is recursive. The parts of each assembly are rendered only if the visibility for the prop is turned on.  
\item {\ttfamily int = obj.\-Render\-Translucent\-Polygonal\-Geometry (vtk\-Viewport ren)} -\/ Render this assembly and all its parts. The rendering process is recursive. The parts of each assembly are rendered only if the visibility for the prop is turned on.  
\item {\ttfamily int = obj.\-Render\-Volumetric\-Geometry (vtk\-Viewport ren)} -\/ Render this assembly and all its parts. The rendering process is recursive. The parts of each assembly are rendered only if the visibility for the prop is turned on.  
\item {\ttfamily int = obj.\-Render\-Overlay (vtk\-Viewport ren)} -\/ Render this assembly and all its parts. The rendering process is recursive. The parts of each assembly are rendered only if the visibility for the prop is turned on.  
\item {\ttfamily int = obj.\-Has\-Translucent\-Polygonal\-Geometry ()} -\/ Does this prop have some translucent polygonal geometry?  
\item {\ttfamily obj.\-Release\-Graphics\-Resources (vtk\-Window )} -\/ Release any graphics resources that are being consumed by this actor. The parameter window could be used to determine which graphic resources to release.  
\item {\ttfamily double = obj.\-Get\-Bounds ()} -\/ Get the bounds for this prop assembly as (Xmin,Xmax,Ymin,Ymax,Zmin,Zmax). May return N\-U\-L\-L in some cases (meaning the bounds is undefined).  
\item {\ttfamily obj.\-Shallow\-Copy (vtk\-Prop Prop)} -\/ Shallow copy of this vtk\-Prop\-Assembly.  
\item {\ttfamily long = obj.\-Get\-M\-Time ()} -\/ Override default Get\-M\-Time method to also consider all of the prop assembly's parts.  
\item {\ttfamily obj.\-Init\-Path\-Traversal ()} -\/ Methods to traverse the paths (i.\-e., leaf nodes) of a prop assembly. These methods should be contrasted to those that traverse the list of parts using Get\-Parts(). Get\-Parts() returns a list of children of this assembly, not necessarily the leaf nodes of the assembly. To use the methods below -\/ first invoke Init\-Path\-Traversal() followed by repeated calls to Get\-Next\-Path(). Get\-Next\-Path() returns a N\-U\-L\-L pointer when the list is exhausted. (See the superclass vtk\-Prop for more information about paths.)  
\item {\ttfamily vtk\-Assembly\-Path = obj.\-Get\-Next\-Path ()} -\/ Methods to traverse the paths (i.\-e., leaf nodes) of a prop assembly. These methods should be contrasted to those that traverse the list of parts using Get\-Parts(). Get\-Parts() returns a list of children of this assembly, not necessarily the leaf nodes of the assembly. To use the methods below -\/ first invoke Init\-Path\-Traversal() followed by repeated calls to Get\-Next\-Path(). Get\-Next\-Path() returns a N\-U\-L\-L pointer when the list is exhausted. (See the superclass vtk\-Prop for more information about paths.)  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Paths ()} -\/ Methods to traverse the paths (i.\-e., leaf nodes) of a prop assembly. These methods should be contrasted to those that traverse the list of parts using Get\-Parts(). Get\-Parts() returns a list of children of this assembly, not necessarily the leaf nodes of the assembly. To use the methods below -\/ first invoke Init\-Path\-Traversal() followed by repeated calls to Get\-Next\-Path(). Get\-Next\-Path() returns a N\-U\-L\-L pointer when the list is exhausted. (See the superclass vtk\-Prop for more information about paths.)  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkpyramid}{}\section{vtk\-Pyramid}\label{vtkfiltering_vtkpyramid}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Pyramid is a concrete implementation of vtk\-Cell to represent a 3\-D pyramid. A pyramid consists of a rectangular base with four triangular faces. vtk\-Pyramid uses the standard isoparametric shape functions for a linear pyramid. The pyramid is defined by the five points (0-\/4) where (0,1,2,3) is the base of the pyramid which, using the right hand rule, forms a quadrilaterial whose normal points in the direction of the pyramid apex at vertex \#4.

To create an instance of class vtk\-Pyramid, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkPyramid
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Pyramid has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Pyramid class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Pyramid = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Pyramid = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int edge\-Id)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int face\-Id)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Parametric\-Center (double pcoords\mbox{[}3\mbox{]})} -\/ Return the center of the pyramid in parametric coordinates.  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double weights\mbox{[}5\mbox{]})} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs\mbox{[}15\mbox{]})}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkquad}{}\section{vtk\-Quad}\label{vtkfiltering_vtkquad}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Quad is a concrete implementation of vtk\-Cell to represent a 2\-D quadrilateral. vtk\-Quad is defined by the four points (0,1,2,3) in counterclockwise order. vtk\-Quad uses the standard isoparametric interpolation functions for a linear quadrilateral.

To create an instance of class vtk\-Quad, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkQuad
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Quad has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Quad class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Quad = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Quad = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int edge\-Id)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int )} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Parametric\-Center (double pcoords\mbox{[}3\mbox{]})} -\/ Return the center of the triangle in parametric coordinates.  
\item {\ttfamily obj.\-Clip (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd, int inside\-Out)} -\/ Clip this quad using scalar value provided. Like contouring, except that it cuts the quad to produce other quads and/or triangles.  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double sf\mbox{[}4\mbox{]})} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs\mbox{[}8\mbox{]})} -\/ Return the ids of the vertices defining edge ({\ttfamily edge\-Id}). Ids are related to the cell, not to the dataset.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkquadraticedge}{}\section{vtk\-Quadratic\-Edge}\label{vtkfiltering_vtkquadraticedge}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Quadratic\-Edge is a concrete implementation of vtk\-Non\-Linear\-Cell to represent a one-\/dimensional, 3-\/nodes, isoparametric parabolic line. The interpolation is the standard finite element, quadratic isoparametric shape function. The cell includes a mid-\/edge node. The ordering of the three points defining the cell is point ids (0,1,2) where id \#2 is the midedge node.

To create an instance of class vtk\-Quadratic\-Edge, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkQuadraticEdge
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Quadratic\-Edge has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Quadratic\-Edge class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Quadratic\-Edge = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Quadratic\-Edge = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int )} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int )}  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)}  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)}  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)}  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)}  
\item {\ttfamily obj.\-Clip (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array lines, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd, int inside\-Out)} -\/ Clip this edge using scalar value provided. Like contouring, except that it cuts the edge to produce linear line segments.  
\item {\ttfamily int = obj.\-Get\-Parametric\-Center (double pcoords\mbox{[}3\mbox{]})} -\/ Return the center of the quadratic tetra in parametric coordinates.  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double weights\mbox{[}3\mbox{]})} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs\mbox{[}3\mbox{]})}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkquadratichexahedron}{}\section{vtk\-Quadratic\-Hexahedron}\label{vtkfiltering_vtkquadratichexahedron}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Quadratic\-Hexahedron is a concrete implementation of vtk\-Non\-Linear\-Cell to represent a three-\/dimensional, 20-\/node isoparametric parabolic hexahedron. The interpolation is the standard finite element, quadratic isoparametric shape function. The cell includes a mid-\/edge node. The ordering of the twenty points defining the cell is point ids (0-\/7,8-\/19) where point ids 0-\/7 are the eight corner vertices of the cube; followed by twelve midedge nodes (8-\/19). Note that these midedge nodes correspond lie on the edges defined by (0,1), (1,2), (2,3), (3,0), (4,5), (5,6), (6,7), (7,4), (0,4), (1,5), (2,6), (3,7).

To create an instance of class vtk\-Quadratic\-Hexahedron, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkQuadraticHexahedron
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Quadratic\-Hexahedron has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Quadratic\-Hexahedron class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Quadratic\-Hexahedron = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Quadratic\-Hexahedron = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int )} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int )} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)}  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)}  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)}  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)}  
\item {\ttfamily obj.\-Clip (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array tetras, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd, int inside\-Out)} -\/ Clip this quadratic hexahedron using scalar value provided. Like contouring, except that it cuts the hex to produce linear tetrahedron.  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double weights\mbox{[}20\mbox{]})} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs\mbox{[}60\mbox{]})} -\/ Return the ids of the vertices defining edge/face ({\ttfamily edge\-Id}/`face\-Id'). Ids are related to the cell, not to the dataset.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkquadraticlinearquad}{}\section{vtk\-Quadratic\-Linear\-Quad}\label{vtkfiltering_vtkquadraticlinearquad}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Quadratic\-Quad is a concrete implementation of vtk\-Non\-Linear\-Cell to represent a two-\/dimensional, 6-\/node isoparametric quadratic-\/linear quadrilateral element. The interpolation is the standard finite element, quadratic-\/linear isoparametric shape function. The cell includes a mid-\/edge node for two of the four edges. The ordering of the six points defining the cell are point ids (0-\/3,4-\/5) where ids 0-\/3 define the four corner vertices of the quad; ids 4-\/7 define the midedge nodes (0,1) and (2,3) .

To create an instance of class vtk\-Quadratic\-Linear\-Quad, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkQuadraticLinearQuad
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Quadratic\-Linear\-Quad has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Quadratic\-Linear\-Quad class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Quadratic\-Linear\-Quad = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Quadratic\-Linear\-Quad = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int )} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int )}  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)}  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)}  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)}  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)}  
\item {\ttfamily obj.\-Clip (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd, int inside\-Out)} -\/ Clip this quadratic linear quad using scalar value provided. Like contouring, except that it cuts the quad to produce linear triangles.  
\item {\ttfamily int = obj.\-Get\-Parametric\-Center (double pcoords\mbox{[}3\mbox{]})} -\/ Return the center of the pyramid in parametric coordinates.  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double weights\mbox{[}6\mbox{]})} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs\mbox{[}12\mbox{]})} -\/ Return the ids of the vertices defining edge ({\ttfamily edge\-Id}). Ids are related to the cell, not to the dataset.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkquadraticlinearwedge}{}\section{vtk\-Quadratic\-Linear\-Wedge}\label{vtkfiltering_vtkquadraticlinearwedge}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Quadratic\-Linear\-Wedge is a concrete implementation of vtk\-Non\-Linear\-Cell to represent a three-\/dimensional, 12-\/node isoparametric linear quadratic wedge. The interpolation is the standard finite element, quadratic isoparametric shape function in xy -\/ layer and the linear functions in z -\/ direction. The cell includes mid-\/edge node in the triangle edges. The ordering of the 12 points defining the cell is point ids (0-\/5,6-\/12) where point ids 0-\/5 are the six corner vertices of the wedge; followed by six midedge nodes (6-\/12). Note that these midedge nodes correspond lie on the edges defined by (0,1), (1,2), (2,0), (3,4), (4,5), (5,3). The Edges (0,3), (1,4), (2,5) dont have midedge nodes.

To create an instance of class vtk\-Quadratic\-Linear\-Wedge, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkQuadraticLinearWedge
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Quadratic\-Linear\-Wedge has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Quadratic\-Linear\-Wedge class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Quadratic\-Linear\-Wedge = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Quadratic\-Linear\-Wedge = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int edge\-Id)} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int face\-Id)} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)}  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)} -\/ The quadratic linear wege is splitted into 4 linear wedges, each of them is contoured by a provided scalar value  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)} -\/ The quadratic linear wege is splitted into 4 linear wedges, each of them is contoured by a provided scalar value  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)} -\/ The quadratic linear wege is splitted into 4 linear wedges, each of them is contoured by a provided scalar value  
\item {\ttfamily obj.\-Clip (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array tetras, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd, int inside\-Out)} -\/ Clip this quadratic linear wedge using scalar value provided. Like contouring, except that it cuts the hex to produce linear tetrahedron.  
\item {\ttfamily int = obj.\-Get\-Parametric\-Center (double pcoords\mbox{[}3\mbox{]})} -\/ Return the center of the quadratic linear wedge in parametric coordinates.  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double weights\mbox{[}15\mbox{]})} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs\mbox{[}45\mbox{]})} -\/ Return the ids of the vertices defining edge/face ({\ttfamily edge\-Id}/`face\-Id'). Ids are related to the cell, not to the dataset.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkquadraticpyramid}{}\section{vtk\-Quadratic\-Pyramid}\label{vtkfiltering_vtkquadraticpyramid}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Quadratic\-Pyramid is a concrete implementation of vtk\-Non\-Linear\-Cell to represent a three-\/dimensional, 13-\/node isoparametric parabolic pyramid. The interpolation is the standard finite element, quadratic isoparametric shape function. The cell includes a mid-\/edge node. The ordering of the thirteen points defining the cell is point ids (0-\/4,5-\/12) where point ids 0-\/4 are the five corner vertices of the pyramid; followed by eight midedge nodes (5-\/12). Note that these midedge nodes correspond lie on the edges defined by (0,1), (1,2), (2,3), (3,0), (0,4), (1,4), (2,4), (3,4).

To create an instance of class vtk\-Quadratic\-Pyramid, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkQuadraticPyramid
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Quadratic\-Pyramid has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Quadratic\-Pyramid class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Quadratic\-Pyramid = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Quadratic\-Pyramid = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int edge\-Id)} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int face\-Id)} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)}  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)}  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)}  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)}  
\item {\ttfamily obj.\-Clip (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array tets, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd, int inside\-Out)} -\/ Clip this quadratic triangle using scalar value provided. Like contouring, except that it cuts the triangle to produce linear triangles.  
\item {\ttfamily int = obj.\-Get\-Parametric\-Center (double pcoords\mbox{[}3\mbox{]})} -\/ Return the center of the quadratic pyramid in parametric coordinates.  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double weights\mbox{[}13\mbox{]})} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs\mbox{[}39\mbox{]})} -\/ Return the ids of the vertices defining edge/face ({\ttfamily edge\-Id}/`face\-Id'). Ids are related to the cell, not to the dataset.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkquadraticquad}{}\section{vtk\-Quadratic\-Quad}\label{vtkfiltering_vtkquadraticquad}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Quadratic\-Quad is a concrete implementation of vtk\-Non\-Linear\-Cell to represent a two-\/dimensional, 8-\/node isoparametric parabolic quadrilateral element. The interpolation is the standard finite element, quadratic isoparametric shape function. The cell includes a mid-\/edge node for each of the four edges of the cell. The ordering of the eight points defining the cell are point ids (0-\/3,4-\/7) where ids 0-\/3 define the four corner vertices of the quad; ids 4-\/7 define the midedge nodes (0,1), (1,2), (2,3), (3,0).

To create an instance of class vtk\-Quadratic\-Quad, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkQuadraticQuad
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Quadratic\-Quad has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Quadratic\-Quad class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Quadratic\-Quad = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Quadratic\-Quad = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int )} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int )}  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)}  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)}  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)}  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)}  
\item {\ttfamily obj.\-Clip (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd, int inside\-Out)} -\/ Clip this quadratic quad using scalar value provided. Like contouring, except that it cuts the quad to produce linear triangles.  
\item {\ttfamily int = obj.\-Get\-Parametric\-Center (double pcoords\mbox{[}3\mbox{]})} -\/ Return the center of the pyramid in parametric coordinates.  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double weights\mbox{[}8\mbox{]})} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs\mbox{[}16\mbox{]})}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkquadratictetra}{}\section{vtk\-Quadratic\-Tetra}\label{vtkfiltering_vtkquadratictetra}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Quadratic\-Tetra is a concrete implementation of vtk\-Non\-Linear\-Cell to represent a three-\/dimensional, 10-\/node, isoparametric parabolic tetrahedron. The interpolation is the standard finite element, quadratic isoparametric shape function. The cell includes a mid-\/edge node on each of the size edges of the tetrahedron. The ordering of the ten points defining the cell is point ids (0-\/3,4-\/9) where ids 0-\/3 are the four tetra vertices; and point ids 4-\/9 are the midedge nodes between (0,1), (1,2), (2,0), (0,3), (1,3), and (2,3).

To create an instance of class vtk\-Quadratic\-Tetra, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkQuadraticTetra
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Quadratic\-Tetra has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Quadratic\-Tetra class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Quadratic\-Tetra = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Quadratic\-Tetra = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int )} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int )} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)}  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)}  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)}  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)}  
\item {\ttfamily obj.\-Clip (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array tetras, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd, int inside\-Out)} -\/ Clip this edge using scalar value provided. Like contouring, except that it cuts the tetra to produce new tetras.  
\item {\ttfamily int = obj.\-Get\-Parametric\-Center (double pcoords\mbox{[}3\mbox{]})} -\/ Return the center of the quadratic tetra in parametric coordinates.  
\item {\ttfamily double = obj.\-Get\-Parametric\-Distance (double pcoords\mbox{[}3\mbox{]})} -\/ Return the distance of the parametric coordinate provided to the cell. If inside the cell, a distance of zero is returned.  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double weights\mbox{[}10\mbox{]})} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs\mbox{[}30\mbox{]})} -\/ Return the ids of the vertices defining edge/face ({\ttfamily edge\-Id}/`face\-Id'). Ids are related to the cell, not to the dataset.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkquadratictriangle}{}\section{vtk\-Quadratic\-Triangle}\label{vtkfiltering_vtkquadratictriangle}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Quadratic\-Triangle is a concrete implementation of vtk\-Non\-Linear\-Cell to represent a two-\/dimensional, 6-\/node, isoparametric parabolic triangle. The interpolation is the standard finite element, quadratic isoparametric shape function. The cell includes three mid-\/edge nodes besides the three triangle vertices. The ordering of the three points defining the cell is point ids (0-\/2,3-\/5) where id \#3 is the midedge node between points (0,1); id \#4 is the midedge node between points (1,2); and id \#5 is the midedge node between points (2,0).

To create an instance of class vtk\-Quadratic\-Triangle, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkQuadraticTriangle
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Quadratic\-Triangle has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Quadratic\-Triangle class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Quadratic\-Triangle = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Quadratic\-Triangle = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int edge\-Id)} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int )}  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)}  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)}  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)}  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)}  
\item {\ttfamily obj.\-Clip (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd, int inside\-Out)} -\/ Clip this quadratic triangle using scalar value provided. Like contouring, except that it cuts the triangle to produce linear triangles.  
\item {\ttfamily int = obj.\-Get\-Parametric\-Center (double pcoords\mbox{[}3\mbox{]})} -\/ Return the center of the quadratic triangle in parametric coordinates.  
\item {\ttfamily double = obj.\-Get\-Parametric\-Distance (double pcoords\mbox{[}3\mbox{]})} -\/ Return the distance of the parametric coordinate provided to the cell. If inside the cell, a distance of zero is returned.  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double weights\mbox{[}6\mbox{]})} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs\mbox{[}12\mbox{]})}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkquadraticwedge}{}\section{vtk\-Quadratic\-Wedge}\label{vtkfiltering_vtkquadraticwedge}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Quadratic\-Wedge is a concrete implementation of vtk\-Non\-Linear\-Cell to represent a three-\/dimensional, 15-\/node isoparametric parabolic wedge. The interpolation is the standard finite element, quadratic isoparametric shape function. The cell includes a mid-\/edge node. The ordering of the fifteen points defining the cell is point ids (0-\/5,6-\/14) where point ids 0-\/5 are the six corner vertices of the wedge; followed by nine midedge nodes (6-\/14). Note that these midedge nodes correspond lie on the edges defined by (0,1), (1,2), (2,0), (3,4), (4,5), (5,3), (0,3), (1,4), (2,5).

To create an instance of class vtk\-Quadratic\-Wedge, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkQuadraticWedge
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Quadratic\-Wedge has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Quadratic\-Wedge class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Quadratic\-Wedge = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Quadratic\-Wedge = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int edge\-Id)} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int face\-Id)} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)}  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)}  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)}  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)}  
\item {\ttfamily obj.\-Clip (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array tetras, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd, int inside\-Out)} -\/ Clip this quadratic hexahedron using scalar value provided. Like contouring, except that it cuts the hex to produce linear tetrahedron.  
\item {\ttfamily int = obj.\-Get\-Parametric\-Center (double pcoords\mbox{[}3\mbox{]})} -\/ Return the center of the quadratic wedge in parametric coordinates.  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double weights\mbox{[}15\mbox{]})} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs\mbox{[}45\mbox{]})} -\/ Return the ids of the vertices defining edge/face ({\ttfamily edge\-Id}/`face\-Id'). Ids are related to the cell, not to the dataset.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkrectilineargrid}{}\section{vtk\-Rectilinear\-Grid}\label{vtkfiltering_vtkrectilineargrid}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Rectilinear\-Grid is a data object that is a concrete implementation of vtk\-Data\-Set. vtk\-Rectilinear\-Grid represents a geometric structure that is topologically regular with variable spacing in the three coordinate directions x-\/y-\/z.

To define a vtk\-Rectilinear\-Grid, you must specify the dimensions of the data and provide three arrays of values specifying the coordinates along the x-\/y-\/z axes. The coordinate arrays are specified using three vtk\-Data\-Array objects (one for x, one for y, one for z).

To create an instance of class vtk\-Rectilinear\-Grid, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkRectilinearGrid
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Rectilinear\-Grid has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Rectilinear\-Grid class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Rectilinear\-Grid = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Rectilinear\-Grid = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Data\-Object\-Type ()} -\/ Return what type of dataset this is.  
\item {\ttfamily obj.\-Copy\-Structure (vtk\-Data\-Set ds)} -\/ Copy the geometric and topological structure of an input rectilinear grid object.  
\item {\ttfamily obj.\-Initialize ()} -\/ Restore object to initial state. Release memory back to system.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Cells ()} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Points ()} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily double = obj.\-Get\-Point (vtk\-Id\-Type pt\-Id)} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily obj.\-Get\-Point (vtk\-Id\-Type id, double x\mbox{[}3\mbox{]})} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Cell (vtk\-Id\-Type cell\-Id)} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily obj.\-Get\-Cell (vtk\-Id\-Type cell\-Id, vtk\-Generic\-Cell cell)} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily obj.\-Get\-Cell\-Bounds (vtk\-Id\-Type cell\-Id, double bounds\mbox{[}6\mbox{]})} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Find\-Point (double x, double y, double z)} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Find\-Point (double x\mbox{[}3\mbox{]})} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily int = obj.\-Get\-Cell\-Type (vtk\-Id\-Type cell\-Id)} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily obj.\-Get\-Cell\-Points (vtk\-Id\-Type cell\-Id, vtk\-Id\-List pt\-Ids)} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily obj.\-Get\-Point\-Cells (vtk\-Id\-Type pt\-Id, vtk\-Id\-List cell\-Ids)} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily obj.\-Compute\-Bounds ()} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily int = obj.\-Get\-Max\-Cell\-Size ()} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily obj.\-Get\-Cell\-Neighbors (vtk\-Id\-Type cell\-Id, vtk\-Id\-List pt\-Ids, vtk\-Id\-List cell\-Ids)} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily obj.\-Set\-Dimensions (int i, int j, int k)} -\/ Set dimensions of rectilinear grid dataset. This also sets the extent.  
\item {\ttfamily obj.\-Set\-Dimensions (int dim\mbox{[}3\mbox{]})} -\/ Set dimensions of rectilinear grid dataset. This also sets the extent.  
\item {\ttfamily int = obj. Get\-Dimensions ()} -\/ Get dimensions of this rectilinear grid dataset.  
\item {\ttfamily int = obj.\-Get\-Data\-Dimension ()} -\/ Return the dimensionality of the data.  
\item {\ttfamily int = obj.\-Compute\-Structured\-Coordinates (double x\mbox{[}3\mbox{]}, int ijk\mbox{[}3\mbox{]}, double pcoords\mbox{[}3\mbox{]})} -\/ Convenience function computes the structured coordinates for a point x\mbox{[}3\mbox{]}. The cell is specified by the array ijk\mbox{[}3\mbox{]}, and the parametric coordinates in the cell are specified with pcoords\mbox{[}3\mbox{]}. The function returns a 0 if the point x is outside of the grid, and a 1 if inside the grid.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Compute\-Point\-Id (int ijk\mbox{[}3\mbox{]})} -\/ Given a location in structured coordinates (i-\/j-\/k), return the point id.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Compute\-Cell\-Id (int ijk\mbox{[}3\mbox{]})} -\/ Given a location in structured coordinates (i-\/j-\/k), return the cell id.  
\item {\ttfamily obj.\-Set\-X\-Coordinates (vtk\-Data\-Array )} -\/ Specify the grid coordinates in the x-\/direction.  
\item {\ttfamily vtk\-Data\-Array = obj.\-Get\-X\-Coordinates ()} -\/ Specify the grid coordinates in the x-\/direction.  
\item {\ttfamily obj.\-Set\-Y\-Coordinates (vtk\-Data\-Array )} -\/ Specify the grid coordinates in the y-\/direction.  
\item {\ttfamily vtk\-Data\-Array = obj.\-Get\-Y\-Coordinates ()} -\/ Specify the grid coordinates in the y-\/direction.  
\item {\ttfamily obj.\-Set\-Z\-Coordinates (vtk\-Data\-Array )} -\/ Specify the grid coordinates in the z-\/direction.  
\item {\ttfamily vtk\-Data\-Array = obj.\-Get\-Z\-Coordinates ()} -\/ Specify the grid coordinates in the z-\/direction.  
\item {\ttfamily obj.\-Set\-Extent (int extent\mbox{[}6\mbox{]})} -\/ Different ways to set the extent of the data array. The extent should be set before the \char`\"{}\-Scalars\char`\"{} are set or allocated. The Extent is stored in the order (X, Y, Z).  
\item {\ttfamily obj.\-Set\-Extent (int x1, int x2, int y1, int y2, int z1, int z2)} -\/ Different ways to set the extent of the data array. The extent should be set before the \char`\"{}\-Scalars\char`\"{} are set or allocated. The Extent is stored in the order (X, Y, Z).  
\item {\ttfamily int = obj. Get\-Extent ()} -\/ Different ways to set the extent of the data array. The extent should be set before the \char`\"{}\-Scalars\char`\"{} are set or allocated. The Extent is stored in the order (X, Y, Z).  
\item {\ttfamily long = obj.\-Get\-Actual\-Memory\-Size ()} -\/ Return the actual size of the data in kilobytes. This number is valid only after the pipeline has updated. The memory size returned is guaranteed to be greater than or equal to the memory required to represent the data (e.\-g., extra space in arrays, etc. are not included in the return value). T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E.  
\item {\ttfamily obj.\-Shallow\-Copy (vtk\-Data\-Object src)} -\/ Shallow and Deep copy.  
\item {\ttfamily obj.\-Deep\-Copy (vtk\-Data\-Object src)} -\/ Shallow and Deep copy.  
\item {\ttfamily int = obj.\-Get\-Extent\-Type ()} -\/ Structured extent. The extent type is a 3\-D extent  
\item {\ttfamily obj.\-Crop ()} -\/ Reallocates and copies to set the Extent to the Update\-Extent. This is used internally when the exact extent is requested, and the source generated more than the update extent.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkrectilineargridalgorithm}{}\section{vtk\-Rectilinear\-Grid\-Algorithm}\label{vtkfiltering_vtkrectilineargridalgorithm}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
To create an instance of class vtk\-Rectilinear\-Grid\-Algorithm, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkRectilinearGridAlgorithm
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Rectilinear\-Grid\-Algorithm has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Rectilinear\-Grid\-Algorithm class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Rectilinear\-Grid\-Algorithm = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Rectilinear\-Grid\-Algorithm = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Rectilinear\-Grid = obj.\-Get\-Output ()} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Rectilinear\-Grid = obj.\-Get\-Output (int )} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily obj.\-Set\-Output (vtk\-Data\-Object d)} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Input ()}  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Input (int port)}  
\item {\ttfamily vtk\-Rectilinear\-Grid = obj.\-Get\-Rectilinear\-Grid\-Input (int port)}  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Object )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Set\-Input (int , vtk\-Data\-Object )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Add\-Input (vtk\-Data\-Object )} -\/ Add an input of this algorithm. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Add\-Input\-Connection(). See Set\-Input() for details.  
\item {\ttfamily obj.\-Add\-Input (int , vtk\-Data\-Object )} -\/ Add an input of this algorithm. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Add\-Input\-Connection(). See Set\-Input() for details.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkrectilineargridsource}{}\section{vtk\-Rectilinear\-Grid\-Source}\label{vtkfiltering_vtkrectilineargridsource}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Rectilinear\-Grid\-Source is an abstract class whose subclasses generate rectilinear grid data.

To create an instance of class vtk\-Rectilinear\-Grid\-Source, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkRectilinearGridSource
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Rectilinear\-Grid\-Source has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Rectilinear\-Grid\-Source class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Rectilinear\-Grid\-Source = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Rectilinear\-Grid\-Source = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Rectilinear\-Grid = obj.\-Get\-Output ()} -\/ Get the output of this source.  
\item {\ttfamily vtk\-Rectilinear\-Grid = obj.\-Get\-Output (int idx)} -\/ Get the output of this source.  
\item {\ttfamily obj.\-Set\-Output (vtk\-Rectilinear\-Grid output)} -\/ Get the output of this source.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkrectilineargridtopolydatafilter}{}\section{vtk\-Rectilinear\-Grid\-To\-Poly\-Data\-Filter}\label{vtkfiltering_vtkrectilineargridtopolydatafilter}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Rectilinear\-Grid\-To\-Poly\-Data\-Filter is a filter whose subclasses take as input rectilinear grid datasets and generate polygonal data on output.

To create an instance of class vtk\-Rectilinear\-Grid\-To\-Poly\-Data\-Filter, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkRectilinearGridToPolyDataFilter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Rectilinear\-Grid\-To\-Poly\-Data\-Filter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Rectilinear\-Grid\-To\-Poly\-Data\-Filter class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Rectilinear\-Grid\-To\-Poly\-Data\-Filter = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Rectilinear\-Grid\-To\-Poly\-Data\-Filter = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Input (vtk\-Rectilinear\-Grid input)} -\/ Set / get the input Grid or filter.  
\item {\ttfamily vtk\-Rectilinear\-Grid = obj.\-Get\-Input ()} -\/ Set / get the input Grid or filter.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkscalartree}{}\section{vtk\-Scalar\-Tree}\label{vtkfiltering_vtkscalartree}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Scalar\-Tree is an abstract class that defines the A\-P\-I to concrete scalar tree subclasses. A scalar tree is a data structure that organizes data according to its scalar value. This allows rapid access to data for those algorithms that access the data based on scalar value. For example, isocontouring operates on cells based on the scalar (isocontour) value.

To use subclasses of this class, you must specify a dataset to operate on, and then specify a scalar value in the Init\-Traversal() method. Then calls to Get\-Next\-Cell() return cells whose scalar data contains the scalar value specified.

To create an instance of class vtk\-Scalar\-Tree, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkScalarTree
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Scalar\-Tree has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Scalar\-Tree class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Scalar\-Tree = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Scalar\-Tree = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Data\-Set (vtk\-Data\-Set )} -\/ Build the tree from the points/cells defining this dataset.  
\item {\ttfamily vtk\-Data\-Set = obj.\-Get\-Data\-Set ()} -\/ Build the tree from the points/cells defining this dataset.  
\item {\ttfamily obj.\-Build\-Tree ()} -\/ Construct the scalar tree from the dataset provided. Checks build times and modified time from input and reconstructs the tree if necessary.  
\item {\ttfamily obj.\-Initialize ()} -\/ Initialize locator. Frees memory and resets object as appropriate.  
\item {\ttfamily obj.\-Init\-Traversal (double scalar\-Value)} -\/ Begin to traverse the cells based on a scalar value. Returned cells will have scalar values that span the scalar value specified.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkselection}{}\section{vtk\-Selection}\label{vtkfiltering_vtkselection}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
To create an instance of class vtk\-Selection, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkSelection
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Selection has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Selection class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Selection = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Selection = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Initialize ()} -\/ Restore data object to initial state,  
\item {\ttfamily int = obj.\-Get\-Data\-Object\-Type ()} -\/ Returns the number of nodes in this selection. Each node contains information about part of the selection.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Nodes ()} -\/ Returns the number of nodes in this selection. Each node contains information about part of the selection.  
\item {\ttfamily vtk\-Selection\-Node = obj.\-Get\-Node (int idx)} -\/ Returns a node given it's index. Performs bound checking and will return 0 if out-\/of-\/bounds.  
\item {\ttfamily obj.\-Add\-Node (vtk\-Selection\-Node )} -\/ Adds a selection node.  
\item {\ttfamily obj.\-Remove\-Node (int idx)} -\/ Removes a selection node.  
\item {\ttfamily obj.\-Remove\-Node (vtk\-Selection\-Node )} -\/ Removes a selection node.  
\item {\ttfamily obj.\-Remove\-All\-Nodes ()} -\/ Removes a selection node.  
\item {\ttfamily obj.\-Deep\-Copy (vtk\-Data\-Object src)} -\/ Copy selection nodes of the input.  
\item {\ttfamily obj.\-Shallow\-Copy (vtk\-Data\-Object src)} -\/ Copy selection nodes of the input. This is a shallow copy\-: selection lists and pointers in the properties are passed by reference.  
\item {\ttfamily obj.\-Union (vtk\-Selection selection)} -\/ Union this selection with the specified selection. Attempts to reuse selection nodes in this selection if properties match exactly. Otherwise, creates new selection nodes.  
\item {\ttfamily obj.\-Union (vtk\-Selection\-Node node)} -\/ Union this selection with the specified selection node. Attempts to reuse a selection node in this selection if properties match exactly. Otherwise, creates a new selection node.  
\item {\ttfamily long = obj.\-Get\-M\-Time ()} -\/ Return the M\-Time taking into account changes to the properties  
\item {\ttfamily obj.\-Dump ()} -\/ Dumps the contents of the selection, giving basic information only.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkselectionalgorithm}{}\section{vtk\-Selection\-Algorithm}\label{vtkfiltering_vtkselectionalgorithm}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Selection\-Algorithm is a convenience class to make writing algorithms easier. It is also designed to help transition old algorithms to the new pipeline edgehitecture. There are some assumptions and defaults made by this class you should be aware of. This class defaults such that your filter will have one input port and one output port. If that is not the case simply change it with Set\-Number\-Of\-Input\-Ports etc. See this class constructor for the default. This class also provides a Fill\-Input\-Port\-Info method that by default says that all inputs will be Selection. If that isn't the case then please override this method in your subclass. This class breaks out the downstream requests into separate functions such as Execute\-Data and Execute\-Information. For new algorithms you should implement Request\-Data( request, input\-Vec, output\-Vec) but for older filters there is a default implementation that calls the old Execute\-Data(output) signature. For even older filters that don't implement Execute\-Data the default implementation calls the even older Execute() signature.

.S\-E\-C\-T\-I\-O\-N Thanks Thanks to Patricia Crossno, Ken Moreland, Andrew Wilson and Brian Wylie from Sandia National Laboratories for their help in developing this class.

To create an instance of class vtk\-Selection\-Algorithm, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkSelectionAlgorithm
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Selection\-Algorithm has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Selection\-Algorithm class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Selection\-Algorithm = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Selection\-Algorithm = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Selection = obj.\-Get\-Output ()} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Selection = obj.\-Get\-Output (int index)} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Object obj)} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Set\-Input (int index, vtk\-Data\-Object obj)} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkselectionnode}{}\section{vtk\-Selection\-Node}\label{vtkfiltering_vtkselectionnode}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
To create an instance of class vtk\-Selection\-Node, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkSelectionNode
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Selection\-Node has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Selection\-Node class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Selection\-Node = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Selection\-Node = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Initialize ()} -\/ Restore data object to initial state,  
\item {\ttfamily obj.\-Set\-Selection\-List (vtk\-Abstract\-Array )} -\/ Sets the selection list.  
\item {\ttfamily vtk\-Abstract\-Array = obj.\-Get\-Selection\-List ()} -\/ Sets the selection list.  
\item {\ttfamily obj.\-Set\-Selection\-Data (vtk\-Data\-Set\-Attributes data)} -\/ Sets the selection table.  
\item {\ttfamily vtk\-Data\-Set\-Attributes = obj.\-Get\-Selection\-Data ()} -\/ Sets the selection table.  
\item {\ttfamily vtk\-Information = obj.\-Get\-Properties ()} -\/ Returns the property map.  
\item {\ttfamily obj.\-Deep\-Copy (vtk\-Selection\-Node src)} -\/ Copy properties, selection list and children of the input.  
\item {\ttfamily obj.\-Shallow\-Copy (vtk\-Selection\-Node src)} -\/ Copy properties, selection list and children of the input. This is a shallow copy\-: selection lists and pointers in the properties are passed by reference.  
\item {\ttfamily long = obj.\-Get\-M\-Time ()} -\/ Return the M\-Time taking into account changes to the properties  
\item {\ttfamily obj.\-Set\-Content\-Type (int type)} -\/ Get or set the content type of the selection. This is the same as setting the C\-O\-N\-T\-E\-N\-T\-\_\-\-T\-Y\-P\-E() key on the property.  
\item {\ttfamily int = obj.\-Get\-Content\-Type ()} -\/ Get or set the content type of the selection. This is the same as setting the C\-O\-N\-T\-E\-N\-T\-\_\-\-T\-Y\-P\-E() key on the property.  
\item {\ttfamily obj.\-Set\-Field\-Type (int type)} -\/ Get or set the field type of the selection. This is the same as setting the F\-I\-E\-L\-D\-\_\-\-T\-Y\-P\-E() key on the property.  
\item {\ttfamily int = obj.\-Get\-Field\-Type ()} -\/ Get or set the field type of the selection. This is the same as setting the F\-I\-E\-L\-D\-\_\-\-T\-Y\-P\-E() key on the property.  
\item {\ttfamily obj.\-Set\-Selected\-Prop (vtk\-Prop prop)} -\/ Get or set the prop of the selection. This is the same as setting the P\-R\-O\-P() key on the property.  
\item {\ttfamily vtk\-Prop = obj.\-Get\-Selected\-Prop ()} -\/ Get or set the prop of the selection. This is the same as setting the P\-R\-O\-P() key on the property.  
\item {\ttfamily obj.\-Union\-Selection\-List (vtk\-Selection\-Node other)} -\/ Merges the selection list between self and the other. Assumes that both has identical properties.  
\item {\ttfamily bool = obj.\-Equal\-Properties (vtk\-Selection\-Node other, bool fullcomparetrue)} -\/ Compares Properties of self and other to ensure that they are exactly same.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtksimplecelltessellator}{}\section{vtk\-Simple\-Cell\-Tessellator}\label{vtkfiltering_vtksimplecelltessellator}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Simple\-Cell\-Tessellator is a helper class to perform adaptive tessellation of particular cell topologies. The major purpose for this class is to transform higher-\/order cell types (e.\-g., higher-\/order finite elements) into linear cells that can then be easily visualized by V\-T\-K. This class works in conjunction with the vtk\-Generic\-Data\-Set and vtk\-Generic\-Adaptor\-Cell classes.

This algorithm is based on edge subdivision. An error metric along each edge is evaluated, and if the error is greater than some tolerance, the edge is subdivided (as well as all connected 2\-D and 3\-D cells). The process repeats until the error metric is satisfied. Since the algorithm is based on edge subdivision it inherently avoid T-\/junctions.

A significant issue addressed by this algorithm is to insure face compatibility across neigboring cells. That is, diagonals due to face triangulation must match to insure that the mesh is compatible. The algorithm employs a precomputed table to accelerate the tessellation process. The table was generated with the help of vtk\-Ordered\-Triangulator the basic idea is that the choice of diagonal is made only by considering the relative value of the point ids.

To create an instance of class vtk\-Simple\-Cell\-Tessellator, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkSimpleCellTessellator
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Simple\-Cell\-Tessellator has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Simple\-Cell\-Tessellator class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Simple\-Cell\-Tessellator = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Simple\-Cell\-Tessellator = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Generic\-Adaptor\-Cell = obj.\-Get\-Generic\-Cell ()} -\/ Get the higher order cell in order to access the evaluation function.  
\item {\ttfamily obj.\-Tessellate\-Face (vtk\-Generic\-Adaptor\-Cell cell, vtk\-Generic\-Attribute\-Collection att, vtk\-Id\-Type index, vtk\-Double\-Array points, vtk\-Cell\-Array cell\-Array, vtk\-Point\-Data internal\-Pd)} -\/ Tessellate a face of a 3\-D `cell'. The face is specified by the index value. The result is a set of smaller linear triangles in `cell\-Array' with `points' and point data `internal\-Pd'. \begin{DoxyPrecond}{Precondition}
cell\-\_\-exists\-: cell!=0 

valid\-\_\-dimension\-: cell-\/$>$Get\-Dimension()==3 

valid\-\_\-index\-\_\-range\-: (index$>$=0) \&\& (index$<$cell-\/$>$Get\-Number\-Of\-Boundaries(2)) 

att\-\_\-exists\-: att!=0 

points\-\_\-exists\-: points!=0 

cell\-Array\-\_\-exists\-: cell\-Array!=0 

internal\-Pd\-\_\-exists\-: internal\-Pd!=0  
\end{DoxyPrecond}

\item {\ttfamily obj.\-Tessellate (vtk\-Generic\-Adaptor\-Cell cell, vtk\-Generic\-Attribute\-Collection att, vtk\-Double\-Array points, vtk\-Cell\-Array cell\-Array, vtk\-Point\-Data internal\-Pd)} -\/ Tessellate a 3\-D `cell'. The result is a set of smaller linear tetrahedra in `cell\-Array' with `points' and point data `internal\-Pd'. \begin{DoxyPrecond}{Precondition}
cell\-\_\-exists\-: cell!=0 

valid\-\_\-dimension\-: cell-\/$>$Get\-Dimension()==3 

att\-\_\-exists\-: att!=0 

points\-\_\-exists\-: points!=0 

cell\-Array\-\_\-exists\-: cell\-Array!=0 

internal\-Pd\-\_\-exists\-: internal\-Pd!=0  
\end{DoxyPrecond}

\item {\ttfamily obj.\-Triangulate (vtk\-Generic\-Adaptor\-Cell cell, vtk\-Generic\-Attribute\-Collection att, vtk\-Double\-Array points, vtk\-Cell\-Array cell\-Array, vtk\-Point\-Data internal\-Pd)} -\/ Triangulate a 2\-D `cell'. The result is a set of smaller linear triangles in `cell\-Array' with `points' and point data `internal\-Pd'. \begin{DoxyPrecond}{Precondition}
cell\-\_\-exists\-: cell!=0 

valid\-\_\-dimension\-: cell-\/$>$Get\-Dimension()==2 

att\-\_\-exists\-: att!=0 

points\-\_\-exists\-: points!=0 

cell\-Array\-\_\-exists\-: cell\-Array!=0 

internal\-Pd\-\_\-exists\-: internal\-Pd!=0  
\end{DoxyPrecond}

\item {\ttfamily obj.\-Reset ()} -\/ Reset the output for repeated use of this class.  
\item {\ttfamily obj.\-Initialize (vtk\-Generic\-Data\-Set ds)} -\/ Initialize the tessellator with a data set `ds'.  
\item {\ttfamily int = obj.\-Get\-Fixed\-Subdivisions ()} -\/ Return the number of fixed subdivisions. It is used to prevent from infinite loop in degenerated cases. For order 3 or higher, if the inflection point is exactly on the mid-\/point, error metric will not detect that a subdivision is required. 0 means no fixed subdivision\-: there will be only adaptive subdivisions.

The algorithm first performs `\-Get\-Fixed\-Subdivisions' non adaptive subdivisions followed by at most `\-Get\-Max\-Adaptive\-Subdivisions' adaptive subdivisions. Hence, there are at most `\-Get\-Max\-Subdivision\-Level' subdivisions. \begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$=0 \&\& result$<$=Get\-Max\-Subdivision\-Level()  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Get\-Max\-Subdivision\-Level ()} -\/ Return the maximum level of subdivision. It is used to prevent from infinite loop in degenerated cases. For order 3 or higher, if the inflection point is exactly on the mid-\/point, error metric will not detect that a subdivision is required. 0 means no subdivision, neither fixed nor adaptive. \begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$=Get\-Fixed\-Subdivisions()  
\end{DoxyPostcond}

\item {\ttfamily int = obj.\-Get\-Max\-Adaptive\-Subdivisions ()} -\/ Return the maximum number of adaptive subdivisions. \begin{DoxyPostcond}{Postcondition}
valid\-\_\-result\-: result==Get\-Max\-Subdivision\-Level()-\/\-Get\-Fixed\-Subdivisions()  
\end{DoxyPostcond}

\item {\ttfamily obj.\-Set\-Fixed\-Subdivisions (int level)} -\/ Set the number of fixed subdivisions. See Get\-Fixed\-Subdivisions() for more explanations. \begin{DoxyPrecond}{Precondition}
positive\-\_\-level\-: level$>$=0 \&\& level$<$=Get\-Max\-Subdivision\-Level() 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
is\-\_\-set\-: Get\-Fixed\-Subdivisions()==level  
\end{DoxyPostcond}

\item {\ttfamily obj.\-Set\-Max\-Subdivision\-Level (int level)} -\/ Set the maximum level of subdivision. See Get\-Max\-Subdivision\-Level() for more explanations. \begin{DoxyPrecond}{Precondition}
positive\-\_\-level\-: level$>$=Get\-Fixed\-Subdivisions() 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
is\-\_\-set\-: level==Get\-Max\-Subdivision\-Level()  
\end{DoxyPostcond}

\item {\ttfamily obj.\-Set\-Subdivision\-Levels (int fixed, int max\-Level)} -\/ Set both the number of fixed subdivisions and the maximum level of subdivisions. See Get\-Fixed\-Subdivisions(), Get\-Max\-Subdivision\-Level() and Get\-Max\-Adaptive\-Subdivisions() for more explanations. \begin{DoxyPrecond}{Precondition}
positive\-\_\-fixed\-: fixed$>$=0 

valid\-\_\-range\-: fixed$<$=max\-Level 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
fixed\-\_\-is\-\_\-set\-: fixed==Get\-Fixed\-Subdivisions() 

max\-Level\-\_\-is\-\_\-set\-: max\-Level==Get\-Max\-Subdivision\-Level()  
\end{DoxyPostcond}

\end{DoxyItemize}\hypertarget{vtkfiltering_vtksimpleimagetoimagefilter}{}\section{vtk\-Simple\-Image\-To\-Image\-Filter}\label{vtkfiltering_vtksimpleimagetoimagefilter}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Simple\-Image\-To\-Image\-Filter is a filter which aims to avoid much of the complexity associated with vtk\-Image\-Algorithm (i.\-e. support for pieces, multi-\/threaded operation). If you need to write a simple image-\/image filter which operates on the whole input, use this as the superclass. The subclass has to provide only an execute method which takes input and output as arguments. Memory allocation is handled in vtk\-Simple\-Image\-To\-Image\-Filter. Also, you are guaranteed to have a valid input in the Execute(input, output) method. By default, this filter requests it's input's whole extent and copies the input's information (spacing, whole extent etc...) to the output. If the output's setup is different (for example, if it performs some sort of sub-\/sampling), Execute\-Information has to be overwritten. As an example of how this can be done, you can look at vtk\-Image\-Shrink3\-D\-::\-Execute\-Information. For a complete example which uses templates to support generic data types, see vtk\-Simple\-Image\-To\-Image\-Filter.

To create an instance of class vtk\-Simple\-Image\-To\-Image\-Filter, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkSimpleImageToImageFilter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Simple\-Image\-To\-Image\-Filter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Simple\-Image\-To\-Image\-Filter class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Simple\-Image\-To\-Image\-Filter = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Simple\-Image\-To\-Image\-Filter = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtksimplescalartree}{}\section{vtk\-Simple\-Scalar\-Tree}\label{vtkfiltering_vtksimplescalartree}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Simple\-Scalar\-Tree creates a pointerless binary tree that helps search for cells that lie within a particular scalar range. This object is used to accelerate some contouring (and other scalar-\/based techniques).

The tree consists of an array of (min,max) scalar range pairs per node in the tree. The (min,max) range is determined from looking at the range of the children of the tree node. If the node is a leaf, then the range is determined by scanning the range of scalar data in n cells in the dataset. The n cells are determined by arbitrary selecting cell ids from id(i) to id(i+n), and where n is specified using the Branching\-Factor ivar. Note that leaf node i=0 contains the scalar range computed from cell ids (0,n-\/1); leaf node i=1 contains the range from cell ids (n,2n-\/1); and so on. The implication is that there are no direct lists of cell ids per leaf node, instead the cell ids are implicitly known.

To create an instance of class vtk\-Simple\-Scalar\-Tree, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkSimpleScalarTree
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Simple\-Scalar\-Tree has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Simple\-Scalar\-Tree class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()} -\/ Standard type related macros and Print\-Self() method.  
\item {\ttfamily int = obj.\-Is\-A (string name)} -\/ Standard type related macros and Print\-Self() method.  
\item {\ttfamily vtk\-Simple\-Scalar\-Tree = obj.\-New\-Instance ()} -\/ Standard type related macros and Print\-Self() method.  
\item {\ttfamily vtk\-Simple\-Scalar\-Tree = obj.\-Safe\-Down\-Cast (vtk\-Object o)} -\/ Standard type related macros and Print\-Self() method.  
\item {\ttfamily obj.\-Set\-Branching\-Factor (int )} -\/ Set the branching factor for the tree. This is the number of children per tree node. Smaller values (minimum is 2) mean deeper trees and more memory overhead. Larger values mean shallower trees, less memory usage, but worse performance.  
\item {\ttfamily int = obj.\-Get\-Branching\-Factor\-Min\-Value ()} -\/ Set the branching factor for the tree. This is the number of children per tree node. Smaller values (minimum is 2) mean deeper trees and more memory overhead. Larger values mean shallower trees, less memory usage, but worse performance.  
\item {\ttfamily int = obj.\-Get\-Branching\-Factor\-Max\-Value ()} -\/ Set the branching factor for the tree. This is the number of children per tree node. Smaller values (minimum is 2) mean deeper trees and more memory overhead. Larger values mean shallower trees, less memory usage, but worse performance.  
\item {\ttfamily int = obj.\-Get\-Branching\-Factor ()} -\/ Set the branching factor for the tree. This is the number of children per tree node. Smaller values (minimum is 2) mean deeper trees and more memory overhead. Larger values mean shallower trees, less memory usage, but worse performance.  
\item {\ttfamily int = obj.\-Get\-Level ()} -\/ Get the level of the scalar tree. This value may change each time the scalar tree is built and the branching factor changes.  
\item {\ttfamily obj.\-Set\-Max\-Level (int )} -\/ Set the maximum allowable level for the tree.  
\item {\ttfamily int = obj.\-Get\-Max\-Level\-Min\-Value ()} -\/ Set the maximum allowable level for the tree.  
\item {\ttfamily int = obj.\-Get\-Max\-Level\-Max\-Value ()} -\/ Set the maximum allowable level for the tree.  
\item {\ttfamily int = obj.\-Get\-Max\-Level ()} -\/ Set the maximum allowable level for the tree.  
\item {\ttfamily obj.\-Build\-Tree ()} -\/ Construct the scalar tree from the dataset provided. Checks build times and modified time from input and reconstructs the tree if necessary.  
\item {\ttfamily obj.\-Initialize ()} -\/ Initialize locator. Frees memory and resets object as appropriate.  
\item {\ttfamily obj.\-Init\-Traversal (double scalar\-Value)} -\/ Begin to traverse the cells based on a scalar value. Returned cells will have scalar values that span the scalar value specified.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtksmootherrormetric}{}\section{vtk\-Smooth\-Error\-Metric}\label{vtkfiltering_vtksmootherrormetric}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
It is a concrete error metric, based on a geometric criterium\-: a max angle between the chord passing through the midpoint and one of the endpoints and the other chord passing through the midpoint and the other endpoint of the edge. It is related to the flatness of an edge.

To create an instance of class vtk\-Smooth\-Error\-Metric, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkSmoothErrorMetric
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Smooth\-Error\-Metric has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Smooth\-Error\-Metric class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()} -\/ Standard V\-T\-K type and error macros.  
\item {\ttfamily int = obj.\-Is\-A (string name)} -\/ Standard V\-T\-K type and error macros.  
\item {\ttfamily vtk\-Smooth\-Error\-Metric = obj.\-New\-Instance ()} -\/ Standard V\-T\-K type and error macros.  
\item {\ttfamily vtk\-Smooth\-Error\-Metric = obj.\-Safe\-Down\-Cast (vtk\-Object o)} -\/ Standard V\-T\-K type and error macros.  
\item {\ttfamily double = obj.\-Get\-Angle\-Tolerance ()} -\/ Return the flatness threshold. \begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$90 \&\& result$<$180  
\end{DoxyPostcond}

\item {\ttfamily obj.\-Set\-Angle\-Tolerance (double value)} -\/ Set the flatness threshold with an angle in degrees. Internally compute the cosine. value is supposed to be in \mbox{]}90,180\mbox{[}, if not it is clamped in \mbox{[}90.\-1,179.\-9\mbox{]}. For instance 178 will give better result than 150.  
\item {\ttfamily int = obj.\-Requires\-Edge\-Subdivision (double left\-Point, double mid\-Point, double right\-Point, double alpha)} -\/ Does the edge need to be subdivided according to the cosine between the two chords passing through the mid-\/point and the endpoints? The edge is defined by its `left\-Point' and its `right\-Point'. `left\-Point', `mid\-Point' and `right\-Point' have to be initialized before calling Requires\-Edge\-Subdivision(). Their format is global coordinates, parametric coordinates and point centered attributes\-: xyx rst abc de... `alpha' is the normalized abscissa of the midpoint along the edge. (close to 0 means close to the left point, close to 1 means close to the right point) \begin{DoxyPrecond}{Precondition}
left\-Point\-\_\-exists\-: left\-Point!=0 

mid\-Point\-\_\-exists\-: mid\-Point!=0 

right\-Point\-\_\-exists\-: right\-Point!=0 

clamped\-\_\-alpha\-: alpha$>$0 \&\& alpha$<$1 

valid\-\_\-size\-: sizeof(left\-Point)=sizeof(mid\-Point)=sizeof(right\-Point) =Get\-Attribute\-Collection()-\/$>$Get\-Number\-Of\-Point\-Centered\-Components()+6  
\end{DoxyPrecond}

\item {\ttfamily double = obj.\-Get\-Error (double left\-Point, double mid\-Point, double right\-Point, double alpha)} -\/ Return the error at the mid-\/point. It will return an error relative to the bounding box size if Get\-Relative() is true, a square absolute error otherwise. See Requires\-Edge\-Subdivision() for a description of the arguments. \begin{DoxyPrecond}{Precondition}
left\-Point\-\_\-exists\-: left\-Point!=0 

mid\-Point\-\_\-exists\-: mid\-Point!=0 

right\-Point\-\_\-exists\-: right\-Point!=0 

clamped\-\_\-alpha\-: alpha$>$0 \&\& alpha$<$1 

valid\-\_\-size\-: sizeof(left\-Point)=sizeof(mid\-Point)=sizeof(right\-Point) =Get\-Attribute\-Collection()-\/$>$Get\-Number\-Of\-Point\-Centered\-Components()+6 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$=0  
\end{DoxyPostcond}

\end{DoxyItemize}\hypertarget{vtkfiltering_vtksource}{}\section{vtk\-Source}\label{vtkfiltering_vtksource}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Source is an abstract object that specifies behavior and interface of source objects. Source objects are objects that begin visualization pipeline. Sources include readers (read data from file or communications port) and procedural sources (generate data programmatically). vtk\-Source objects are also objects that generate output data. In this sense vtk\-Source is used as a superclass to vtk\-Filter.

Concrete subclasses of vtk\-Source must define Update() and Execute() methods. The public method Update() invokes network execution and will bring the network up-\/to-\/date. The protected Execute() method actually does the work of data creation/generation. The difference between the two methods is that Update() implements input consistency checks and modified time comparisons and then invokes the Execute() which is an implementation of a particular algorithm.

An important feature of subclasses of vtk\-Source is that it is possible to control the memory-\/management model (i.\-e., retain output versus delete output data). If enabled the Release\-Data\-Flag enables the deletion of the output data once the downstream process object finishes processing the data (please see text).

To create an instance of class vtk\-Source, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkSource
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Source has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Source class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Source = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Source = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Update ()} -\/ Bring object up-\/to-\/date before execution. Update() checks modified time against last execution time, and re-\/executes object if necessary.  
\item {\ttfamily obj.\-Update\-Whole\-Extent ()} -\/ Like update, but make sure the update extent is the whole extent in the output.  
\item {\ttfamily obj.\-Update\-Information ()} -\/ Updates any global information about the data (like spacing for images)  
\item {\ttfamily obj.\-Propagate\-Update\-Extent (vtk\-Data\-Object output)} -\/ W\-A\-R\-N\-I\-N\-G\-: I\-N\-T\-E\-R\-N\-A\-L M\-E\-T\-H\-O\-D -\/ N\-O\-T F\-O\-R G\-E\-N\-E\-R\-A\-L U\-S\-E. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S P\-A\-R\-T O\-F T\-H\-E P\-I\-P\-E\-L\-I\-N\-E U\-P\-D\-A\-T\-E F\-U\-N\-C\-T\-I\-O\-N\-A\-L\-I\-T\-Y. The update extent for this object is propagated up the pipeline. This propagation may early terminate based on the Pipeline\-M\-Time.  
\item {\ttfamily obj.\-Trigger\-Asynchronous\-Update ()} -\/ W\-A\-R\-N\-I\-N\-G\-: I\-N\-T\-E\-R\-N\-A\-L M\-E\-T\-H\-O\-D -\/ N\-O\-T F\-O\-R G\-E\-N\-E\-R\-A\-L U\-S\-E. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S P\-A\-R\-T O\-F T\-H\-E P\-I\-P\-E\-L\-I\-N\-E U\-P\-D\-A\-T\-E F\-U\-N\-C\-T\-I\-O\-N\-A\-L\-I\-T\-Y. Propagate back up the pipeline for ports and trigger the update on the other side of the port to allow for asynchronous parallel processing in the pipeline. This propagation may early terminate based on the Pipeline\-M\-Time.  
\item {\ttfamily obj.\-Update\-Data (vtk\-Data\-Object output)} -\/ W\-A\-R\-N\-I\-N\-G\-: I\-N\-T\-E\-R\-N\-A\-L M\-E\-T\-H\-O\-D -\/ N\-O\-T F\-O\-R G\-E\-N\-E\-R\-A\-L U\-S\-E. T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S P\-A\-R\-T O\-F T\-H\-E P\-I\-P\-E\-L\-I\-N\-E U\-P\-D\-A\-T\-E F\-U\-N\-C\-T\-I\-O\-N\-A\-L\-I\-T\-Y. Propagate the update back up the pipeline, and perform the actual work of updating on the way down. When the propagate arrives at a port, block and wait for the asynchronous update to finish on the other side. This propagation may early terminate based on the Pipeline\-M\-Time.  
\item {\ttfamily obj.\-Compute\-Input\-Update\-Extents (vtk\-Data\-Object output)} -\/ What is the input update extent that is required to produce the desired output? By default, the whole input is always required but this is overridden in many subclasses.  
\item {\ttfamily obj.\-Set\-Release\-Data\-Flag (int )} -\/ Turn on/off flag to control whether this object's data is released after being used by a source.  
\item {\ttfamily int = obj.\-Get\-Release\-Data\-Flag ()} -\/ Turn on/off flag to control whether this object's data is released after being used by a source.  
\item {\ttfamily obj.\-Release\-Data\-Flag\-On ()} -\/ Turn on/off flag to control whether this object's data is released after being used by a source.  
\item {\ttfamily obj.\-Release\-Data\-Flag\-Off ()} -\/ Turn on/off flag to control whether this object's data is released after being used by a source.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Outputs ()} -\/ Return an array with all the inputs of this process object. This is useful for tracing back in the pipeline to construct graphs etc.  
\item {\ttfamily obj.\-Un\-Register\-All\-Outputs (void )} -\/ Release/disconnect all outputs of this source. This is intended to be called prior to Delete() if the user is concerned about outputs holding on to the filter/source.  
\item {\ttfamily int = obj.\-Get\-Output\-Index (vtk\-Data\-Object out)} -\/ Return what index output the passed in output is, return -\/1 if it does not match any of the outputs  
\item {\ttfamily obj.\-Set\-Executive (vtk\-Executive executive)} -\/ Set this algorithm's executive. This algorithm is removed from any executive to which it has previously been assigned and then assigned to the given executive.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtksphere}{}\section{vtk\-Sphere}\label{vtkfiltering_vtksphere}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Sphere computes the implicit function and/or gradient for a sphere. vtk\-Sphere is a concrete implementation of vtk\-Implicit\-Function. Additional methods are available for sphere-\/related computations, such as computing bounding spheres for a set of points, or set of spheres.

To create an instance of class vtk\-Sphere, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkSphere
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Sphere has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Sphere class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Sphere = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Sphere = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily double = obj.\-Evaluate\-Function (double x\mbox{[}3\mbox{]})}  
\item {\ttfamily double = obj.\-Evaluate\-Function (double x, double y, double z)}  
\item {\ttfamily obj.\-Evaluate\-Gradient (double x\mbox{[}3\mbox{]}, double n\mbox{[}3\mbox{]})}  
\item {\ttfamily obj.\-Set\-Radius (double )} -\/ Set / get the radius of the sphere.  
\item {\ttfamily double = obj.\-Get\-Radius ()} -\/ Set / get the radius of the sphere.  
\item {\ttfamily obj.\-Set\-Center (double , double , double )} -\/ Set / get the center of the sphere.  
\item {\ttfamily obj.\-Set\-Center (double a\mbox{[}3\mbox{]})} -\/ Set / get the center of the sphere.  
\item {\ttfamily double = obj. Get\-Center ()} -\/ Set / get the center of the sphere.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkspline}{}\section{vtk\-Spline}\label{vtkfiltering_vtkspline}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Spline interpolates a set of data points (i.\-e., interpolation means that the spline passes through the points). vtk\-Spline is an abstract class\-: its subclasses vtk\-Cardinal\-Spline and vtk\-Kochenek\-Spline do the interpolation. Note that this spline maps the 1\-D parametric coordinate t into a single value x. Thus if you want to use the spline to interpolate points (i.\-e. x\mbox{[}3\mbox{]}), you have to create three splines for each of the x-\/y-\/z coordinates. Fortunately, the vtk\-Parametric\-Spline class does this for you.

Typically a spline is used by adding a sequence of parametric coordinate / data (t,x) values followed by use of an evaluation function (e.\-g., vtk\-Cardinal\-Spline\-::\-Evaluate()). Since these splines are 1\-D, a point in this context is an independent / dependent variable pair.

Splines can also be set up to be closed or open. Closed splines continue from the last point to the first point with continuous function and derivative values. (You don't need to duplicate the first point to close the spline, just set Closed\-On.)

This implementation of splines does not use a normalized parametric coordinate. If the spline is open, then the parameter space is (t\-Min $<$= t $<$= t\-Max) where t\-Min and t\-Max are the minimum and maximum parametric values seen when performing Add\-Point(). If the spline is closed, then the parameter space is (t\-Min $<$= t $<$= (t\-Max+1)) where t\-Min and t\-Max are the minimum and maximum parametric values seen when performing Add\-Point(). Note, however, that this behavior can be changed by explicitly setting the Parametric\-Range(t\-Min,t\-Max). If set, the parameter space remains (t\-Min $<$= t $<$= t\-Max), except that additions of data with parametric values outside this range are clamped within this range.

To create an instance of class vtk\-Spline, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkSpline
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Spline has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Spline class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Spline = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Spline = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Parametric\-Range (double t\-Min, double t\-Max)} -\/ Set/\-Get the parametric range. If not set, the range is determined implicitly by keeping track of the (min,max) parameter values for t. If set, the Add\-Point() method will clamp the t value to lie within the specified range.  
\item {\ttfamily obj.\-Set\-Parametric\-Range (double t\-Range\mbox{[}2\mbox{]})} -\/ Set/\-Get the parametric range. If not set, the range is determined implicitly by keeping track of the (min,max) parameter values for t. If set, the Add\-Point() method will clamp the t value to lie within the specified range.  
\item {\ttfamily obj.\-Get\-Parametric\-Range (double t\-Range\mbox{[}2\mbox{]}) const} -\/ Set/\-Get the parametric range. If not set, the range is determined implicitly by keeping track of the (min,max) parameter values for t. If set, the Add\-Point() method will clamp the t value to lie within the specified range.  
\item {\ttfamily obj.\-Set\-Clamp\-Value (int )} -\/ Set/\-Get Clamp\-Value. If On, results of the interpolation will be clamped to the min/max of the input data.  
\item {\ttfamily int = obj.\-Get\-Clamp\-Value ()} -\/ Set/\-Get Clamp\-Value. If On, results of the interpolation will be clamped to the min/max of the input data.  
\item {\ttfamily obj.\-Clamp\-Value\-On ()} -\/ Set/\-Get Clamp\-Value. If On, results of the interpolation will be clamped to the min/max of the input data.  
\item {\ttfamily obj.\-Clamp\-Value\-Off ()} -\/ Set/\-Get Clamp\-Value. If On, results of the interpolation will be clamped to the min/max of the input data.  
\item {\ttfamily obj.\-Compute ()} -\/ Compute the coefficients for the spline.  
\item {\ttfamily double = obj.\-Evaluate (double t)} -\/ Interpolate the value of the spline at parametric location of t.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Points ()} -\/ Return the number of points inserted thus far.  
\item {\ttfamily obj.\-Add\-Point (double t, double x)} -\/ Add a pair of points to be fit with the spline.  
\item {\ttfamily obj.\-Remove\-Point (double t)} -\/ Remove a point from the data to be fit with the spline.  
\item {\ttfamily obj.\-Remove\-All\-Points ()} -\/ Remove all points from the data.  
\item {\ttfamily obj.\-Set\-Closed (int )} -\/ Control whether the spline is open or closed. A closed spline forms a continuous loop\-: the first and last points are the same, and derivatives are continuous.  
\item {\ttfamily int = obj.\-Get\-Closed ()} -\/ Control whether the spline is open or closed. A closed spline forms a continuous loop\-: the first and last points are the same, and derivatives are continuous.  
\item {\ttfamily obj.\-Closed\-On ()} -\/ Control whether the spline is open or closed. A closed spline forms a continuous loop\-: the first and last points are the same, and derivatives are continuous.  
\item {\ttfamily obj.\-Closed\-Off ()} -\/ Control whether the spline is open or closed. A closed spline forms a continuous loop\-: the first and last points are the same, and derivatives are continuous.  
\item {\ttfamily obj.\-Set\-Left\-Constraint (int )} -\/ Set the type of constraint of the left(right) end points. Four constraints are available\-:

0\-: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.

1\-: the first derivative at left(right) most point is set to Left(\-Right)Value.

2\-: the second derivative at left(right) most point is set to Left(\-Right)Value.

3\-: the second derivative at left(right)most points is Left(\-Right)Value times second derivative at first interior point.  
\item {\ttfamily int = obj.\-Get\-Left\-Constraint\-Min\-Value ()} -\/ Set the type of constraint of the left(right) end points. Four constraints are available\-:

0\-: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.

1\-: the first derivative at left(right) most point is set to Left(\-Right)Value.

2\-: the second derivative at left(right) most point is set to Left(\-Right)Value.

3\-: the second derivative at left(right)most points is Left(\-Right)Value times second derivative at first interior point.  
\item {\ttfamily int = obj.\-Get\-Left\-Constraint\-Max\-Value ()} -\/ Set the type of constraint of the left(right) end points. Four constraints are available\-:

0\-: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.

1\-: the first derivative at left(right) most point is set to Left(\-Right)Value.

2\-: the second derivative at left(right) most point is set to Left(\-Right)Value.

3\-: the second derivative at left(right)most points is Left(\-Right)Value times second derivative at first interior point.  
\item {\ttfamily int = obj.\-Get\-Left\-Constraint ()} -\/ Set the type of constraint of the left(right) end points. Four constraints are available\-:

0\-: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.

1\-: the first derivative at left(right) most point is set to Left(\-Right)Value.

2\-: the second derivative at left(right) most point is set to Left(\-Right)Value.

3\-: the second derivative at left(right)most points is Left(\-Right)Value times second derivative at first interior point.  
\item {\ttfamily obj.\-Set\-Right\-Constraint (int )} -\/ Set the type of constraint of the left(right) end points. Four constraints are available\-:

0\-: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.

1\-: the first derivative at left(right) most point is set to Left(\-Right)Value.

2\-: the second derivative at left(right) most point is set to Left(\-Right)Value.

3\-: the second derivative at left(right)most points is Left(\-Right)Value times second derivative at first interior point.  
\item {\ttfamily int = obj.\-Get\-Right\-Constraint\-Min\-Value ()} -\/ Set the type of constraint of the left(right) end points. Four constraints are available\-:

0\-: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.

1\-: the first derivative at left(right) most point is set to Left(\-Right)Value.

2\-: the second derivative at left(right) most point is set to Left(\-Right)Value.

3\-: the second derivative at left(right)most points is Left(\-Right)Value times second derivative at first interior point.  
\item {\ttfamily int = obj.\-Get\-Right\-Constraint\-Max\-Value ()} -\/ Set the type of constraint of the left(right) end points. Four constraints are available\-:

0\-: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.

1\-: the first derivative at left(right) most point is set to Left(\-Right)Value.

2\-: the second derivative at left(right) most point is set to Left(\-Right)Value.

3\-: the second derivative at left(right)most points is Left(\-Right)Value times second derivative at first interior point.  
\item {\ttfamily int = obj.\-Get\-Right\-Constraint ()} -\/ Set the type of constraint of the left(right) end points. Four constraints are available\-:

0\-: the first derivative at left(right) most point is determined from the line defined from the first(last) two points.

1\-: the first derivative at left(right) most point is set to Left(\-Right)Value.

2\-: the second derivative at left(right) most point is set to Left(\-Right)Value.

3\-: the second derivative at left(right)most points is Left(\-Right)Value times second derivative at first interior point.  
\item {\ttfamily obj.\-Set\-Left\-Value (double )} -\/ The values of the derivative on the left and right sides. The value is used only if the left(right) constraint is type 1-\/3.  
\item {\ttfamily double = obj.\-Get\-Left\-Value ()} -\/ The values of the derivative on the left and right sides. The value is used only if the left(right) constraint is type 1-\/3.  
\item {\ttfamily obj.\-Set\-Right\-Value (double )} -\/ The values of the derivative on the left and right sides. The value is used only if the left(right) constraint is type 1-\/3.  
\item {\ttfamily double = obj.\-Get\-Right\-Value ()} -\/ The values of the derivative on the left and right sides. The value is used only if the left(right) constraint is type 1-\/3.  
\item {\ttfamily long = obj.\-Get\-M\-Time ()} -\/ Return the M\-Time also considering the Piecewise function.  
\item {\ttfamily obj.\-Deep\-Copy (vtk\-Spline s)} -\/ Deep copy of spline data.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkstreamingdemanddrivenpipeline}{}\section{vtk\-Streaming\-Demand\-Driven\-Pipeline}\label{vtkfiltering_vtkstreamingdemanddrivenpipeline}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Streaming\-Demand\-Driven\-Pipeline is an executive that supports updating only a portion of the data set in the pipeline. This is the style of pipeline update that is provided by the old-\/style V\-T\-K 4.\-x pipeline. Instead of always updating an entire data set, this executive supports asking for pieces or sub-\/extents.

To create an instance of class vtk\-Streaming\-Demand\-Driven\-Pipeline, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkStreamingDemandDrivenPipeline
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Streaming\-Demand\-Driven\-Pipeline has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Streaming\-Demand\-Driven\-Pipeline class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Streaming\-Demand\-Driven\-Pipeline = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Streaming\-Demand\-Driven\-Pipeline = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Update ()} -\/ Bring the outputs up-\/to-\/date.  
\item {\ttfamily int = obj.\-Update (int port)} -\/ Bring the outputs up-\/to-\/date.  
\item {\ttfamily int = obj.\-Update\-Whole\-Extent ()} -\/ Bring the outputs up-\/to-\/date.  
\item {\ttfamily int = obj.\-Propagate\-Update\-Extent (int output\-Port)} -\/ Propagate the update request from the given output port back through the pipeline. Should be called only when information is up to date.  
\item {\ttfamily int = obj.\-Set\-Maximum\-Number\-Of\-Pieces (int port, int n)} -\/ Set/\-Get the maximum number of pieces that can be requested from the given port. The maximum number of pieces is meta data for unstructured data sets. It gets set by the source during the update information call. A value of -\/1 indicates that there is no maximum.  
\item {\ttfamily int = obj.\-Set\-Maximum\-Number\-Of\-Pieces (vtk\-Information , int n)} -\/ Set/\-Get the maximum number of pieces that can be requested from the given port. The maximum number of pieces is meta data for unstructured data sets. It gets set by the source during the update information call. A value of -\/1 indicates that there is no maximum.  
\item {\ttfamily int = obj.\-Get\-Maximum\-Number\-Of\-Pieces (int port)} -\/ Set/\-Get the maximum number of pieces that can be requested from the given port. The maximum number of pieces is meta data for unstructured data sets. It gets set by the source during the update information call. A value of -\/1 indicates that there is no maximum.  
\item {\ttfamily int = obj.\-Get\-Maximum\-Number\-Of\-Pieces (vtk\-Information )} -\/ Set/\-Get the maximum number of pieces that can be requested from the given port. The maximum number of pieces is meta data for unstructured data sets. It gets set by the source during the update information call. A value of -\/1 indicates that there is no maximum.  
\item {\ttfamily int = obj.\-Set\-Whole\-Extent (vtk\-Information , int extent\mbox{[}6\mbox{]})} -\/ Set/\-Get the whole extent of an output port. The whole extent is meta data for structured data sets. It gets set by the algorithm during the update information pass.  
\item {\ttfamily obj.\-Get\-Whole\-Extent (vtk\-Information , int extent\mbox{[}6\mbox{]})} -\/ Set/\-Get the whole extent of an output port. The whole extent is meta data for structured data sets. It gets set by the algorithm during the update information pass.  
\item {\ttfamily int = obj.\-Set\-Update\-Extent\-To\-Whole\-Extent (int port)} -\/ If the whole input extent is required to generate the requested output extent, this method can be called to set the input update extent to the whole input extent. This method assumes that the whole extent is known (that Update\-Information has been called)  
\item {\ttfamily int = obj.\-Set\-Update\-Extent\-To\-Whole\-Extent (vtk\-Information )} -\/ If the whole input extent is required to generate the requested output extent, this method can be called to set the input update extent to the whole input extent. This method assumes that the whole extent is known (that Update\-Information has been called)  
\item {\ttfamily int = obj.\-Set\-Update\-Extent (int port, int extent\mbox{[}6\mbox{]})} -\/ Get/\-Set the update extent for output ports that use 3\-D extents.  
\item {\ttfamily int = obj.\-Set\-Update\-Extent (vtk\-Information , int extent\mbox{[}6\mbox{]})} -\/ Get/\-Set the update extent for output ports that use 3\-D extents.  
\item {\ttfamily obj.\-Get\-Update\-Extent (vtk\-Information , int extent\mbox{[}6\mbox{]})} -\/ Get/\-Set the update extent for output ports that use 3\-D extents.  
\item {\ttfamily int = obj.\-Set\-Update\-Extent (int port, int piece, int num\-Pieces, int ghost\-Level)} -\/ Set/\-Get the update piece, update number of pieces, and update number of ghost levels for an output port. Similar to update extent in 3\-D.  
\item {\ttfamily int = obj.\-Set\-Update\-Extent (vtk\-Information , int piece, int num\-Pieces, int ghost\-Level)} -\/ Set/\-Get the update piece, update number of pieces, and update number of ghost levels for an output port. Similar to update extent in 3\-D.  
\item {\ttfamily int = obj.\-Set\-Update\-Piece (vtk\-Information , int piece)} -\/ Set/\-Get the update piece, update number of pieces, and update number of ghost levels for an output port. Similar to update extent in 3\-D.  
\item {\ttfamily int = obj.\-Get\-Update\-Piece (vtk\-Information )} -\/ Set/\-Get the update piece, update number of pieces, and update number of ghost levels for an output port. Similar to update extent in 3\-D.  
\item {\ttfamily int = obj.\-Set\-Update\-Number\-Of\-Pieces (vtk\-Information , int n)} -\/ Set/\-Get the update piece, update number of pieces, and update number of ghost levels for an output port. Similar to update extent in 3\-D.  
\item {\ttfamily int = obj.\-Get\-Update\-Number\-Of\-Pieces (vtk\-Information )} -\/ Set/\-Get the update piece, update number of pieces, and update number of ghost levels for an output port. Similar to update extent in 3\-D.  
\item {\ttfamily int = obj.\-Set\-Update\-Ghost\-Level (vtk\-Information , int n)} -\/ Set/\-Get the update piece, update number of pieces, and update number of ghost levels for an output port. Similar to update extent in 3\-D.  
\item {\ttfamily int = obj.\-Get\-Update\-Ghost\-Level (vtk\-Information )} -\/ Set/\-Get the update piece, update number of pieces, and update number of ghost levels for an output port. Similar to update extent in 3\-D.  
\item {\ttfamily int = obj.\-Set\-Update\-Resolution (int port, double r)} -\/ Set/\-Get the update piece, update number of pieces, and update number of ghost levels for an output port. Similar to update extent in 3\-D.  
\item {\ttfamily int = obj.\-Set\-Update\-Resolution (vtk\-Information , double r)} -\/ Set/\-Get the update piece, update number of pieces, and update number of ghost levels for an output port. Similar to update extent in 3\-D.  
\item {\ttfamily double = obj.\-Get\-Update\-Resolution (vtk\-Information )} -\/ Set/\-Get the update piece, update number of pieces, and update number of ghost levels for an output port. Similar to update extent in 3\-D.  
\item {\ttfamily int = obj.\-Set\-Split\-Update\-Extent (int port, int major, int minor, int num\-Pieces, int ghost\-Level)} -\/ Get/\-Set the update extent for output ports that use Temporal Extents  
\item {\ttfamily int = obj.\-Set\-Update\-Time\-Steps (int port, double times, int length)} -\/ Get/\-Set the update extent for output ports that use Temporal Extents  
\item {\ttfamily int = obj.\-Set\-Update\-Time\-Steps (vtk\-Information , double times, int length)} -\/ Get/\-Set the update extent for output ports that use Temporal Extents  
\item {\ttfamily int = obj.\-Set\-Update\-Time\-Step (int port, double time)} -\/ Get/\-Set the update extent for output ports that use Temporal Extents  
\item {\ttfamily int = obj.\-Set\-Request\-Exact\-Extent (int port, int flag)} -\/ This request flag indicates whether the requester can handle more data than requested for the given port. Right now it is used in vtk\-Image\-Data. Image filters can return more data than requested. The the consumer cannot handle this (i.\-e. Data\-Set\-To\-Data\-Set\-Fitler) the image will crop itself. This functionality used to be in Image\-To\-Structured\-Points.  
\item {\ttfamily int = obj.\-Get\-Request\-Exact\-Extent (int port)} -\/ This request flag indicates whether the requester can handle more data than requested for the given port. Right now it is used in vtk\-Image\-Data. Image filters can return more data than requested. The the consumer cannot handle this (i.\-e. Data\-Set\-To\-Data\-Set\-Fitler) the image will crop itself. This functionality used to be in Image\-To\-Structured\-Points.  
\item {\ttfamily int = obj.\-Set\-Extent\-Translator (int port, vtk\-Extent\-Translator translator)} -\/ Get/\-Set the object that will translate pieces into structured extents for an output port.  
\item {\ttfamily int = obj.\-Set\-Extent\-Translator (vtk\-Information , vtk\-Extent\-Translator translator)} -\/ Get/\-Set the object that will translate pieces into structured extents for an output port.  
\item {\ttfamily vtk\-Extent\-Translator = obj.\-Get\-Extent\-Translator (int port)} -\/ Get/\-Set the object that will translate pieces into structured extents for an output port.  
\item {\ttfamily vtk\-Extent\-Translator = obj.\-Get\-Extent\-Translator (vtk\-Information info)} -\/ Get/\-Set the object that will translate pieces into structured extents for an output port.  
\item {\ttfamily int = obj.\-Set\-Whole\-Bounding\-Box (int port, double bb\mbox{[}6\mbox{]})} -\/ Set/\-Get the whole bounding box of an output port data object. The whole whole bounding box is meta data for data sets. It gets set by the algorithm during the update information pass.  
\item {\ttfamily obj.\-Get\-Whole\-Bounding\-Box (int port, double bb\mbox{[}6\mbox{]})} -\/ Set/\-Get the whole bounding box of an output port data object. The whole whole bounding box is meta data for data sets. It gets set by the algorithm during the update information pass.  
\item {\ttfamily int = obj.\-Set\-Piece\-Bounding\-Box (int port, double bb\mbox{[}6\mbox{]})} -\/ Set/\-Get the piece bounding box of an output port data object. The piece bounding box is meta data for data sets. It gets set by the algorithm during the update extent information pass.  
\item {\ttfamily obj.\-Get\-Piece\-Bounding\-Box (int port, double bb\mbox{[}6\mbox{]})} -\/ Set/\-Get the piece bounding box of an output port data object. The piece bounding box is meta data for data sets. It gets set by the algorithm during the update extent information pass.  
\item {\ttfamily double = obj.\-Compute\-Priority ()} -\/ Issues pipeline request to determine and return the priority of the piece described by the current update extent. The priority is a number between 0.\-0 and 1.\-0 with 0 meaning skippable (R\-E\-Q\-U\-E\-S\-T\-\_\-\-D\-A\-T\-A not needed) and 1.\-0 meaning important.  
\item {\ttfamily double = obj.\-Compute\-Priority (int port)} -\/ Issues pipeline request to determine and return the priority of the piece described by the current update extent. The priority is a number between 0.\-0 and 1.\-0 with 0 meaning skippable (R\-E\-Q\-U\-E\-S\-T\-\_\-\-D\-A\-T\-A not needed) and 1.\-0 meaning important.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkstructuredgrid}{}\section{vtk\-Structured\-Grid}\label{vtkfiltering_vtkstructuredgrid}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Structured\-Grid is a data object that is a concrete implementation of vtk\-Data\-Set. vtk\-Structured\-Grid represents a geometric structure that is a topologically regular array of points. The topology is that of a cube that has been subdivided into a regular array of smaller cubes. Each point/cell can be addressed with i-\/j-\/k indices. Examples include finite difference grids.

The order and number of points must match that specified by the dimensions of the grid. The point order increases in i fastest (from 0$<$=i$<$dims\mbox{[}0\mbox{]}), then j (0$<$=j$<$dims\mbox{[}1\mbox{]}), then k (0$<$=k$<$dims\mbox{[}2\mbox{]}) where dims\mbox{[}\mbox{]} are the dimensions of the grid in the i-\/j-\/k topological directions. The number of points is dims\mbox{[}0\mbox{]}$\ast$dims\mbox{[}1\mbox{]}$\ast$dims\mbox{[}2\mbox{]}. The same is true for the cells of the grid. The order and number of cells must match that specified by the dimensions of the grid. The cell order increases in i fastest (from 0$<$=i$<$(dims\mbox{[}0\mbox{]}-\/1)), then j (0$<$=j$<$(dims\mbox{[}1\mbox{]}-\/1)), then k (0$<$=k$<$(dims\mbox{[}2\mbox{]}-\/1)) The number of cells is (dims\mbox{[}0\mbox{]}-\/1)$\ast$(dims\mbox{[}1\mbox{]}-\/1)$\ast$(dims\mbox{[}2\mbox{]}-\/1).

A unusual feature of vtk\-Structured\-Grid is the ability to blank, or \char`\"{}turn-\/off\char`\"{} points and cells in the dataset. This is controlled by defining a \char`\"{}blanking array\char`\"{} whose values (0,1) specify whether a point should be blanked or not.

To create an instance of class vtk\-Structured\-Grid, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkStructuredGrid
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Structured\-Grid has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Structured\-Grid class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Structured\-Grid = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Structured\-Grid = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Data\-Object\-Type ()} -\/ Copy the geometric and topological structure of an input poly data object.  
\item {\ttfamily obj.\-Copy\-Structure (vtk\-Data\-Set ds)} -\/ Copy the geometric and topological structure of an input poly data object.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Points ()} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily double = obj.\-Get\-Point (vtk\-Id\-Type pt\-Id)} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily obj.\-Get\-Point (vtk\-Id\-Type pt\-Id, double p\mbox{[}3\mbox{]})} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Cell (vtk\-Id\-Type cell\-Id)} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily obj.\-Get\-Cell (vtk\-Id\-Type cell\-Id, vtk\-Generic\-Cell cell)} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily obj.\-Get\-Cell\-Bounds (vtk\-Id\-Type cell\-Id, double bounds\mbox{[}6\mbox{]})} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily int = obj.\-Get\-Cell\-Type (vtk\-Id\-Type cell\-Id)} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Cells ()} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily obj.\-Get\-Cell\-Points (vtk\-Id\-Type cell\-Id, vtk\-Id\-List pt\-Ids)} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily obj.\-Get\-Point\-Cells (vtk\-Id\-Type pt\-Id, vtk\-Id\-List cell\-Ids)} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily obj.\-Initialize ()} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily int = obj.\-Get\-Max\-Cell\-Size ()} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily obj.\-Get\-Cell\-Neighbors (vtk\-Id\-Type cell\-Id, vtk\-Id\-List pt\-Ids, vtk\-Id\-List cell\-Ids)} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily obj.\-Get\-Scalar\-Range (double range\mbox{[}2\mbox{]})} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily double = obj.\-Get\-Scalar\-Range ()} -\/ following methods are specific to structured grid  
\item {\ttfamily obj.\-Set\-Dimensions (int i, int j, int k)} -\/ following methods are specific to structured grid  
\item {\ttfamily obj.\-Set\-Dimensions (int dim\mbox{[}3\mbox{]})} -\/ following methods are specific to structured grid  
\item {\ttfamily int = obj.\-Get\-Dimensions ()} -\/ Get dimensions of this structured points dataset.  
\item {\ttfamily obj.\-Get\-Dimensions (int dim\mbox{[}3\mbox{]})} -\/ Get dimensions of this structured points dataset.  
\item {\ttfamily int = obj.\-Get\-Data\-Dimension ()} -\/ Return the dimensionality of the data.  
\item {\ttfamily obj.\-Set\-Extent (int extent\mbox{[}6\mbox{]})} -\/ Different ways to set the extent of the data array. The extent should be set before the \char`\"{}\-Scalars\char`\"{} are set or allocated. The Extent is stored in the order (X, Y, Z).  
\item {\ttfamily obj.\-Set\-Extent (int x1, int x2, int y1, int y2, int z1, int z2)} -\/ Different ways to set the extent of the data array. The extent should be set before the \char`\"{}\-Scalars\char`\"{} are set or allocated. The Extent is stored in the order (X, Y, Z).  
\item {\ttfamily int = obj. Get\-Extent ()} -\/ Different ways to set the extent of the data array. The extent should be set before the \char`\"{}\-Scalars\char`\"{} are set or allocated. The Extent is stored in the order (X, Y, Z).  
\item {\ttfamily long = obj.\-Get\-Actual\-Memory\-Size ()} -\/ Return the actual size of the data in kilobytes. This number is valid only after the pipeline has updated. The memory size returned is guaranteed to be greater than or equal to the memory required to represent the data (e.\-g., extra space in arrays, etc. are not included in the return value). T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E.  
\item {\ttfamily obj.\-Shallow\-Copy (vtk\-Data\-Object src)} -\/ Shallow and Deep copy.  
\item {\ttfamily obj.\-Deep\-Copy (vtk\-Data\-Object src)} -\/ Shallow and Deep copy.  
\item {\ttfamily int = obj.\-Get\-Extent\-Type ()} -\/ Methods for supporting blanking of cells. Blanking turns on or off points in the structured grid, and hence the cells connected to them. These methods should be called only after the dimensions of the grid are set.  
\item {\ttfamily obj.\-Blank\-Point (vtk\-Id\-Type pt\-Id)} -\/ Methods for supporting blanking of cells. Blanking turns on or off points in the structured grid, and hence the cells connected to them. These methods should be called only after the dimensions of the grid are set.  
\item {\ttfamily obj.\-Un\-Blank\-Point (vtk\-Id\-Type pt\-Id)} -\/ Methods for supporting blanking of cells. Blanking turns on or off points in the structured grid, and hence the cells connected to them. These methods should be called only after the dimensions of the grid are set.  
\item {\ttfamily obj.\-Blank\-Cell (vtk\-Id\-Type pt\-Id)} -\/ Methods for supporting blanking of cells. Blanking turns on or off cells in the structured grid, and hence the cells connected to them. These methods should be called only after the dimensions of the grid are set.  
\item {\ttfamily obj.\-Un\-Blank\-Cell (vtk\-Id\-Type pt\-Id)} -\/ Methods for supporting blanking of cells. Blanking turns on or off cells in the structured grid, and hence the cells connected to them. These methods should be called only after the dimensions of the grid are set.  
\item {\ttfamily vtk\-Unsigned\-Char\-Array = obj.\-Get\-Point\-Visibility\-Array ()} -\/ Get the array that defines the blanking (visibility) of each point.  
\item {\ttfamily obj.\-Set\-Point\-Visibility\-Array (vtk\-Unsigned\-Char\-Array point\-Visibility)} -\/ Set an array that defines the (blanking) visibility of the points in the grid. Make sure that length of the visibility array matches the number of points in the grid.  
\item {\ttfamily vtk\-Unsigned\-Char\-Array = obj.\-Get\-Cell\-Visibility\-Array ()} -\/ Get the array that defines the blanking (visibility) of each cell.  
\item {\ttfamily obj.\-Set\-Cell\-Visibility\-Array (vtk\-Unsigned\-Char\-Array point\-Visibility)} -\/ Set an array that defines the (blanking) visibility of the cells in the grid. Make sure that length of the visibility array matches the number of points in the grid.  
\item {\ttfamily char = obj.\-Is\-Point\-Visible (vtk\-Id\-Type pt\-Id)} -\/ Return non-\/zero value if specified point is visible. These methods should be called only after the dimensions of the grid are set.  
\item {\ttfamily char = obj.\-Is\-Cell\-Visible (vtk\-Id\-Type cell\-Id)} -\/ Return non-\/zero value if specified point is visible. These methods should be called only after the dimensions of the grid are set.  
\item {\ttfamily char = obj.\-Get\-Point\-Blanking ()} -\/ Returns 1 if there is any visibility constraint on the points, 0 otherwise.  
\item {\ttfamily char = obj.\-Get\-Cell\-Blanking ()} -\/ Returns 1 if there is any visibility constraint on the cells, 0 otherwise.  
\item {\ttfamily obj.\-Crop ()} -\/ Reallocates and copies to set the Extent to the Update\-Extent. This is used internally when the exact extent is requested, and the source generated more than the update extent.  
\item {\ttfamily obj.\-Get\-Point (int i, int j, int k, double p\mbox{[}3\mbox{]}, bool adjust\-For\-Extenttrue)} -\/ Get a point in the grid. If adjust\-For\-Extent is true, (i,j,k) is interpreted as a position relative to the beginning of the extent. If adjust\-For\-Extent is false, (i,j,k) is interpreted literally and the (i,j,k) point of the grid is returned regardless of the extent beginning. The point coordinate is returned in 'p'. The default adjust\-For\-Extent is true.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkstructuredgridalgorithm}{}\section{vtk\-Structured\-Grid\-Algorithm}\label{vtkfiltering_vtkstructuredgridalgorithm}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
To create an instance of class vtk\-Structured\-Grid\-Algorithm, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkStructuredGridAlgorithm
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Structured\-Grid\-Algorithm has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Structured\-Grid\-Algorithm class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Structured\-Grid\-Algorithm = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Structured\-Grid\-Algorithm = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Structured\-Grid = obj.\-Get\-Output ()} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Structured\-Grid = obj.\-Get\-Output (int )} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily obj.\-Set\-Output (vtk\-Data\-Object d)} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Input ()}  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Input (int port)}  
\item {\ttfamily vtk\-Structured\-Grid = obj.\-Get\-Structured\-Grid\-Input (int port)}  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Object )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Set\-Input (int , vtk\-Data\-Object )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Add\-Input (vtk\-Data\-Object )} -\/ Add an input of this algorithm. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Add\-Input\-Connection(). See Set\-Input() for details.  
\item {\ttfamily obj.\-Add\-Input (int , vtk\-Data\-Object )} -\/ Add an input of this algorithm. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Add\-Input\-Connection(). See Set\-Input() for details.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkstructuredgridsource}{}\section{vtk\-Structured\-Grid\-Source}\label{vtkfiltering_vtkstructuredgridsource}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Structured\-Grid\-Source is an abstract class whose subclasses generate structured grid data.

To create an instance of class vtk\-Structured\-Grid\-Source, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkStructuredGridSource
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Structured\-Grid\-Source has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Structured\-Grid\-Source class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Structured\-Grid\-Source = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Structured\-Grid\-Source = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Structured\-Grid = obj.\-Get\-Output ()} -\/ Get the output of this source.  
\item {\ttfamily vtk\-Structured\-Grid = obj.\-Get\-Output (int idx)} -\/ Get the output of this source.  
\item {\ttfamily obj.\-Set\-Output (vtk\-Structured\-Grid output)} -\/ Get the output of this source.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkstructuredgridtopolydatafilter}{}\section{vtk\-Structured\-Grid\-To\-Poly\-Data\-Filter}\label{vtkfiltering_vtkstructuredgridtopolydatafilter}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Structured\-Grid\-To\-Poly\-Data\-Filter is a filter whose subclasses take as input structured grid datasets and generate polygonal data on output.

To create an instance of class vtk\-Structured\-Grid\-To\-Poly\-Data\-Filter, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkStructuredGridToPolyDataFilter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Structured\-Grid\-To\-Poly\-Data\-Filter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Structured\-Grid\-To\-Poly\-Data\-Filter class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Structured\-Grid\-To\-Poly\-Data\-Filter = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Structured\-Grid\-To\-Poly\-Data\-Filter = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Input (vtk\-Structured\-Grid input)} -\/ Set / get the input Grid or filter.  
\item {\ttfamily vtk\-Structured\-Grid = obj.\-Get\-Input ()} -\/ Set / get the input Grid or filter.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkstructuredgridtostructuredgridfilter}{}\section{vtk\-Structured\-Grid\-To\-Structured\-Grid\-Filter}\label{vtkfiltering_vtkstructuredgridtostructuredgridfilter}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Structured\-Points\-To\-Structured\-Points\-Filter is an abstract filter class whose subclasses take on input a structured grid and generate a structured grid on output.

To create an instance of class vtk\-Structured\-Grid\-To\-Structured\-Grid\-Filter, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkStructuredGridToStructuredGridFilter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Structured\-Grid\-To\-Structured\-Grid\-Filter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Structured\-Grid\-To\-Structured\-Grid\-Filter class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Structured\-Grid\-To\-Structured\-Grid\-Filter = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Structured\-Grid\-To\-Structured\-Grid\-Filter = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Input (vtk\-Structured\-Grid input)} -\/ Set / get the input Grid or filter.  
\item {\ttfamily vtk\-Structured\-Grid = obj.\-Get\-Input ()} -\/ Set / get the input Grid or filter.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkstructuredpoints}{}\section{vtk\-Structured\-Points}\label{vtkfiltering_vtkstructuredpoints}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Structured\-Points is a subclass of Image\-Data that requires the data extent to exactly match the update extent. Normall image data allows that the data extent may be larger than the update extent. Structured\-Points also defines the origin differently that vtk\-Image\-Data. For structured points the origin is the location of first point. Whereas images define the origin as the location of point 0, 0, 0. Image Origin is stored in ivar, and structured points have special methods for setting/getting the origin/extents.

To create an instance of class vtk\-Structured\-Points, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkStructuredPoints
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Structured\-Points has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Structured\-Points class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Structured\-Points = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Structured\-Points = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Data\-Object\-Type ()}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkstructuredpointscollection}{}\section{vtk\-Structured\-Points\-Collection}\label{vtkfiltering_vtkstructuredpointscollection}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Structured\-Points\-Collection is an object that creates and manipulates lists of structured points datasets. See also vtk\-Collection and subclasses.

To create an instance of class vtk\-Structured\-Points\-Collection, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkStructuredPointsCollection
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Structured\-Points\-Collection has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Structured\-Points\-Collection class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Structured\-Points\-Collection = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Structured\-Points\-Collection = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Add\-Item (vtk\-Structured\-Points ds)} -\/ Get the next item in the collection. N\-U\-L\-L is returned if the collection is exhausted.  
\item {\ttfamily vtk\-Structured\-Points = obj.\-Get\-Next\-Item ()} -\/ Get the next item in the collection. N\-U\-L\-L is returned if the collection is exhausted.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkstructuredpointssource}{}\section{vtk\-Structured\-Points\-Source}\label{vtkfiltering_vtkstructuredpointssource}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Structured\-Points\-Source is an abstract class whose subclasses generate structured Points data.

To create an instance of class vtk\-Structured\-Points\-Source, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkStructuredPointsSource
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Structured\-Points\-Source has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Structured\-Points\-Source class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Structured\-Points\-Source = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Structured\-Points\-Source = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Output (vtk\-Structured\-Points output)} -\/ Set/\-Get the output of this source.  
\item {\ttfamily vtk\-Structured\-Points = obj.\-Get\-Output ()} -\/ Set/\-Get the output of this source.  
\item {\ttfamily vtk\-Structured\-Points = obj.\-Get\-Output (int idx)} -\/ Set/\-Get the output of this source.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkstructuredpointstopolydatafilter}{}\section{vtk\-Structured\-Points\-To\-Poly\-Data\-Filter}\label{vtkfiltering_vtkstructuredpointstopolydatafilter}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Structured\-Points\-To\-Poly\-Data\-Filter is an abstract filter class whose subclasses take on input structured points and generate polygonal data on output.

To create an instance of class vtk\-Structured\-Points\-To\-Poly\-Data\-Filter, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkStructuredPointsToPolyDataFilter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Structured\-Points\-To\-Poly\-Data\-Filter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Structured\-Points\-To\-Poly\-Data\-Filter class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Structured\-Points\-To\-Poly\-Data\-Filter = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Structured\-Points\-To\-Poly\-Data\-Filter = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Input (vtk\-Image\-Data input)} -\/ Set / get the input data or filter.  
\item {\ttfamily vtk\-Image\-Data = obj.\-Get\-Input ()} -\/ Set / get the input data or filter.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkstructuredpointstostructuredpointsfilter}{}\section{vtk\-Structured\-Points\-To\-Structured\-Points\-Filter}\label{vtkfiltering_vtkstructuredpointstostructuredpointsfilter}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Structured\-Points\-To\-Structured\-Points\-Filter is an abstract filter class whose subclasses take on input structured points and generate structured points on output.

To create an instance of class vtk\-Structured\-Points\-To\-Structured\-Points\-Filter, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkStructuredPointsToStructuredPointsFilter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Structured\-Points\-To\-Structured\-Points\-Filter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Structured\-Points\-To\-Structured\-Points\-Filter class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Structured\-Points\-To\-Structured\-Points\-Filter = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Structured\-Points\-To\-Structured\-Points\-Filter = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Input (vtk\-Image\-Data input)} -\/ Set / get the input data or filter.  
\item {\ttfamily vtk\-Image\-Data = obj.\-Get\-Input ()} -\/ Set / get the input data or filter.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkstructuredpointstounstructuredgridfilter}{}\section{vtk\-Structured\-Points\-To\-Unstructured\-Grid\-Filter}\label{vtkfiltering_vtkstructuredpointstounstructuredgridfilter}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Structured\-Points\-To\-Unstructured\-Grid\-Filter is an abstract filter class whose subclasses take on input structured points and generate unstructured grid data on output.

To create an instance of class vtk\-Structured\-Points\-To\-Unstructured\-Grid\-Filter, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkStructuredPointsToUnstructuredGridFilter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Structured\-Points\-To\-Unstructured\-Grid\-Filter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Structured\-Points\-To\-Unstructured\-Grid\-Filter class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Structured\-Points\-To\-Unstructured\-Grid\-Filter = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Structured\-Points\-To\-Unstructured\-Grid\-Filter = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Input (vtk\-Image\-Data input)} -\/ Set / get the input data or filter.  
\item {\ttfamily vtk\-Image\-Data = obj.\-Get\-Input ()} -\/ Set / get the input data or filter.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtksuperquadric}{}\section{vtk\-Superquadric}\label{vtkfiltering_vtksuperquadric}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Superquadric computes the implicit function and function gradient for a superquadric. vtk\-Superquadric is a concrete implementation of vtk\-Implicit\-Function. The superquadric is centered at Center and axes of rotation is along the y-\/axis. (Use the superclass' vtk\-Implicit\-Function transformation matrix if necessary to reposition.) Roundness parameters (Phi\-Roundness and Theta\-Roundness) control the shape of the superquadric. The Toroidal boolean controls whether a toroidal superquadric is produced. If so, the Thickness parameter controls the thickness of the toroid\-: 0 is the thinnest allowable toroid, and 1 has a minimum sized hole. The Scale parameters allow the superquadric to be scaled in x, y, and z (normal vectors are correctly generated in any case). The Size parameter controls size of the superquadric.

This code is based on \char`\"{}\-Rigid physically based superquadrics\char`\"{}, A. H. Barr, in \char`\"{}\-Graphics Gems I\-I\-I\char`\"{}, David Kirk, ed., Academic Press, 1992.

To create an instance of class vtk\-Superquadric, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkSuperquadric
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Superquadric has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Superquadric class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Superquadric = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Superquadric = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily double = obj.\-Evaluate\-Function (double x\mbox{[}3\mbox{]})}  
\item {\ttfamily double = obj.\-Evaluate\-Function (double x, double y, double z)}  
\item {\ttfamily obj.\-Evaluate\-Gradient (double x\mbox{[}3\mbox{]}, double g\mbox{[}3\mbox{]})}  
\item {\ttfamily obj.\-Set\-Center (double , double , double )} -\/ Set the center of the superquadric. Default is 0,0,0.  
\item {\ttfamily obj.\-Set\-Center (double a\mbox{[}3\mbox{]})} -\/ Set the center of the superquadric. Default is 0,0,0.  
\item {\ttfamily double = obj. Get\-Center ()} -\/ Set the center of the superquadric. Default is 0,0,0.  
\item {\ttfamily obj.\-Set\-Scale (double , double , double )} -\/ Set the scale factors of the superquadric. Default is 1,1,1.  
\item {\ttfamily obj.\-Set\-Scale (double a\mbox{[}3\mbox{]})} -\/ Set the scale factors of the superquadric. Default is 1,1,1.  
\item {\ttfamily double = obj. Get\-Scale ()} -\/ Set the scale factors of the superquadric. Default is 1,1,1.  
\item {\ttfamily double = obj.\-Get\-Thickness ()} -\/ Set/\-Get Superquadric ring thickness (toroids only). Changing thickness maintains the outside diameter of the toroid.  
\item {\ttfamily obj.\-Set\-Thickness (double )} -\/ Set/\-Get Superquadric ring thickness (toroids only). Changing thickness maintains the outside diameter of the toroid.  
\item {\ttfamily double = obj.\-Get\-Thickness\-Min\-Value ()} -\/ Set/\-Get Superquadric ring thickness (toroids only). Changing thickness maintains the outside diameter of the toroid.  
\item {\ttfamily double = obj.\-Get\-Thickness\-Max\-Value ()} -\/ Set/\-Get Superquadric ring thickness (toroids only). Changing thickness maintains the outside diameter of the toroid.  
\item {\ttfamily double = obj.\-Get\-Phi\-Roundness ()} -\/ Set/\-Get Superquadric north/south roundness. Values range from 0 (rectangular) to 1 (circular) to higher orders.  
\item {\ttfamily obj.\-Set\-Phi\-Roundness (double e)} -\/ Set/\-Get Superquadric north/south roundness. Values range from 0 (rectangular) to 1 (circular) to higher orders.  
\item {\ttfamily double = obj.\-Get\-Theta\-Roundness ()} -\/ Set/\-Get Superquadric east/west roundness. Values range from 0 (rectangular) to 1 (circular) to higher orders.  
\item {\ttfamily obj.\-Set\-Theta\-Roundness (double e)} -\/ Set/\-Get Superquadric east/west roundness. Values range from 0 (rectangular) to 1 (circular) to higher orders.  
\item {\ttfamily obj.\-Set\-Size (double )} -\/ Set/\-Get Superquadric isotropic size.  
\item {\ttfamily double = obj.\-Get\-Size ()} -\/ Set/\-Get Superquadric isotropic size.  
\item {\ttfamily obj.\-Toroidal\-On ()} -\/ Set/\-Get whether or not the superquadric is toroidal (1) or ellipsoidal (0).  
\item {\ttfamily obj.\-Toroidal\-Off ()} -\/ Set/\-Get whether or not the superquadric is toroidal (1) or ellipsoidal (0).  
\item {\ttfamily int = obj.\-Get\-Toroidal ()} -\/ Set/\-Get whether or not the superquadric is toroidal (1) or ellipsoidal (0).  
\item {\ttfamily obj.\-Set\-Toroidal (int )} -\/ Set/\-Get whether or not the superquadric is toroidal (1) or ellipsoidal (0).  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtktable}{}\section{vtk\-Table}\label{vtkfiltering_vtktable}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Table is a basic data structure for storing columns of data. Internally, columns are stored in a vtk\-Data\-Set\-Attributes structure called Row\-Data. However, using the vtk\-Table A\-P\-I additionally ensures that every column has the same number of entries, and provides row access (using vtk\-Variant\-Array) and single entry access (using vtk\-Variant).

The field data inherited from vtk\-Data\-Object may be used to store metadata related to the table.

To create an instance of class vtk\-Table, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkTable
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Table has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Table class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Table = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Table = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Dump (int col\-Width)} -\/ Dump table contents.  
\item {\ttfamily int = obj.\-Get\-Data\-Object\-Type ()} -\/ Return the actual size of the data in kilobytes. This number is valid only after the pipeline has updated. The memory size returned is guaranteed to be greater than or equal to the memory required to represent the data (e.\-g., extra space in arrays, etc. are not included in the return value).  
\item {\ttfamily long = obj.\-Get\-Actual\-Memory\-Size ()} -\/ Return the actual size of the data in kilobytes. This number is valid only after the pipeline has updated. The memory size returned is guaranteed to be greater than or equal to the memory required to represent the data (e.\-g., extra space in arrays, etc. are not included in the return value).  
\item {\ttfamily vtk\-Data\-Set\-Attributes = obj.\-Get\-Row\-Data ()} -\/ Get/\-Set the main data (columns) of the table.  
\item {\ttfamily obj.\-Set\-Row\-Data (vtk\-Data\-Set\-Attributes data)} -\/ Get/\-Set the main data (columns) of the table.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Rows ()} -\/ Get the number of rows in the table.  
\item {\ttfamily obj.\-Set\-Number\-Of\-Rows (vtk\-Id\-Type )} -\/ Set the number of rows in the table. Note that memory allocation might be performed as a result of this, but no memory will be released.  
\item {\ttfamily vtk\-Variant\-Array = obj.\-Get\-Row (vtk\-Id\-Type row)} -\/ Get a row of the table as a vtk\-Variant\-Array which has one entry for each column. N\-O\-T\-E\-: This version of the method is N\-O\-T thread safe.  
\item {\ttfamily obj.\-Get\-Row (vtk\-Id\-Type row, vtk\-Variant\-Array values)} -\/ Get a row of the table as a vtk\-Variant\-Array which has one entry for each column.  
\item {\ttfamily obj.\-Set\-Row (vtk\-Id\-Type row, vtk\-Variant\-Array values)} -\/ Set a row of the table with a vtk\-Variant\-Array which has one entry for each column.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Insert\-Next\-Blank\-Row (double default\-\_\-num\-\_\-val)} -\/ Insert a blank row at the end of the table.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Insert\-Next\-Row (vtk\-Variant\-Array arr)} -\/ Insert a row specified by a vtk\-Variant\-Array. The number of entries in the array should match the number of columns in the table.  
\item {\ttfamily obj.\-Remove\-Row (vtk\-Id\-Type row)} -\/ Delete a row from the table. Rows below the deleted row are shifted up.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Columns ()} -\/ Get the number of columns in the table.  
\item {\ttfamily string = obj.\-Get\-Column\-Name (vtk\-Id\-Type col)}  
\item {\ttfamily vtk\-Abstract\-Array = obj.\-Get\-Column\-By\-Name (string name)} -\/ Get a column of the table by its name.  
\item {\ttfamily vtk\-Abstract\-Array = obj.\-Get\-Column (vtk\-Id\-Type col)} -\/ Get a column of the table by its column index.  
\item {\ttfamily obj.\-Add\-Column (vtk\-Abstract\-Array arr)} -\/ Add a column to the table.  
\item {\ttfamily obj.\-Remove\-Column\-By\-Name (string name)} -\/ Remove a column from the table by its name.  
\item {\ttfamily obj.\-Remove\-Column (vtk\-Id\-Type col)} -\/ Remove a column from the table by its column index.  
\item {\ttfamily obj.\-Initialize ()} -\/ Initialize to an empty table.  
\item {\ttfamily obj.\-Shallow\-Copy (vtk\-Data\-Object src)} -\/ Shallow/deep copy the data from src into this object.  
\item {\ttfamily obj.\-Deep\-Copy (vtk\-Data\-Object src)} -\/ Shallow/deep copy the data from src into this object.  
\item {\ttfamily vtk\-Field\-Data = obj.\-Get\-Attributes\-As\-Field\-Data (int type)} -\/ Returns the attributes of the data object as a vtk\-Field\-Data. This returns non-\/null values in all the same cases as Get\-Attributes, in addition to the case of F\-I\-E\-L\-D, which will return the field data for any vtk\-Data\-Object subclass.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Elements (int type)} -\/ Get the number of elements for a specific attribute type (R\-O\-W, etc.).  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtktablealgorithm}{}\section{vtk\-Table\-Algorithm}\label{vtkfiltering_vtktablealgorithm}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Table\-Algorithm is a convenience class to make writing algorithms easier. It is also designed to help transition old algorithms to the new pipeline architecture. There are some assumptions and defaults made by this class you should be aware of. This class defaults such that your filter will have one input port and one output port. If that is not the case simply change it with Set\-Number\-Of\-Input\-Ports etc. See this class constructor for the default. This class also provides a Fill\-Input\-Port\-Info method that by default says that all inputs will be Tree. If that isn't the case then please override this method in your subclass. This class breaks out the downstream requests into separate functions such as Execute\-Data and Execute\-Information. For new algorithms you should implement Request\-Data( request, input\-Vec, output\-Vec) but for older filters there is a default implementation that calls the old Execute\-Data(output) signature. For even older filters that don't implement Execute\-Data the default implementation calls the even older Execute() signature.

.S\-E\-C\-T\-I\-O\-N Thanks Thanks to Brian Wylie for creating this class.

To create an instance of class vtk\-Table\-Algorithm, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkTableAlgorithm
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Table\-Algorithm has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Table\-Algorithm class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Table\-Algorithm = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Table\-Algorithm = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Table = obj.\-Get\-Output ()} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Table = obj.\-Get\-Output (int index)} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Object obj)} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Set\-Input (int index, vtk\-Data\-Object obj)} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtktemporaldataset}{}\section{vtk\-Temporal\-Data\-Set}\label{vtkfiltering_vtktemporaldataset}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Temporal\-Data\-Set is a vtk\-Composite\-Data\-Set that stores multiple time steps of data.

To create an instance of class vtk\-Temporal\-Data\-Set, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkTemporalDataSet
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Temporal\-Data\-Set has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Temporal\-Data\-Set class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Temporal\-Data\-Set = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Temporal\-Data\-Set = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Data\-Object\-Type ()} -\/ Set the number of time steps in theis dataset  
\item {\ttfamily obj.\-Set\-Number\-Of\-Time\-Steps (int num\-Levels)} -\/ Returns the number of time steps.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Time\-Steps ()} -\/ Set a data object as a timestep. Cannot be vtk\-Temporal\-Data\-Set.  
\item {\ttfamily obj.\-Set\-Time\-Step (int timestep, vtk\-Data\-Object dobj)} -\/ Set a data object as a timestep. Cannot be vtk\-Temporal\-Data\-Set.  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Time\-Step (int timestep)} -\/ Get timestep meta-\/data.  
\item {\ttfamily vtk\-Information = obj.\-Get\-Meta\-Data (int timestep)} -\/ Returns if timestep meta-\/data is present.  
\item {\ttfamily int = obj.\-Has\-Meta\-Data (int timestep)} -\/ The extent type is a 3\-D extent  
\item {\ttfamily int = obj.\-Get\-Extent\-Type ()} -\/ The extent type is a 3\-D extent  
\item {\ttfamily vtk\-Information = obj.\-Get\-Meta\-Data (vtk\-Composite\-Data\-Iterator iter)} -\/ Unhiding superclass method.  
\item {\ttfamily int = obj.\-Has\-Meta\-Data (vtk\-Composite\-Data\-Iterator iter)}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtktemporaldatasetalgorithm}{}\section{vtk\-Temporal\-Data\-Set\-Algorithm}\label{vtkfiltering_vtktemporaldatasetalgorithm}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Algorithms that take any type of data object (including composite dataset) and produce a vtk\-Temporal\-Data\-Set in the output can subclass from this class.

To create an instance of class vtk\-Temporal\-Data\-Set\-Algorithm, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkTemporalDataSetAlgorithm
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Temporal\-Data\-Set\-Algorithm has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Temporal\-Data\-Set\-Algorithm class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Temporal\-Data\-Set\-Algorithm = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Temporal\-Data\-Set\-Algorithm = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Temporal\-Data\-Set = obj.\-Get\-Output ()} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Temporal\-Data\-Set = obj.\-Get\-Output (int )} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Object )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Set\-Input (int , vtk\-Data\-Object )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtktetra}{}\section{vtk\-Tetra}\label{vtkfiltering_vtktetra}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Tetra is a concrete implementation of vtk\-Cell to represent a 3\-D tetrahedron. vtk\-Tetra uses the standard isoparametric shape functions for a linear tetrahedron. The tetrahedron is defined by the four points (0-\/3); where (0,1,2) is the base of the tetrahedron which, using the right hand rule, forms a triangle whose normal points in the direction of the fourth point.

To create an instance of class vtk\-Tetra, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkTetra
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Tetra has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Tetra class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Tetra = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Tetra = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int edge\-Id)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int face\-Id)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Clip (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array connectivity, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd, int inside\-Out)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)} -\/ Returns the set of points that are on the boundary of the tetrahedron that are closest parametrically to the point specified. This may include faces, edges, or vertices.  
\item {\ttfamily int = obj.\-Get\-Parametric\-Center (double pcoords\mbox{[}3\mbox{]})} -\/ Return the center of the tetrahedron in parametric coordinates.  
\item {\ttfamily double = obj.\-Get\-Parametric\-Distance (double pcoords\mbox{[}3\mbox{]})} -\/ Return the distance of the parametric coordinate provided to the cell. If inside the cell, a distance of zero is returned.  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double weights\mbox{[}4\mbox{]})} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs\mbox{[}12\mbox{]})} -\/ Return the ids of the vertices defining edge/face ({\ttfamily edge\-Id}/`face\-Id'). Ids are related to the cell, not to the dataset.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkthreadedimagealgorithm}{}\section{vtk\-Threaded\-Image\-Algorithm}\label{vtkfiltering_vtkthreadedimagealgorithm}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Threaded\-Image\-Algorithm is a filter superclass that hides much of the pipeline complexity. It handles breaking the pipeline execution into smaller extents so that the vtk\-Image\-Data limits are observed. It also provides support for multithreading. If you don't need any of this functionality, consider using vtk\-Simple\-Image\-To\-Image\-Algorithm instead. .S\-E\-C\-T\-I\-O\-N See also vtk\-Simple\-Image\-To\-Image\-Algorithm

To create an instance of class vtk\-Threaded\-Image\-Algorithm, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkThreadedImageAlgorithm
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Threaded\-Image\-Algorithm has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Threaded\-Image\-Algorithm class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Threaded\-Image\-Algorithm = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Threaded\-Image\-Algorithm = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Threaded\-Execute (vtk\-Image\-Data in\-Data, vtk\-Image\-Data out\-Data, int extent\mbox{[}6\mbox{]}, int thread\-Id)}  
\item {\ttfamily obj.\-Set\-Number\-Of\-Threads (int )} -\/ Get/\-Set the number of threads to create when rendering  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Threads\-Min\-Value ()} -\/ Get/\-Set the number of threads to create when rendering  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Threads\-Max\-Value ()} -\/ Get/\-Set the number of threads to create when rendering  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Threads ()} -\/ Get/\-Set the number of threads to create when rendering  
\item {\ttfamily int = obj.\-Split\-Extent (int split\-Ext\mbox{[}6\mbox{]}, int start\-Ext\mbox{[}6\mbox{]}, int num, int total)} -\/ Putting this here until I merge graphics and imaging streaming.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtktree}{}\section{vtk\-Tree}\label{vtkfiltering_vtktree}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Tree is a connected directed graph with no cycles. A tree is a type of directed graph, so works with all graph algorithms.

vtk\-Tree is a read-\/only data structure. To construct a tree, create an instance of vtk\-Mutable\-Directed\-Graph. Add vertices and edges with Add\-Vertex() and Add\-Edge(). You may alternately start by adding a single vertex as the root then call graph-\/$>$Add\-Child(parent) which adds a new vertex and connects the parent to the child. The tree M\-U\-S\-T have all edges in the proper direction, from parent to child. After building the tree, call tree-\/$>$Checked\-Shallow\-Copy(graph) to copy the structure into a vtk\-Tree. This method will return false if the graph is an invalid tree.

vtk\-Tree provides some convenience methods for obtaining the parent and children of a vertex, for finding the root, and determining if a vertex is a leaf (a vertex with no children).

To create an instance of class vtk\-Tree, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkTree
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Tree has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Tree class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Tree = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Tree = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Data\-Object\-Type ()} -\/ Get the root vertex of the tree.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Root ()} -\/ Get the root vertex of the tree.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Children (vtk\-Id\-Type v)} -\/ Get the i-\/th child of a parent vertex.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Child (vtk\-Id\-Type v, vtk\-Id\-Type i)} -\/ Get the i-\/th child of a parent vertex.  
\item {\ttfamily obj.\-Get\-Children (vtk\-Id\-Type v, vtk\-Adjacent\-Vertex\-Iterator it)} -\/ Get the parent of a vertex.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Parent (vtk\-Id\-Type v)} -\/ Get the parent of a vertex.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Level (vtk\-Id\-Type v)} -\/ Get the level of the vertex in the tree. The root vertex has level 0. Returns -\/1 if the vertex id is $<$ 0 or greater than the number of vertices in the tree.  
\item {\ttfamily bool = obj.\-Is\-Leaf (vtk\-Id\-Type vertex)} -\/ Return whether the vertex is a leaf (i.\-e. it has no children).  
\item {\ttfamily obj.\-Reorder\-Children (vtk\-Id\-Type parent, vtk\-Id\-Type\-Array children)} -\/ Reorder the children of a parent vertex. The children array must contain all the children of parent, just in a different order. This does not change the topology of the tree.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtktreealgorithm}{}\section{vtk\-Tree\-Algorithm}\label{vtkfiltering_vtktreealgorithm}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Tree\-Algorithm is a convenience class to make writing algorithms easier. It is also designed to help transition old algorithms to the new pipeline edgehitecture. There are some assumptions and defaults made by this class you should be aware of. This class defaults such that your filter will have one input port and one output port. If that is not the case simply change it with Set\-Number\-Of\-Input\-Ports etc. See this class constructor for the default. This class also provides a Fill\-Input\-Port\-Info method that by default says that all inputs will be Tree. If that isn't the case then please override this method in your subclass. This class breaks out the downstream requests into separate functions such as Execute\-Data and Execute\-Information. For new algorithms you should implement Request\-Data( request, input\-Vec, output\-Vec) but for older filters there is a default implementation that calls the old Execute\-Data(output) signature. For even older filters that don't implement Execute\-Data the default implementation calls the even older Execute() signature.

To create an instance of class vtk\-Tree\-Algorithm, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkTreeAlgorithm
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Tree\-Algorithm has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Tree\-Algorithm class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Tree\-Algorithm = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Tree\-Algorithm = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Tree = obj.\-Get\-Output ()} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Tree = obj.\-Get\-Output (int index)} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Object obj)} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Set\-Input (int index, vtk\-Data\-Object obj)} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtktreedfsiterator}{}\section{vtk\-Tree\-D\-F\-S\-Iterator}\label{vtkfiltering_vtktreedfsiterator}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Tree\-D\-F\-S\-Iterator performs a depth first seedgeh of a tree. First, you must set the tree on which you are going to iterate, and set the starting vertex and mode. The mode is either D\-I\-S\-C\-O\-V\-E\-R, in which case vertices are visited as they are first reached, or F\-I\-N\-I\-S\-H, in which case vertices are visited when they are done, i.\-e. all adjacent vertices have been discovered already.

After setting up the iterator, the normal mode of operation is to set up a {\ttfamily while(iter-\/$>$Has\-Next())} loop, with the statement {\ttfamily vtk\-Id\-Type vertex = iter-\/$>$Next()} inside the loop.

To create an instance of class vtk\-Tree\-D\-F\-S\-Iterator, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkTreeDFSIterator
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Tree\-D\-F\-S\-Iterator has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Tree\-D\-F\-S\-Iterator class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Tree\-D\-F\-S\-Iterator = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Tree\-D\-F\-S\-Iterator = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Tree (vtk\-Tree graph)} -\/ Set the graph to iterate over.  
\item {\ttfamily obj.\-Set\-Mode (int mode)} -\/ Set the visit mode of the iterator. Mode can be D\-I\-S\-C\-O\-V\-E\-R (0)\-: Order by discovery time F\-I\-N\-I\-S\-H (1)\-: Order by finish time Default is D\-I\-S\-C\-O\-V\-E\-R. Use D\-I\-S\-C\-O\-V\-E\-R for top-\/down algorithms where parents need to be processed before children. Use F\-I\-N\-I\-S\-H for bottom-\/up algorithms where children need to be processed before parents.  
\item {\ttfamily int = obj.\-Get\-Mode ()} -\/ Set the visit mode of the iterator. Mode can be D\-I\-S\-C\-O\-V\-E\-R (0)\-: Order by discovery time F\-I\-N\-I\-S\-H (1)\-: Order by finish time Default is D\-I\-S\-C\-O\-V\-E\-R. Use D\-I\-S\-C\-O\-V\-E\-R for top-\/down algorithms where parents need to be processed before children. Use F\-I\-N\-I\-S\-H for bottom-\/up algorithms where children need to be processed before parents.  
\item {\ttfamily obj.\-Set\-Start\-Vertex (vtk\-Id\-Type vertex)} -\/ The start vertex of the seedgeh. The tree iterator will only iterate over the subtree rooted at vertex. If not set (or set to a negative value), starts at the root of the tree.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Start\-Vertex ()} -\/ The start vertex of the seedgeh. The tree iterator will only iterate over the subtree rooted at vertex. If not set (or set to a negative value), starts at the root of the tree.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Next ()} -\/ The next vertex visited in the graph.  
\item {\ttfamily bool = obj.\-Has\-Next ()} -\/ Return true when all vertices have been visited.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtktriangle}{}\section{vtk\-Triangle}\label{vtkfiltering_vtktriangle}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Triangle is a concrete implementation of vtk\-Cell to represent a triangle located in 3-\/space.

To create an instance of class vtk\-Triangle, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkTriangle
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Triangle has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Triangle class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Triangle = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Triangle = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int edge\-Id)} -\/ Get the edge specified by edge\-Id (range 0 to 2) and return that edge's coordinates.  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int )} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily double = obj.\-Compute\-Area ()} -\/ A convenience function to compute the area of a vtk\-Triangle.  
\item {\ttfamily obj.\-Clip (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd, int inside\-Out)} -\/ Clip this triangle using scalar value provided. Like contouring, except that it cuts the triangle to produce other triangles.  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double sf\mbox{[}3\mbox{]})} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs\mbox{[}6\mbox{]})} -\/ Return the ids of the vertices defining edge ({\ttfamily edge\-Id}). Ids are related to the cell, not to the dataset.  
\item {\ttfamily int = obj.\-Get\-Parametric\-Center (double pcoords\mbox{[}3\mbox{]})} -\/ Return the center of the triangle in parametric coordinates.  
\item {\ttfamily double = obj.\-Get\-Parametric\-Distance (double pcoords\mbox{[}3\mbox{]})} -\/ Return the distance of the parametric coordinate provided to the cell. If inside the cell, a distance of zero is returned.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtktrianglestrip}{}\section{vtk\-Triangle\-Strip}\label{vtkfiltering_vtktrianglestrip}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Triangle\-Strip is a concrete implementation of vtk\-Cell to represent a 2\-D triangle strip. A triangle strip is a compact representation of triangles connected edge to edge in strip fashion. The connectivity of a triangle strip is three points defining an initial triangle, then for each additional triangle, a single point that, combined with the previous two points, defines the next triangle.

To create an instance of class vtk\-Triangle\-Strip, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkTriangleStrip
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Triangle\-Strip has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Triangle\-Strip class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Triangle\-Strip = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Triangle\-Strip = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int edge\-Id)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int )} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Clip (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd, int inside\-Out)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)}  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)}  
\item {\ttfamily int = obj.\-Is\-Primary\-Cell ()} -\/ Return the center of the point cloud in parametric coordinates.  
\item {\ttfamily int = obj.\-Get\-Parametric\-Center (double pcoords\mbox{[}3\mbox{]})} -\/ Return the center of the point cloud in parametric coordinates.  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double weights)} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs)} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtktriquadratichexahedron}{}\section{vtk\-Tri\-Quadratic\-Hexahedron}\label{vtkfiltering_vtktriquadratichexahedron}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Tri\-Quadratic\-Hexahedron is a concrete implementation of vtk\-Non\-Linear\-Cell to represent a three-\/dimensional, 27-\/node isoparametric triquadratic hexahedron. The interpolation is the standard finite element, triquadratic isoparametric shape function. The cell includes 8 edge nodes, 12 mid-\/edge nodes, 6 mid-\/face nodes and one mid-\/volume node. The ordering of the 27 points defining the cell is point ids (0-\/7,8-\/19, 20-\/25, 26) where point ids 0-\/7 are the eight corner vertices of the cube; followed by twelve midedge nodes (8-\/19); followed by 6 mid-\/face nodes (20-\/25) and the last node (26) is the mid-\/volume node. Note that these midedge nodes correspond lie on the edges defined by (0,1), (1,2), (2,3), (3,0), (4,5), (5,6), (6,7), (7,4), (0,4), (1,5), (2,6), (3,7). The mid-\/surface nodes lies on the faces defined by (first edge nodes id's, than mid-\/edge nodes id's)\-: (0,1,5,4;8,17,12,16), (1,2,6,5;9,18,13,17), (2,3,7,6,10,19,14,18), (3,0,4,7;11,16,15,19), (0,1,2,3;8,9,10,11), (4,5,6,7;12,13,14,15). The last point lies in the center of the cell (0,1,2,3,4,5,6,7).

\begin{DoxyVerb} top 
  7--14--6
  |      |
 15  25  13
  |      |
  4--12--5

  middle
 19--23--18
  |      |
 20  26  21
  |      |
 16--22--17

 bottom
  3--10--2
  |      |
 11  24  9 
  |      |
  0-- 8--1\end{DoxyVerb}


To create an instance of class vtk\-Tri\-Quadratic\-Hexahedron, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkTriQuadraticHexahedron
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Tri\-Quadratic\-Hexahedron has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Tri\-Quadratic\-Hexahedron class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Tri\-Quadratic\-Hexahedron = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Tri\-Quadratic\-Hexahedron = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int )} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int )} -\/ Implement the vtk\-Cell A\-P\-I. See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)}  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)}  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)}  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)}  
\item {\ttfamily obj.\-Clip (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array tetras, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd, int inside\-Out)} -\/ Clip this triquadratic hexahedron using scalar value provided. Like contouring, except that it cuts the hex to produce linear tetrahedron.  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double weights\mbox{[}27\mbox{]})} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs\mbox{[}81\mbox{]})} -\/ Return the ids of the vertices defining edge/face ({\ttfamily edge\-Id}/`face\-Id'). Ids are related to the cell, not to the dataset.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtktrivialproducer}{}\section{vtk\-Trivial\-Producer}\label{vtkfiltering_vtktrivialproducer}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Trivial\-Producer allows stand-\/alone data objects to be connected as inputs in a pipeline. All data objects that are connected to a pipeline involving vtk\-Algorithm must have a producer. This trivial producer allows data objects that are hand-\/constructed in a program without another vtk producer to be connected.

To create an instance of class vtk\-Trivial\-Producer, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkTrivialProducer
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Trivial\-Producer has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Trivial\-Producer class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Trivial\-Producer = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Trivial\-Producer = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Output (vtk\-Data\-Object output)} -\/ Set the data object that is \char`\"{}produced\char`\"{} by this producer. It is never really modified.  
\item {\ttfamily long = obj.\-Get\-M\-Time ()} -\/ The modified time of this producer is the newer of this object or the assigned output.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkundirectedgraph}{}\section{vtk\-Undirected\-Graph}\label{vtkfiltering_vtkundirectedgraph}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Undirected\-Graph is a collection of vertices along with a collection of undirected edges (they connect two vertices in no particular order). Shallow\-Copy(), Deep\-Copy(), Checked\-Shallow\-Copy(), Checked\-Deep\-Copy() accept instances of vtk\-Undirected\-Graph and vtk\-Mutable\-Undirected\-Graph. Get\-Out\-Edges(v, it) and Get\-In\-Edges(v, it) return the same list of edges, which is the list of all edges which have a v as an endpoint. Get\-In\-Degree(v), Get\-Out\-Degree(v) and Get\-Degree(v) all return the full degree of vertex v.

vtk\-Undirected\-Graph is read-\/only. To create an undirected graph, use an instance of vtk\-Mutable\-Undirected\-Graph, then you may set the structure to a vtk\-Undirected\-Graph using Shallow\-Copy().

To create an instance of class vtk\-Undirected\-Graph, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkUndirectedGraph
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Undirected\-Graph has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Undirected\-Graph class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Undirected\-Graph = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Undirected\-Graph = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Data\-Object\-Type ()} -\/ Returns the full degree of the vertex.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-In\-Degree (vtk\-Id\-Type v)} -\/ Returns the full degree of the vertex.  
\item {\ttfamily obj.\-Get\-In\-Edge (vtk\-Id\-Type v, vtk\-Id\-Type i, vtk\-Graph\-Edge e)} -\/ Initialize the iterator to get the incoming edges to a vertex. For an undirected graph, this is all incident edges.  
\item {\ttfamily obj.\-Get\-In\-Edges (vtk\-Id\-Type v, vtk\-In\-Edge\-Iterator it)}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkundirectedgraphalgorithm}{}\section{vtk\-Undirected\-Graph\-Algorithm}\label{vtkfiltering_vtkundirectedgraphalgorithm}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Undirected\-Graph\-Algorithm is a convenience class to make writing algorithms easier. It is also designed to help transition old algorithms to the new pipeline edgehitecture. There are some assumptions and defaults made by this class you should be aware of. This class defaults such that your filter will have one input port and one output port. If that is not the case simply change it with Set\-Number\-Of\-Input\-Ports etc. See this class constructor for the default. This class also provides a Fill\-Input\-Port\-Info method that by default says that all inputs will be Graph. If that isn't the case then please override this method in your subclass. This class breaks out the downstream requests into separate functions such as Execute\-Data and Execute\-Information. For new algorithms you should implement Request\-Data( request, input\-Vec, output\-Vec) but for older filters there is a default implementation that calls the old Execute\-Data(output) signature. For even older filters that don't implement Execute\-Data the default implementation calls the even older Execute() signature.

.S\-E\-C\-T\-I\-O\-N Thanks Thanks to Patricia Crossno, Ken Moreland, Andrew Wilson and Brian Wylie from Sandia National Laboratories for their help in developing this class.

To create an instance of class vtk\-Undirected\-Graph\-Algorithm, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkUndirectedGraphAlgorithm
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Undirected\-Graph\-Algorithm has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Undirected\-Graph\-Algorithm class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Undirected\-Graph\-Algorithm = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Undirected\-Graph\-Algorithm = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Undirected\-Graph = obj.\-Get\-Output ()} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Undirected\-Graph = obj.\-Get\-Output (int index)} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Object obj)} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Set\-Input (int index, vtk\-Data\-Object obj)} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkuniformgrid}{}\section{vtk\-Uniform\-Grid}\label{vtkfiltering_vtkuniformgrid}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Uniform\-Grid is a subclass of vtk\-Image\-Data. In addition to all the image data functionality, it supports blanking.

To create an instance of class vtk\-Uniform\-Grid, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkUniformGrid
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Uniform\-Grid has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Uniform\-Grid class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()} -\/ Construct an empty uniform grid.  
\item {\ttfamily int = obj.\-Is\-A (string name)} -\/ Construct an empty uniform grid.  
\item {\ttfamily vtk\-Uniform\-Grid = obj.\-New\-Instance ()} -\/ Construct an empty uniform grid.  
\item {\ttfamily vtk\-Uniform\-Grid = obj.\-Safe\-Down\-Cast (vtk\-Object o)} -\/ Construct an empty uniform grid.  
\item {\ttfamily obj.\-Copy\-Structure (vtk\-Data\-Set ds)} -\/ Copy the geometric and topological structure of an input image data object.  
\item {\ttfamily int = obj.\-Get\-Data\-Object\-Type ()} -\/ Return what type of dataset this is.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Cell (vtk\-Id\-Type cell\-Id)} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily obj.\-Get\-Cell (vtk\-Id\-Type cell\-Id, vtk\-Generic\-Cell cell)} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily int = obj.\-Get\-Cell\-Type (vtk\-Id\-Type cell\-Id)} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily obj.\-Get\-Cell\-Points (vtk\-Id\-Type cell\-Id, vtk\-Id\-List pt\-Ids)} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily obj.\-Get\-Point\-Cells (vtk\-Id\-Type pt\-Id, vtk\-Id\-List cell\-Ids)} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily obj.\-Initialize ()} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily int = obj.\-Get\-Max\-Cell\-Size ()} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily obj.\-Shallow\-Copy (vtk\-Data\-Object src)} -\/ Shallow and Deep copy.  
\item {\ttfamily obj.\-Deep\-Copy (vtk\-Data\-Object src)} -\/ Shallow and Deep copy.  
\item {\ttfamily obj.\-Blank\-Point (vtk\-Id\-Type pt\-Id)} -\/ Methods for supporting blanking of cells. Blanking turns on or off points in the structured grid, and hence the cells connected to them. These methods should be called only after the dimensions of the grid are set.  
\item {\ttfamily obj.\-Un\-Blank\-Point (vtk\-Id\-Type pt\-Id)} -\/ Methods for supporting blanking of cells. Blanking turns on or off points in the structured grid, and hence the cells connected to them. These methods should be called only after the dimensions of the grid are set.  
\item {\ttfamily obj.\-Blank\-Cell (vtk\-Id\-Type pt\-Id)} -\/ Methods for supporting blanking of cells. Blanking turns on or off cells in the structured grid. These methods should be called only after the dimensions of the grid are set.  
\item {\ttfamily obj.\-Un\-Blank\-Cell (vtk\-Id\-Type pt\-Id)} -\/ Methods for supporting blanking of cells. Blanking turns on or off cells in the structured grid. These methods should be called only after the dimensions of the grid are set.  
\item {\ttfamily vtk\-Unsigned\-Char\-Array = obj.\-Get\-Point\-Visibility\-Array ()} -\/ Get the array that defines the blanking (visibility) of each point.  
\item {\ttfamily obj.\-Set\-Point\-Visibility\-Array (vtk\-Unsigned\-Char\-Array point\-Visibility)} -\/ Set an array that defines the (blanking) visibility of the points in the grid. Make sure that length of the visibility array matches the number of points in the grid.  
\item {\ttfamily vtk\-Unsigned\-Char\-Array = obj.\-Get\-Cell\-Visibility\-Array ()} -\/ Get the array that defines the blanking (visibility) of each cell.  
\item {\ttfamily obj.\-Set\-Cell\-Visibility\-Array (vtk\-Unsigned\-Char\-Array point\-Visibility)} -\/ Set an array that defines the (blanking) visibility of the cells in the grid. Make sure that length of the visibility array matches the number of points in the grid.  
\item {\ttfamily char = obj.\-Is\-Point\-Visible (vtk\-Id\-Type pt\-Id)} -\/ Return non-\/zero value if specified point is visible. These methods should be called only after the dimensions of the grid are set.  
\item {\ttfamily char = obj.\-Is\-Cell\-Visible (vtk\-Id\-Type cell\-Id)} -\/ Return non-\/zero value if specified cell is visible. These methods should be called only after the dimensions of the grid are set.  
\item {\ttfamily char = obj.\-Get\-Point\-Blanking ()} -\/ Returns 1 if there is any visibility constraint on the points, 0 otherwise.  
\item {\ttfamily char = obj.\-Get\-Cell\-Blanking ()} -\/ Returns 1 if there is any visibility constraint on the cells, 0 otherwise.  
\item {\ttfamily vtk\-Image\-Data = obj.\-New\-Image\-Data\-Copy ()}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkunstructuredgrid}{}\section{vtk\-Unstructured\-Grid}\label{vtkfiltering_vtkunstructuredgrid}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Unstructured\-Grid is a data object that is a concrete implementation of vtk\-Data\-Set. vtk\-Unstructured\-Grid represents any combinations of any cell types. This includes 0\-D (e.\-g., points), 1\-D (e.\-g., lines, polylines), 2\-D (e.\-g., triangles, polygons), and 3\-D (e.\-g., hexahedron, tetrahedron).

To create an instance of class vtk\-Unstructured\-Grid, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkUnstructuredGrid
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Unstructured\-Grid has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Unstructured\-Grid class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Unstructured\-Grid = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Unstructured\-Grid = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Data\-Object\-Type ()} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily obj.\-Allocate (vtk\-Id\-Type num\-Cells, int ext\-Size)} -\/ Standard vtk\-Data\-Set A\-P\-I methods. See vtk\-Data\-Set for more information.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Insert\-Next\-Cell (int type, vtk\-Id\-List pt\-Ids)} -\/ Insert/create cell in object by type and list of point ids defining cell topology.  
\item {\ttfamily obj.\-Reset ()}  
\item {\ttfamily obj.\-Copy\-Structure (vtk\-Data\-Set ds)}  
\item {\ttfamily vtk\-Id\-Type = obj.\-Get\-Number\-Of\-Cells ()}  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Cell (vtk\-Id\-Type cell\-Id)}  
\item {\ttfamily obj.\-Get\-Cell (vtk\-Id\-Type cell\-Id, vtk\-Generic\-Cell cell)}  
\item {\ttfamily obj.\-Get\-Cell\-Bounds (vtk\-Id\-Type cell\-Id, double bounds\mbox{[}6\mbox{]})}  
\item {\ttfamily obj.\-Get\-Cell\-Points (vtk\-Id\-Type cell\-Id, vtk\-Id\-List pt\-Ids)}  
\item {\ttfamily obj.\-Get\-Point\-Cells (vtk\-Id\-Type pt\-Id, vtk\-Id\-List cell\-Ids)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type (vtk\-Id\-Type cell\-Id)}  
\item {\ttfamily vtk\-Unsigned\-Char\-Array = obj.\-Get\-Cell\-Types\-Array ()}  
\item {\ttfamily vtk\-Id\-Type\-Array = obj.\-Get\-Cell\-Locations\-Array ()}  
\item {\ttfamily obj.\-Squeeze ()}  
\item {\ttfamily obj.\-Initialize ()}  
\item {\ttfamily int = obj.\-Get\-Max\-Cell\-Size ()}  
\item {\ttfamily obj.\-Build\-Links ()}  
\item {\ttfamily vtk\-Cell\-Links = obj.\-Get\-Cell\-Links ()}  
\item {\ttfamily obj.\-Set\-Cells (int type, vtk\-Cell\-Array cells)} -\/ Special methods specific to vtk\-Unstructured\-Grid for defining the cells composing the dataset.  
\item {\ttfamily obj.\-Set\-Cells (int types, vtk\-Cell\-Array cells)} -\/ Special methods specific to vtk\-Unstructured\-Grid for defining the cells composing the dataset.  
\item {\ttfamily obj.\-Set\-Cells (vtk\-Unsigned\-Char\-Array cell\-Types, vtk\-Id\-Type\-Array cell\-Locations, vtk\-Cell\-Array cells)} -\/ Special methods specific to vtk\-Unstructured\-Grid for defining the cells composing the dataset.  
\item {\ttfamily vtk\-Cell\-Array = obj.\-Get\-Cells ()} -\/ Special methods specific to vtk\-Unstructured\-Grid for defining the cells composing the dataset.  
\item {\ttfamily obj.\-Remove\-Reference\-To\-Cell (vtk\-Id\-Type pt\-Id, vtk\-Id\-Type cell\-Id)} -\/ Special methods specific to vtk\-Unstructured\-Grid for defining the cells composing the dataset.  
\item {\ttfamily obj.\-Add\-Reference\-To\-Cell (vtk\-Id\-Type pt\-Id, vtk\-Id\-Type cell\-Id)} -\/ Special methods specific to vtk\-Unstructured\-Grid for defining the cells composing the dataset.  
\item {\ttfamily obj.\-Resize\-Cell\-List (vtk\-Id\-Type pt\-Id, int size)} -\/ Special methods specific to vtk\-Unstructured\-Grid for defining the cells composing the dataset.  
\item {\ttfamily obj.\-Get\-Cell\-Neighbors (vtk\-Id\-Type cell\-Id, vtk\-Id\-List pt\-Ids, vtk\-Id\-List cell\-Ids)} -\/ Topological inquiry to get all cells using list of points exclusive of cell specified (e.\-g., cell\-Id). T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E I\-F F\-I\-R\-S\-T C\-A\-L\-L\-E\-D F\-R\-O\-M A S\-I\-N\-G\-L\-E T\-H\-R\-E\-A\-D A\-N\-D T\-H\-E D\-A\-T\-A\-S\-E\-T I\-S N\-O\-T M\-O\-D\-I\-F\-I\-E\-D  
\item {\ttfamily int = obj.\-Get\-Update\-Extent ()} -\/ We need this here to avoid hiding superclass method  
\item {\ttfamily obj.\-Get\-Update\-Extent (int extent\mbox{[}6\mbox{]})} -\/ We need this here to avoid hiding superclass method  
\item {\ttfamily int = obj.\-Get\-Piece ()} -\/ Set / Get the piece and the number of pieces. Similar to extent in 3\-D.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Pieces ()} -\/ Set / Get the piece and the number of pieces. Similar to extent in 3\-D.  
\item {\ttfamily int = obj.\-Get\-Ghost\-Level ()} -\/ Get the ghost level.  
\item {\ttfamily long = obj.\-Get\-Actual\-Memory\-Size ()} -\/ Return the actual size of the data in kilobytes. This number is valid only after the pipeline has updated. The memory size returned is guaranteed to be greater than or equal to the memory required to represent the data (e.\-g., extra space in arrays, etc. are not included in the return value). T\-H\-I\-S M\-E\-T\-H\-O\-D I\-S T\-H\-R\-E\-A\-D S\-A\-F\-E.  
\item {\ttfamily obj.\-Shallow\-Copy (vtk\-Data\-Object src)} -\/ Shallow and Deep copy.  
\item {\ttfamily obj.\-Deep\-Copy (vtk\-Data\-Object src)} -\/ Shallow and Deep copy.  
\item {\ttfamily obj.\-Get\-Ids\-Of\-Cells\-Of\-Type (int type, vtk\-Id\-Type\-Array array)} -\/ Fill vtk\-Id\-Type\-Array container with list of cell Ids. This method traverses all cells and, for a particular cell type, inserts the cell Id into the container.  
\item {\ttfamily int = obj.\-Is\-Homogeneous ()} -\/ Traverse cells and determine if cells are all of the same type.  
\item {\ttfamily obj.\-Remove\-Ghost\-Cells (int level)} -\/ This method will remove any cell that has a ghost level array value greater or equal to level.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkunstructuredgridalgorithm}{}\section{vtk\-Unstructured\-Grid\-Algorithm}\label{vtkfiltering_vtkunstructuredgridalgorithm}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
To create an instance of class vtk\-Unstructured\-Grid\-Algorithm, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkUnstructuredGridAlgorithm
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Unstructured\-Grid\-Algorithm has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Unstructured\-Grid\-Algorithm class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Unstructured\-Grid\-Algorithm = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Unstructured\-Grid\-Algorithm = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Unstructured\-Grid = obj.\-Get\-Output ()} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Unstructured\-Grid = obj.\-Get\-Output (int )} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily obj.\-Set\-Output (vtk\-Data\-Object d)} -\/ Get the output data object for a port on this algorithm.  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Input (int port)}  
\item {\ttfamily vtk\-Data\-Object = obj.\-Get\-Input ()}  
\item {\ttfamily vtk\-Unstructured\-Grid = obj.\-Get\-Unstructured\-Grid\-Input (int port)}  
\item {\ttfamily obj.\-Set\-Input (vtk\-Data\-Object )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Set\-Input (int , vtk\-Data\-Object )} -\/ Set an input of this algorithm. You should not override these methods because they are not the only way to connect a pipeline. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Set\-Input\-Connection(). These methods transform the input index to the input port index, not an index of a connection within a single port.  
\item {\ttfamily obj.\-Add\-Input (vtk\-Data\-Object )} -\/ Add an input of this algorithm. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Add\-Input\-Connection(). See Set\-Input() for details.  
\item {\ttfamily obj.\-Add\-Input (int , vtk\-Data\-Object )} -\/ Add an input of this algorithm. Note that these methods support old-\/style pipeline connections. When writing new code you should use the more general vtk\-Algorithm\-::\-Add\-Input\-Connection(). See Set\-Input() for details.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkunstructuredgridsource}{}\section{vtk\-Unstructured\-Grid\-Source}\label{vtkfiltering_vtkunstructuredgridsource}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Unstructured\-Grid\-Source is an abstract class whose subclasses generate unstructured grid data.

To create an instance of class vtk\-Unstructured\-Grid\-Source, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkUnstructuredGridSource
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Unstructured\-Grid\-Source has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Unstructured\-Grid\-Source class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Unstructured\-Grid\-Source = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Unstructured\-Grid\-Source = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily vtk\-Unstructured\-Grid = obj.\-Get\-Output ()} -\/ Get the output of this source.  
\item {\ttfamily vtk\-Unstructured\-Grid = obj.\-Get\-Output (int idx)} -\/ Get the output of this source.  
\item {\ttfamily obj.\-Set\-Output (vtk\-Unstructured\-Grid output)} -\/ Get the output of this source.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkunstructuredgridtopolydatafilter}{}\section{vtk\-Unstructured\-Grid\-To\-Poly\-Data\-Filter}\label{vtkfiltering_vtkunstructuredgridtopolydatafilter}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Unstructured\-Grid\-To\-Poly\-Data\-Filter is an abstract filter class whose subclasses take as input datasets of type vtk\-Unstructured\-Grid and generate polygonal data on output.

To create an instance of class vtk\-Unstructured\-Grid\-To\-Poly\-Data\-Filter, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkUnstructuredGridToPolyDataFilter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Unstructured\-Grid\-To\-Poly\-Data\-Filter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Unstructured\-Grid\-To\-Poly\-Data\-Filter class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Unstructured\-Grid\-To\-Poly\-Data\-Filter = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Unstructured\-Grid\-To\-Poly\-Data\-Filter = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Input (vtk\-Unstructured\-Grid input)} -\/ Set / get the input data or filter.  
\item {\ttfamily vtk\-Unstructured\-Grid = obj.\-Get\-Input ()} -\/ Set / get the input data or filter.  
\item {\ttfamily obj.\-Compute\-Input\-Update\-Extents (vtk\-Data\-Object output)} -\/ Do not let datasets return more than requested.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkunstructuredgridtounstructuredgridfilter}{}\section{vtk\-Unstructured\-Grid\-To\-Unstructured\-Grid\-Filter}\label{vtkfiltering_vtkunstructuredgridtounstructuredgridfilter}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
To create an instance of class vtk\-Unstructured\-Grid\-To\-Unstructured\-Grid\-Filter, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkUnstructuredGridToUnstructuredGridFilter
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Unstructured\-Grid\-To\-Unstructured\-Grid\-Filter has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Unstructured\-Grid\-To\-Unstructured\-Grid\-Filter class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Unstructured\-Grid\-To\-Unstructured\-Grid\-Filter = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Unstructured\-Grid\-To\-Unstructured\-Grid\-Filter = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Input (vtk\-Unstructured\-Grid input)} -\/ Set / get the input Grid or filter.  
\item {\ttfamily vtk\-Unstructured\-Grid = obj.\-Get\-Input ()} -\/ Set / get the input Grid or filter.  
\item {\ttfamily int = obj.\-Fill\-Input\-Port\-Information (int , vtk\-Information )}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkvertex}{}\section{vtk\-Vertex}\label{vtkfiltering_vtkvertex}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Vertex is a concrete implementation of vtk\-Cell to represent a 3\-D point.

To create an instance of class vtk\-Vertex, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkVertex
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Vertex has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Vertex class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Vertex = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Vertex = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int )} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int )} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Clip (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array pts, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd, int inside\-Out)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)} -\/ Given parametric coordinates of a point, return the closest cell boundary, and whether the point is inside or outside of the cell. The cell boundary is defined by a list of points (pts) that specify a vertex (1\-D cell). If the return value of the method is != 0, then the point is inside the cell.  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts1, vtk\-Cell\-Array lines, vtk\-Cell\-Array verts2, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)} -\/ Generate contouring primitives. The scalar list cell\-Scalars are scalar values at each cell point. The point locator is essentially a points list that merges points as they are inserted (i.\-e., prevents duplicates).  
\item {\ttfamily int = obj.\-Get\-Parametric\-Center (double pcoords\mbox{[}3\mbox{]})} -\/ Return the center of the triangle in parametric coordinates.  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)} -\/ Triangulate the vertex. This method fills pts and pt\-Ids with information from the only point in the vertex.  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)} -\/ Get the derivative of the vertex. Returns (0.\-0, 0.\-0, 0.\-0) for all dimensions.  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double weights\mbox{[}1\mbox{]})} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs\mbox{[}3\mbox{]})}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkvertexlistiterator}{}\section{vtk\-Vertex\-List\-Iterator}\label{vtkfiltering_vtkvertexlistiterator}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Vertex\-List\-Iterator iterates through all vertices in a graph. Create an instance of this and call graph-\/$>$Get\-Vertices(it) to initialize this iterator. You may alternately call Set\-Graph() to initialize the iterator.

To create an instance of class vtk\-Vertex\-List\-Iterator, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkVertexListIterator
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Vertex\-List\-Iterator has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Vertex\-List\-Iterator class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Vertex\-List\-Iterator = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Vertex\-List\-Iterator = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Set\-Graph (vtk\-Graph graph)} -\/ Setup the iterator with a graph.  
\item {\ttfamily vtk\-Graph = obj.\-Get\-Graph ()} -\/ Get the graph associated with this iterator.  
\item {\ttfamily vtk\-Id\-Type = obj.\-Next ()} -\/ Whether this iterator has more edges.  
\item {\ttfamily bool = obj.\-Has\-Next ()}  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkviewdependenterrormetric}{}\section{vtk\-View\-Dependent\-Error\-Metric}\label{vtkfiltering_vtkviewdependenterrormetric}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
It is a concrete error metric, based on a geometric criterium in the screen space\-: the variation of the projected edge from a projected straight line

To create an instance of class vtk\-View\-Dependent\-Error\-Metric, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkViewDependentErrorMetric
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-View\-Dependent\-Error\-Metric has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-View\-Dependent\-Error\-Metric class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()} -\/ Standard V\-T\-K type and error macros.  
\item {\ttfamily int = obj.\-Is\-A (string name)} -\/ Standard V\-T\-K type and error macros.  
\item {\ttfamily vtk\-View\-Dependent\-Error\-Metric = obj.\-New\-Instance ()} -\/ Standard V\-T\-K type and error macros.  
\item {\ttfamily vtk\-View\-Dependent\-Error\-Metric = obj.\-Safe\-Down\-Cast (vtk\-Object o)} -\/ Standard V\-T\-K type and error macros.  
\item {\ttfamily double = obj.\-Get\-Pixel\-Tolerance ()} -\/ Return the squared screen-\/based geometric accurary measured in pixels. An accuracy less or equal to 0.\-25 (0.\-5$^\wedge$2) ensures that the screen-\/space interpolation of a mid-\/point matchs exactly with the projection of the mid-\/point (a value less than 1 but greater than 0.\-25 is not enough, because of 8-\/neighbors). Maybe it is useful for lower accuracy in case of anti-\/aliasing? \begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$0  
\end{DoxyPostcond}

\item {\ttfamily obj.\-Set\-Pixel\-Tolerance (double value)} -\/ Set the squared screen-\/based geometric accuracy measured in pixels. Subdivision will be required if the square distance between the projection of the real point and the straight line passing through the projection of the vertices of the edge is greater than `value'. For instance, 0.\-25 will give better result than 1. \begin{DoxyPrecond}{Precondition}
positive\-\_\-value\-: value$>$0  
\end{DoxyPrecond}

\item {\ttfamily vtk\-Viewport = obj.\-Get\-Viewport ()} -\/ Set/\-Get the renderer with `renderer' on which the error metric is based. The error metric use the active camera of the renderer.  
\item {\ttfamily obj.\-Set\-Viewport (vtk\-Viewport viewport)} -\/ Set/\-Get the renderer with `renderer' on which the error metric is based. The error metric use the active camera of the renderer.  
\item {\ttfamily int = obj.\-Requires\-Edge\-Subdivision (double left\-Point, double mid\-Point, double right\-Point, double alpha)} -\/ Does the edge need to be subdivided according to the distance between the line passing through its endpoints in screen space and the projection of its mid point? The edge is defined by its `left\-Point' and its `right\-Point'. `left\-Point', `mid\-Point' and `right\-Point' have to be initialized before calling Requires\-Edge\-Subdivision(). Their format is global coordinates, parametric coordinates and point centered attributes\-: xyx rst abc de... `alpha' is the normalized abscissa of the midpoint along the edge. (close to 0 means close to the left point, close to 1 means close to the right point) \begin{DoxyPrecond}{Precondition}
left\-Point\-\_\-exists\-: left\-Point!=0 

mid\-Point\-\_\-exists\-: mid\-Point!=0 

right\-Point\-\_\-exists\-: right\-Point!=0 

clamped\-\_\-alpha\-: alpha$>$0 \&\& alpha$<$1 

valid\-\_\-size\-: sizeof(left\-Point)=sizeof(mid\-Point)=sizeof(right\-Point) =Get\-Attribute\-Collection()-\/$>$Get\-Number\-Of\-Point\-Centered\-Components()+6  
\end{DoxyPrecond}

\item {\ttfamily double = obj.\-Get\-Error (double left\-Point, double mid\-Point, double right\-Point, double alpha)} -\/ Return the error at the mid-\/point. The type of error depends on the state of the concrete error metric. For instance, it can return an absolute or relative error metric. See Requires\-Edge\-Subdivision() for a description of the arguments. \begin{DoxyPrecond}{Precondition}
left\-Point\-\_\-exists\-: left\-Point!=0 

mid\-Point\-\_\-exists\-: mid\-Point!=0 

right\-Point\-\_\-exists\-: right\-Point!=0 

clamped\-\_\-alpha\-: alpha$>$0 \&\& alpha$<$1 

valid\-\_\-size\-: sizeof(left\-Point)=sizeof(mid\-Point)=sizeof(right\-Point) =Get\-Attribute\-Collection()-\/$>$Get\-Number\-Of\-Point\-Centered\-Components()+6 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
positive\-\_\-result\-: result$>$=0  
\end{DoxyPostcond}

\end{DoxyItemize}\hypertarget{vtkfiltering_vtkviewport}{}\section{vtk\-Viewport}\label{vtkfiltering_vtkviewport}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Viewport provides an abstract specification for Viewports. A Viewport is an object that controls the rendering process for objects. Rendering is the process of converting geometry, a specification for lights, and a camera view into an image. vtk\-Viewport also performs coordinate transformation between world coordinates, view coordinates (the computer graphics rendering coordinate system), and display coordinates (the actual screen coordinates on the display device). Certain advanced rendering features such as two-\/sided lighting can also be controlled.

To create an instance of class vtk\-Viewport, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkViewport
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Viewport has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Viewport class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Viewport = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Viewport = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily obj.\-Add\-View\-Prop (vtk\-Prop )} -\/ Add a prop to the list of props. Prop is the superclass of all actors, volumes, 2\-D actors, composite props etc.  
\item {\ttfamily vtk\-Prop\-Collection = obj.\-Get\-View\-Props ()} -\/ Return any props in this viewport.  
\item {\ttfamily int = obj.\-Has\-View\-Prop (vtk\-Prop )} -\/ Query if a prop is in the list of props.  
\item {\ttfamily obj.\-Remove\-View\-Prop (vtk\-Prop )} -\/ Remove an actor from the list of actors.  
\item {\ttfamily obj.\-Remove\-All\-View\-Props (void )} -\/ Remove all actors from the list of actors.  
\item {\ttfamily obj.\-Add\-Actor2\-D (vtk\-Prop p)} -\/ Add/\-Remove different types of props to the renderer. These methods are all synonyms to Add\-View\-Prop and Remove\-View\-Prop. They are here for convenience and backwards compatibility.  
\item {\ttfamily obj.\-Remove\-Actor2\-D (vtk\-Prop p)} -\/ Add/\-Remove different types of props to the renderer. These methods are all synonyms to Add\-View\-Prop and Remove\-View\-Prop. They are here for convenience and backwards compatibility.  
\item {\ttfamily vtk\-Actor2\-D\-Collection = obj.\-Get\-Actors2\-D ()} -\/ Add/\-Remove different types of props to the renderer. These methods are all synonyms to Add\-View\-Prop and Remove\-View\-Prop. They are here for convenience and backwards compatibility.  
\item {\ttfamily obj.\-Set\-Background (double , double , double )} -\/ Set/\-Get the background color of the rendering screen using an rgb color specification.  
\item {\ttfamily obj.\-Set\-Background (double a\mbox{[}3\mbox{]})} -\/ Set/\-Get the background color of the rendering screen using an rgb color specification.  
\item {\ttfamily double = obj. Get\-Background ()} -\/ Set/\-Get the background color of the rendering screen using an rgb color specification.  
\item {\ttfamily obj.\-Set\-Background2 (double , double , double )} -\/ Set/\-Get the second background color of the rendering screen for gradient backgrounds using an rgb color specification.  
\item {\ttfamily obj.\-Set\-Background2 (double a\mbox{[}3\mbox{]})} -\/ Set/\-Get the second background color of the rendering screen for gradient backgrounds using an rgb color specification.  
\item {\ttfamily double = obj. Get\-Background2 ()} -\/ Set/\-Get the second background color of the rendering screen for gradient backgrounds using an rgb color specification.  
\item {\ttfamily obj.\-Set\-Gradient\-Background (bool )} -\/ Set/\-Get whether this viewport should have a gradient background using the Background (top) and Background2 (bottom) colors. Default is off.  
\item {\ttfamily bool = obj.\-Get\-Gradient\-Background ()} -\/ Set/\-Get whether this viewport should have a gradient background using the Background (top) and Background2 (bottom) colors. Default is off.  
\item {\ttfamily obj.\-Gradient\-Background\-On ()} -\/ Set/\-Get whether this viewport should have a gradient background using the Background (top) and Background2 (bottom) colors. Default is off.  
\item {\ttfamily obj.\-Gradient\-Background\-Off ()} -\/ Set/\-Get whether this viewport should have a gradient background using the Background (top) and Background2 (bottom) colors. Default is off.  
\item {\ttfamily obj.\-Set\-Aspect (double , double )} -\/ Set the aspect ratio of the rendered image. This is computed automatically and should not be set by the user.  
\item {\ttfamily obj.\-Set\-Aspect (double a\mbox{[}2\mbox{]})} -\/ Set the aspect ratio of the rendered image. This is computed automatically and should not be set by the user.  
\item {\ttfamily double = obj. Get\-Aspect ()} -\/ Set the aspect ratio of the rendered image. This is computed automatically and should not be set by the user.  
\item {\ttfamily obj.\-Compute\-Aspect ()} -\/ Set the aspect ratio of the rendered image. This is computed automatically and should not be set by the user.  
\item {\ttfamily obj.\-Set\-Pixel\-Aspect (double , double )} -\/ Set the aspect ratio of a pixel in the rendered image. This factor permits the image to rendered anisotropically (i.\-e., stretched in one direction or the other).  
\item {\ttfamily obj.\-Set\-Pixel\-Aspect (double a\mbox{[}2\mbox{]})} -\/ Set the aspect ratio of a pixel in the rendered image. This factor permits the image to rendered anisotropically (i.\-e., stretched in one direction or the other).  
\item {\ttfamily double = obj. Get\-Pixel\-Aspect ()} -\/ Set the aspect ratio of a pixel in the rendered image. This factor permits the image to rendered anisotropically (i.\-e., stretched in one direction or the other).  
\item {\ttfamily obj.\-Set\-Viewport (double , double , double , double )} -\/ Specify the viewport for the Viewport to draw in the rendering window. Coordinates are expressed as (xmin,ymin,xmax,ymax), where each coordinate is 0 $<$= coordinate $<$= 1.\-0.  
\item {\ttfamily obj.\-Set\-Viewport (double a\mbox{[}4\mbox{]})} -\/ Specify the viewport for the Viewport to draw in the rendering window. Coordinates are expressed as (xmin,ymin,xmax,ymax), where each coordinate is 0 $<$= coordinate $<$= 1.\-0.  
\item {\ttfamily double = obj. Get\-Viewport ()} -\/ Specify the viewport for the Viewport to draw in the rendering window. Coordinates are expressed as (xmin,ymin,xmax,ymax), where each coordinate is 0 $<$= coordinate $<$= 1.\-0.  
\item {\ttfamily obj.\-Set\-Display\-Point (double , double , double )} -\/ Set/get a point location in display (or screen) coordinates. The lower left corner of the window is the origin and y increases as you go up the screen.  
\item {\ttfamily obj.\-Set\-Display\-Point (double a\mbox{[}3\mbox{]})} -\/ Set/get a point location in display (or screen) coordinates. The lower left corner of the window is the origin and y increases as you go up the screen.  
\item {\ttfamily double = obj. Get\-Display\-Point ()} -\/ Set/get a point location in display (or screen) coordinates. The lower left corner of the window is the origin and y increases as you go up the screen.  
\item {\ttfamily obj.\-Set\-View\-Point (double , double , double )} -\/ Specify a point location in view coordinates. The origin is in the middle of the viewport and it extends from -\/1 to 1 in all three dimensions.  
\item {\ttfamily obj.\-Set\-View\-Point (double a\mbox{[}3\mbox{]})} -\/ Specify a point location in view coordinates. The origin is in the middle of the viewport and it extends from -\/1 to 1 in all three dimensions.  
\item {\ttfamily double = obj. Get\-View\-Point ()} -\/ Specify a point location in view coordinates. The origin is in the middle of the viewport and it extends from -\/1 to 1 in all three dimensions.  
\item {\ttfamily obj.\-Set\-World\-Point (double , double , double , double )} -\/ Specify a point location in world coordinates. This method takes homogeneous coordinates.  
\item {\ttfamily obj.\-Set\-World\-Point (double a\mbox{[}4\mbox{]})} -\/ Specify a point location in world coordinates. This method takes homogeneous coordinates.  
\item {\ttfamily double = obj. Get\-World\-Point ()} -\/ Specify a point location in world coordinates. This method takes homogeneous coordinates.  
\item {\ttfamily double = obj.\-Get\-Center ()} -\/ Return the center of this viewport in display coordinates.  
\item {\ttfamily int = obj.\-Is\-In\-Viewport (int x, int y)} -\/ Is a given display point in this Viewport's viewport.  
\item {\ttfamily vtk\-Window = obj.\-Get\-V\-T\-K\-Window ()} -\/ Return the vtk\-Window that owns this vtk\-Viewport.  
\item {\ttfamily obj.\-Display\-To\-View ()} -\/ Convert display coordinates to view coordinates.  
\item {\ttfamily obj.\-View\-To\-Display ()} -\/ Convert view coordinates to display coordinates.  
\item {\ttfamily obj.\-World\-To\-View ()} -\/ Convert world point coordinates to view coordinates.  
\item {\ttfamily obj.\-View\-To\-World ()} -\/ Convert view point coordinates to world coordinates.  
\item {\ttfamily obj.\-Display\-To\-World ()} -\/ Convert display (or screen) coordinates to world coordinates.  
\item {\ttfamily obj.\-World\-To\-Display ()} -\/ Convert world point coordinates to display (or screen) coordinates.  
\item {\ttfamily int = obj.\-Get\-Size ()} -\/ Get the size and origin of the viewport in display coordinates. Note\-: if the window has not yet been realized, Get\-Size() and Get\-Origin() return (0,0).  
\item {\ttfamily int = obj.\-Get\-Origin ()} -\/ Get the size and origin of the viewport in display coordinates. Note\-: if the window has not yet been realized, Get\-Size() and Get\-Origin() return (0,0).  
\item {\ttfamily obj.\-Get\-Tiled\-Size (int width, int height)} -\/ Get the size and origin of the viewport in display coordinates. Note\-: if the window has not yet been realized, Get\-Size() and Get\-Origin() return (0,0).  
\item {\ttfamily obj.\-Get\-Tiled\-Size\-And\-Origin (int width, int height, int lower\-Left\-X, int lower\-Left\-Y)} -\/ Get the size and origin of the viewport in display coordinates. Note\-: if the window has not yet been realized, Get\-Size() and Get\-Origin() return (0,0).  
\item {\ttfamily vtk\-Assembly\-Path = obj.\-Pick\-Prop (double selection\-X, double selection\-Y)} -\/ Return the Prop that has the highest z value at the given x, y position in the viewport. Basically, the top most prop that renders the pixel at selection\-X, selection\-Y will be returned. If no Props are there N\-U\-L\-L is returned. This method selects from the Viewports Prop list.  
\item {\ttfamily vtk\-Assembly\-Path = obj.\-Pick\-Prop\-From (double selection\-X, double selection\-Y, vtk\-Prop\-Collection )} -\/ Same as Pick\-Prop with two arguments, but selects from the given collection of Props instead of the Renderers props. Make sure the Props in the collection are in this renderer.  
\item {\ttfamily double = obj.\-Get\-Pick\-X () const} -\/ Methods used to return the pick (x,y) in local display coordinates (i.\-e., it's that same as selection\-X and selection\-Y).  
\item {\ttfamily double = obj.\-Get\-Pick\-Y () const} -\/ Methods used to return the pick (x,y) in local display coordinates (i.\-e., it's that same as selection\-X and selection\-Y).  
\item {\ttfamily double = obj.\-Get\-Pick\-Width () const} -\/ Methods used to return the pick (x,y) in local display coordinates (i.\-e., it's that same as selection\-X and selection\-Y).  
\item {\ttfamily double = obj.\-Get\-Pick\-Height () const} -\/ Methods used to return the pick (x,y) in local display coordinates (i.\-e., it's that same as selection\-X and selection\-Y).  
\item {\ttfamily double = obj.\-Get\-Pick\-X1 () const} -\/ Methods used to return the pick (x,y) in local display coordinates (i.\-e., it's that same as selection\-X and selection\-Y).  
\item {\ttfamily double = obj.\-Get\-Pick\-Y1 () const} -\/ Methods used to return the pick (x,y) in local display coordinates (i.\-e., it's that same as selection\-X and selection\-Y).  
\item {\ttfamily double = obj.\-Get\-Pick\-X2 () const} -\/ Methods used to return the pick (x,y) in local display coordinates (i.\-e., it's that same as selection\-X and selection\-Y).  
\item {\ttfamily double = obj.\-Get\-Pick\-Y2 () const} -\/ Methods used to return the pick (x,y) in local display coordinates (i.\-e., it's that same as selection\-X and selection\-Y).  
\item {\ttfamily int = obj.\-Get\-Is\-Picking ()} -\/ Methods used to return the pick (x,y) in local display coordinates (i.\-e., it's that same as selection\-X and selection\-Y).  
\item {\ttfamily vtk\-Prop\-Collection = obj.\-Get\-Pick\-Result\-Props ()} -\/ Methods used to return the pick (x,y) in local display coordinates (i.\-e., it's that same as selection\-X and selection\-Y).  
\item {\ttfamily double = obj.\-Get\-Picked\-Z ()} -\/ Return the Z value for the last picked Prop.  
\item {\ttfamily obj.\-Remove\-Prop (vtk\-Prop )} -\/  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkvoxel}{}\section{vtk\-Voxel}\label{vtkfiltering_vtkvoxel}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Voxel is a concrete implementation of vtk\-Cell to represent a 3\-D orthogonal parallelepiped. Unlike vtk\-Hexahedron, vtk\-Voxel has interior angles of 90 degrees, and sides are parallel to coordinate axes. This results in large increases in computational performance.

To create an instance of class vtk\-Voxel, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkVoxel
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Voxel has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Voxel class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Voxel = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Voxel = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int edge\-Id)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int face\-Id)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double weights\mbox{[}8\mbox{]})} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs\mbox{[}24\mbox{]})} -\/ Return the ids of the vertices defining edge/face ({\ttfamily edge\-Id}/`face\-Id'). Ids are related to the cell, not to the dataset.  
\end{DoxyItemize}\hypertarget{vtkfiltering_vtkwedge}{}\section{vtk\-Wedge}\label{vtkfiltering_vtkwedge}
Section\-: \hyperlink{sec_vtkfiltering}{Visualization Toolkit Filtering Classes} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
vtk\-Wedge is a concrete implementation of vtk\-Cell to represent a linear 3\-D wedge. A wedge consists of two triangular and three quadrilateral faces and is defined by the six points (0-\/5). vtk\-Wedge uses the standard isoparametric shape functions for a linear wedge. The wedge is defined by the six points (0-\/5) where (0,1,2) is the base of the wedge which, using the right hand rule, forms a triangle whose normal points outward (away from the triangular face (3,4,5)).

To create an instance of class vtk\-Wedge, simply invoke its constructor as follows \begin{DoxyVerb}  obj = vtkWedge
\end{DoxyVerb}
 \hypertarget{vtkwidgets_vtkxyplotwidget_Methods}{}\subsection{Methods}\label{vtkwidgets_vtkxyplotwidget_Methods}
The class vtk\-Wedge has several methods that can be used. They are listed below. Note that the documentation is translated automatically from the V\-T\-K sources, and may not be completely intelligible. When in doubt, consult the V\-T\-K website. In the methods listed below, {\ttfamily obj} is an instance of the vtk\-Wedge class. 
\begin{DoxyItemize}
\item {\ttfamily string = obj.\-Get\-Class\-Name ()}  
\item {\ttfamily int = obj.\-Is\-A (string name)}  
\item {\ttfamily vtk\-Wedge = obj.\-New\-Instance ()}  
\item {\ttfamily vtk\-Wedge = obj.\-Safe\-Down\-Cast (vtk\-Object o)}  
\item {\ttfamily int = obj.\-Get\-Cell\-Type ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Cell\-Dimension ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Edges ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Number\-Of\-Faces ()} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Edge (int edge\-Id)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily vtk\-Cell = obj.\-Get\-Face (int face\-Id)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Cell\-Boundary (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, vtk\-Id\-List pts)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Contour (double value, vtk\-Data\-Array cell\-Scalars, vtk\-Incremental\-Point\-Locator locator, vtk\-Cell\-Array verts, vtk\-Cell\-Array lines, vtk\-Cell\-Array polys, vtk\-Point\-Data in\-Pd, vtk\-Point\-Data out\-Pd, vtk\-Cell\-Data in\-Cd, vtk\-Id\-Type cell\-Id, vtk\-Cell\-Data out\-Cd)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Triangulate (int index, vtk\-Id\-List pt\-Ids, vtk\-Points pts)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily obj.\-Derivatives (int sub\-Id, double pcoords\mbox{[}3\mbox{]}, double values, int dim, double derivs)} -\/ See the vtk\-Cell A\-P\-I for descriptions of these methods.  
\item {\ttfamily int = obj.\-Get\-Parametric\-Center (double pcoords\mbox{[}3\mbox{]})} -\/ Return the center of the wedge in parametric coordinates.  
\item {\ttfamily obj.\-Interpolate\-Functions (double pcoords\mbox{[}3\mbox{]}, double weights\mbox{[}6\mbox{]})} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\item {\ttfamily obj.\-Interpolate\-Derivs (double pcoords\mbox{[}3\mbox{]}, double derivs\mbox{[}18\mbox{]})} -\/ Compute the interpolation functions/derivatives (aka shape functions/derivatives)  
\end{DoxyItemize}

\begin{DoxyItemize}
\item \hyperlink{inspection_clear}{C\-L\-E\-A\-R Clear or Delete a Variable}  
\item \hyperlink{inspection_end}{E\-N\-D End Function}  
\item \hyperlink{inspection_exist}{E\-X\-I\-S\-T Test for Existence}  
\item \hyperlink{inspection_fieldnames}{F\-I\-E\-L\-D\-N\-A\-M\-E\-S Fieldnames of a Structure}  
\item \hyperlink{inspection_isa}{I\-S\-A Test Type of Variable}  
\item \hyperlink{inspection_iscell}{I\-S\-C\-E\-L\-L Test For Cell Array}  
\item \hyperlink{inspection_iscellstr}{I\-S\-C\-E\-L\-L\-S\-T\-R Test For Cell Array of Strings}  
\item \hyperlink{inspection_ischar}{I\-S\-C\-H\-A\-R Test For Character Array (string)}  
\item \hyperlink{inspection_isempty}{I\-S\-E\-M\-P\-T\-Y Test For Variable Empty}  
\item \hyperlink{inspection_isequal}{I\-S\-E\-Q\-U\-A\-L Test For Matrix Equality}  
\item \hyperlink{inspection_isequalwithequalnans}{I\-S\-E\-Q\-U\-A\-L\-W\-I\-T\-H\-E\-Q\-U\-A\-L\-N\-A\-N\-S Test For Matrix Equality}  
\item \hyperlink{inspection_isfield}{I\-S\-F\-I\-E\-L\-D Test for Existence of a Structure Field}  
\item \hyperlink{inspection_ishandle}{I\-S\-H\-A\-N\-D\-L\-E Test for Graphics Handle}  
\item \hyperlink{inspection_isinf}{I\-S\-I\-N\-F Test for infinities}  
\item \hyperlink{inspection_isinttype}{I\-S\-I\-N\-T\-T\-Y\-P\-E Test For Integer-\/type Array}  
\item \hyperlink{inspection_islogical}{I\-S\-L\-O\-G\-I\-C\-A\-L Test for Logical Array}  
\item \hyperlink{inspection_ismatrix}{I\-S\-M\-A\-T\-R\-I\-X Test For a 2\-D Matrix}  
\item \hyperlink{inspection_isnan}{I\-S\-N\-A\-N Test for Not-\/a-\/\-Numbers}  
\item \hyperlink{inspection_isnumeric}{I\-S\-N\-U\-M\-E\-R\-I\-C Test for Numeric Array}  
\item \hyperlink{inspection_isreal}{I\-S\-R\-E\-A\-L Test For Real Array}  
\item \hyperlink{inspection_issame}{I\-S\-S\-A\-M\-E Test If Two Arrays Are Identical}  
\item \hyperlink{inspection_isscalar}{I\-S\-S\-C\-A\-L\-A\-R Test For Scalar}  
\item \hyperlink{inspection_isset}{I\-S\-S\-E\-T Test If Variable Set}  
\item \hyperlink{inspection_issparse}{I\-S\-S\-P\-A\-R\-S\-E Test for Sparse Matrix}  
\item \hyperlink{inspection_issquare}{I\-S\-S\-Q\-U\-A\-R\-E Test For a Square matrix}  
\item \hyperlink{inspection_isstr}{I\-S\-S\-T\-R Test For Character Array (string)}  
\item \hyperlink{inspection_isstruct}{I\-S\-S\-T\-R\-U\-C\-T Test For Structure Array}  
\item \hyperlink{inspection_isvector}{I\-S\-V\-E\-C\-T\-O\-R Test For a Vector}  
\item \hyperlink{inspection_length}{L\-E\-N\-G\-T\-H Length of an Array}  
\item \hyperlink{inspection_maxdim}{M\-A\-X\-D\-I\-M Maximum Dimension in Array}  
\item \hyperlink{inspection_ndims}{N\-D\-I\-M\-S Number of Dimensions in Array}  
\item \hyperlink{inspection_nnz}{N\-N\-Z Number of Nonzeros}  
\item \hyperlink{inspection_numel}{N\-U\-M\-E\-L Number of Elements in an Array}  
\item \hyperlink{inspection_size}{S\-I\-Z\-E Size of a Variable}  
\item \hyperlink{inspection_typeof}{T\-Y\-P\-E\-O\-F Determine the Type of an Argument}  
\item \hyperlink{inspection_what}{W\-H\-A\-T List Free\-Mat Files In Directory}  
\item \hyperlink{inspection_where}{W\-H\-E\-R\-E Get Information on Program Stack}  
\item \hyperlink{inspection_which}{W\-H\-I\-C\-H Get Information on Function}  
\item \hyperlink{inspection_who}{W\-H\-O Describe Currently Defined Variables}  
\item \hyperlink{inspection_whos}{W\-H\-O\-S Describe Currently Defined Variables With Memory Usage}  
\end{DoxyItemize}\hypertarget{inspection_clear}{}\section{C\-L\-E\-A\-R Clear or Delete a Variable}\label{inspection_clear}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Clears a set of variables from the current context, or alternately, delete all variables defined in the current context. There are several formats for the function call. The first is the explicit form in which a list of variables are provided\-: \begin{DoxyVerb}   clear a1 a2 ...
\end{DoxyVerb}
 The variables can be persistent or global, and they will be deleted. The second form \begin{DoxyVerb}   clear 'all'
\end{DoxyVerb}
 clears all variables and libraries from the current context. Alternately, you can use the form\-: \begin{DoxyVerb}   clear 'libs'
\end{DoxyVerb}
 which will unload any libraries or D\-L\-Ls that have been {\ttfamily import}ed. Optionally, you can specify that persistent variables should be cleared via\-: \begin{DoxyVerb}   clear 'persistent'
\end{DoxyVerb}
 and similarly for global variables\-: \begin{DoxyVerb}   clear 'global'
\end{DoxyVerb}
 You can use \begin{DoxyVerb}   clear 'classes'
\end{DoxyVerb}
 to clear all definitions of user-\/defined classes. With no arguments, {\ttfamily clear} defaults to clearing {\ttfamily 'all'}. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Here is a simple example of using {\ttfamily clear} to delete a variable. First, we create a variable called {\ttfamily a}\-:


\begin{DoxyVerbInclude}
--> a = 53

a = 
 53 
\end{DoxyVerbInclude}


Next, we clear {\ttfamily a} using the {\ttfamily clear} function, and verify that it is deleted.


\begin{DoxyVerbInclude}
--> clear a
--> a
Error: Undefined function or variable a
\end{DoxyVerbInclude}
 \hypertarget{inspection_end}{}\section{E\-N\-D End Function}\label{inspection_end}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Computes the size of a variable along a given dimension. The syntax for its use is \begin{DoxyVerb}   y = end(x,dim,subindexes)
\end{DoxyVerb}
 where {\ttfamily x} is the array to be analyzed, {\ttfamily dim} is the dimension along which to compute the end, and {\ttfamily subindexes} indicates how many dimensions are involved in the {\ttfamily end} calculation. \hypertarget{inspection_exist}{}\section{E\-X\-I\-S\-T Test for Existence}\label{inspection_exist}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Tests for the existence of a variable, function, directory or file. The general syntax for its use is \begin{DoxyVerb}  y = exist(item,kind)
\end{DoxyVerb}
 where {\ttfamily item} is a string containing the name of the item to look for, and {\ttfamily kind} is a string indicating the type of the search. The {\ttfamily kind} must be one of 
\begin{DoxyItemize}
\item {\ttfamily 'builtin'} checks for built-\/in functions  
\item {\ttfamily 'dir'} checks for directories  
\item {\ttfamily 'file'} checks for files  
\item {\ttfamily 'var'} checks for variables  
\item {\ttfamily 'all'} checks all possibilities (same as leaving out {\ttfamily kind})  
\end{DoxyItemize}You can also leave the {\ttfamily kind} specification out, in which case the calling syntax is \begin{DoxyVerb}  y = exist(item)
\end{DoxyVerb}
 The return code is one of the following\-: 
\begin{DoxyItemize}
\item 0 -\/ if {\ttfamily item} does not exist  
\item 1 -\/ if {\ttfamily item} is a variable in the workspace  
\item 2 -\/ if {\ttfamily item} is an M file on the search path, a full pathname to a file, or an ordinary file on your search path  
\item 5 -\/ if {\ttfamily item} is a built-\/in Free\-Mat function  
\item 7 -\/ if {\ttfamily item} is a directory  
\end{DoxyItemize}Note\-: previous to version {\ttfamily 1.\-10}, {\ttfamily exist} used a different notion of existence for variables\-: a variable was said to exist if it was defined and non-\/empty. This test is now performed by {\ttfamily isset}. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Some examples of the {\ttfamily exist} function. Note that generally {\ttfamily exist} is used in functions to test for keywords. For example, \begin{DoxyVerb}  function y = testfunc(a, b, c)
  if (~exist('c'))
    % c was not defined, so establish a default
    c = 13;
  end
  y = a + b + c;
\end{DoxyVerb}
 An example of {\ttfamily exist} in action.


\begin{DoxyVerbInclude}
--> a = randn(3,5,2)

a = 

(:,:,1) = 
    0.7785    0.6357    1.7582    1.5784   -0.8470 
    0.7235    1.0468   -0.6919   -0.6796    0.4767 
    0.2100    0.0865    1.5704   -0.1267    2.1381 

(:,:,2) = 
    1.5525   -0.2908   -1.4220    1.1076    0.2419 
    0.1652   -0.5668   -0.8018   -0.5975    0.8483 
    0.3147   -0.1109   -0.5203    0.5851    1.1503 

--> b = []

b = 
  []
--> who
  Variable Name       Type   Flags             Size
              a    double                    [3x5x2]
              b    double                    [0x0]
--> exist('a')

ans = 
 1 

--> exist('b')

ans = 
 1 

--> exist('c')

ans = 
 0 
\end{DoxyVerbInclude}
 \hypertarget{inspection_fieldnames}{}\section{F\-I\-E\-L\-D\-N\-A\-M\-E\-S Fieldnames of a Structure}\label{inspection_fieldnames}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Returns a cell array containing the names of the fields in a structure array. The syntax for its use is \begin{DoxyVerb}   x = fieldnames(y)
\end{DoxyVerb}
 where {\ttfamily y} is a structure array of object array. The result is a cell array, with one entry per field in {\ttfamily y}. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
We define a simple structure array\-:


\begin{DoxyVerbInclude}
--> y.foo = 3; y.goo = 'hello';
--> x = fieldnames(y)

x = 
 [foo] 
 [goo] 
\end{DoxyVerbInclude}
 \hypertarget{inspection_isa}{}\section{I\-S\-A Test Type of Variable}\label{inspection_isa}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Tests the type of a variable. The syntax for its use is \begin{DoxyVerb}   y = isa(x,type)
\end{DoxyVerb}
 where {\ttfamily x} is the variable to test, and {\ttfamily type} is the type. Supported built-\/in types are 
\begin{DoxyItemize}
\item {\ttfamily 'cell'} for cell-\/arrays  
\item {\ttfamily 'struct'} for structure-\/arrays  
\item {\ttfamily 'logical'} for logical arrays  
\item {\ttfamily 'uint8'} for unsigned 8-\/bit integers  
\item {\ttfamily 'int8'} for signed 8-\/bit integers  
\item {\ttfamily 'uint16'} for unsigned 16-\/bit integers  
\item {\ttfamily 'int16'} for signed 16-\/bit integers  
\item {\ttfamily 'uint32'} for unsigned 32-\/bit integers  
\item {\ttfamily 'int32'} for signed 32-\/bit integers  
\item {\ttfamily 'uint64'} for unsigned 64-\/bit integers  
\item {\ttfamily 'int64'} for signed 64-\/bit integers  
\item {\ttfamily 'single'} for 32-\/bit floating point numbers  
\item {\ttfamily 'double'} for 64-\/bit floating point numbers  
\item {\ttfamily 'char'} for string arrays  
\end{DoxyItemize}If the argument is a user-\/defined type (via the {\ttfamily class} function), then the name of that class is returned. \hypertarget{variables_matrix_Examples}{}\subsection{Examples}\label{variables_matrix_Examples}
Here are some examples of the {\ttfamily isa} call.


\begin{DoxyVerbInclude}
--> a = {1}

a = 
 [1] 

--> isa(a,'char')

ans = 
 0 

--> isa(a,'cell')

ans = 
 1 
\end{DoxyVerbInclude}


Here we use {\ttfamily isa} along with shortcut boolean evaluation to safely determine if a variable contains the string {\ttfamily 'hello'}


\begin{DoxyVerbInclude}
--> a = 'hello'

a = 
hello
--> isa(a,'char') && strcmp(a,'hello')

ans = 
 1 
\end{DoxyVerbInclude}
 \hypertarget{inspection_iscell}{}\section{I\-S\-C\-E\-L\-L Test For Cell Array}\label{inspection_iscell}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The syntax for {\ttfamily iscell} is \begin{DoxyVerb}   x = iscell(y)
\end{DoxyVerb}
 and it returns a logical 1 if the argument is a cell array and a logical 0 otherwise. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Here are some examples of {\ttfamily iscell}


\begin{DoxyVerbInclude}
--> iscell('foo')

ans = 
 0 

--> iscell(2)

ans = 
 0 

--> iscell({1,2,3})

ans = 
 1 
\end{DoxyVerbInclude}
 \hypertarget{inspection_iscellstr}{}\section{I\-S\-C\-E\-L\-L\-S\-T\-R Test For Cell Array of Strings}\label{inspection_iscellstr}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The syntax for {\ttfamily iscellstr} is \begin{DoxyVerb}   x = iscellstr(y)
\end{DoxyVerb}
 and it returns a logical 1 if the argument is a cell array in which every cell is a character array (or is empty), and a logical 0 otherwise. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Here is a simple example


\begin{DoxyVerbInclude}
--> A = {'Hello','Yellow';'Mellow','Othello'}

A = 
 [Hello] [Yellow] 
 [Mellow] [Othello] 

--> iscellstr(A)

ans = 
 1 
\end{DoxyVerbInclude}
 \hypertarget{inspection_ischar}{}\section{I\-S\-C\-H\-A\-R Test For Character Array (string)}\label{inspection_ischar}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The syntax for {\ttfamily ischar} is \begin{DoxyVerb}   x = ischar(y)
\end{DoxyVerb}
 and it returns a logical 1 if the argument is a string and a logical 0 otherwise. \hypertarget{inspection_isempty}{}\section{I\-S\-E\-M\-P\-T\-Y Test For Variable Empty}\label{inspection_isempty}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The {\ttfamily isempty} function returns a boolean that indicates if the argument variable is empty or not. The general syntax for its use is \begin{DoxyVerb}  y = isempty(x).
\end{DoxyVerb}
 \hypertarget{variables_matrix_Examples}{}\subsection{Examples}\label{variables_matrix_Examples}
Here are some examples of the {\ttfamily isempty} function


\begin{DoxyVerbInclude}
--> a = []

a = 
  []
--> isempty(a)

ans = 
 1 

--> b = 1:3

b = 
 1 2 3 

--> isempty(b)

ans = 
 0 
\end{DoxyVerbInclude}


Note that if the variable is not defined, {\ttfamily isempty} does not return true.


\begin{DoxyVerbInclude}
--> clear x
--> isempty(x)
Error: Undefined function or variable x
\end{DoxyVerbInclude}
 \hypertarget{inspection_isequal}{}\section{I\-S\-E\-Q\-U\-A\-L Test For Matrix Equality}\label{inspection_isequal}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Test two arrays for equality. The general format for its use is \begin{DoxyVerb}   y = isequal(a,b)
\end{DoxyVerb}
 This function returns true if the two arrays are equal (compared element-\/wise). Unlike {\ttfamily issame} the {\ttfamily isequal} function will type convert where possible to do the comparison. \hypertarget{inspection_isequalwithequalnans}{}\section{I\-S\-E\-Q\-U\-A\-L\-W\-I\-T\-H\-E\-Q\-U\-A\-L\-N\-A\-N\-S Test For Matrix Equality}\label{inspection_isequalwithequalnans}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Test two arrays for equality, with Na\-Ns being equal. The general format for its use is \begin{DoxyVerb}   y = isequalwithequalnans(a,b)
\end{DoxyVerb}
 This function returns true if the two arrays are equal (compared element-\/wise). Unlike {\ttfamily issame} the {\ttfamily isequalwithequalnans} function will type convert where possible to do the comparison. \hypertarget{inspection_isfield}{}\section{I\-S\-F\-I\-E\-L\-D Test for Existence of a Structure Field}\label{inspection_isfield}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Given a structure array, tests to see if that structure array contains a field with the given name. The syntax for its use is \begin{DoxyVerb}  y = isfield(x,field)
\end{DoxyVerb}
 and returns a logical {\ttfamily 1} if {\ttfamily x} has a field with the name {\ttfamily field} and a logical {\ttfamily 0} if not. It also returns a logical {\ttfamily 0} if the argument {\ttfamily x} is not a structure array. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Here we define a simple struct, and then test for some fields


\begin{DoxyVerbInclude}
--> a.foo = 32

a = 
    foo: 32
--> a.goo = 64

a = 
    foo: 32
    goo: 64
--> isfield(a,'goo')

ans = 
 1 

--> isfield(a,'got')

ans = 
 0 

--> isfield(pi,'round')

ans = 
 0 
\end{DoxyVerbInclude}
 \hypertarget{inspection_ishandle}{}\section{I\-S\-H\-A\-N\-D\-L\-E Test for Graphics Handle}\label{inspection_ishandle}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Given a constant, this routine will test to see if the constant is a valid graphics handle or not. The syntax for its use is \begin{DoxyVerb}  y = ishandle(h,type)
\end{DoxyVerb}
 and returns a logical {\ttfamily 1} if {\ttfamily x} is a handle of type {\ttfamily type} and a logical {\ttfamily 0} if not. \hypertarget{inspection_isinf}{}\section{I\-S\-I\-N\-F Test for infinities}\label{inspection_isinf}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Returns true for entries of an array that are infs (i.\-e., infinities). The usage is \begin{DoxyVerb}   y = isinf(x)
\end{DoxyVerb}
 The result is a logical array of the same size as {\ttfamily x}, which is true if {\ttfamily x} is not-\/a-\/number, and false otherwise. Note that for {\ttfamily complex} or {\ttfamily dcomplex} data types that the result is true if either the real or imaginary parts are infinite. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Suppose we have an array of floats with one element that is {\ttfamily inf}\-:


\begin{DoxyVerbInclude}
--> a = [1.2 3.4 inf 5]

a = 
    1.2000    3.4000 Inf    5.0000 

--> isinf(a)

ans = 
 0 0 1 0 

--> b = 3./[2 5 0 3 1]

b = 
    1.5000    0.6000 Inf    1.0000    3.0000 
\end{DoxyVerbInclude}
 \hypertarget{inspection_isinttype}{}\section{I\-S\-I\-N\-T\-T\-Y\-P\-E Test For Integer-\/type Array}\label{inspection_isinttype}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The syntax for {\ttfamily isinttype} is \begin{DoxyVerb}   x = isinttype(y)
\end{DoxyVerb}
 and it returns a logical 1 if the argument is an integer type and a logical 0 otherwise. Note that this function only tests the type of the variable, not the value. So if, for example, {\ttfamily y} is a {\ttfamily float} array containing all integer values, it will still return a logical 0. \hypertarget{inspection_islogical}{}\section{I\-S\-L\-O\-G\-I\-C\-A\-L Test for Logical Array}\label{inspection_islogical}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The syntax for {\ttfamily islogical} is \begin{DoxyVerb}   x = islogical(y)
\end{DoxyVerb}
 and it returns a logical 1 if the argument is a logical array and a logical 0 otherwise. \hypertarget{inspection_ismatrix}{}\section{I\-S\-M\-A\-T\-R\-I\-X Test For a 2\-D Matrix}\label{inspection_ismatrix}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This function tests to see if the argument is a matrix. The syntax for {\ttfamily ismatrix} is \begin{DoxyVerb}   x = ismatrix(y)
\end{DoxyVerb}
 and it returns a logical 1 if the argument is size {\ttfamily N x M} or {\ttfamily M x N} and a logical 0 otherwise. \hypertarget{inspection_isnan}{}\section{I\-S\-N\-A\-N Test for Not-\/a-\/\-Numbers}\label{inspection_isnan}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Returns true for entries of an array that are Na\-N's (i.\-e., Not-\/a-\/\-Numbers). The usage is \begin{DoxyVerb}   y = isnan(x)
\end{DoxyVerb}
 The result is a logical array of the same size as {\ttfamily x}, which is true if {\ttfamily x} is not-\/a-\/number, and false otherwise. Note that for complex data types that the result is true if either the real or imaginary parts are Na\-Ns. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Suppose we have an array of floats with one element that is {\ttfamily nan}\-:


\begin{DoxyVerbInclude}
--> a = [1.2 3.4 nan 5]

a = 
    1.2000    3.4000 NaN    5.0000 

--> isnan(a)

ans = 
 0 0 1 0 
\end{DoxyVerbInclude}
 \hypertarget{inspection_isnumeric}{}\section{I\-S\-N\-U\-M\-E\-R\-I\-C Test for Numeric Array}\label{inspection_isnumeric}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The syntax for {\ttfamily isnumeric} is \begin{DoxyVerb}  x = isnumeric(y)
\end{DoxyVerb}
 and it returns a logical 1 if the argument is a numeric (i.\-e., not a structure array, cell array, string or user defined class), and a logical 0 otherwise. \hypertarget{inspection_isreal}{}\section{I\-S\-R\-E\-A\-L Test For Real Array}\label{inspection_isreal}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The syntax for {\ttfamily isreal} is \begin{DoxyVerb}   x = isreal(y)
\end{DoxyVerb}
 and it returns a logical 1 if the argument is real valued and a logical 0 otherwise. \hypertarget{inspection_issame}{}\section{I\-S\-S\-A\-M\-E Test If Two Arrays Are Identical}\label{inspection_issame}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Tests for two arrays to be identical. The syntax for its use is \begin{DoxyVerb}   y = issame(a,b)
\end{DoxyVerb}
 where {\ttfamily a} and {\ttfamily b} are two arrays to compare. This comparison succeeds only if {\ttfamily a} and {\ttfamily b} are of the same data type, size, and contents. Unlike numerical equivalence tests, the {\ttfamily issame} function considers {\ttfamily Na\-N} to be equal in both arguments. \hypertarget{inspection_isscalar}{}\section{I\-S\-S\-C\-A\-L\-A\-R Test For Scalar}\label{inspection_isscalar}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The syntax for {\ttfamily isscalar} is \begin{DoxyVerb}   x = isscalar(y)
\end{DoxyVerb}
 and it returns a logical 1 if the argument is a scalar, and a logical 0 otherwise. \hypertarget{inspection_isset}{}\section{I\-S\-S\-E\-T Test If Variable Set}\label{inspection_isset}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Tests for the existence and non-\/emptiness of a variable. the general syntax for its use is \begin{DoxyVerb}   y = isset('name')
\end{DoxyVerb}
 where {\ttfamily name} is the name of the variable to test. This is functionally equivalent to \begin{DoxyVerb}   y = exist('name','var') & ~isempty(name)
\end{DoxyVerb}
 It returns a {\ttfamily logical} 1 if the variable is defined in the current workspace, and is not empty, and returns a 0 otherwise. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Some simple examples of using {\ttfamily isset}


\begin{DoxyVerbInclude}
--> who
  Variable Name       Type   Flags             Size
--> isset('a')

ans = 
 0 

--> a = [];
--> isset('a')

ans = 
 0 

--> a = 2;
--> isset('a')

ans = 
 1 
\end{DoxyVerbInclude}
 \hypertarget{inspection_issparse}{}\section{I\-S\-S\-P\-A\-R\-S\-E Test for Sparse Matrix}\label{inspection_issparse}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Test a matrix to see if it is sparse or not. The general format for its use is \begin{DoxyVerb}   y = issparse(x)
\end{DoxyVerb}
 This function returns true if {\ttfamily x} is encoded as a sparse matrix, and false otherwise. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Here is an example of using {\ttfamily issparse}\-:


\begin{DoxyVerbInclude}
--> a = [1,0,0,5;0,3,2,0]

a = 
 1 0 0 5 
 0 3 2 0 

--> issparse(a)

ans = 
 0 

--> A = sparse(a)

A = 
 1 1 1
 2 2 3
 2 3 2
 1 4 5
--> issparse(A)

ans = 
 1 
\end{DoxyVerbInclude}
 \hypertarget{inspection_issquare}{}\section{I\-S\-S\-Q\-U\-A\-R\-E Test For a Square matrix}\label{inspection_issquare}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This function tests to see if the argument is a square matrix. The syntax for {\ttfamily issquare} is \begin{DoxyVerb}   x = issquare(y)
\end{DoxyVerb}
 and it returns a logical 1 if the argument is size {\ttfamily N x N} logical 0 otherwise. \hypertarget{inspection_isstr}{}\section{I\-S\-S\-T\-R Test For Character Array (string)}\label{inspection_isstr}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The syntax for {\ttfamily isstr} is \begin{DoxyVerb}   x = isstr(y)
\end{DoxyVerb}
 and it returns a logical 1 if the argument is a string and a logical 0 otherwise. \hypertarget{inspection_isstruct}{}\section{I\-S\-S\-T\-R\-U\-C\-T Test For Structure Array}\label{inspection_isstruct}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The syntax for {\ttfamily isstruct} is \begin{DoxyVerb}   x = isstruct(y)
\end{DoxyVerb}
 and it returns a logical 1 if the argument is a structure array, and a logical 0 otherwise. \hypertarget{inspection_isvector}{}\section{I\-S\-V\-E\-C\-T\-O\-R Test For a Vector}\label{inspection_isvector}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
This function tests to see if the argument is a vector. The syntax for {\ttfamily isvector} is \begin{DoxyVerb}   x = isvector(y)
\end{DoxyVerb}
 and it returns a logical 1 if the argument is size {\ttfamily N x 1} or {\ttfamily 1 x N} and a logical 0 otherwise. \hypertarget{inspection_length}{}\section{L\-E\-N\-G\-T\-H Length of an Array}\label{inspection_length}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Returns the length of an array {\ttfamily x}. The syntax for its use is \begin{DoxyVerb}   y = length(x)
\end{DoxyVerb}
 and is defined as the maximum length of {\ttfamily x} along any of its dimensions, i.\-e., {\ttfamily max(size(x))}. If you want to determine the number of elements in {\ttfamily x}, use the {\ttfamily numel} function instead. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
For a {\ttfamily 4 x 4 x 3} matrix, the length is {\ttfamily 4}, not {\ttfamily 48}, as you might expect.


\begin{DoxyVerbInclude}
--> x = rand(4,4,3);
--> length(x)

ans = 
 4 
\end{DoxyVerbInclude}
 \hypertarget{inspection_maxdim}{}\section{M\-A\-X\-D\-I\-M Maximum Dimension in Array}\label{inspection_maxdim}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The {\ttfamily maxdim} function returns the lowest order dimension along which an array is largest. The general syntax for its use is \begin{DoxyVerb}  n = maxdim(x)
\end{DoxyVerb}
 and is equivalent to min(find(size(x) == max(size(x)))). \hypertarget{inspection_ndims}{}\section{N\-D\-I\-M\-S Number of Dimensions in Array}\label{inspection_ndims}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The {\ttfamily ndims} function returns the number of dimensions allocated in an array. The general syntax for its use is \begin{DoxyVerb}  n = ndims(x)
\end{DoxyVerb}
 and is equivalent to {\ttfamily length(size(x))}. \hypertarget{inspection_nnz}{}\section{N\-N\-Z Number of Nonzeros}\label{inspection_nnz}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Returns the number of nonzero elements in a matrix. The general format for its use is \begin{DoxyVerb}   y = nnz(x)
\end{DoxyVerb}
 This function returns the number of nonzero elements in a matrix or array. This function works for both sparse and non-\/sparse arrays. For \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}

\begin{DoxyVerbInclude}
--> a = [1,0,0,5;0,3,2,0]

a = 
 1 0 0 5 
 0 3 2 0 

--> nnz(a)

ans = 
 4 

--> A = sparse(a)

A = 
 1 1 1
 2 2 3
 2 3 2
 1 4 5
--> nnz(A)

ans = 
 4 
\end{DoxyVerbInclude}
 \hypertarget{inspection_numel}{}\section{N\-U\-M\-E\-L Number of Elements in an Array}\label{inspection_numel}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Returns the number of elements in an array {\ttfamily x}, or in a subindex expression. The syntax for its use is either \begin{DoxyVerb}   y = numel(x)
\end{DoxyVerb}
 or \begin{DoxyVerb}   y = numel(x,varargin)
\end{DoxyVerb}
 Generally, {\ttfamily numel} returns {\ttfamily prod(size(x))}, the number of total elements in {\ttfamily x}. However, you can specify a number of indexing expressions for {\ttfamily varagin} such as {\ttfamily index1, index2, ..., indexm}. In that case, the output of {\ttfamily numel} is {\ttfamily prod(size(x(index1,...,indexm)))}. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
For a {\ttfamily 4 x 4 x 3} matrix, the length is {\ttfamily 4}, not {\ttfamily 48}, as you might expect, but {\ttfamily numel} is {\ttfamily 48}.


\begin{DoxyVerbInclude}
--> x = rand(4,4,3);
--> length(x)

ans = 
 4 

--> numel(x)

ans = 
 48 
\end{DoxyVerbInclude}


Here is an example of using {\ttfamily numel} with indexing expressions.


\begin{DoxyVerbInclude}
--> numel(x,1:3,1:2,2)

ans = 
 6 
\end{DoxyVerbInclude}
 \hypertarget{inspection_size}{}\section{S\-I\-Z\-E Size of a Variable}\label{inspection_size}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Returns the size of a variable. There are two syntaxes for its use. The first syntax returns the size of the array as a vector of integers, one integer for each dimension \begin{DoxyVerb}  [d1,d2,...,dn] = size(x)
\end{DoxyVerb}
 The other format returns the size of {\ttfamily x} along a particular dimension\-: \begin{DoxyVerb}  d = size(x,n)
\end{DoxyVerb}
 where {\ttfamily n} is the dimension along which to return the size. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}

\begin{DoxyVerbInclude}
--> a = randn(23,12,5);
--> size(a)

ans = 
 23 12  5 
\end{DoxyVerbInclude}


Here is an example of the second form of {\ttfamily size}.


\begin{DoxyVerbInclude}
--> size(a,2)

ans = 
 12 
\end{DoxyVerbInclude}
 \hypertarget{inspection_typeof}{}\section{T\-Y\-P\-E\-O\-F Determine the Type of an Argument}\label{inspection_typeof}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Returns a string describing the type of an array. The syntax for its use is \begin{DoxyVerb}   y = typeof(x),
\end{DoxyVerb}
 The returned string is one of 
\begin{DoxyItemize}
\item {\ttfamily 'cell'} for cell-\/arrays  
\item {\ttfamily 'struct'} for structure-\/arrays  
\item {\ttfamily 'logical'} for logical arrays  
\item {\ttfamily 'uint8'} for unsigned 8-\/bit integers  
\item {\ttfamily 'int8'} for signed 8-\/bit integers  
\item {\ttfamily 'uint16'} for unsigned 16-\/bit integers  
\item {\ttfamily 'int16'} for signed 16-\/bit integers  
\item {\ttfamily 'uint32'} for unsigned 32-\/bit integers  
\item {\ttfamily 'int32'} for signed 32-\/bit integers  
\item {\ttfamily 'float'} for 32-\/bit floating point numbers  
\item {\ttfamily 'double'} for 64-\/bit floating point numbers  
\item {\ttfamily 'string'} for string arrays  
\end{DoxyItemize}\hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
The following piece of code demonstrates the output of the {\ttfamily typeof} command for each possible type. The first example is with a simple cell array.


\begin{DoxyVerbInclude}
--> typeof({1})

ans = 
cell
\end{DoxyVerbInclude}


The next example uses the {\ttfamily struct} constructor to make a simple scalar struct.


\begin{DoxyVerbInclude}
--> typeof(struct('foo',3))

ans = 
struct
\end{DoxyVerbInclude}


The next example uses a comparison between two scalar integers to generate a scalar logical type.


\begin{DoxyVerbInclude}
--> typeof(3>5)

ans = 
logical
\end{DoxyVerbInclude}


For the integers, the typecast operations are used to generate the arguments.


\begin{DoxyVerbInclude}
--> typeof(uint8(3))

ans = 
uint8
--> typeof(int8(8))

ans = 
int8
--> typeof(uint16(3))

ans = 
uint16
--> typeof(int16(8))

ans = 
int16
--> typeof(uint32(3))

ans = 
uint32
--> typeof(int32(3))

ans = 
int32
--> typeof(uint64(3))

ans = 
uint64
--> typeof(int64(3))

ans = 
int64
\end{DoxyVerbInclude}


Float, and double can be created using the suffixes.


\begin{DoxyVerbInclude}
--> typeof(1.0f)

ans = 
single
--> typeof(1.0D)

ans = 
double
--> typeof(1.0f+i)

ans = 
single
--> typeof(1.0D+2.0D*i)

ans = 
double
\end{DoxyVerbInclude}
 \hypertarget{inspection_what}{}\section{W\-H\-A\-T List Free\-Mat Files In Directory}\label{inspection_what}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Lists files in a directory (or the current directory if no argument is supplied) that are relevant to Free\-Mat. These are {\ttfamily M}-\/files, {\ttfamily M\-A\-T}-\/files, and class directories. There are several syntaxes for its use. The first is \begin{DoxyVerb}   what
\end{DoxyVerb}
 which lists the aforementioned items. If you provide a path instead \begin{DoxyVerb}   what path-to-folder
\end{DoxyVerb}
 then {\ttfamily what} will list the relevant Free\-Mat items in the specified directory. \hypertarget{inspection_where}{}\section{W\-H\-E\-R\-E Get Information on Program Stack}\label{inspection_where}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Returns information on the current stack. The usage is \begin{DoxyVerb}   where
\end{DoxyVerb}
 The result is a kind of stack trace that indicates the state of the current call stack, and where you are relative to the stack. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Suppose we have the following chain of functions.

\begin{DoxyVerb}     chain1.m
\end{DoxyVerb}



\begin{DoxyVerbInclude}
function chain1
  a = 32;
  b = a + 5;
  chain2(b)
\end{DoxyVerbInclude}


\begin{DoxyVerb}     chain2.m
\end{DoxyVerb}



\begin{DoxyVerbInclude}
function chain2(d)
  d = d + 5;
  chain3
\end{DoxyVerbInclude}


\begin{DoxyVerb}     chain3.m
\end{DoxyVerb}



\begin{DoxyVerbInclude}
function chain3
  g = 54;
  f = g + 1;
  keyboard
\end{DoxyVerbInclude}


The execution of the {\ttfamily where} command shows the stack trace.


\begin{DoxyVerbInclude}
--> chain1
[chain3,4]--> where
In /home/sbasu/Devel/FreeMat4/doc/fragments/chain3.m(chain3) at line 4
    In /home/sbasu/Devel/FreeMat4/doc/fragments/chain2.m(chain2) at line 4
    In /home/sbasu/Devel/FreeMat4/doc/fragments/chain1.m(chain1) at line 4
    In scratch() at line 2
    In base(base)
    In base()
    In global()
[chain3,4]
\end{DoxyVerbInclude}
 \hypertarget{inspection_which}{}\section{W\-H\-I\-C\-H Get Information on Function}\label{inspection_which}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Returns information on a function (if defined). The usage is \begin{DoxyVerb}   which(fname)
\end{DoxyVerb}
 where {\ttfamily fname} is a {\ttfamily string} argument that contains the name of the function. For functions and scripts defined via {\ttfamily .m} files, the {\ttfamily which} command returns the location of the source file\-: \begin{DoxyVerb}   y = which(fname)
\end{DoxyVerb}
 will return the filename for the {\ttfamily .m} file corresponding to the given function, and an empty string otherwise. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
First, we apply the {\ttfamily which} command to a built in function.


\begin{DoxyVerbInclude}
--> which fft
Function fft is a built in function
\end{DoxyVerbInclude}


Next, we apply it to a function defined via a {\ttfamily .m} file.


\begin{DoxyVerbInclude}
--> which fliplr
Function fliplr, M-File function in file '/home/sbasu/Devel/FreeMat4/toolbox/array/fliplr.m'
\end{DoxyVerbInclude}
 \hypertarget{inspection_who}{}\section{W\-H\-O Describe Currently Defined Variables}\label{inspection_who}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Reports information on either all variables in the current context or on a specified set of variables. For each variable, the {\ttfamily who} function indicates the size and type of the variable as well as if it is a global or persistent. There are two formats for the function call. The first is the explicit form, in which a list of variables are provided\-: \begin{DoxyVerb}  who a1 a2 ...
\end{DoxyVerb}
 In the second form \begin{DoxyVerb}  who
\end{DoxyVerb}
 the {\ttfamily who} function lists all variables defined in the current context (as well as global and persistent variables). Note that there are two alternate forms for calling the {\ttfamily who} function\-: \begin{DoxyVerb}  who 'a1' 'a2' ...
\end{DoxyVerb}
 and \begin{DoxyVerb}  who('a1','a2',...)
\end{DoxyVerb}
 \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Here is an example of the general use of {\ttfamily who}, which lists all of the variables defined.


\begin{DoxyVerbInclude}
--> c = [1,2,3];
--> f = 'hello';
--> p = randn(1,256);
--> who
  Variable Name       Type   Flags             Size
              c    double                    [1x3]
              f      char                    [1x5]
              p    double                    [1x256]
\end{DoxyVerbInclude}


In the second case, we examine only a specific variable\-:


\begin{DoxyVerbInclude}
--> who c
  Variable Name       Type   Flags             Size
              c    double                    [1x3]
--> who('c')
  Variable Name       Type   Flags             Size
              c    double                    [1x3]
\end{DoxyVerbInclude}
 \hypertarget{inspection_whos}{}\section{W\-H\-O\-S Describe Currently Defined Variables With Memory Usage}\label{inspection_whos}
Section\-: \hyperlink{sec_inspection}{Inspection Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Reports information on either all variables in the current context or on a specified set of variables. For each variable, the {\ttfamily who} function indicates the size and type of the variable as well as if it is a global or persistent. There are two formats for the function call. The first is the explicit form, in which a list of variables are provided\-: \begin{DoxyVerb}  whos a1 a2 ...
\end{DoxyVerb}
 In the second form \begin{DoxyVerb}  whos
\end{DoxyVerb}
 the {\ttfamily whos} function lists all variables defined in the current context (as well as global and persistent variables). Note that there are two alternate forms for calling the {\ttfamily whos} function\-: \begin{DoxyVerb}  whos 'a1' 'a2' ...
\end{DoxyVerb}
 and \begin{DoxyVerb}  whos('a1','a2',...)
\end{DoxyVerb}
 
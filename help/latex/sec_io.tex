
\begin{DoxyItemize}
\item \hyperlink{io_csvread}{C\-S\-V\-R\-E\-A\-D Read Comma Separated Value (C\-S\-V) File}  
\item \hyperlink{io_csvwrite}{C\-S\-V\-W\-R\-I\-T\-E Write Comma Separated Value (C\-S\-V) File}  
\item \hyperlink{io_disp}{D\-I\-S\-P Display a Variable or Expression}  
\item \hyperlink{io_dlmread}{D\-L\-M\-R\-E\-A\-D Read A\-S\-C\-I\-I-\/delimited File}  
\item \hyperlink{io_fclose}{F\-C\-L\-O\-S\-E File Close Function}  
\item \hyperlink{io_feof}{F\-E\-O\-F End Of File Function}  
\item \hyperlink{io_fflush}{F\-F\-L\-U\-S\-H Force File Flush}  
\item \hyperlink{io_fgetline}{F\-G\-E\-T\-L\-I\-N\-E Read a String from a File}  
\item \hyperlink{io_fopen}{F\-O\-P\-E\-N File Open Function}  
\item \hyperlink{io_format}{F\-O\-R\-M\-A\-T Control the Format of Matrix Display}  
\item \hyperlink{io_fprintf}{F\-P\-R\-I\-N\-T\-F Formated File Output Function (C-\/\-Style)}  
\item \hyperlink{io_fread}{F\-R\-E\-A\-D File Read Function}  
\item \hyperlink{io_fscanf}{F\-S\-C\-A\-N\-F Formatted File Input Function (C-\/\-Style)}  
\item \hyperlink{io_fseek}{F\-S\-E\-E\-K Seek File To A Given Position}  
\item \hyperlink{io_ftell}{F\-T\-E\-L\-L File Position Function}  
\item \hyperlink{io_fwrite}{F\-W\-R\-I\-T\-E File Write Function}  
\item \hyperlink{io_getline}{G\-E\-T\-L\-I\-N\-E Get a Line of Input from User}  
\item \hyperlink{io_getprintlimit}{G\-E\-T\-P\-R\-I\-N\-T\-L\-I\-M\-I\-T Get Limit For Printing Of Arrays}  
\item \hyperlink{io_htmlread}{H\-T\-M\-L\-R\-E\-A\-D Read an H\-T\-M\-L Document into Free\-Mat}  
\item \hyperlink{io_imread}{I\-M\-R\-E\-A\-D Read Image File To Matrix}  
\item \hyperlink{io_imwrite}{I\-M\-W\-R\-I\-T\-E Write Matrix to Image File}  
\item \hyperlink{io_input}{I\-N\-P\-U\-T Get Input From User}  
\item \hyperlink{io_load}{L\-O\-A\-D Load Variables From A File}  
\item \hyperlink{io_pause}{P\-A\-U\-S\-E Pause Script Execution}  
\item \hyperlink{io_printf}{P\-R\-I\-N\-T\-F Formated Output Function (C-\/\-Style)}  
\item \hyperlink{io_rawread}{R\-A\-W\-R\-E\-A\-D Read N-\/dimensional Array From File}  
\item \hyperlink{io_rawwrite}{R\-A\-W\-W\-R\-I\-T\-E Write N-\/dimensional Array From File}  
\item \hyperlink{io_save}{S\-A\-V\-E Save Variables To A File}  
\item \hyperlink{io_setprintlimit}{S\-E\-T\-P\-R\-I\-N\-T\-L\-I\-M\-I\-T Set Limit For Printing Of Arrays}  
\item \hyperlink{io_sprintf}{S\-P\-R\-I\-N\-T\-F Formated String Output Function (C-\/\-Style)}  
\item \hyperlink{io_sscanf}{S\-S\-C\-A\-N\-F Formated String Input Function (C-\/\-Style)}  
\item \hyperlink{io_str2num}{S\-T\-R2\-N\-U\-M Convert a String to a Number}  
\item \hyperlink{io_type}{T\-Y\-P\-E Type Contents of File or Function}  
\item \hyperlink{io_urlwrite}{U\-R\-L\-W\-R\-I\-T\-E Retrieve a U\-R\-L into a File}  
\item \hyperlink{io_wavplay}{W\-A\-V\-P\-L\-A\-Y}  
\item \hyperlink{io_wavread}{W\-A\-V\-R\-E\-A\-D Read a W\-A\-V Audio File}  
\item \hyperlink{io_wavrecord}{W\-A\-V\-R\-E\-C\-O\-R\-D}  
\item \hyperlink{io_wavwrite}{W\-A\-V\-W\-R\-I\-T\-E Write a W\-A\-V Audio File}  
\item \hyperlink{io_xmlread}{X\-M\-L\-R\-E\-A\-D Read an X\-M\-L Document into Free\-Mat}  
\end{DoxyItemize}\hypertarget{io_csvread}{}\section{C\-S\-V\-R\-E\-A\-D Read Comma Separated Value (C\-S\-V) File}\label{io_csvread}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The {\ttfamily csvread} function reads a text file containing comma separated values (C\-S\-V), and returns the resulting numeric matrix (2\-D). The function supports multiple syntaxes. The first syntax for {\ttfamily csvread} is \begin{DoxyVerb}   x = csvread('filename')
\end{DoxyVerb}
 which attempts to read the entire C\-S\-V file into array {\ttfamily x}. The file can contain only numeric values. Each entry in the file should be separated from other entries by a comma. However, Free\-Mat will attempt to make sense of the entries if the comma is missing (e.\-g., a space separated file will also parse correctly). For complex values, you must be careful with the spaces). The second form of {\ttfamily csvread} allows you to specify the first row and column (zero-\/based index) \begin{DoxyVerb}  x = csvread('filename',firstrow,firstcol)
\end{DoxyVerb}
 The last form allows you to specify the range to read also. This form is \begin{DoxyVerb}  x = csvread('filename',firstrow,firstcol,readrange)
\end{DoxyVerb}
 where {\ttfamily readrange} is either a 4-\/vector of the form {\ttfamily \mbox{[}R1,C1,R2,C2\mbox{]}}, where {\ttfamily R1,C1} is the first row and column to use, and {\ttfamily R2,C2} is the last row and column to use. You can also specify the {\ttfamily readrange} as a spreadsheet range {\ttfamily B12..C34}, in which case the index for the range is 1-\/based (as in a typical spreadsheet), so that {\ttfamily A1} is the first cell in the upper left corner. Note also that {\ttfamily csvread} is somewhat limited. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Here is an example of a C\-S\-V file that we wish to read in

\begin{DoxyVerb}     sample_data.csv
\end{DoxyVerb}



\begin{DoxyVerbInclude}
10, 12, 13, 00, 45, 16
09, 11, 52, 93, 05, 06
01, 03, 04, 04, 90, -3
14, 17, 13, 67, 30, 43
21, 33, 14, 44, 01, 00
\end{DoxyVerbInclude}


We start by reading the entire file


\begin{DoxyVerbInclude}
--> csvread('sample_data.csv')

ans = 
 10 12 13  0 45 16 
  9 11 52 93  5  6 
  1  3  4  4 90 -3 
 14 17 13 67 30 43 
 21 33 14 44  1  0 
\end{DoxyVerbInclude}


Next, we read everything starting with the second row, and third column


\begin{DoxyVerbInclude}
--> csvread('sample_data.csv',1,2)

ans = 
 52 93  5  6 
  4  4 90 -3 
 13 67 30 43 
 14 44  1  0 
\end{DoxyVerbInclude}


Finally, we specify that we only want the {\ttfamily 3 x 3} submatrix starting with the second row, and third column


\begin{DoxyVerbInclude}
--> csvread('sample_data.csv',1,2,[1,2,3,4])

ans = 
 52 93  5 
  4  4 90 
 13 67 30 
\end{DoxyVerbInclude}
 \hypertarget{io_csvwrite}{}\section{C\-S\-V\-W\-R\-I\-T\-E Write Comma Separated Value (C\-S\-V) File}\label{io_csvwrite}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The {\ttfamily csvwrite} function writes a given matrix to a text file using comma separated value (C\-S\-V) notation. Note that you can create C\-S\-V files with arbitrary sized matrices, but that {\ttfamily csvread} has limits on line length. If you need to reliably read and write large matrices, use {\ttfamily rawwrite} and {\ttfamily rawread} respectively. The syntax for {\ttfamily csvwrite} is \begin{DoxyVerb}   csvwrite('filename',x)
\end{DoxyVerb}
 where {\ttfamily x} is a numeric array. The contents of {\ttfamily x} are written to {\ttfamily filename} as comma-\/separated values. You can also specify a row and column offset to {\ttfamily csvwrite} to force {\ttfamily csvwrite} to write the matrix {\ttfamily x} starting at the specified location in the file. This syntax of the function is \begin{DoxyVerb}   csvwrite('filename',x,startrow,startcol)
\end{DoxyVerb}
 where {\ttfamily startrow} and {\ttfamily startcol} are the offsets in zero-\/based indexing. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Here we create a simple matrix, and write it to a C\-S\-V file


\begin{DoxyVerbInclude}
--> x = [1,2,3;5,6,7]

x = 
 1 2 3 
 5 6 7 

--> csvwrite('csvwrite.csv',x)
--> csvread('csvwrite.csv')

ans = 
 1 2 3 
 5 6 7 
\end{DoxyVerbInclude}


Next, we do the same with an offset.


\begin{DoxyVerbInclude}
--> csvwrite('csvwrite.csv',x,1,2)
--> csvread('csvwrite.csv')

ans = 
 0 0 0 0 
 0 1 2 3 
 0 5 6 7 
\end{DoxyVerbInclude}


Note the extra zeros. \hypertarget{io_disp}{}\section{D\-I\-S\-P Display a Variable or Expression}\label{io_disp}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Displays the result of a set of expressions. The {\ttfamily disp} function takes a variable number of arguments, each of which is an expression to output\-: \begin{DoxyVerb}  disp(expr1,expr2,...,exprn)
\end{DoxyVerb}
 This is functionally equivalent to evaluating each of the expressions without a semicolon after each. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Here are some simple examples of using {\ttfamily disp}.


\begin{DoxyVerbInclude}
--> a = 32;
--> b = 1:4;
--> disp(a,b,pi)
 32 

 1 2 3 4 

    3.1416 
\end{DoxyVerbInclude}
 \hypertarget{io_dlmread}{}\section{D\-L\-M\-R\-E\-A\-D Read A\-S\-C\-I\-I-\/delimited File}\label{io_dlmread}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Loads a matrix from an A\-S\-C\-I\-I-\/formatted text file with a delimiter between the entries. This function is similar to the {\ttfamily load -\/ascii} command, except that it can handle complex data, and it allows you to specify the delimiter. Also, you can read only a subset of the data from the file. The general syntax for the {\ttfamily dlmread} function is \begin{DoxyVerb}    y = dlmread(filename)
\end{DoxyVerb}
 where {\ttfamily filename} is a string containing the name of the file to read. In this form, Free\-Mat will guess at the type of the delimiter in the file. The guess is made by examining the input for common delimiter characters, which are {\ttfamily ,;\-:} or a whitespace (e.\-g., tab). The text in the file is preprocessed to replace these characters with whitespace and the file is then read in using a whitespace for the delimiter.

If you know the delimiter in the file, you can specify it using this form of the function\-: \begin{DoxyVerb}    y = dlmread(filename, delimiter)
\end{DoxyVerb}
 where {\ttfamily delimiter} is a string containing the delimiter. If {\ttfamily delimiter} is the empty string, then the delimiter is guessed from the file.

You can also read only a portion of the file by specifying a start row and start column\-: \begin{DoxyVerb}    y = dlmread(filename, delimiter, startrow, startcol)
\end{DoxyVerb}
 where {\ttfamily startrow} and {\ttfamily startcol} are zero-\/based. You can also specify the data to read using a range argument\-: \begin{DoxyVerb}    y = dlmread(filename, delimiter, range)
\end{DoxyVerb}
 where {\ttfamily range} is either a vector {\ttfamily \mbox{[}startrow,startcol,stoprow,stopcol\mbox{]}} or is specified in spreadsheet notation as {\ttfamily B4..Z\-A5}.

Note that complex numbers can be present in the file if they are encoded without whitespaces inside the number, and use either {\ttfamily i} or {\ttfamily j} as the indicator. Note also that when the delimiter is given, each incidence of the delimiter counts as a separator. Multiple separators generate zeros in the matrix. \hypertarget{io_fclose}{}\section{F\-C\-L\-O\-S\-E File Close Function}\label{io_fclose}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Closes a file handle, or all open file handles. The general syntax for its use is either \begin{DoxyVerb}  fclose(handle)
\end{DoxyVerb}
 or \begin{DoxyVerb}  fclose('all')
\end{DoxyVerb}
 In the first case a specific file is closed, In the second, all open files are closed. Note that until a file is closed the file buffers are not flushed. Returns a '0' if the close was successful and a '-\/1' if the close failed for some reason. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
A simple example of a file being opened with {\ttfamily fopen} and then closed with {\ttfamily fclose}.


\begin{DoxyVerbInclude}
--> fp = fopen('test.dat','wb','ieee-le')

fp = 
 3 

--> fclose(fp)
\end{DoxyVerbInclude}
 \hypertarget{io_feof}{}\section{F\-E\-O\-F End Of File Function}\label{io_feof}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Check to see if we are at the end of the file. The usage is \begin{DoxyVerb}  b = feof(handle)
\end{DoxyVerb}
 The {\ttfamily handle} argument must be a valid and active file handle. The return is true (logical 1) if the current position is at the end of the file, and false (logical 0) otherwise. Note that simply reading to the end of a file will not cause {\ttfamily feof} to return {\ttfamily true}. You must read past the end of the file (which will cause an error anyway). See the example for more details. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Here, we read to the end of the file to demonstrate how {\ttfamily feof} works. At first pass, we force a read of the contents of the file by specifying {\ttfamily inf} for the dimension of the array to read. We then test the end of file, and somewhat counter-\/intuitively, the answer is {\ttfamily false}. We then attempt to read past the end of the file, which causes an error. An {\ttfamily feof} test now returns the expected value of {\ttfamily true}.


\begin{DoxyVerbInclude}
--> fp = fopen('test.dat','rb');
--> x = fread(fp,[512,inf],'float');
--> feof(fp)

ans = 
 1 

--> x = fread(fp,[1,1],'float');
--> feof(fp)

ans = 
 1 
\end{DoxyVerbInclude}
 \hypertarget{io_fflush}{}\section{F\-F\-L\-U\-S\-H Force File Flush}\label{io_fflush}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Flushes any pending output to a given file. The general use of this function is \begin{DoxyVerb}   fflush(handle)
\end{DoxyVerb}
 where {\ttfamily handle} is an active file handle (as returned by {\ttfamily fopen}). \hypertarget{io_fgetline}{}\section{F\-G\-E\-T\-L\-I\-N\-E Read a String from a File}\label{io_fgetline}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Reads a string from a file. The general syntax for its use is \begin{DoxyVerb}  s = fgetline(handle)
\end{DoxyVerb}
 This function reads characters from the file {\ttfamily handle} into a {\ttfamily string} array {\ttfamily s} until it encounters the end of the file or a newline. The newline, if any, is retained in the output string. If the file is at its end, (i.\-e., that {\ttfamily feof} would return true on this handle), {\ttfamily fgetline} returns an empty string. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
First we write a couple of strings to a test file.


\begin{DoxyVerbInclude}
--> fp = fopen('testtext','w');
--> fprintf(fp,'String 1\n');
--> fprintf(fp,'String 2\n');
--> fclose(fp);
\end{DoxyVerbInclude}


Next, we read then back.


\begin{DoxyVerbInclude}
--> fp = fopen('testtext','r')

fp = 
 4 

--> fgetline(fp)

ans = 
String 1

--> fgetline(fp)

ans = 
String 2

--> fclose(fp);
\end{DoxyVerbInclude}
 \hypertarget{io_fopen}{}\section{F\-O\-P\-E\-N File Open Function}\label{io_fopen}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Opens a file and returns a handle which can be used for subsequent file manipulations. The general syntax for its use is \begin{DoxyVerb}  fp = fopen(fname,mode,byteorder)
\end{DoxyVerb}
 Here {\ttfamily fname} is a string containing the name of the file to be opened. {\ttfamily mode} is the mode string for the file open command. The first character of the mode string is one of the following\-: 
\begin{DoxyItemize}
\item {\ttfamily 'r'} Open file for reading. The file pointer is placed at the beginning of the file. The file can be read from, but not written to.  
\item {\ttfamily 'r+'} Open for reading and writing. The file pointer is placed at the beginning of the file. The file can be read from and written to, but must exist at the outset.  
\item {\ttfamily 'w'} Open file for writing. If the file already exists, it is truncated to zero length. Otherwise, a new file is created. The file pointer is placed at the beginning of the file.  
\item {\ttfamily 'w+'} Open for reading and writing. The file is created if it does not exist, otherwise it is truncated to zero length. The file pointer placed at the beginning of the file.  
\item {\ttfamily 'a'} Open for appending (writing at end of file). The file is created if it does not exist. The file pointer is placed at the end of the file.  
\item {\ttfamily 'a+'} Open for reading and appending (writing at end of file). The file is created if it does not exist. The file pointer is placed at the end of the file.  
\end{DoxyItemize}Starting with Free\-Mat 4, all files are treated as binary files by default. To invoke the operating systems 'C\-R/\-L\-F $<$-\/$>$ C\-R' translation (on Win32) add a 't' to the mode string, as in 'rt+'.

Also, you can supply a second argument to {\ttfamily fopen} to retrieve error messages if the {\ttfamily fopen} fails. \begin{DoxyVerb}  [fp,messages] = fopen(fname,mode,byteorder)
\end{DoxyVerb}


Finally, Free\-Mat has the ability to read and write files of any byte-\/sex (endian). The third (optional) input indicates the byte-\/endianness of the file. If it is omitted, the native endian-\/ness of the machine running Free\-Mat is used. Otherwise, the third argument should be one of the following strings\-: 
\begin{DoxyItemize}
\item {\ttfamily 'le','ieee-\/le','little-\/endian','little\-Endian','little','l','ieee-\/le.\-l64','s'}  
\item {\ttfamily 'be','ieee-\/be','big-\/endian','big\-Endian','big','b','ieee-\/be.\-l64','a'}  
\end{DoxyItemize}

If the file cannot be opened, or the file mode is illegal, then an error occurs. Otherwise, a file handle is returned (which is an integer). This file handle can then be used with {\ttfamily fread}, {\ttfamily fwrite}, or {\ttfamily fclose} for file access.

Note that three handles are assigned at initialization time\-: 
\begin{DoxyItemize}
\item Handle 0 -\/ is assigned to standard input  
\item Handle 1 -\/ is assigned to standard output  
\item Handle 2 -\/ is assigned to standard error  
\end{DoxyItemize}These handles cannot be closed, so that user created file handles start at {\ttfamily 3}.\hypertarget{variables_matrix_Examples}{}\subsection{Examples}\label{variables_matrix_Examples}
Here are some examples of how to use {\ttfamily fopen}. First, we create a new file, which we want to be little-\/endian, regardless of the type of the machine. We also use the {\ttfamily fwrite} function to write some floating point data to the file.


\begin{DoxyVerbInclude}
--> fp = fopen('test.dat','w','ieee-le')

fp = 
 4 

--> fwrite(fp,float([1.2,4.3,2.1]))

ans = 
 12 

--> fclose(fp)
\end{DoxyVerbInclude}


Next, we open the file and read the data back


\begin{DoxyVerbInclude}
--> fp = fopen('test.dat','r','ieee-le')

fp = 
 4 

--> fread(fp,[1,3],'float')

ans = 
    1.2000    4.3000    2.1000 

--> fclose(fp)
\end{DoxyVerbInclude}


Now, we re-\/open the file in append mode and add two additional {\ttfamily float}s to the file.


\begin{DoxyVerbInclude}
--> fp = fopen('test.dat','a+','le')

fp = 
 4 

--> fwrite(fp,float([pi,e]))

ans = 
 8 

--> fclose(fp)
\end{DoxyVerbInclude}


Finally, we read all 5 {\ttfamily float} values from the file


\begin{DoxyVerbInclude}
--> fp = fopen('test.dat','r','ieee-le')

fp = 
 4 

--> fread(fp,[1,5],'float')

ans = 
    1.2000    4.3000    2.1000    3.1416    2.7183 

--> fclose(fp)
\end{DoxyVerbInclude}
 \hypertarget{io_format}{}\section{F\-O\-R\-M\-A\-T Control the Format of Matrix Display}\label{io_format}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Free\-Mat supports several modes for displaying matrices (either through the {\ttfamily disp} function or simply by entering expressions on the command line. There are several options for the format command. The default mode is equivalent to \begin{DoxyVerb}   format short
\end{DoxyVerb}
 which generally displays matrices with 4 decimals, and scales matrices if the entries have magnitudes larger than roughly {\ttfamily 1e2} or smaller than {\ttfamily 1e-\/2}. For more information you can use \begin{DoxyVerb}   format long
\end{DoxyVerb}
 which displays roughly 7 decimals for {\ttfamily float} and {\ttfamily complex} arrays, and 14 decimals for {\ttfamily double} and {\ttfamily dcomplex}. You can also use \begin{DoxyVerb}   format short e
\end{DoxyVerb}
 to get exponential format with 4 decimals. Matrices are not scaled for exponential formats. Similarly, you can use \begin{DoxyVerb}   format long e
\end{DoxyVerb}
 which displays the same decimals as {\ttfamily format long}, but in exponential format. You can also use the {\ttfamily format} command to retrieve the current format\-: \begin{DoxyVerb}   s = format
\end{DoxyVerb}
 where {\ttfamily s} is a string describing the current format. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
We start with the short format, and two matrices, one of double precision, and the other of single precision.


\begin{DoxyVerbInclude}
--> format short
--> a = randn(4)

a = 
   -0.3756    0.0920    0.9516    1.8527 
    0.5078   -0.2088   -0.3120   -0.2380 
    0.5578    0.7695    0.0226    2.9326 
   -0.4420   -0.4871   -0.7582   -0.5059 

--> b = float(randn(4))

b = 
    0.2010    0.3416    0.1562   -0.5460 
    1.2842   -0.3808   -1.2720   -0.3398 
   -0.7660   -0.6251    2.4811    0.7956 
   -0.1727    0.8577    1.5701   -1.5048 
\end{DoxyVerbInclude}


Note that in the short format, these two matrices are displayed with the same format. In {\ttfamily long} format, however, they display differently


\begin{DoxyVerbInclude}
--> format long
--> a

ans = 

 Columns 1 to 3

  -0.37559630424227   0.09196341864118   0.95155934364300 
   0.50776589164635  -0.20877480315311  -0.31198760445638 
   0.55783547335483   0.76954243414671   0.02264031516947 
  -0.44202929771190  -0.48708606879623  -0.75822963661106 

 Columns 4 to 4

   1.85265231634028 
  -0.23799081322695 
   2.93263318869123 
  -0.50590405332950 

--> b

ans = 
   0.2010476   0.3415550   0.1561587  -0.5460028 
   1.2841575  -0.3808453  -1.2719837  -0.3397521 
  -0.7659672  -0.6251388   2.4811494   0.7956446 
  -0.1726678   0.8576548   1.5701485  -1.5048176 
\end{DoxyVerbInclude}


Note also that we we scale the contents of the matrices, Free\-Mat rescales the entries with a scale premultiplier.


\begin{DoxyVerbInclude}
--> format short
--> a*1e4

ans = 

   1.0e+04 * 
   -0.3756    0.0920    0.9516    1.8527 
    0.5078   -0.2088   -0.3120   -0.2380 
    0.5578    0.7695    0.0226    2.9326 
   -0.4420   -0.4871   -0.7582   -0.5059 

--> a*1e-4

ans = 

   1.0e-04 * 
   -0.3756    0.0920    0.9516    1.8527 
    0.5078   -0.2088   -0.3120   -0.2380 
    0.5578    0.7695    0.0226    2.9326 
   -0.4420   -0.4871   -0.7582   -0.5059 

--> b*1e4

ans = 

   1.0e+04 * 
    0.2010    0.3416    0.1562   -0.5460 
    1.2842   -0.3808   -1.2720   -0.3398 
   -0.7660   -0.6251    2.4811    0.7956 
   -0.1727    0.8577    1.5701   -1.5048 

--> b*1e-4

ans = 

   1.0e-04 * 
    0.2010    0.3416    0.1562   -0.5460 
    1.2842   -0.3808   -1.2720   -0.3398 
   -0.7660   -0.6251    2.4811    0.7956 
   -0.1727    0.8577    1.5701   -1.5048 
\end{DoxyVerbInclude}


Next, we use the exponential formats\-:


\begin{DoxyVerbInclude}
--> format short e
--> a*1e4

ans = 
 -3.7560e+03  9.1963e+02  9.5156e+03  1.8527e+04 
  5.0777e+03 -2.0877e+03 -3.1199e+03 -2.3799e+03 
  5.5784e+03  7.6954e+03  2.2640e+02  2.9326e+04 
 -4.4203e+03 -4.8709e+03 -7.5823e+03 -5.0590e+03 

--> a*1e-4

ans = 
 -3.7560e-05  9.1963e-06  9.5156e-05  1.8527e-04 
  5.0777e-05 -2.0877e-05 -3.1199e-05 -2.3799e-05 
  5.5784e-05  7.6954e-05  2.2640e-06  2.9326e-04 
 -4.4203e-05 -4.8709e-05 -7.5823e-05 -5.0590e-05 

--> b*1e4

ans = 
  2.0105e+03  3.4156e+03  1.5616e+03 -5.4600e+03 
  1.2842e+04 -3.8085e+03 -1.2720e+04 -3.3975e+03 
 -7.6597e+03 -6.2514e+03  2.4811e+04  7.9564e+03 
 -1.7267e+03  8.5765e+03  1.5701e+04 -1.5048e+04 

--> b*1e-4

ans = 
  2.0105e-05  3.4155e-05  1.5616e-05 -5.4600e-05 
  1.2842e-04 -3.8085e-05 -1.2720e-04 -3.3975e-05 
 -7.6597e-05 -6.2514e-05  2.4811e-04  7.9564e-05 
 -1.7267e-05  8.5765e-05  1.5701e-04 -1.5048e-04 
\end{DoxyVerbInclude}


Finally, if we assign the {\ttfamily format} function to a variable, we can retrieve the current format\-:


\begin{DoxyVerbInclude}
--> format short
--> t = format

t = 
short
\end{DoxyVerbInclude}
 \hypertarget{io_fprintf}{}\section{F\-P\-R\-I\-N\-T\-F Formated File Output Function (C-\/\-Style)}\label{io_fprintf}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Prints values to a file. The general syntax for its use is \begin{DoxyVerb}  fprintf(fp,format,a1,a2,...).
\end{DoxyVerb}
 or, \begin{DoxyVerb}  fprintf(format,a1,a2,...).
\end{DoxyVerb}
 Here {\ttfamily format} is the format string, which is a string that controls the format of the output. The values of the variables {\ttfamily ai} are substituted into the output as required. It is an error if there are not enough variables to satisfy the format string. Note that this {\ttfamily fprintf} command is not vectorized! Each variable must be a scalar. The value {\ttfamily fp} is the file handle. If {\ttfamily fp} is omitted, file handle {\ttfamily 1} is assumed, and the behavior of {\ttfamily fprintf} is effectively equivalent to {\ttfamily printf}. For more details on the format string, see {\ttfamily printf}. \hypertarget{variables_matrix_Examples}{}\subsection{Examples}\label{variables_matrix_Examples}
A number of examples are present in the Examples section of the {\ttfamily printf} command. \hypertarget{io_fread}{}\section{F\-R\-E\-A\-D File Read Function}\label{io_fread}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Reads a block of binary data from the given file handle into a variable of a given shape and precision. The general use of the function is \begin{DoxyVerb}  A = fread(handle,size,precision)
\end{DoxyVerb}
 The {\ttfamily handle} argument must be a valid value returned by the fopen function, and accessable for reading. The {\ttfamily size} argument determines the number of values read from the file. The {\ttfamily size} argument is simply a vector indicating the size of the array {\ttfamily A}. The {\ttfamily size} argument can also contain a single {\ttfamily inf} dimension, indicating that Free\-Mat should calculate the size of the array along that dimension so as to read as much data as possible from the file (see the examples listed below for more details). The data is stored as columns in the file, not rows.

Alternately, you can specify two return values to the {\ttfamily fread} function, in which case the second value contains the number of elements read \begin{DoxyVerb}   [A,count] = fread(...)
\end{DoxyVerb}
 where {\ttfamily count} is the number of elements in {\ttfamily A}.

The third argument determines the type of the data. Legal values for this argument are listed below\-: 
\begin{DoxyItemize}
\item 'uint8','uchar','unsigned char' for an unsigned, 8-\/bit integer.  
\item 'int8','char','integer$\ast$1' for a signed, 8-\/bit integer.  
\item 'uint16','unsigned short' for an unsigned, 16-\/bit integer.  
\item 'int16','short','integer$\ast$2' for a signed, 16-\/bit integer.  
\item 'uint32','unsigned int' for an unsigned, 32-\/bit integer.  
\item 'int32','int','integer$\ast$4' for a signed, 32-\/bit integer.  
\item 'single','float32','float','real$\ast$4' for a 32-\/bit floating point.  
\item 'double','float64','real$\ast$8' for a 64-\/bit floating point.  
\end{DoxyItemize}

Starting with Free\-Mat 4, the format for the third argument has changed. If you specify only a type, such as {\ttfamily 'float'}, the data is read in as single precision, but the output type is always {\ttfamily 'double'}. This behavior is consistent with Matlab. If you want the output type to match the input type (as was previous behavior in Free\-Mat), you must preface the precision string with a {\ttfamily '$\ast$'}. Thus, the precision string {\ttfamily '$\ast$float'} implies that data is read in as single precision, and the output is also single precision.

The third option is to specify the input and output types explicitly. You can do this by specifiying a precision string of the form {\ttfamily 'type1 =$>$ type2'}, where {\ttfamily 'type1'} is the input type and {\ttfamily 'type2'} is the output type. For example, if the input type is {\ttfamily 'double'} and the output type is to be a {\ttfamily 'float'}, then a type spec of {\ttfamily 'double =$>$ float'} should be used.\hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
First, we create an array of {\ttfamily 512 x 512} Gaussian-\/distributed {\ttfamily float} random variables, and then writing them to a file called {\ttfamily test.\-dat}.


\begin{DoxyVerbInclude}
--> A = float(randn(512));
--> fp = fopen('test.dat','w');
--> fwrite(fp,A);
--> fclose(fp);
\end{DoxyVerbInclude}


Read as many floats as possible into a row vector


\begin{DoxyVerbInclude}
--> fp = fopen('test.dat','r');
--> x = fread(fp,[1,inf],'float');
--> fclose(fp);
--> who x
  Variable Name       Type   Flags             Size
              x    double                    [1x262144]
\end{DoxyVerbInclude}


Note that {\ttfamily x} is a {\ttfamily double} array. This behavior is new to Free\-Mat 4. Read the same floats into a 2-\/\-D float array.


\begin{DoxyVerbInclude}
--> fp = fopen('test.dat','r');
--> x = fread(fp,[512,inf],'float');
--> fclose(fp);
--> who x
  Variable Name       Type   Flags             Size
              x    double                    [512x512]
\end{DoxyVerbInclude}


To read them as a single precision float array, we can use the following form\-:


\begin{DoxyVerbInclude}
--> fp = fopen('test.dat','r');
--> x = fread(fp,[512,inf],'*float');
--> fclose(fp);
--> who x
  Variable Name       Type   Flags             Size
              x    single                    [512x512]
\end{DoxyVerbInclude}
 \hypertarget{io_fscanf}{}\section{F\-S\-C\-A\-N\-F Formatted File Input Function (C-\/\-Style)}\label{io_fscanf}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Reads values from a file. The general syntax for its use is \begin{DoxyVerb}  [a,count] = fscanf(handle,format,[size])
\end{DoxyVerb}
 Here {\ttfamily format} is the format string, which is a string that controls the format of the input, {\ttfamily size} specifies the amount of data to be read. Values that are parsed from the {\ttfamily text} are stored in a. Note that fscanf is vectorized -\/ the format string is reused as long as there are entries in the {\ttfamily text} string. See {\ttfamily printf} for a description of the format. Note that if the file is at the end-\/of-\/file, the fscanf will return \hypertarget{io_fseek}{}\section{F\-S\-E\-E\-K Seek File To A Given Position}\label{io_fseek}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Moves the file pointer associated with the given file handle to the specified offset (in bytes). The usage is \begin{DoxyVerb}  fseek(handle,offset,style)
\end{DoxyVerb}
 The {\ttfamily handle} argument must be a value and active file handle. The {\ttfamily offset} parameter indicates the desired seek offset (how much the file pointer is moved in bytes). The {\ttfamily style} parameter determines how the offset is treated. Three values for the {\ttfamily style} parameter are understood\-: 
\begin{DoxyItemize}
\item string {\ttfamily 'bof'} or the value -\/1, which indicate the seek is relative to the beginning of the file. This is equivalent to {\ttfamily S\-E\-E\-K\-\_\-\-S\-E\-T} in A\-N\-S\-I C.  
\item string {\ttfamily 'cof'} or the value 0, which indicates the seek is relative to the current position of the file. This is equivalent to {\ttfamily S\-E\-E\-K\-\_\-\-C\-U\-R} in A\-N\-S\-I C.  
\item string {\ttfamily 'eof'} or the value 1, which indicates the seek is relative to the end of the file. This is equivalent to {\ttfamily S\-E\-E\-K\-\_\-\-E\-N\-D} in A\-N\-S\-I C.  
\end{DoxyItemize}The offset can be positive or negative. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
The first example reads a file and then ``rewinds'' the file pointer by seeking to the beginning. The next example seeks forward by 2048 bytes from the files current position, and then reads a line of 512 floats.


\begin{DoxyVerbInclude}
--> % First we create the file
--> fp = fopen('test.dat','wb');
--> fwrite(fp,float(rand(4096,1)));
--> fclose(fp);
--> % Now we open it
--> fp = fopen('test.dat','rb');
--> % Read the whole thing
--> x = fread(fp,[1,inf],'float');
--> % Rewind to the beginning
--> fseek(fp,0,'bof');
--> % Read part of the file
--> y = fread(fp,[1,1024],'float');
--> who x y
  Variable Name       Type   Flags             Size
              x    double                    [1x4096]
              y    double                    [1x1024]
--> % Seek 2048 bytes into the file
--> fseek(fp,2048,'cof');
--> % Read 512 floats from the file
--> x = fread(fp,[512,1],'float');
--> % Close the file
--> fclose(fp);
\end{DoxyVerbInclude}
 \hypertarget{io_ftell}{}\section{F\-T\-E\-L\-L File Position Function}\label{io_ftell}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Returns the current file position for a valid file handle. The general use of this function is \begin{DoxyVerb}  n = ftell(handle)
\end{DoxyVerb}
 The {\ttfamily handle} argument must be a valid and active file handle. The return is the offset into the file relative to the start of the file (in bytes). \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Here is an example of using {\ttfamily ftell} to determine the current file position. We read 512 4-\/byte floats, which results in the file pointer being at position 512$\ast$4 = 2048.


\begin{DoxyVerbInclude}
--> fp = fopen('test.dat','wb');
--> fwrite(fp,randn(512,1));
--> fclose(fp);
--> fp = fopen('test.dat','rb');
--> x = fread(fp,[512,1],'float');
--> ftell(fp)

ans = 
 2048 
\end{DoxyVerbInclude}
 \hypertarget{io_fwrite}{}\section{F\-W\-R\-I\-T\-E File Write Function}\label{io_fwrite}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Writes an array to a given file handle as a block of binary (raw) data. The general use of the function is \begin{DoxyVerb}  n = fwrite(handle,A)
\end{DoxyVerb}
 The {\ttfamily handle} argument must be a valid value returned by the fopen function, and accessable for writing. The array {\ttfamily A} is written to the file a column at a time. The form of the output data depends on (and is inferred from) the precision of the array {\ttfamily A}. If the write fails (because we ran out of disk space, etc.) then an error is returned. The output {\ttfamily n} indicates the number of elements successfully written.

Note that unlike M\-A\-T\-L\-A\-B, Free\-Mat 4 does not default to {\ttfamily uint8} for writing arrays to files. Alternately, the type of the data to be written to the file can be specified with the syntax \begin{DoxyVerb}  n = fwrite(handle,A,type)
\end{DoxyVerb}
 where {\ttfamily type} is one of the following legal values\-: 
\begin{DoxyItemize}
\item 'uint8','uchar','unsigned char' for an unsigned, 8-\/bit integer.  
\item 'int8','char','integer$\ast$1' for a signed, 8-\/bit integer.  
\item 'uint16','unsigned short' for an unsigned, 16-\/bit integer.  
\item 'int16','short','integer$\ast$2' for a signed, 16-\/bit integer.  
\item 'uint32','unsigned int' for an unsigned, 32-\/bit integer.  
\item 'int32','int','integer$\ast$4' for a signed, 32-\/bit integer.  
\item 'single','float32','float','real$\ast$4' for a 32-\/bit floating point.  
\item 'double','float64','real$\ast$8' for a 64-\/bit floating point.  
\end{DoxyItemize}\hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Heres an example of writing an array of {\ttfamily 512 x 512} Gaussian-\/distributed {\ttfamily float} random variables, and then writing them to a file called {\ttfamily test.\-dat}.


\begin{DoxyVerbInclude}
--> A = float(randn(512));
--> fp = fopen('test.dat','w');
--> fwrite(fp,A,'single');
--> fclose(fp);
\end{DoxyVerbInclude}
 \hypertarget{io_getline}{}\section{G\-E\-T\-L\-I\-N\-E Get a Line of Input from User}\label{io_getline}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Reads a line (as a string) from the user. This function has two syntaxes. The first is \begin{DoxyVerb}  a = getline(prompt)
\end{DoxyVerb}
 where {\ttfamily prompt} is a prompt supplied to the user for the query. The second syntax omits the {\ttfamily prompt} argument\-: \begin{DoxyVerb}  a = getline
\end{DoxyVerb}
 Note that this function requires command line input, i.\-e., it will only operate correctly for programs or scripts written to run inside the Free\-Mat G\-U\-I environment or from the X11 terminal. If you build a stand-\/alone application and expect it to operate cross-\/platform, do not use this function (unless you include the Free\-Mat console in the final application). \hypertarget{io_getprintlimit}{}\section{G\-E\-T\-P\-R\-I\-N\-T\-L\-I\-M\-I\-T Get Limit For Printing Of Arrays}\label{io_getprintlimit}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Returns the limit on how many elements of an array are printed using either the {\ttfamily disp} function or using expressions on the command line without a semi-\/colon. The default is set to one thousand elements. You can increase or decrease this limit by calling {\ttfamily setprintlimit}. This function is provided primarily so that you can temporarily change the output truncation and then restore it to the previous value (see the examples). \begin{DoxyVerb}   n=getprintlimit
\end{DoxyVerb}
 where {\ttfamily n} is the current limit in use. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Here is an example of using {\ttfamily getprintlimit} along with {\ttfamily setprintlimit} to temporarily change the output behavior of Free\-Mat.


\begin{DoxyVerbInclude}
--> A = randn(100,1);
--> n = getprintlimit

n = 
 1000 

--> setprintlimit(5);
--> A

ans = 
   -0.6933 
   -0.9500 
    0.0824 
   -1.1740 
   -0.3467
Print limit has been reached.  Use setprintlimit function to enable longer printouts
--> setprintlimit(n)
\end{DoxyVerbInclude}
 \hypertarget{io_htmlread}{}\section{H\-T\-M\-L\-R\-E\-A\-D Read an H\-T\-M\-L Document into Free\-Mat}\label{io_htmlread}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Given a filename, reads an H\-T\-M\-L document, (attempts to) parse it, and returns the result as a Free\-Mat data structure. The syntax for its use is\-: \begin{DoxyVerb}   p = htmlread(filename)
\end{DoxyVerb}
 where {\ttfamily filename} is a {\ttfamily string}. The resulting object {\ttfamily p} is a data structure containing the information in the document. Note that this function works by internally converting the H\-T\-M\-L document into something closer to X\-H\-T\-M\-L, and then using the X\-M\-L parser to parse it. In some cases, the converted H\-T\-M\-L cannot be properly parsed. In such cases, a third party tool such as \char`\"{}tidy\char`\"{} will probably do a better job. \hypertarget{io_imread}{}\section{I\-M\-R\-E\-A\-D Read Image File To Matrix}\label{io_imread}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Reads the image data from the given file into a matrix. Note that Free\-Mat's support for {\ttfamily imread} is not complete. Only some of the formats specified in the M\-A\-T\-L\-A\-B A\-P\-I are implemented. The syntax for its use is \begin{DoxyVerb}  [A,map,alpha] = imread(filename)
\end{DoxyVerb}
 where {\ttfamily filename} is the name of the file to read from. The returned arrays {\ttfamily A} contain the image data, {\ttfamily map} contains the colormap information (for indexed images), and {\ttfamily alpha} contains the alphamap (transparency). The returned values will depend on the type of the original image. Generally you can read images in the {\ttfamily jpg,png,xpm,ppm} and some other formats. \hypertarget{io_imwrite}{}\section{I\-M\-W\-R\-I\-T\-E Write Matrix to Image File}\label{io_imwrite}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Write the image data from the matrix into a given file. Note that Free\-Mat's support for {\ttfamily imwrite} is not complete. You can write images in the {\ttfamily jpg,png,xpm,ppm} and some other formats. The syntax for its use is \begin{DoxyVerb}  imwrite(A, filename)
  imwrite(A, map, filename)
  imwrite(A, map, filename, 'Alpha', alpha)

or Octave-style syntax:
  imwrite(filename, A)
  imwrite(filename, A, map)
  imwrite(filename, A, map, alpha)
\end{DoxyVerb}
 where {\ttfamily filename} is the name of the file to write to. The input array {\ttfamily A} contains the image data (2\-D for gray or indexed, and 3\-D for color). If {\ttfamily A} is an integer array (int8, uint8, int16, uint16, int32, uint32), the values of its elements should be within 0-\/255. If {\ttfamily A} is a floating-\/point array (float or double), the value of its elements should be in the range \mbox{[}0,1\mbox{]}. {\ttfamily map} contains the colormap information (for indexed images), and {\ttfamily alpha} the alphamap (transparency). \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Here is a simple example of {\ttfamily imread}/{\ttfamily imwrite}. First, we generate a grayscale image and save it to an image file.


\begin{DoxyVerbInclude}
--> a =  uint8(255*rand(64));
--> figure(1), image(a), colormap(gray)
--> title('image to save')
--> imwrite(a, 'test.bmp')
\end{DoxyVerbInclude}


Then, we read image file and show it\-:


\begin{DoxyVerbInclude}
--> b = imread('test.bmp');
--> figure(2), image(b), colormap(gray)
--> title('loaded image')
\end{DoxyVerbInclude}
 \hypertarget{io_input}{}\section{I\-N\-P\-U\-T Get Input From User}\label{io_input}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The {\ttfamily input} function is used to obtain input from the user. There are two syntaxes for its use. The first is \begin{DoxyVerb}    r = input('prompt')
\end{DoxyVerb}
 in which case, the prompt is presented, and the user is allowed to enter an expression. The expression is evaluated in the current workspace or context (so it can use any defined variables or functions), and returned for assignment to the variable ({\ttfamily r} in this case). In the second form of the {\ttfamily input} function, the syntax is \begin{DoxyVerb}    r = input('prompt','s')
\end{DoxyVerb}
 in which case the text entered by the user is copied verbatim to the output. \hypertarget{io_load}{}\section{L\-O\-A\-D Load Variables From A File}\label{io_load}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Loads a set of variables from a file in a machine independent format. The {\ttfamily load} function takes one argument\-: \begin{DoxyVerb}  load filename,
\end{DoxyVerb}
 or alternately, \begin{DoxyVerb}  load('filename')
\end{DoxyVerb}
 This command is the companion to {\ttfamily save}. It loads the contents of the file generated by {\ttfamily save} back into the current context. Global and persistent variables are also loaded and flagged appropriately. By default, Free\-Mat assumes that files that end in a {\ttfamily .mat} or {\ttfamily .M\-A\-T} extension are M\-A\-T\-L\-A\-B-\/formatted files. Also, Free\-Mat assumes that files that end in {\ttfamily .txt} or {\ttfamily .T\-X\-T} are A\-S\-C\-I\-I files. For other filenames, Free\-Mat first tries to open the file as a Free\-Mat binary format file (as created by the {\ttfamily save} function). If the file fails to open as a Free\-Mat binary file, then Free\-Mat attempts to read it as an A\-S\-C\-I\-I file.

You can force Free\-Mat to assume a particular format for the file by using alternate forms of the {\ttfamily load} command. In particular, \begin{DoxyVerb}  load -ascii filename
\end{DoxyVerb}
 will load the data in file {\ttfamily filename} as an A\-S\-C\-I\-I file (space delimited numeric text) loaded into a single variable in the current workspace with the name {\ttfamily filename} (without the extension).

For M\-A\-T\-L\-A\-B-\/formatted data files, you can use \begin{DoxyVerb}  load -mat filename
\end{DoxyVerb}
 which forces Free\-Mat to assume that {\ttfamily filename} is a M\-A\-T-\/file, regardless of the extension on the filename.

You can also specify which variables to load from a file (not from an A\-S\-C\-I\-I file -\/ only single 2-\/\-D variables can be successfully saved and retrieved from A\-S\-C\-I\-I files) using the additional syntaxes of the {\ttfamily load} command. In particular, you can specify a set of variables to load by name \begin{DoxyVerb}  load filename Var_1 Var_2 Var_3 ...
\end{DoxyVerb}
 where {\ttfamily Var\-\_\-n} is the name of a variable to load from the file. Alternately, you can use the regular expression syntax \begin{DoxyVerb}  load filename -regexp expr_1 expr_2 expr_3 ...
\end{DoxyVerb}
 where {\ttfamily expr\-\_\-n} is a regular expression (roughly as expected by {\ttfamily regexp}). Note that a simpler regular expression mechanism is used for this syntax than the full mechanism used by the {\ttfamily regexp} command.

Finally, you can use {\ttfamily load} to create a variable containing the contents of the file, instead of automatically inserting the variables into the curent workspace. For this form of {\ttfamily load} you must use the function syntax, and capture the output\-: \begin{DoxyVerb}  V = load('arg1','arg2',...)
\end{DoxyVerb}
 which returns a structure {\ttfamily V} with one field for each variable retrieved from the file. For A\-S\-C\-I\-I files, {\ttfamily V} is a double precision matrix.\hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Here is a simple example of {\ttfamily save}/{\ttfamily load}. First, we save some variables to a file.


\begin{DoxyVerbInclude}
--> D = {1,5,'hello'};
--> s = 'test string';
--> x = randn(512,1);
--> z = zeros(512);
--> who
  Variable Name       Type   Flags             Size
              D      cell                    [1x3]
              s      char                    [1x11]
              x    double                    [512x1]
              z    double                    [512x512]
--> save loadsave.dat
\end{DoxyVerbInclude}


Next, we clear the variables, and then load them back from the file.


\begin{DoxyVerbInclude}
--> clear D s x z
--> who
  Variable Name       Type   Flags             Size
            ans    double                    [0x0]
--> load loadsave.dat
--> who
  Variable Name       Type   Flags             Size
              D      cell                    [1x3]
            ans    double                    [0x0]
              s      char                    [1x11]
              x    double                    [512x1]
              z    double                    [512x512]
\end{DoxyVerbInclude}
 \hypertarget{io_pause}{}\section{P\-A\-U\-S\-E Pause Script Execution}\label{io_pause}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The {\ttfamily pause} function can be used to pause execution of Free\-Mat scripts. There are several syntaxes for its use. The first form is \begin{DoxyVerb}   pause
\end{DoxyVerb}
 This form of the {\ttfamily pause} function pauses Free\-Mat until you press any key. The second form of the {\ttfamily pause} function takes an argument \begin{DoxyVerb}   pause(p)
\end{DoxyVerb}
 where {\ttfamily p} is the number of seconds to pause Free\-Mat for. The pause argument should be accurate to a millisecond on all supported platforms. Alternately, you can control all {\ttfamily pause} statements using\-: \begin{DoxyVerb}   pause on
\end{DoxyVerb}
 which enables pauses and \begin{DoxyVerb}   pause off
\end{DoxyVerb}
 which disables all {\ttfamily pause} statements, both with and without arguments. \hypertarget{io_printf}{}\section{P\-R\-I\-N\-T\-F Formated Output Function (C-\/\-Style)}\label{io_printf}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Prints values to the output. The general syntax for its use is \begin{DoxyVerb}  printf(format,a1,a2,...)
\end{DoxyVerb}
 Here {\ttfamily format} is the format string, which is a string that controls the format of the output. The values of the variables {\ttfamily a\-\_\-i} are substituted into the output as required. It is an error if there are not enough variables to satisfy the format string. Note that this {\ttfamily printf} command is not vectorized! Each variable must be a scalar.

It is important to point out that the {\ttfamily printf} function does not add a newline (or carriage return) to the output by default. That can lead to some confusing behavior if you do not know what to expect. For example, the command {\ttfamily printf('Hello')} does not appear to produce any output. In fact, it does produce the text, but it then gets overwritten by the prompt. To see the text, you need {\ttfamily printf('Hello\par
')}. This seems odd, but allows you to assemble a line using multiple {\ttfamily printf} commands, including the {\ttfamily '\par
'} when you are done with the line. You can also use the {\ttfamily '\textbackslash{}r'} character as an explicit carriage return (with no line feed). This allows you to write to the same line many times (to show a progress string, for example).\hypertarget{io_printf_Format}{}\subsection{of the format string}\label{io_printf_Format}
The format string is a character string, beginning and ending in its initial shift state, if any. The format string is composed of zero or more directives\-: ordinary characters (not \%), which are copied unchanged to the output stream; and conversion specifications, each of which results in fetching zero or more subsequent arguments. Each conversion specification is introduced by the character \%, and ends with a conversion specifier. In between there may be (in this order) zero or more flags, an optional minimum field width, and an optional precision.

The arguments must correspond properly (after type promotion) with the conversion specifier, and are used in the order given.\hypertarget{io_printf_The}{}\subsection{conversion specifier}\label{io_printf_The}
The character {\ttfamily \%} is followed by zero or more of the following flags\-: 
\begin{DoxyItemize}
\item {\ttfamily \#} The value should be converted to an ``alternate form''. For {\ttfamily o} conversions, the first character of the output string is made zero (by prefixing a {\ttfamily 0} if it was not zero already). For {\ttfamily x} and {\ttfamily X} conversions, a nonzero result has the string {\ttfamily '0x'} (or {\ttfamily '0\-X'} for {\ttfamily X} conversions) prepended to it. For {\ttfamily a, A, e, E, f, F, g,} and {\ttfamily G} conversions, the result will always contain a decimal point, even if no digits follow it (normally, a decimal point appears in the results of those conversions only if a digit follows). For {\ttfamily g} and {\ttfamily G} conversions, trailing zeros are not removed from the result as they would otherwise be. For other conversions, the result is undefined.  
\item {\ttfamily 0} The value should be zero padded. For {\ttfamily d, i, o, u, x, X, a, A, e, E, f, F, g,} and {\ttfamily G} conversions, the converted value is padded on the left with zeros rather than blanks. If the {\ttfamily 0} and {\ttfamily -\/} flags both appear, the {\ttfamily 0} flag is ignored. If a precision is given with a numeric conversion {\ttfamily (d, i, o, u, x, and X)}, the {\ttfamily 0} flag is ignored. For other conversions, the behavior is undefined.  
\item {\ttfamily -\/} The converted value is to be left adjusted on the field boundary. (The default is right justification.) Except for {\ttfamily n} conversions, the converted value is padded on the right with blanks, rather than on the left with blanks or zeros. A {\ttfamily -\/} overrides a {\ttfamily 0} if both are given.  
\item {\ttfamily ' '} (a space) A blank should be left before a positive number (or empty string) produced by a signed conversion.  
\item {\ttfamily +} A sign ({\ttfamily +} or {\ttfamily -\/}) always be placed before a number produced by a signed conversion. By default a sign is used only for negative numbers. A {\ttfamily +} overrides a space if both are used.  
\end{DoxyItemize}\hypertarget{io_printf_The}{}\subsection{conversion specifier}\label{io_printf_The}
An optional decimal digit string (with nonzero first digit) specifying a minimum field width. If the converted value has fewer characters than the field width, it will be padded with spaces on the left (or right, if the left-\/adjustment flag has been given). A negative field width is taken as a {\ttfamily '-\/'} flag followed by a positive field width. In no case does a non-\/existent or small field width cause truncation of a field; if the result of a conversion is wider than the field width, the field is expanded to contain the conversion result.\hypertarget{io_printf_The}{}\subsection{conversion specifier}\label{io_printf_The}
An optional precision, in the form of a period ({\ttfamily '.'}) followed by an optional decimal digit string. If the precision is given as just {\ttfamily '.'}, or the precision is negative, the precision is taken to be zero. This gives the minimum number of digits to appear for {\ttfamily d, i, o, u, x}, and {\ttfamily X} conversions, the number of digits to appear after the radix character for {\ttfamily a, A, e, E, f}, and {\ttfamily F} conversions, the maximum number of significant digits for {\ttfamily g} and {\ttfamily G} conversions, or the maximum number of characters to be printed from a string for s conversions.\hypertarget{io_printf_The}{}\subsection{conversion specifier}\label{io_printf_The}
A character that specifies the type of conversion to be applied. The conversion specifiers and their meanings are\-: 
\begin{DoxyItemize}
\item {\ttfamily d,i} The int argument is converted to signed decimal notation. The precision, if any, gives the minimum number of digits that must appear; if the converted value requires fewer digits, it is padded on the left with zeros. The default precision is {\ttfamily 1}. When {\ttfamily 0} is printed with an explicit precision {\ttfamily 0}, the output is empty.  
\item {\ttfamily o,u,x,X} The unsigned int argument is converted to unsigned octal ({\ttfamily o}), unsigned decimal ({\ttfamily u}), or unsigned hexadecimal ({\ttfamily x} and {\ttfamily X}) notation. The letters {\ttfamily abcdef} are used for {\ttfamily x} conversions; the letters {\ttfamily A\-B\-C\-D\-E\-F} are used for {\ttfamily X} conversions. The precision, if any, gives the minimum number of digits that must appear; if the converted value requires fewer digits, it is padded on the left with zeros. The default precision is {\ttfamily 1}. When {\ttfamily 0} is printed with an explicit precision {\ttfamily 0}, the output is empty.  
\item {\ttfamily e,E} The double argument is rounded and converted in the style {\ttfamily \mbox{[}-\/\mbox{]}d.\-ddde dd} where there is one digit before the decimal-\/point character and the number of digits after it is equal to the precision; if the precision is missing, it is taken as {\ttfamily 6}; if the precision is zero, no decimal-\/point character appears. An {\ttfamily E} conversion uses the letter {\ttfamily E} (rather than {\ttfamily e}) to introduce the exponent. The exponent always contains at least two digits; if the value is zero, the exponent is {\ttfamily 00}.  
\item {\ttfamily f,F} The double argument is rounded and converted to decimal notation in the style {\ttfamily \mbox{[}-\/\mbox{]}ddd.\-ddd}, where the number of digits after the decimal-\/point character is equal to the precision specification. If the precision is missing, it is taken as {\ttfamily 6}; if the precision is explicitly zero, no decimal-\/point character appears. If a decimal point appears, at least one digit appears before it.  
\item {\ttfamily g,G} The double argument is converted in style {\ttfamily f} or {\ttfamily e} (or {\ttfamily F} or {\ttfamily E} for {\ttfamily G} conversions). The precision specifies the number of significant digits. If the precision is missing, {\ttfamily 6} digits are given; if the precision is zero, it is treated as {\ttfamily 1}. Style e is used if the exponent from its conversion is less than {\ttfamily -\/4} or greater than or equal to the precision. Trailing zeros are removed from the fractional part of the result; a decimal point appears only if it is followed by at least one digit.  
\item {\ttfamily c} The int argument is converted to an unsigned char, and the resulting character is written.  
\item {\ttfamily s} The string argument is printed.  
\item {\ttfamily \%} A {\ttfamily ''} is written. No argument is converted. The complete conversion specification is {\ttfamily '\%'}.  
\end{DoxyItemize}\hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Here are some examples of the use of {\ttfamily printf} with various arguments. First we print out an integer and double value.


\begin{DoxyVerbInclude}
--> printf('intvalue is %d, floatvalue is %f\n',3,1.53);
intvalue is 3, floatvalue is 1.530000
\end{DoxyVerbInclude}


Next, we print out a string value.


\begin{DoxyVerbInclude}
--> printf('string value is %s\n','hello');
string value is hello
\end{DoxyVerbInclude}


Now, we print out an integer using 12 digits, zeros up front.


\begin{DoxyVerbInclude}
--> printf('integer padded is %012d\n',32);
integer padded is 000000000032
\end{DoxyVerbInclude}


Print out a double precision value with a sign, a total of 18 characters (zero prepended if necessary), a decimal point, and 12 digit precision.


\begin{DoxyVerbInclude}
--> printf('float value is %+018.12f\n',pi);
float value is +0003.141592653590
\end{DoxyVerbInclude}
 \hypertarget{io_rawread}{}\section{R\-A\-W\-R\-E\-A\-D Read N-\/dimensional Array From File}\label{io_rawread}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The syntax for {\ttfamily rawread} is \begin{DoxyVerb}   function x = rawread(fname,size,precision,byteorder)
\end{DoxyVerb}
 where {\ttfamily fname} is the name of the file to read from, and {\ttfamily size} is an n-\/dimensional vector that stores the size of the array in each dimension. The argument {\ttfamily precision} is the type of the data to read in\-: 
\begin{DoxyItemize}
\item 'uint8','uchar','unsigned char' for unsigned, 8-\/bit integers  
\item 'int8','char','integer$\ast$1' for signed, 8-\/bit integers  
\item 'uint16','unsigned short' for unsigned, 16-\/bit integers  
\item 'int16','short','integer$\ast$2' for signed, 16-\/bit integers  
\item 'uint32','unsigned int' for unsigned, 32-\/bit integers  
\item 'int32','int','integer$\ast$4' for signed, 32-\/bit integers  
\item 'uint64','unsigned int' for unsigned, 64-\/bit integers  
\item 'int64','int','integer$\ast$8' for signed, 64-\/bit integers  
\item 'single','float32','float','real$\ast$4' for 32-\/bit floating point  
\item 'double','float64','real$\ast$8' for 64-\/bit floating point  
\item 'complex','complex$\ast$8' for 64-\/bit complex floating point (32 bits for the real and imaginary part).  
\item 'dcomplex','complex$\ast$16' for 128-\/bit complex floating point (64 bits for the real and imaginary part).  
\end{DoxyItemize}As a special feature, one of the size elements can be 'inf', in which case, the largest possible array is read in. If {\ttfamily byteorder} is left unspecified, the file is assumed to be of the same byte-\/order as the machine {\ttfamily Free\-Mat} is running on. If you wish to force a particular byte order, specify the {\ttfamily byteorder} argument as 
\begin{DoxyItemize}
\item {\ttfamily 'le','ieee-\/le','little-\/endian','little\-Endian','little'}  
\item {\ttfamily 'be','ieee-\/be','big-\/endian','big\-Endian','big'}  
\end{DoxyItemize}\hypertarget{io_rawwrite}{}\section{R\-A\-W\-W\-R\-I\-T\-E Write N-\/dimensional Array From File}\label{io_rawwrite}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The syntax for {\ttfamily rawwrite} is \begin{DoxyVerb}   function rawwrite(fname,x,byteorder)
\end{DoxyVerb}
 where {\ttfamily fname} is the name of the file to write to, and the (numeric) array {\ttfamily x} is writen to the file in its native type (e.\-g. if {\ttfamily x} is of type {\ttfamily int16}, then it will be written to the file as 16-\/bit signed integers. If {\ttfamily byteorder} is left unspecified, the file is assumed to be of the same byte-\/order as the machine {\ttfamily Free\-Mat} is running on. If you wish to force a particular byte order, specify the {\ttfamily byteorder} argument as 
\begin{DoxyItemize}
\item {\ttfamily 'le','ieee-\/le','little-\/endian','little\-Endian','little'}  
\item {\ttfamily 'be','ieee-\/be','big-\/endian','big\-Endian','big'}  
\end{DoxyItemize}\hypertarget{io_save}{}\section{S\-A\-V\-E Save Variables To A File}\label{io_save}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Saves a set of variables to a file in a machine independent format. There are two formats for the function call. The first is the explicit form, in which a list of variables are provided to write to the file\-: \begin{DoxyVerb}  save filename a1 a2 ...
\end{DoxyVerb}
 In the second form, \begin{DoxyVerb}  save filename
\end{DoxyVerb}
 all variables in the current context are written to the file. The format of the file is a simple binary encoding (raw) of the data with enough information to restore the variables with the {\ttfamily load} command. The endianness of the machine is encoded in the file, and the resulting file should be portable between machines of similar types (in particular, machines that support I\-E\-E\-E floating point representation).

You can also specify both the filename as a string, in which case you also have to specify the names of the variables to save. In particular \begin{DoxyVerb}   save('filename','a1','a2')
\end{DoxyVerb}
 will save variables {\ttfamily a1} and {\ttfamily a2} to the file.

Starting with version 2.\-0, Free\-Mat can also read and write M\-A\-T files (the file format used by M\-A\-T\-L\-A\-B) thanks to substantial work by Thomas Beutlich. Support for M\-A\-T files in version 2.\-1 has improved over previous versions. In particular, classes should be saved properly, as well as a broader range of sparse matrices. Compression is supported for both reading and writing to M\-A\-T files. M\-A\-T file support is still in the alpha stages, so please be cautious with using it to store critical data. The file format is triggered by the extension. To save files with a M\-A\-T format, simply use a filename with a \char`\"{}.\-mat\char`\"{} ending.

The {\ttfamily save} function also supports A\-S\-C\-I\-I output. This is a very limited form of the save command -\/ it can only save numeric arrays that are 2-\/dimensional. This form of the {\ttfamily save} command is triggered using \begin{DoxyVerb}   save -ascii filename var1 var 2
\end{DoxyVerb}
 although where {\ttfamily -\/ascii} appears on the command line is arbitrary (provided it comes after the {\ttfamily save} command, of course). Be default, the {\ttfamily save} command uses an 8-\/digit exponential format notation to save the values to the file. You can specify that you want 16-\/digits using the \begin{DoxyVerb}   save -ascii -double filename var1 var2
\end{DoxyVerb}
 form of the command. Also, by default, {\ttfamily save} uses spaces as the delimiters between the entries in the matrix. If you want tabs instead, you can use \begin{DoxyVerb}   save -ascii -tabs filename var1 var2
\end{DoxyVerb}
 (you can also use both the {\ttfamily -\/tabs} and {\ttfamily -\/double} flags simultaneously).

Finally, you can specify that {\ttfamily save} should only save variables that match a particular regular expression. Any of the above forms can be combined with the {\ttfamily -\/regexp} flag\-: \begin{DoxyVerb}   save filename -regexp pattern1 pattern2
\end{DoxyVerb}
 in which case variables that match any of the patterns will be saved. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Here is a simple example of {\ttfamily save}/{\ttfamily load}. First, we save some variables to a file.


\begin{DoxyVerbInclude}
--> D = {1,5,'hello'};
--> s = 'test string';
--> x = randn(512,1);
--> z = zeros(512);
--> who
  Variable Name       Type   Flags             Size
              D      cell                    [1x3]
              s      char                    [1x11]
              x    double                    [512x1]
              z    double                    [512x512]
--> save loadsave.dat
\end{DoxyVerbInclude}


Next, we clear the variables, and then load them back from the file.


\begin{DoxyVerbInclude}
--> clear D s x z
--> who
  Variable Name       Type   Flags             Size
            ans    double                    [0x0]
--> load loadsave.dat
--> who
  Variable Name       Type   Flags             Size
              D      cell                    [1x3]
            ans    double                    [0x0]
              s      char                    [1x11]
              x    double                    [512x1]
              z    double                    [512x512]
\end{DoxyVerbInclude}
 \hypertarget{io_setprintlimit}{}\section{S\-E\-T\-P\-R\-I\-N\-T\-L\-I\-M\-I\-T Set Limit For Printing Of Arrays}\label{io_setprintlimit}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Changes the limit on how many elements of an array are printed using either the {\ttfamily disp} function or using expressions on the command line without a semi-\/colon. The default is set to one thousand elements. You can increase or decrease this limit by calling \begin{DoxyVerb}  setprintlimit(n)
\end{DoxyVerb}
 where {\ttfamily n} is the new limit to use. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Setting a smaller print limit avoids pages of output when you forget the semicolon on an expression.


\begin{DoxyVerbInclude}
--> A = randn(512);
--> setprintlimit(10)
--> A

ans = 

 Columns 1 to 7

   -0.2514   -0.1353   -1.3148    1.7915   -0.4740   -1.6836   -0.2605 
   -0.6206   -0.6711   -0.4389
Print limit has been reached.  Use setprintlimit function to enable longer printouts
--> setprintlimit(1000)
\end{DoxyVerbInclude}
 \hypertarget{io_sprintf}{}\section{S\-P\-R\-I\-N\-T\-F Formated String Output Function (C-\/\-Style)}\label{io_sprintf}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Prints values to a string. The general syntax for its use is \begin{DoxyVerb}  y = sprintf(format,a1,a2,...).
\end{DoxyVerb}
 Here {\ttfamily format} is the format string, which is a string that controls the format of the output. The values of the variables {\ttfamily a\-\_\-i} are substituted into the output as required. It is an error if there are not enough variables to satisfy the format string. Note that this {\ttfamily sprintf} command is not vectorized! Each variable must be a scalar. The returned value {\ttfamily y} contains the string that would normally have been printed. For more details on the format string, see {\ttfamily printf}. \hypertarget{variables_matrix_Examples}{}\subsection{Examples}\label{variables_matrix_Examples}
Here is an example of a loop that generates a sequence of files based on a template name, and stores them in a cell array.


\begin{DoxyVerbInclude}
--> l = {}; for i = 1:5; s = sprintf('file_%d.dat',i); l(i) = {s}; end;
--> l

ans = 
 [file_1.dat] [file_2.dat] [file_3.dat] [file_4.dat] [file_5.dat] 
\end{DoxyVerbInclude}
 \hypertarget{io_sscanf}{}\section{S\-S\-C\-A\-N\-F Formated String Input Function (C-\/\-Style)}\label{io_sscanf}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Reads values from a string. The general syntax for its use is \begin{DoxyVerb}  [a, count, errmsg, nextind] = sscanf(text,format,[size])
\end{DoxyVerb}
 Here {\ttfamily format} is the format string, which is a string that controls the format of the input, {\ttfamily size} specifies the amount of data to be read. Values that are parsed from the {\ttfamily text} are stored in a. Note that sscanf is vectorized -\/ the format string is reused as long as there are entries in the {\ttfamily text} string. See {\ttfamily printf} for a description of the format. \hypertarget{io_str2num}{}\section{S\-T\-R2\-N\-U\-M Convert a String to a Number}\label{io_str2num}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Converts a string to a number. The general syntax for its use is \begin{DoxyVerb}  x = str2num(string)
\end{DoxyVerb}
 Here {\ttfamily string} is the data string, which contains the data to be converted into a number. The output is in double precision, and must be typecasted to the appropriate type based on what you need. Note that by definition, {\ttfamily str2num} is entirely equivalent to {\ttfamily eval(\mbox{[}'\mbox{[}' string '\mbox{]}'\mbox{]},\mbox{[}\mbox{]})} with all of the associated problems where {\ttfamily string} contains text that causes side effects. \hypertarget{io_type}{}\section{T\-Y\-P\-E Type Contents of File or Function}\label{io_type}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Displays the contents of a file or a function to the screen or console. The syntax for its use is \begin{DoxyVerb}   type filename
   type('filename')
\end{DoxyVerb}
 or \begin{DoxyVerb}   type function
   type('function')
\end{DoxyVerb}
 in which case the function named {\ttfamily 'function.\-m'} will be displayed. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}
Here we use {\ttfamily type} to display the contents of itself


\begin{DoxyVerbInclude}
--> type('type')
% DOCBLOCK io_type

function type(filename)
fp = fopen(filename,'r');
if (fp == -1)
  f = which(filename);
  if (isempty(f)), return; end
  filename = f;
  fp = fopen(filename,'r');
end
if (fp == -1), return; end
while (~feof(fp))
  printf('%s',fgetline(fp));
end
fclose(fp);
\end{DoxyVerbInclude}
 \hypertarget{io_urlwrite}{}\section{U\-R\-L\-W\-R\-I\-T\-E Retrieve a U\-R\-L into a File}\label{io_urlwrite}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Given a U\-R\-L and a timeout, attempts to retrieve the U\-R\-L and write the contents to a file. The syntax is \begin{DoxyVerb}   f = urlwrite(url,filename,timeout)
\end{DoxyVerb}
 The {\ttfamily timeout} is in milliseconds. Note that the U\-R\-L must be a complete spec (i.\-e., including the name of the resource you wish to retrieve). So for example, you cannot use {\ttfamily \href{http://www.google.com}{\tt http\-://www.\-google.\-com}} as a U\-R\-L, but must instead use {\ttfamily \href{http://www.google.com/index.html}{\tt http\-://www.\-google.\-com/index.\-html}}. \hypertarget{io_wavplay}{}\section{W\-A\-V\-P\-L\-A\-Y}\label{io_wavplay}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Plays a linear P\-C\-M set of samples through the audio system. This function is only available if the {\ttfamily portaudio} library was available when Free\-Mat was built. The syntax for the command is one of\-: \begin{DoxyVerb}   wavplay(y)
   wavplay(y,sampling_rate)
   wavplay(...,mode)
\end{DoxyVerb}
 where {\ttfamily y} is a matrix of audio samples. If {\ttfamily y} has two columns, then the audio playback is in stereo. The {\ttfamily y} input can be of types {\ttfamily float, double, int32, int16, int8, uint8}. For {\ttfamily float} and {\ttfamily double} types, the sample values in {\ttfamily y} must be between {\ttfamily -\/1} and {\ttfamily 1}. The {\ttfamily sampling\-\_\-rate} specifies the rate at which the data is recorded. If not specified, the {\ttfamily sampling\-\_\-rate} defaults to {\ttfamily 11025\-Hz}. Finally, you can specify a playback mode of {\ttfamily 'sync'} which is synchronous playback or a playback mode of {\ttfamily 'async'} which is asynchronous playback. For {\ttfamily 'sync'} playback, the wavplay function returns when the playback is complete. For {\ttfamily 'async'} playback, the function returns immediately (unless a former playback is still issuing). \hypertarget{io_wavread}{}\section{W\-A\-V\-R\-E\-A\-D Read a W\-A\-V Audio File}\label{io_wavread}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The {\ttfamily wavread} function (attempts) to read the contents of a linear P\-C\-M audio W\-A\-V file. This function could definitely use improvements -\/ it is based on a very simplistic notion of a W\-A\-V file. The simplest form for its use is \begin{DoxyVerb}   y = wavread(filename)
\end{DoxyVerb}
 where {\ttfamily filename} is the name of the W\-A\-V file to read. If no extension is provided, Free\-Mat will add a '.wav' extension. This loads the data from the W\-A\-V file into {\ttfamily y}, and returns it in {\ttfamily double} precision, normalized format. If you want additional information on, for example, the W\-A\-V sampling rate or bit depth, you can request it via \begin{DoxyVerb}  [y, SamplingRate, BitDepth] = wavread(filename)
\end{DoxyVerb}
 where {\ttfamily Sampling\-Rate} and {\ttfamily Bit\-Depth} are the sampling rate (in Hz) and the bit depth of the original data in the W\-A\-V file. If you only want to load part of the W\-A\-V file, you can use \begin{DoxyVerb}  [...] = wavread(filename, N)
\end{DoxyVerb}
 where {\ttfamily N} indicates the number of samples to read from the file. Alternately, you can indicate a range of samples to load via \begin{DoxyVerb}  [...] = wavread(filename, [N1 N2])
\end{DoxyVerb}
 which returns only the indicated samples from each channel in the file. By default, the output format is {\ttfamily double} precision. You can cntrol the format of the output by indicating \begin{DoxyVerb}  [...] = wavread(filename, format)
\end{DoxyVerb}
 where {\ttfamily format} is either {\ttfamily 'double'} for double precision output, or {\ttfamily 'native'} for native precision output (meaning whatever bitdepth that was present in the original file). Finally, you can use the {\ttfamily 'size'} flag \begin{DoxyVerb}  y_siz = wavread(filename,'size')
\end{DoxyVerb}
 which returns a vector {\ttfamily \mbox{[}samples channels\mbox{]}} indicating the size of the data present in the W\-A\-V file. \hypertarget{io_wavrecord}{}\section{W\-A\-V\-R\-E\-C\-O\-R\-D}\label{io_wavrecord}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Records linear P\-C\-M sound from the audio system. This function is only available if the {\ttfamily portaudio} library was available when Free\-Mat was built. The syntax for this command is one of\-: \begin{DoxyVerb}  y = wavrecord(samples,rate)
  y = wavrecord(...,channels)
  y = wavrecord(...,'datatype')
\end{DoxyVerb}
 where {\ttfamily samples} is the number of samples to record, and {\ttfamily rate} is the sampling rate. If not specified, the {\ttfamily rate} defaults to {\ttfamily 11025\-Hz}. If you want to record in stero, specify {\ttfamily channels = 2}. Finally, you can specify the type of the recorded data (defaults to {\ttfamily F\-M\-\_\-\-D\-O\-U\-B\-L\-E}). Valid choices are {\ttfamily float, double, int32, int16, int8, uint8}. \hypertarget{io_wavwrite}{}\section{W\-A\-V\-W\-R\-I\-T\-E Write a W\-A\-V Audio File}\label{io_wavwrite}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
The {\ttfamily wavwrite} funtion writes an audio signal to a linear P\-C\-M W\-A\-V file. The simplest form for its use is \begin{DoxyVerb}    wavwrite(y,filename)
\end{DoxyVerb}
 which writes the data stored in {\ttfamily y} to a W\-A\-V file with the name {\ttfamily filename}. By default, the output data is assumed to be sampled at a rate of 8 K\-Hz, and is output using 16 bit integer format. Each column of {\ttfamily y} is written as a separate channel. The data are clipped to the range {\ttfamily \mbox{[}-\/1,1\mbox{]}} prior to writing them out. If you want the data to be written with a different sampling frequency, you can use the following form of the {\ttfamily wavwrite} command\-: \begin{DoxyVerb}   wavwrite(y,SampleRate,filename)
\end{DoxyVerb}
 where {\ttfamily Sample\-Rate} is in Hz. Finally, you can specify the number of bits to use in the output form of the file using the form \begin{DoxyVerb}   wavwrite(y,SampleRate,NBits,filename)
\end{DoxyVerb}
 where {\ttfamily N\-Bits} is the number of bits to use. Legal values include {\ttfamily 8,16,24,32}. For less than 32 bit output format, the data is truncated to the range {\ttfamily \mbox{[}-\/1,1\mbox{]}}, and an integer output format is used (type 1 P\-C\-M in W\-A\-V-\/speak). For 32 bit output format, the data is written in type 3 P\-C\-M as floating point data. \hypertarget{io_xmlread}{}\section{X\-M\-L\-R\-E\-A\-D Read an X\-M\-L Document into Free\-Mat}\label{io_xmlread}
Section\-: \hyperlink{sec_io}{Input/\-Ouput Functions} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Given a filename, reads an X\-M\-L document, parses it, and returns the result as a Free\-Mat data structure. The syntax for its use is\-: \begin{DoxyVerb}   p = xmlread(filename)
\end{DoxyVerb}
 where {\ttfamily filename} is a {\ttfamily string}. The resulting object {\ttfamily p} is a data structure containing the information in the document. Note that the returned object {\ttfamily p} is not the same object as the one returned by M\-A\-T\-L\-A\-B's {\ttfamily xmlread}, although the information content is the same. The output is largely compatible with the output of the parse\-X\-M\-L example in the {\ttfamily xmlread} documentation of the M\-A\-T\-L\-A\-B A\-P\-I. 
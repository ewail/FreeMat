
\begin{DoxyItemize}
\item \hyperlink{binary_bitand}{B\-I\-T\-A\-N\-D Bitwise Boolean And Operation}  
\item \hyperlink{binary_bitcmp}{B\-I\-T\-C\-M\-P Bitwise Boolean Complement Operation}  
\item \hyperlink{binary_bitor}{B\-I\-T\-O\-R Bitwise Boolean Or Operation}  
\item \hyperlink{binary_bitxor}{B\-I\-T\-X\-O\-R Bitwise Boolean Exclusive-\/\-Or (X\-O\-R) Operation}  
\end{DoxyItemize}\hypertarget{binary_bitand}{}\section{B\-I\-T\-A\-N\-D Bitwise Boolean And Operation}\label{binary_bitand}
Section\-: \hyperlink{sec_binary}{Bitwise Operations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Performs a bitwise binary and operation on the two arguments and returns the result. The syntax for its use is \begin{DoxyVerb}   y = bitand(a,b)
\end{DoxyVerb}
 where {\ttfamily a} and {\ttfamily b} are multi-\/dimensional unsigned integer arrays. The and operation is performed using 32 bit unsigned intermediates. Note that if a or b is a scalar, then each element of the other array is and'ed with that scalar. Otherwise the two arrays must match in size. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}

\begin{DoxyVerbInclude}
--> bitand(uint16([1,16,255]),uint16([3,17,128]))

ans = 
   1  16 128 

--> bitand(uint16([1,16,255]),uint16(3))

ans = 
 1 0 3 
\end{DoxyVerbInclude}
 \hypertarget{binary_bitcmp}{}\section{B\-I\-T\-C\-M\-P Bitwise Boolean Complement Operation}\label{binary_bitcmp}
Section\-: \hyperlink{sec_binary}{Bitwise Operations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Usage

Performs a bitwise binary complement operation on the argument and returns the result. The syntax for its use is \begin{DoxyVerb}    y = bitcmp(a)
\end{DoxyVerb}
 where a is an unsigned integer arrays. This version of the command uses as many bits as required by the type of a. For example, if a is an uint8 type, then the complement is formed using 8 bits. The second form of bitcmp allows you to specify the number of bits to use, \begin{DoxyVerb}    y = bitcmp(a,n)
\end{DoxyVerb}
 in which case the complement is taken with respect to n bits, where n must be less than the length of the integer type.\hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}

\begin{DoxyVerbInclude}
--> bitcmp(uint16(2^14-2))

ans = 
 49153 

--> bitcmp(uint16(2^14-2),14)

ans = 
 1 
\end{DoxyVerbInclude}
 \hypertarget{binary_bitor}{}\section{B\-I\-T\-O\-R Bitwise Boolean Or Operation}\label{binary_bitor}
Section\-: \hyperlink{sec_binary}{Bitwise Operations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Performs a bitwise binary or operation on the two arguments and returns the result. The syntax for its use is \begin{DoxyVerb}   y = bitor(a,b)
\end{DoxyVerb}
 where {\ttfamily a} and {\ttfamily b} are multi-\/dimensional unsigned integer arrays. The and operation is performed using 32 bit unsigned intermediates. Note that if a or b is a scalar, then each element of the other array is or'ed with that scalar. Otherwise the two arrays must match in size. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}

\begin{DoxyVerbInclude}
--> bitand(uint16([1,16,255]),uint16([3,17,128]))

ans = 
   1  16 128 

--> bitand(uint16([1,16,255]),uint16(3))

ans = 
 1 0 3 
\end{DoxyVerbInclude}
 \hypertarget{binary_bitxor}{}\section{B\-I\-T\-X\-O\-R Bitwise Boolean Exclusive-\/\-Or (X\-O\-R) Operation}\label{binary_bitxor}
Section\-: \hyperlink{sec_binary}{Bitwise Operations} \hypertarget{vtkwidgets_vtkxyplotwidget_Usage}{}\subsection{Usage}\label{vtkwidgets_vtkxyplotwidget_Usage}
Performs a bitwise binary xor operation on the two arguments and returns the result. The syntax for its use is \begin{DoxyVerb}   y = bitxor(a,b)
\end{DoxyVerb}
 where {\ttfamily a} and {\ttfamily b} are multi-\/dimensional unsigned integer arrays. The and operation is performed using 32 bit unsigned intermediates. Note that if a or b is a scalar, then each element of the other array is xor'ed with that scalar. Otherwise the two arrays must match in size. \hypertarget{variables_struct_Example}{}\subsection{Example}\label{variables_struct_Example}

\begin{DoxyVerbInclude}
--> bitand(uint16([1,16,255]),uint16([3,17,128]))

ans = 
   1  16 128 

--> bitand(uint16([1,16,255]),uint16(3))

ans = 
 1 0 3 
\end{DoxyVerbInclude}
 
/*!
\page vtkgraphics_vtkstreamingtessellator vtkStreamingTessellator

<p>
Section: \ref sec_vtkgraphics "Visualization Toolkit Graphics Classes"
\section Usage
 This class is a simple algorithm that takes a single starting simplex -- a
 tetrahedron, triangle, or line segment -- and calls a function you
 pass it with (possibly many times) tetrahedra, triangles, or lines
 adaptively sampled from the one you specified. It
 uses an algorithm you specify to control the level of adaptivity.

 This class does not create vtkUnstructuredGrid output because it is
 intended for use in mappers as well as filters. Instead, it
 calls the registered function with simplices as they are
 created.

 The subdivision algorithm should change the vertex
 coordinates (it must change both geometric and, if desired, parametric
 coordinates) of the midpoint. These coordinates need not be
 changed unless the EvaluateEdge() member returns true.
 The vtkStreamingTessellator itself has no way of creating
 a more accurate midpoint vertex.

 Here's how to use this class:
 - Call AdaptivelySample1Facet, AdaptivelySample2Facet, or
   AdaptivelySample3Facet, with an edge, triangle, or
   tetrahedron you want tessellated.
 - The adaptive tessellator classifies each edge by passing
   the midpoint values to the vtkEdgeSubdivisionCriterion.
 - After each edge is classified, the tessellator subdivides
   edges as required until the subdivision criterion is
   satisfied or the maximum subdivision depth has been
   reached.
 - Edges, triangles, or tetrahedra connecting the vertices
   generated by the subdivision algorithm are processed by
   calling the user-defined callback functions (set with 
   SetTetrahedronCallback(), SetTriangleCallback(),
   or SetEdgeCallback() ).

 .SECTION Warning
 Note that the vertices passed to AdaptivelySample3Facet, AdaptivelySample2Facet,
 or AdaptivelySample1Facet must be at least 6, 5, or 4 entries long, respectively!
 This is because the &lt;r,s,t&gt;, &lt;r,s&gt;, or &lt;r&gt;
 parametric coordinates of the vertices are maintained as the
 facet is subdivided. This information is often
 required by the subdivision algorithm in order to compute
 an error metric. You may change the number of parametric coordinates
 associated with each vertex using vtkStreamingTessellator::SetEmbeddingDimension().

 .SECTION Interpolating Field Values
 If you wish, you may also use \p vtkStreamingTessellator to interpolate field
 values at newly created vertices. Interpolated field values are stored just beyond
 the parametric coordinates associated with a vertex. They will always be \p double
 values; it does not make sense to interpolate a boolean or string value and your
 output and subdivision subroutines may always cast to a \p float or use \p floor() to
 truncate an interpolated value to an integer.


To create an instance of class vtkStreamingTessellator, simply
invoke its constructor as follows
\verbatim
  obj = vtkStreamingTessellator
\endverbatim
\section Methods
The class vtkStreamingTessellator has several methods that can be used.
  They are listed below.
Note that the documentation is translated automatically from the VTK sources,
and may not be completely intelligible.  When in doubt, consult the VTK website.
In the methods listed below, <tt>obj</tt> is an instance of the vtkStreamingTessellator class.
<UL>
<LI>  <tt>string = obj.GetClassName ()</tt>
 </LI>
<LI>  <tt>int = obj.IsA (string name)</tt>
 </LI>
<LI>  <tt>vtkStreamingTessellator = obj.NewInstance ()</tt>
 </LI>
<LI>  <tt>vtkStreamingTessellator = obj.SafeDownCast (vtkObject o)</tt>
 </LI>
<LI>  <tt>obj.SetSubdivisionAlgorithm (vtkEdgeSubdivisionCriterion )</tt> -  Get/Set the algorithm used to determine whether an edge should be
 subdivided or left as-is. This is used once for each call to
 AdaptivelySample1Facet (which is recursive and will call itself
 resulting in additional edges to be checked) or three times for
 each call to AdaptivelySample2Facet (also recursive).
 </LI>
<LI>  <tt>vtkEdgeSubdivisionCriterion = obj.GetSubdivisionAlgorithm ()</tt> -  Get/Set the algorithm used to determine whether an edge should be
 subdivided or left as-is. This is used once for each call to
 AdaptivelySample1Facet (which is recursive and will call itself
 resulting in additional edges to be checked) or three times for
 each call to AdaptivelySample2Facet (also recursive).
 </LI>
<LI>  <tt>obj.SetEmbeddingDimension (int k, int d)</tt> -  Get/Set the number of parameter-space coordinates associated with each input and output point.
 The default is \a k for \a k -facets. You may
 specify a different dimension, \a d, for each type of \a k -facet to be processed.
 For example, \p SetEmbeddingDimension( \p 2, \p 3 ) would associate \a r, \a s, and
 \a t coordinates with each input and output point generated by \p AdaptivelySample2Facet
 but does not say anything about input or output points generated by
 \p AdaptivelySample1Facet. 
 Call \p SetEmbeddingDimension( \p -1, \a d ) to specify the same dimension for
 all possible \a k values.
 \a d may not exceed 8, as that would be plain silly.
 </LI>
<LI>  <tt>int = obj.GetEmbeddingDimension (int k) const</tt> -  Get/Set the number of parameter-space coordinates associated with each input and output point.
 The default is \a k for \a k -facets. You may
 specify a different dimension, \a d, for each type of \a k -facet to be processed.
 For example, \p SetEmbeddingDimension( \p 2, \p 3 ) would associate \a r, \a s, and
 \a t coordinates with each input and output point generated by \p AdaptivelySample2Facet
 but does not say anything about input or output points generated by
 \p AdaptivelySample1Facet. 
 Call \p SetEmbeddingDimension( \p -1, \a d ) to specify the same dimension for
 all possible \a k values.
 \a d may not exceed 8, as that would be plain silly.
 </LI>
<LI>  <tt>obj.SetFieldSize (int k, int s)</tt> -  Get/Set the number of field value coordinates associated with each input and output point.
 The default is 0; no field values are interpolated.
 You may specify a different size, \a s, for each type of \a k -facet to be processed.
 For example, \p SetFieldSize( \p 2, \p 3 ) would associate 3 field value coordinates
 with each input and output point of an \p AdaptivelySample2Facet call,
 but does not say anything about input or output points of \p AdaptivelySample1Facet. 
 Call \p SetFieldSize( \p -1, \a s ) to specify the same dimension for all possible \a k values.
 \a s may not exceed vtkStreamingTessellator::MaxFieldSize.
 This is a compile-time constant that defaults to 18, which is large enough for
 a scalar, vector, tensor, normal, and texture coordinate to be included at each point.

 Normally, you will not call \a SetFieldSize() directly; instead, subclasses of
 vtkEdgeSubdivisionCriterion, such as vtkShoeMeshSubdivisionAlgorithm, will call it
 for you.

 In any event, setting \a FieldSize to a non-zero value means you must pass field
 values to the \p AdaptivelySamplekFacet routines; For example,
 @verbatim
    vtkStreamingTessellator* t = vtkStreamingTessellator::New();
    t->SetFieldSize( 1, 3 );
    t->SetEmbeddingDimension( 1, 1 ); // not really required, this is the default
    double p0[3+1+3] = { x0, y0, z0, r0, fx0, fy0, fz0 };
    double p1[3+1+3] = { x1, y1, z1, r1, fx1, fy1, fz1 };
    t->AdaptivelySample1Facet( p0, p1 );
 @endverbatim
 This would adaptively sample an curve (1-facet) with geometry and
 a vector field at every output point on the curve.
 </LI>
<LI>  <tt>int = obj.GetFieldSize (int k) const</tt> -  Get/Set the number of field value coordinates associated with each input and output point.
 The default is 0; no field values are interpolated.
 You may specify a different size, \a s, for each type of \a k -facet to be processed.
 For example, \p SetFieldSize( \p 2, \p 3 ) would associate 3 field value coordinates
 with each input and output point of an \p AdaptivelySample2Facet call,
 but does not say anything about input or output points of \p AdaptivelySample1Facet. 
 Call \p SetFieldSize( \p -1, \a s ) to specify the same dimension for all possible \a k values.
 \a s may not exceed vtkStreamingTessellator::MaxFieldSize.
 This is a compile-time constant that defaults to 18, which is large enough for
 a scalar, vector, tensor, normal, and texture coordinate to be included at each point.

 Normally, you will not call \a SetFieldSize() directly; instead, subclasses of
 vtkEdgeSubdivisionCriterion, such as vtkShoeMeshSubdivisionAlgorithm, will call it
 for you.

 In any event, setting \a FieldSize to a non-zero value means you must pass field
 values to the \p AdaptivelySamplekFacet routines; For example,
 @verbatim
    vtkStreamingTessellator* t = vtkStreamingTessellator::New();
    t->SetFieldSize( 1, 3 );
    t->SetEmbeddingDimension( 1, 1 ); // not really required, this is the default
    double p0[3+1+3] = { x0, y0, z0, r0, fx0, fy0, fz0 };
    double p1[3+1+3] = { x1, y1, z1, r1, fx1, fy1, fz1 };
    t->AdaptivelySample1Facet( p0, p1 );
 @endverbatim
 This would adaptively sample an curve (1-facet) with geometry and
 a vector field at every output point on the curve.
 </LI>
<LI>  <tt>obj.SetMaximumNumberOfSubdivisions (int num_subdiv_in)</tt> -  Get/Set the maximum number of subdivisions that may occur.
 </LI>
<LI>  <tt>int = obj.GetMaximumNumberOfSubdivisions ()</tt> -  Get/Set the maximum number of subdivisions that may occur.
 </LI>
<LI>  <tt>obj.AdaptivelySample3Facet (double v1, double v2, double v3, double v4) const</tt> -  This will adaptively subdivide the tetrahedron (3-facet),
 triangle (2-facet), or edge (1-facet) until the subdivision
 algorithm returns false for every edge or the maximum recursion
 depth is reached.

 Use \p SetMaximumNumberOfSubdivisions to change the maximum
 recursion depth.

 The AdaptivelySample0Facet method is provided as a convenience.
 Obviously, there is no way to adaptively subdivide a vertex.
 Instead the input vertex is passed unchanged to the output
 via a call to the registered VertexProcessorFunction callback.

 .SECTION Warning
 This assumes that you have called SetSubdivisionAlgorithm(),
 SetEdgeCallback(), SetTriangleCallback(), and SetTetrahedronCallback()
 with valid values!
 </LI>
<LI>  <tt>obj.AdaptivelySample2Facet (double v1, double v2, double v3) const</tt> -  This will adaptively subdivide the tetrahedron (3-facet),
 triangle (2-facet), or edge (1-facet) until the subdivision
 algorithm returns false for every edge or the maximum recursion
 depth is reached.

 Use \p SetMaximumNumberOfSubdivisions to change the maximum
 recursion depth.

 The AdaptivelySample0Facet method is provided as a convenience.
 Obviously, there is no way to adaptively subdivide a vertex.
 Instead the input vertex is passed unchanged to the output
 via a call to the registered VertexProcessorFunction callback.

 .SECTION Warning
 This assumes that you have called SetSubdivisionAlgorithm(),
 SetEdgeCallback(), SetTriangleCallback(), and SetTetrahedronCallback()
 with valid values!
 </LI>
<LI>  <tt>obj.AdaptivelySample1Facet (double v1, double v2) const</tt> -  This will adaptively subdivide the tetrahedron (3-facet),
 triangle (2-facet), or edge (1-facet) until the subdivision
 algorithm returns false for every edge or the maximum recursion
 depth is reached.

 Use \p SetMaximumNumberOfSubdivisions to change the maximum
 recursion depth.

 The AdaptivelySample0Facet method is provided as a convenience.
 Obviously, there is no way to adaptively subdivide a vertex.
 Instead the input vertex is passed unchanged to the output
 via a call to the registered VertexProcessorFunction callback.

 .SECTION Warning
 This assumes that you have called SetSubdivisionAlgorithm(),
 SetEdgeCallback(), SetTriangleCallback(), and SetTetrahedronCallback()
 with valid values!
 </LI>
<LI>  <tt>obj.AdaptivelySample0Facet (double v1) const</tt> -  This will adaptively subdivide the tetrahedron (3-facet),
 triangle (2-facet), or edge (1-facet) until the subdivision
 algorithm returns false for every edge or the maximum recursion
 depth is reached.

 Use \p SetMaximumNumberOfSubdivisions to change the maximum
 recursion depth.

 The AdaptivelySample0Facet method is provided as a convenience.
 Obviously, there is no way to adaptively subdivide a vertex.
 Instead the input vertex is passed unchanged to the output
 via a call to the registered VertexProcessorFunction callback.

 .SECTION Warning
 This assumes that you have called SetSubdivisionAlgorithm(),
 SetEdgeCallback(), SetTriangleCallback(), and SetTetrahedronCallback()
 with valid values!
 </LI>
<LI>  <tt>obj.ResetCounts ()</tt> -  Reset/access the histogram of subdivision cases encountered.
 The histogram may be used to examine coverage during testing as well as characterizing the
 tessellation algorithm's performance.
 You should call ResetCounts() once, at the beginning of a stream of tetrahedra.
 It must be called before AdaptivelySample3Facet() to prevent uninitialized memory reads.

 These functions have no effect (and return 0) when PARAVIEW_DEBUG_TESSELLATOR has not been defined.
 By default, PARAVIEW_DEBUG_TESSELLATOR is not defined, and your code will be fast and efficient. Really!
 </LI>
<LI>  <tt>vtkIdType = obj.GetCaseCount (int c)</tt> -  Reset/access the histogram of subdivision cases encountered.
 The histogram may be used to examine coverage during testing as well as characterizing the
 tessellation algorithm's performance.
 You should call ResetCounts() once, at the beginning of a stream of tetrahedra.
 It must be called before AdaptivelySample3Facet() to prevent uninitialized memory reads.

 These functions have no effect (and return 0) when PARAVIEW_DEBUG_TESSELLATOR has not been defined.
 By default, PARAVIEW_DEBUG_TESSELLATOR is not defined, and your code will be fast and efficient. Really!
 </LI>
<LI>  <tt>vtkIdType = obj.GetSubcaseCount (int casenum, int sub)</tt>
 </LI>
</UL>
*/
